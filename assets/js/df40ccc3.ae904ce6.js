"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[5815],{30876:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var o=n(2784);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){p(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,o,p=function(t,e){if(null==t)return{};var n,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(p[n]=t[n]);return p}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(p[n]=t[n])}return p}var i=o.createContext({}),a=function(t){var e=o.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=a(t.components);return o.createElement(i.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(n),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,s(s({ref:e},l),{},{components:n})):o.createElement(h,s({ref:e},l))}));function h(t,e){var n=arguments,p=e&&e.mdxType;if("string"==typeof t||p){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=n[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},83851:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),p=n(2784),r=n(6277),s=n(1077),c=n(97683),i=n(89817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:e,id:n,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===e||!n)return p.createElement(e,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:n});return p.createElement(e,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:n}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${n}`,"aria-label":d,title:d},"\u200b"))}},52665:(t,e,n)=>{n.d(e,{Z:()=>k});var o=n(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=n(89817),d=n(6277);function h(t){let{name:e}=t;const n=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${e}.tsx`;return o.createElement(m.Z,{to:n,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function k(t){let{name:e,banner:n,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,n&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${e}.js`,auto:n}),o.createElement(h,{name:a||e}))}n(31263).Z.canUseDOM&&n.e(5483).then(n.bind(n,85483))},42072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),p=n(88617),r=n(31930);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return o.createElement(r.Z,{reflection:n,headless:!0})}},3866:(t,e,n)=>{n.d(e,{Z:()=>H_e});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>te,content_0_1000:()=>Ef,content_0_1002:()=>Gf,content_0_1004:()=>Ff,content_0_1006:()=>qf,content_0_1008:()=>jf,content_0_1010:()=>Hf,content_0_1012:()=>Yf,content_0_1014:()=>Jf,content_0_1016:()=>eM,content_0_1018:()=>oM,content_0_102:()=>ne,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>kM,content_0_1032:()=>fM,content_0_104:()=>pe,content_0_106:()=>se,content_0_108:()=>ie,content_0_110:()=>le,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ye,content_0_118:()=>Me,content_0_12:()=>w,content_0_120:()=>we,content_0_122:()=>Xe,content_0_124:()=>Te,content_0_126:()=>Ce,content_0_128:()=>Le,content_0_130:()=>be,content_0_132:()=>ze,content_0_134:()=>We,content_0_136:()=>Ie,content_0_138:()=>Pe,content_0_14:()=>X,content_0_140:()=>Be,content_0_142:()=>Oe,content_0_144:()=>Ue,content_0_146:()=>Ve,content_0_148:()=>Qe,content_0_150:()=>$e,content_0_152:()=>Ke,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>pn,content_0_16:()=>T,content_0_160:()=>sn,content_0_162:()=>an,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>kn,content_0_170:()=>fn,content_0_172:()=>Dn,content_0_174:()=>_n,content_0_176:()=>gn,content_0_178:()=>xn,content_0_18:()=>C,content_0_180:()=>vn,content_0_182:()=>Zn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>Rn,content_0_190:()=>Sn,content_0_192:()=>En,content_0_194:()=>Gn,content_0_196:()=>Fn,content_0_198:()=>qn,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>jn,content_0_202:()=>Hn,content_0_204:()=>Yn,content_0_206:()=>Jn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>Po,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Uo,content_0_252:()=>Vo,content_0_254:()=>Qo,content_0_256:()=>$o,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>np,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Up,content_0_306:()=>Vp,content_0_308:()=>Qp,content_0_310:()=>$p,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Pr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Ur,content_0_36:()=>U,content_0_360:()=>Vr,content_0_362:()=>Qr,content_0_364:()=>$r,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>ns,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ys,content_0_386:()=>Ms,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>Q,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ps,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Us,content_0_414:()=>Vs,content_0_416:()=>Qs,content_0_418:()=>$s,content_0_42:()=>$,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>nc,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>yc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Pc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Uc,content_0_468:()=>Vc,content_0_470:()=>Qc,content_0_472:()=>$c,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ni,content_0_48:()=>nt,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>yi,content_0_494:()=>Mi,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Pi,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Ui,content_0_522:()=>Vi,content_0_524:()=>Qi,content_0_526:()=>$i,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ya,content_0_548:()=>Ma,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Pa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Ua,content_0_576:()=>Va,content_0_578:()=>Qa,content_0_58:()=>mt,content_0_580:()=>$a,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>Ml,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>yt,content_0_620:()=>Il,content_0_622:()=>Pl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Ul,content_0_630:()=>Vl,content_0_632:()=>Ql,content_0_634:()=>$l,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>nu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Pu,content_0_678:()=>Bu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>Uu,content_0_684:()=>Vu,content_0_686:()=>Qu,content_0_688:()=>$u,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Pm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Um,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Qm,content_0_742:()=>$m,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Pd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Ud,content_0_792:()=>Vd,content_0_794:()=>Qd,content_0_796:()=>$d,content_0_798:()=>Kd,content_0_8:()=>y,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Uh,content_0_846:()=>Vh,content_0_848:()=>Qh,content_0_850:()=>$h,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>nk,content_0_858:()=>pk,content_0_86:()=>Bt,content_0_860:()=>sk,content_0_862:()=>ik,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>wk,content_0_876:()=>Xk,content_0_878:()=>Tk,content_0_88:()=>Ot,content_0_880:()=>Ck,content_0_882:()=>Lk,content_0_884:()=>bk,content_0_886:()=>zk,content_0_888:()=>Wk,content_0_890:()=>Ik,content_0_892:()=>Pk,content_0_894:()=>Bk,content_0_896:()=>Ok,content_0_898:()=>Uk,content_0_90:()=>Ut,content_0_900:()=>Vk,content_0_902:()=>Qk,content_0_904:()=>$k,content_0_906:()=>Kk,content_0_908:()=>ty,content_0_910:()=>ny,content_0_912:()=>py,content_0_914:()=>sy,content_0_916:()=>iy,content_0_918:()=>ly,content_0_92:()=>Vt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>My,content_0_928:()=>wy,content_0_930:()=>Xy,content_0_932:()=>Ty,content_0_934:()=>Cy,content_0_936:()=>Ly,content_0_938:()=>by,content_0_94:()=>Qt,content_0_940:()=>zy,content_0_942:()=>Wy,content_0_944:()=>Iy,content_0_946:()=>Py,content_0_948:()=>By,content_0_950:()=>Oy,content_0_952:()=>Uy,content_0_954:()=>Vy,content_0_956:()=>Qy,content_0_958:()=>$y,content_0_96:()=>$t,content_0_960:()=>Ky,content_0_962:()=>tf,content_0_964:()=>nf,content_0_966:()=>pf,content_0_968:()=>sf,content_0_970:()=>af,content_0_972:()=>uf,content_0_974:()=>df,content_0_976:()=>kf,content_0_978:()=>ff,content_0_98:()=>Kt,content_0_980:()=>Df,content_0_982:()=>_f,content_0_984:()=>gf,content_0_986:()=>xf,content_0_988:()=>vf,content_0_990:()=>Zf,content_0_992:()=>Nf,content_0_994:()=>Af,content_0_996:()=>Rf,content_0_998:()=>Sf,content_2247_0:()=>DM,content_2247_10:()=>ZM,content_2247_100:()=>uw,content_2247_1000:()=>jI,content_2247_1002:()=>HI,content_2247_1004:()=>YI,content_2247_1006:()=>JI,content_2247_1008:()=>eS,content_2247_1010:()=>oS,content_2247_1012:()=>rS,content_2247_1014:()=>cS,content_2247_1016:()=>aS,content_2247_1018:()=>uS,content_2247_102:()=>dw,content_2247_1020:()=>dS,content_2247_1022:()=>kS,content_2247_1024:()=>fS,content_2247_1026:()=>DS,content_2247_1028:()=>_S,content_2247_1030:()=>gS,content_2247_1032:()=>xS,content_2247_1034:()=>vS,content_2247_1036:()=>ZS,content_2247_1038:()=>NS,content_2247_104:()=>kw,content_2247_1040:()=>AS,content_2247_1042:()=>RS,content_2247_1044:()=>SS,content_2247_1046:()=>ES,content_2247_1048:()=>GS,content_2247_1050:()=>FS,content_2247_1052:()=>qS,content_2247_1054:()=>jS,content_2247_1056:()=>HS,content_2247_1058:()=>YS,content_2247_106:()=>fw,content_2247_1060:()=>JS,content_2247_1062:()=>eP,content_2247_1064:()=>oP,content_2247_1066:()=>rP,content_2247_1068:()=>cP,content_2247_1070:()=>aP,content_2247_1072:()=>uP,content_2247_1074:()=>dP,content_2247_1076:()=>kP,content_2247_1078:()=>fP,content_2247_108:()=>Dw,content_2247_1080:()=>DP,content_2247_1082:()=>_P,content_2247_1084:()=>gP,content_2247_1086:()=>xP,content_2247_1088:()=>vP,content_2247_1090:()=>ZP,content_2247_1092:()=>NP,content_2247_1094:()=>AP,content_2247_1096:()=>RP,content_2247_1098:()=>SP,content_2247_110:()=>_w,content_2247_1100:()=>EP,content_2247_1102:()=>GP,content_2247_1104:()=>FP,content_2247_1106:()=>qP,content_2247_1108:()=>jP,content_2247_1110:()=>HP,content_2247_1112:()=>YP,content_2247_1114:()=>JP,content_2247_1116:()=>eE,content_2247_1118:()=>oE,content_2247_112:()=>gw,content_2247_1120:()=>rE,content_2247_1122:()=>cE,content_2247_1124:()=>aE,content_2247_1126:()=>uE,content_2247_1128:()=>dE,content_2247_1130:()=>kE,content_2247_1132:()=>fE,content_2247_1134:()=>DE,content_2247_1136:()=>_E,content_2247_1138:()=>gE,content_2247_114:()=>xw,content_2247_1140:()=>xE,content_2247_1142:()=>vE,content_2247_1144:()=>ZE,content_2247_1146:()=>NE,content_2247_1148:()=>AE,content_2247_1150:()=>RE,content_2247_1152:()=>SE,content_2247_1154:()=>EE,content_2247_1156:()=>GE,content_2247_1158:()=>FE,content_2247_116:()=>vw,content_2247_1160:()=>qE,content_2247_1162:()=>jE,content_2247_1164:()=>HE,content_2247_1166:()=>YE,content_2247_1168:()=>JE,content_2247_1170:()=>eB,content_2247_1172:()=>oB,content_2247_1174:()=>rB,content_2247_1176:()=>cB,content_2247_1178:()=>aB,content_2247_118:()=>Zw,content_2247_1180:()=>uB,content_2247_1182:()=>dB,content_2247_1184:()=>kB,content_2247_1186:()=>fB,content_2247_1188:()=>DB,content_2247_1190:()=>_B,content_2247_1192:()=>gB,content_2247_1194:()=>xB,content_2247_1196:()=>vB,content_2247_1198:()=>ZB,content_2247_12:()=>NM,content_2247_120:()=>Nw,content_2247_1200:()=>NB,content_2247_1202:()=>AB,content_2247_1204:()=>RB,content_2247_1206:()=>SB,content_2247_1208:()=>EB,content_2247_1210:()=>GB,content_2247_1212:()=>FB,content_2247_1214:()=>qB,content_2247_1216:()=>jB,content_2247_1218:()=>HB,content_2247_122:()=>Aw,content_2247_1220:()=>YB,content_2247_1222:()=>JB,content_2247_1224:()=>eG,content_2247_1226:()=>oG,content_2247_1228:()=>rG,content_2247_1230:()=>cG,content_2247_1232:()=>aG,content_2247_1234:()=>uG,content_2247_1236:()=>dG,content_2247_1238:()=>kG,content_2247_124:()=>Rw,content_2247_1240:()=>fG,content_2247_1242:()=>DG,content_2247_1244:()=>_G,content_2247_1246:()=>gG,content_2247_1248:()=>xG,content_2247_1250:()=>vG,content_2247_1252:()=>ZG,content_2247_1254:()=>NG,content_2247_1256:()=>AG,content_2247_1258:()=>RG,content_2247_126:()=>Sw,content_2247_1260:()=>SG,content_2247_1262:()=>EG,content_2247_1264:()=>GG,content_2247_1266:()=>FG,content_2247_1268:()=>qG,content_2247_1270:()=>jG,content_2247_1272:()=>HG,content_2247_1274:()=>YG,content_2247_1276:()=>JG,content_2247_1278:()=>eO,content_2247_128:()=>Ew,content_2247_1280:()=>oO,content_2247_1282:()=>rO,content_2247_1284:()=>cO,content_2247_1286:()=>aO,content_2247_1288:()=>uO,content_2247_1290:()=>dO,content_2247_1292:()=>kO,content_2247_1294:()=>fO,content_2247_1296:()=>DO,content_2247_1298:()=>_O,content_2247_130:()=>Gw,content_2247_1300:()=>gO,content_2247_1302:()=>xO,content_2247_1304:()=>vO,content_2247_1306:()=>ZO,content_2247_1308:()=>NO,content_2247_1310:()=>AO,content_2247_1312:()=>RO,content_2247_1314:()=>SO,content_2247_1316:()=>EO,content_2247_1318:()=>GO,content_2247_132:()=>Fw,content_2247_1320:()=>FO,content_2247_1322:()=>qO,content_2247_1324:()=>jO,content_2247_1326:()=>HO,content_2247_1328:()=>YO,content_2247_1330:()=>JO,content_2247_1332:()=>eF,content_2247_1334:()=>oF,content_2247_1336:()=>rF,content_2247_1338:()=>cF,content_2247_134:()=>qw,content_2247_1340:()=>aF,content_2247_1342:()=>uF,content_2247_1344:()=>dF,content_2247_1346:()=>kF,content_2247_1348:()=>fF,content_2247_1350:()=>DF,content_2247_1352:()=>_F,content_2247_1354:()=>gF,content_2247_1356:()=>xF,content_2247_1358:()=>vF,content_2247_136:()=>jw,content_2247_1360:()=>ZF,content_2247_1362:()=>NF,content_2247_1364:()=>AF,content_2247_1366:()=>RF,content_2247_1368:()=>SF,content_2247_1370:()=>EF,content_2247_1372:()=>GF,content_2247_1374:()=>FF,content_2247_1376:()=>qF,content_2247_1378:()=>jF,content_2247_138:()=>Hw,content_2247_1380:()=>HF,content_2247_1382:()=>YF,content_2247_1384:()=>JF,content_2247_1386:()=>eU,content_2247_1388:()=>oU,content_2247_1390:()=>rU,content_2247_1392:()=>cU,content_2247_1394:()=>aU,content_2247_1396:()=>uU,content_2247_1398:()=>dU,content_2247_14:()=>AM,content_2247_140:()=>Yw,content_2247_1400:()=>kU,content_2247_1402:()=>fU,content_2247_1404:()=>DU,content_2247_1406:()=>_U,content_2247_1408:()=>gU,content_2247_1410:()=>xU,content_2247_1412:()=>vU,content_2247_1414:()=>ZU,content_2247_1416:()=>NU,content_2247_1418:()=>AU,content_2247_142:()=>Jw,content_2247_1420:()=>RU,content_2247_1422:()=>SU,content_2247_1424:()=>EU,content_2247_1426:()=>GU,content_2247_1428:()=>FU,content_2247_1430:()=>qU,content_2247_1432:()=>jU,content_2247_1434:()=>HU,content_2247_1436:()=>YU,content_2247_1438:()=>JU,content_2247_144:()=>e_,content_2247_1440:()=>eq,content_2247_1442:()=>oq,content_2247_1444:()=>rq,content_2247_1446:()=>cq,content_2247_1448:()=>aq,content_2247_1450:()=>uq,content_2247_1452:()=>dq,content_2247_1454:()=>kq,content_2247_1456:()=>fq,content_2247_1458:()=>Dq,content_2247_146:()=>o_,content_2247_1460:()=>_q,content_2247_1462:()=>gq,content_2247_1464:()=>xq,content_2247_1466:()=>vq,content_2247_1468:()=>Zq,content_2247_1470:()=>Nq,content_2247_1472:()=>Aq,content_2247_1474:()=>Rq,content_2247_1476:()=>Sq,content_2247_1478:()=>Eq,content_2247_148:()=>r_,content_2247_1480:()=>Gq,content_2247_1482:()=>Fq,content_2247_1484:()=>qq,content_2247_1486:()=>jq,content_2247_1488:()=>Hq,content_2247_1490:()=>Yq,content_2247_1492:()=>Jq,content_2247_1494:()=>eV,content_2247_1496:()=>oV,content_2247_1498:()=>rV,content_2247_150:()=>c_,content_2247_1500:()=>cV,content_2247_1502:()=>aV,content_2247_1504:()=>uV,content_2247_1506:()=>dV,content_2247_1508:()=>kV,content_2247_1510:()=>fV,content_2247_1512:()=>DV,content_2247_1514:()=>_V,content_2247_1516:()=>gV,content_2247_1518:()=>xV,content_2247_152:()=>a_,content_2247_1520:()=>vV,content_2247_1522:()=>ZV,content_2247_1524:()=>NV,content_2247_1526:()=>AV,content_2247_1528:()=>RV,content_2247_1530:()=>SV,content_2247_1532:()=>EV,content_2247_1534:()=>GV,content_2247_1536:()=>FV,content_2247_1538:()=>qV,content_2247_154:()=>u_,content_2247_1540:()=>jV,content_2247_1542:()=>HV,content_2247_1544:()=>YV,content_2247_1546:()=>JV,content_2247_1548:()=>ej,content_2247_1550:()=>oj,content_2247_1552:()=>rj,content_2247_1554:()=>cj,content_2247_1556:()=>aj,content_2247_1558:()=>uj,content_2247_156:()=>d_,content_2247_1560:()=>dj,content_2247_1562:()=>kj,content_2247_1564:()=>fj,content_2247_1566:()=>Dj,content_2247_1568:()=>_j,content_2247_1570:()=>gj,content_2247_1572:()=>xj,content_2247_1574:()=>vj,content_2247_1576:()=>Zj,content_2247_1578:()=>Nj,content_2247_158:()=>k_,content_2247_1580:()=>Aj,content_2247_1582:()=>Rj,content_2247_1584:()=>Sj,content_2247_1586:()=>Ej,content_2247_1588:()=>Gj,content_2247_1590:()=>Fj,content_2247_1592:()=>qj,content_2247_1594:()=>jj,content_2247_1596:()=>Hj,content_2247_1598:()=>Yj,content_2247_16:()=>RM,content_2247_160:()=>f_,content_2247_1600:()=>Jj,content_2247_1602:()=>eQ,content_2247_1604:()=>oQ,content_2247_1606:()=>rQ,content_2247_1608:()=>cQ,content_2247_1610:()=>aQ,content_2247_1612:()=>uQ,content_2247_1614:()=>dQ,content_2247_1616:()=>kQ,content_2247_1618:()=>fQ,content_2247_162:()=>D_,content_2247_1620:()=>DQ,content_2247_1622:()=>_Q,content_2247_1624:()=>gQ,content_2247_1626:()=>xQ,content_2247_1628:()=>vQ,content_2247_1630:()=>ZQ,content_2247_1632:()=>NQ,content_2247_1634:()=>AQ,content_2247_1636:()=>RQ,content_2247_1638:()=>SQ,content_2247_164:()=>__,content_2247_1640:()=>EQ,content_2247_1642:()=>GQ,content_2247_1644:()=>FQ,content_2247_1646:()=>qQ,content_2247_1648:()=>jQ,content_2247_1650:()=>HQ,content_2247_1652:()=>YQ,content_2247_1654:()=>JQ,content_2247_1656:()=>eH,content_2247_1658:()=>oH,content_2247_166:()=>g_,content_2247_1660:()=>rH,content_2247_1662:()=>cH,content_2247_1664:()=>aH,content_2247_1666:()=>uH,content_2247_1668:()=>dH,content_2247_1670:()=>kH,content_2247_1672:()=>fH,content_2247_1674:()=>DH,content_2247_1676:()=>_H,content_2247_1678:()=>gH,content_2247_168:()=>x_,content_2247_1680:()=>xH,content_2247_1682:()=>vH,content_2247_1684:()=>ZH,content_2247_1686:()=>NH,content_2247_1688:()=>AH,content_2247_1690:()=>RH,content_2247_1692:()=>SH,content_2247_1694:()=>EH,content_2247_1696:()=>GH,content_2247_1698:()=>FH,content_2247_170:()=>v_,content_2247_1700:()=>qH,content_2247_1702:()=>jH,content_2247_1704:()=>HH,content_2247_1706:()=>YH,content_2247_1708:()=>JH,content_2247_1710:()=>e$,content_2247_1712:()=>o$,content_2247_1714:()=>r$,content_2247_1716:()=>c$,content_2247_1718:()=>a$,content_2247_172:()=>Z_,content_2247_1720:()=>u$,content_2247_1722:()=>d$,content_2247_1724:()=>k$,content_2247_1726:()=>f$,content_2247_1728:()=>D$,content_2247_1730:()=>_$,content_2247_1732:()=>g$,content_2247_1734:()=>x$,content_2247_1736:()=>v$,content_2247_1738:()=>Z$,content_2247_174:()=>N_,content_2247_1740:()=>N$,content_2247_1742:()=>A$,content_2247_1744:()=>R$,content_2247_1746:()=>S$,content_2247_1748:()=>E$,content_2247_1750:()=>G$,content_2247_1752:()=>F$,content_2247_1754:()=>q$,content_2247_1756:()=>j$,content_2247_1758:()=>H$,content_2247_176:()=>A_,content_2247_1760:()=>Y$,content_2247_1762:()=>J$,content_2247_1764:()=>eY,content_2247_1766:()=>oY,content_2247_1768:()=>rY,content_2247_1770:()=>cY,content_2247_1772:()=>aY,content_2247_1774:()=>uY,content_2247_1776:()=>dY,content_2247_1778:()=>kY,content_2247_178:()=>R_,content_2247_1780:()=>fY,content_2247_1782:()=>DY,content_2247_1784:()=>_Y,content_2247_1786:()=>gY,content_2247_1788:()=>xY,content_2247_1790:()=>vY,content_2247_1792:()=>ZY,content_2247_1794:()=>NY,content_2247_1796:()=>AY,content_2247_1798:()=>RY,content_2247_18:()=>SM,content_2247_180:()=>S_,content_2247_1800:()=>SY,content_2247_1802:()=>EY,content_2247_1804:()=>GY,content_2247_1806:()=>FY,content_2247_1808:()=>qY,content_2247_1810:()=>jY,content_2247_1812:()=>HY,content_2247_1814:()=>YY,content_2247_1816:()=>JY,content_2247_1818:()=>eK,content_2247_182:()=>E_,content_2247_1820:()=>oK,content_2247_1822:()=>rK,content_2247_1824:()=>cK,content_2247_1826:()=>aK,content_2247_1828:()=>uK,content_2247_1830:()=>dK,content_2247_1832:()=>kK,content_2247_1834:()=>fK,content_2247_1836:()=>DK,content_2247_1838:()=>_K,content_2247_184:()=>G_,content_2247_1840:()=>gK,content_2247_1842:()=>xK,content_2247_1844:()=>vK,content_2247_1846:()=>ZK,content_2247_1848:()=>NK,content_2247_1850:()=>AK,content_2247_1852:()=>RK,content_2247_1854:()=>SK,content_2247_1856:()=>EK,content_2247_1858:()=>GK,content_2247_186:()=>F_,content_2247_1860:()=>FK,content_2247_1862:()=>qK,content_2247_1864:()=>jK,content_2247_1866:()=>HK,content_2247_1868:()=>YK,content_2247_1870:()=>JK,content_2247_1872:()=>eJ,content_2247_1874:()=>oJ,content_2247_1876:()=>rJ,content_2247_1878:()=>cJ,content_2247_188:()=>q_,content_2247_1880:()=>aJ,content_2247_1882:()=>uJ,content_2247_1884:()=>dJ,content_2247_1886:()=>kJ,content_2247_1888:()=>fJ,content_2247_1890:()=>DJ,content_2247_1892:()=>_J,content_2247_1894:()=>gJ,content_2247_1896:()=>xJ,content_2247_1898:()=>vJ,content_2247_190:()=>j_,content_2247_1900:()=>ZJ,content_2247_1902:()=>NJ,content_2247_1904:()=>AJ,content_2247_1906:()=>RJ,content_2247_1908:()=>SJ,content_2247_1910:()=>EJ,content_2247_1912:()=>GJ,content_2247_1914:()=>FJ,content_2247_1916:()=>qJ,content_2247_1918:()=>jJ,content_2247_192:()=>H_,content_2247_1920:()=>HJ,content_2247_1922:()=>YJ,content_2247_1924:()=>JJ,content_2247_1926:()=>e0,content_2247_1928:()=>o0,content_2247_1930:()=>r0,content_2247_1932:()=>c0,content_2247_1934:()=>a0,content_2247_1936:()=>u0,content_2247_1938:()=>d0,content_2247_194:()=>Y_,content_2247_1940:()=>k0,content_2247_1942:()=>f0,content_2247_1944:()=>D0,content_2247_1946:()=>_0,content_2247_1948:()=>g0,content_2247_1950:()=>x0,content_2247_1952:()=>v0,content_2247_1954:()=>Z0,content_2247_1956:()=>N0,content_2247_1958:()=>A0,content_2247_196:()=>J_,content_2247_1960:()=>R0,content_2247_1962:()=>S0,content_2247_1964:()=>E0,content_2247_1966:()=>G0,content_2247_1968:()=>F0,content_2247_1970:()=>q0,content_2247_1972:()=>j0,content_2247_1974:()=>H0,content_2247_1976:()=>Y0,content_2247_1978:()=>J0,content_2247_198:()=>eX,content_2247_1980:()=>e2,content_2247_1982:()=>o2,content_2247_1984:()=>r2,content_2247_1986:()=>c2,content_2247_1988:()=>a2,content_2247_1990:()=>u2,content_2247_1992:()=>d2,content_2247_1994:()=>k2,content_2247_1996:()=>f2,content_2247_1998:()=>D2,content_2247_2:()=>_M,content_2247_20:()=>EM,content_2247_200:()=>oX,content_2247_2000:()=>_2,content_2247_2002:()=>g2,content_2247_2004:()=>x2,content_2247_2006:()=>v2,content_2247_2008:()=>Z2,content_2247_2010:()=>N2,content_2247_2012:()=>A2,content_2247_2014:()=>R2,content_2247_2016:()=>S2,content_2247_2018:()=>E2,content_2247_202:()=>rX,content_2247_2020:()=>G2,content_2247_2022:()=>F2,content_2247_2024:()=>q2,content_2247_2026:()=>j2,content_2247_2028:()=>H2,content_2247_2030:()=>Y2,content_2247_2032:()=>J2,content_2247_2034:()=>e4,content_2247_2036:()=>o4,content_2247_2038:()=>r4,content_2247_204:()=>cX,content_2247_2040:()=>c4,content_2247_2042:()=>a4,content_2247_2044:()=>u4,content_2247_2046:()=>d4,content_2247_2048:()=>k4,content_2247_2050:()=>f4,content_2247_2052:()=>D4,content_2247_2054:()=>_4,content_2247_2056:()=>g4,content_2247_2058:()=>x4,content_2247_206:()=>aX,content_2247_2060:()=>v4,content_2247_2062:()=>Z4,content_2247_2064:()=>N4,content_2247_2066:()=>A4,content_2247_2068:()=>R4,content_2247_2070:()=>S4,content_2247_2072:()=>E4,content_2247_2074:()=>G4,content_2247_2076:()=>F4,content_2247_2078:()=>q4,content_2247_208:()=>uX,content_2247_2080:()=>j4,content_2247_2082:()=>H4,content_2247_2084:()=>Y4,content_2247_2086:()=>J4,content_2247_2088:()=>e7,content_2247_2090:()=>o7,content_2247_2092:()=>r7,content_2247_2094:()=>c7,content_2247_2096:()=>a7,content_2247_2098:()=>u7,content_2247_210:()=>dX,content_2247_2100:()=>d7,content_2247_2102:()=>k7,content_2247_2104:()=>f7,content_2247_2106:()=>D7,content_2247_2108:()=>_7,content_2247_2110:()=>g7,content_2247_2112:()=>x7,content_2247_2114:()=>v7,content_2247_2116:()=>Z7,content_2247_2118:()=>N7,content_2247_212:()=>kX,content_2247_2120:()=>A7,content_2247_2122:()=>R7,content_2247_2124:()=>S7,content_2247_2126:()=>E7,content_2247_2128:()=>G7,content_2247_2130:()=>F7,content_2247_2132:()=>q7,content_2247_2134:()=>j7,content_2247_2136:()=>H7,content_2247_2138:()=>Y7,content_2247_214:()=>fX,content_2247_2140:()=>J7,content_2247_2142:()=>e6,content_2247_2144:()=>o6,content_2247_2146:()=>r6,content_2247_2148:()=>c6,content_2247_2150:()=>a6,content_2247_2152:()=>u6,content_2247_2154:()=>d6,content_2247_2156:()=>k6,content_2247_2158:()=>f6,content_2247_216:()=>DX,content_2247_2160:()=>D6,content_2247_2162:()=>_6,content_2247_2164:()=>g6,content_2247_2166:()=>x6,content_2247_2168:()=>v6,content_2247_2170:()=>Z6,content_2247_2172:()=>N6,content_2247_2174:()=>A6,content_2247_2176:()=>R6,content_2247_2178:()=>S6,content_2247_218:()=>_X,content_2247_2180:()=>E6,content_2247_2182:()=>G6,content_2247_2184:()=>F6,content_2247_2186:()=>q6,content_2247_2188:()=>j6,content_2247_2190:()=>H6,content_2247_2192:()=>Y6,content_2247_2194:()=>J6,content_2247_2196:()=>e1,content_2247_2198:()=>o1,content_2247_22:()=>GM,content_2247_220:()=>gX,content_2247_2200:()=>r1,content_2247_2202:()=>c1,content_2247_2204:()=>a1,content_2247_2206:()=>u1,content_2247_2208:()=>d1,content_2247_2210:()=>k1,content_2247_2212:()=>f1,content_2247_2214:()=>D1,content_2247_2216:()=>_1,content_2247_2218:()=>g1,content_2247_222:()=>xX,content_2247_2220:()=>x1,content_2247_2222:()=>v1,content_2247_2224:()=>Z1,content_2247_2226:()=>N1,content_2247_2228:()=>A1,content_2247_2230:()=>R1,content_2247_2232:()=>S1,content_2247_2234:()=>E1,content_2247_2236:()=>G1,content_2247_2238:()=>F1,content_2247_224:()=>vX,content_2247_2240:()=>q1,content_2247_2242:()=>j1,content_2247_2244:()=>H1,content_2247_2246:()=>Y1,content_2247_2248:()=>J1,content_2247_2250:()=>e8,content_2247_2252:()=>o8,content_2247_2254:()=>r8,content_2247_2256:()=>c8,content_2247_2258:()=>a8,content_2247_226:()=>ZX,content_2247_2260:()=>u8,content_2247_2262:()=>d8,content_2247_2264:()=>k8,content_2247_2266:()=>f8,content_2247_2268:()=>D8,content_2247_2270:()=>_8,content_2247_2272:()=>g8,content_2247_2274:()=>x8,content_2247_2276:()=>v8,content_2247_2278:()=>Z8,content_2247_228:()=>NX,content_2247_2280:()=>N8,content_2247_2282:()=>A8,content_2247_2284:()=>R8,content_2247_2286:()=>S8,content_2247_2288:()=>E8,content_2247_2290:()=>G8,content_2247_2292:()=>F8,content_2247_2294:()=>q8,content_2247_2296:()=>j8,content_2247_2298:()=>H8,content_2247_230:()=>AX,content_2247_2300:()=>Y8,content_2247_2302:()=>J8,content_2247_2304:()=>e3,content_2247_2306:()=>o3,content_2247_2308:()=>r3,content_2247_2310:()=>c3,content_2247_2312:()=>a3,content_2247_2314:()=>u3,content_2247_2316:()=>d3,content_2247_2318:()=>k3,content_2247_232:()=>RX,content_2247_2320:()=>f3,content_2247_2322:()=>D3,content_2247_2324:()=>_3,content_2247_2326:()=>g3,content_2247_2328:()=>x3,content_2247_2330:()=>v3,content_2247_2332:()=>Z3,content_2247_2334:()=>N3,content_2247_2336:()=>A3,content_2247_2338:()=>R3,content_2247_234:()=>SX,content_2247_2340:()=>S3,content_2247_2342:()=>E3,content_2247_2344:()=>G3,content_2247_2346:()=>F3,content_2247_2348:()=>q3,content_2247_2350:()=>j3,content_2247_2352:()=>H3,content_2247_2354:()=>Y3,content_2247_2356:()=>J3,content_2247_2358:()=>e5,content_2247_236:()=>EX,content_2247_2360:()=>o5,content_2247_2362:()=>r5,content_2247_2364:()=>c5,content_2247_2366:()=>a5,content_2247_2368:()=>u5,content_2247_2370:()=>d5,content_2247_2372:()=>k5,content_2247_2374:()=>f5,content_2247_2376:()=>D5,content_2247_2378:()=>_5,content_2247_238:()=>GX,content_2247_2380:()=>g5,content_2247_2382:()=>x5,content_2247_2384:()=>v5,content_2247_2386:()=>Z5,content_2247_2388:()=>N5,content_2247_2390:()=>A5,content_2247_2392:()=>R5,content_2247_2394:()=>S5,content_2247_2396:()=>E5,content_2247_2398:()=>G5,content_2247_24:()=>FM,content_2247_240:()=>FX,content_2247_2400:()=>F5,content_2247_2402:()=>q5,content_2247_2404:()=>j5,content_2247_2406:()=>H5,content_2247_2408:()=>Y5,content_2247_2410:()=>J5,content_2247_2412:()=>e9,content_2247_2414:()=>o9,content_2247_2416:()=>r9,content_2247_2418:()=>c9,content_2247_242:()=>qX,content_2247_2420:()=>a9,content_2247_2422:()=>u9,content_2247_2424:()=>d9,content_2247_2426:()=>k9,content_2247_2428:()=>f9,content_2247_2430:()=>D9,content_2247_2432:()=>_9,content_2247_2434:()=>g9,content_2247_2436:()=>x9,content_2247_2438:()=>v9,content_2247_244:()=>jX,content_2247_2440:()=>Z9,content_2247_2442:()=>N9,content_2247_2444:()=>A9,content_2247_2446:()=>R9,content_2247_2448:()=>S9,content_2247_2450:()=>E9,content_2247_2452:()=>G9,content_2247_2454:()=>F9,content_2247_2456:()=>q9,content_2247_2458:()=>j9,content_2247_246:()=>HX,content_2247_2460:()=>H9,content_2247_2462:()=>Y9,content_2247_2464:()=>J9,content_2247_2466:()=>ett,content_2247_2468:()=>ott,content_2247_2470:()=>rtt,content_2247_2472:()=>ctt,content_2247_2474:()=>att,content_2247_2476:()=>utt,content_2247_2478:()=>dtt,content_2247_248:()=>YX,content_2247_2480:()=>ktt,content_2247_2482:()=>ftt,content_2247_2484:()=>Dtt,content_2247_2486:()=>_tt,content_2247_2488:()=>gtt,content_2247_2490:()=>xtt,content_2247_2492:()=>vtt,content_2247_2494:()=>Ztt,content_2247_2496:()=>Ntt,content_2247_2498:()=>Att,content_2247_250:()=>JX,content_2247_2500:()=>Rtt,content_2247_2502:()=>Stt,content_2247_2504:()=>Ett,content_2247_2506:()=>Gtt,content_2247_2508:()=>Ftt,content_2247_2510:()=>qtt,content_2247_2512:()=>jtt,content_2247_2514:()=>Htt,content_2247_2516:()=>Ytt,content_2247_2518:()=>Jtt,content_2247_252:()=>eg,content_2247_2520:()=>eet,content_2247_2522:()=>oet,content_2247_2524:()=>ret,content_2247_2526:()=>cet,content_2247_2528:()=>aet,content_2247_2530:()=>met,content_2247_2532:()=>het,content_2247_2534:()=>yet,content_2247_2536:()=>Met,content_2247_2538:()=>wet,content_2247_254:()=>og,content_2247_2540:()=>Xet,content_2247_2542:()=>Tet,content_2247_2544:()=>Cet,content_2247_2546:()=>Let,content_2247_2548:()=>bet,content_2247_2550:()=>zet,content_2247_2552:()=>Wet,content_2247_2554:()=>Iet,content_2247_2556:()=>Pet,content_2247_2558:()=>Bet,content_2247_256:()=>rg,content_2247_2560:()=>Oet,content_2247_2562:()=>Uet,content_2247_2564:()=>Vet,content_2247_2566:()=>Qet,content_2247_2568:()=>$et,content_2247_2570:()=>Ket,content_2247_2572:()=>tnt,content_2247_2574:()=>nnt,content_2247_2576:()=>pnt,content_2247_2578:()=>snt,content_2247_258:()=>cg,content_2247_2580:()=>int,content_2247_2582:()=>lnt,content_2247_2584:()=>mnt,content_2247_2586:()=>hnt,content_2247_2588:()=>ynt,content_2247_2590:()=>Mnt,content_2247_2592:()=>wnt,content_2247_2594:()=>Xnt,content_2247_2596:()=>Tnt,content_2247_2598:()=>Cnt,content_2247_26:()=>qM,content_2247_260:()=>ag,content_2247_2600:()=>Lnt,content_2247_2602:()=>bnt,content_2247_2604:()=>znt,content_2247_2606:()=>Wnt,content_2247_2608:()=>Int,content_2247_2610:()=>Pnt,content_2247_2612:()=>Bnt,content_2247_2614:()=>Ont,content_2247_2616:()=>Unt,content_2247_2618:()=>Vnt,content_2247_262:()=>ug,content_2247_2620:()=>Qnt,content_2247_2622:()=>$nt,content_2247_2624:()=>Knt,content_2247_2626:()=>tot,content_2247_2628:()=>not,content_2247_2630:()=>pot,content_2247_2632:()=>sot,content_2247_2634:()=>iot,content_2247_2636:()=>lot,content_2247_2638:()=>mot,content_2247_264:()=>dg,content_2247_2640:()=>hot,content_2247_2642:()=>yot,content_2247_2644:()=>Mot,content_2247_2646:()=>wot,content_2247_2648:()=>Xot,content_2247_2650:()=>Tot,content_2247_2652:()=>Cot,content_2247_2654:()=>Lot,content_2247_2656:()=>bot,content_2247_2658:()=>zot,content_2247_266:()=>kg,content_2247_2660:()=>Wot,content_2247_2662:()=>Iot,content_2247_2664:()=>Pot,content_2247_2666:()=>Bot,content_2247_2668:()=>Oot,content_2247_2670:()=>Uot,content_2247_2672:()=>Vot,content_2247_2674:()=>Qot,content_2247_2676:()=>$ot,content_2247_2678:()=>Kot,content_2247_268:()=>fg,content_2247_2680:()=>tpt,content_2247_2682:()=>npt,content_2247_2684:()=>ppt,content_2247_2686:()=>spt,content_2247_2688:()=>ipt,content_2247_2690:()=>lpt,content_2247_2692:()=>mpt,content_2247_2694:()=>hpt,content_2247_2696:()=>ypt,content_2247_2698:()=>Mpt,content_2247_270:()=>Dg,content_2247_2700:()=>wpt,content_2247_2702:()=>Xpt,content_2247_2704:()=>Tpt,content_2247_2706:()=>Cpt,content_2247_2708:()=>Lpt,content_2247_2710:()=>bpt,content_2247_2712:()=>zpt,content_2247_2714:()=>Wpt,content_2247_2716:()=>Ipt,content_2247_2718:()=>Ppt,content_2247_272:()=>_g,content_2247_2720:()=>Bpt,content_2247_2722:()=>Opt,content_2247_2724:()=>Upt,content_2247_2726:()=>Vpt,content_2247_2728:()=>Qpt,content_2247_2730:()=>$pt,content_2247_2732:()=>Kpt,content_2247_2734:()=>trt,content_2247_2736:()=>nrt,content_2247_2738:()=>prt,content_2247_274:()=>gg,content_2247_2740:()=>srt,content_2247_2742:()=>irt,content_2247_2744:()=>lrt,content_2247_2746:()=>mrt,content_2247_2748:()=>hrt,content_2247_2750:()=>yrt,content_2247_2752:()=>Mrt,content_2247_2754:()=>wrt,content_2247_2756:()=>Xrt,content_2247_2758:()=>Trt,content_2247_276:()=>xg,content_2247_2760:()=>Crt,content_2247_2762:()=>Lrt,content_2247_2764:()=>brt,content_2247_2766:()=>zrt,content_2247_2768:()=>Wrt,content_2247_2770:()=>Irt,content_2247_2772:()=>Prt,content_2247_2774:()=>Brt,content_2247_2776:()=>Ort,content_2247_2778:()=>Urt,content_2247_278:()=>vg,content_2247_2780:()=>Vrt,content_2247_2782:()=>Qrt,content_2247_2784:()=>$rt,content_2247_2786:()=>Krt,content_2247_2788:()=>tst,content_2247_2790:()=>nst,content_2247_2792:()=>pst,content_2247_2794:()=>sst,content_2247_2796:()=>ist,content_2247_2798:()=>lst,content_2247_28:()=>jM,content_2247_280:()=>Zg,content_2247_2800:()=>mst,content_2247_2802:()=>hst,content_2247_2804:()=>yst,content_2247_2806:()=>Mst,content_2247_2808:()=>wst,content_2247_2810:()=>Xst,content_2247_2812:()=>Tst,content_2247_2814:()=>Cst,content_2247_2816:()=>Lst,content_2247_2818:()=>bst,content_2247_282:()=>Ng,content_2247_2820:()=>zst,content_2247_2822:()=>Wst,content_2247_2824:()=>Ist,content_2247_2826:()=>Pst,content_2247_2828:()=>Bst,content_2247_2830:()=>Ost,content_2247_2832:()=>Ust,content_2247_2834:()=>Vst,content_2247_2836:()=>Qst,content_2247_2838:()=>$st,content_2247_284:()=>Ag,content_2247_2840:()=>Kst,content_2247_2842:()=>tct,content_2247_2844:()=>nct,content_2247_2846:()=>pct,content_2247_2848:()=>sct,content_2247_2850:()=>ict,content_2247_2852:()=>lct,content_2247_2854:()=>mct,content_2247_2856:()=>hct,content_2247_2858:()=>yct,content_2247_286:()=>Rg,content_2247_2860:()=>Mct,content_2247_2862:()=>wct,content_2247_2864:()=>Xct,content_2247_2866:()=>Tct,content_2247_2868:()=>Cct,content_2247_2870:()=>Lct,content_2247_2872:()=>bct,content_2247_2874:()=>zct,content_2247_2876:()=>Wct,content_2247_2878:()=>Ict,content_2247_288:()=>Sg,content_2247_2880:()=>Pct,content_2247_2882:()=>Bct,content_2247_2884:()=>Oct,content_2247_2886:()=>Uct,content_2247_2888:()=>Vct,content_2247_2890:()=>Qct,content_2247_2892:()=>$ct,content_2247_2894:()=>Kct,content_2247_2896:()=>tit,content_2247_2898:()=>nit,content_2247_290:()=>Eg,content_2247_2900:()=>pit,content_2247_2902:()=>sit,content_2247_2904:()=>iit,content_2247_2906:()=>lit,content_2247_2908:()=>mit,content_2247_2910:()=>hit,content_2247_2912:()=>yit,content_2247_2914:()=>Mit,content_2247_2916:()=>wit,content_2247_2918:()=>Xit,content_2247_292:()=>Gg,content_2247_2920:()=>Tit,content_2247_2922:()=>Cit,content_2247_2924:()=>Lit,content_2247_2926:()=>bit,content_2247_2928:()=>zit,content_2247_2930:()=>Wit,content_2247_2932:()=>Iit,content_2247_2934:()=>Pit,content_2247_2936:()=>Bit,content_2247_2938:()=>Oit,content_2247_294:()=>Fg,content_2247_2940:()=>Uit,content_2247_2942:()=>Vit,content_2247_2944:()=>Qit,content_2247_2946:()=>$it,content_2247_2948:()=>Kit,content_2247_2950:()=>tat,content_2247_2952:()=>nat,content_2247_2954:()=>pat,content_2247_2956:()=>sat,content_2247_2958:()=>iat,content_2247_296:()=>qg,content_2247_2960:()=>lat,content_2247_2962:()=>mat,content_2247_2964:()=>hat,content_2247_2966:()=>yat,content_2247_2968:()=>Mat,content_2247_2970:()=>wat,content_2247_2972:()=>Xat,content_2247_2974:()=>Tat,content_2247_2976:()=>Cat,content_2247_2978:()=>Lat,content_2247_298:()=>jg,content_2247_2980:()=>bat,content_2247_2982:()=>zat,content_2247_2984:()=>Wat,content_2247_2986:()=>Iat,content_2247_2988:()=>Pat,content_2247_2990:()=>Bat,content_2247_2992:()=>Oat,content_2247_2994:()=>Uat,content_2247_2996:()=>Vat,content_2247_2998:()=>Qat,content_2247_30:()=>HM,content_2247_300:()=>Hg,content_2247_3000:()=>$at,content_2247_3002:()=>Kat,content_2247_3004:()=>tlt,content_2247_3006:()=>nlt,content_2247_3008:()=>plt,content_2247_3010:()=>slt,content_2247_3012:()=>ilt,content_2247_3014:()=>llt,content_2247_3016:()=>mlt,content_2247_3018:()=>hlt,content_2247_302:()=>Yg,content_2247_3020:()=>ylt,content_2247_3022:()=>Mlt,content_2247_3024:()=>wlt,content_2247_3026:()=>Xlt,content_2247_3028:()=>Tlt,content_2247_3030:()=>Clt,content_2247_3032:()=>Llt,content_2247_3034:()=>blt,content_2247_3036:()=>zlt,content_2247_3038:()=>Wlt,content_2247_304:()=>Jg,content_2247_3040:()=>Ilt,content_2247_3042:()=>Plt,content_2247_3044:()=>Blt,content_2247_3046:()=>Olt,content_2247_3048:()=>Ult,content_2247_3050:()=>Vlt,content_2247_3052:()=>Qlt,content_2247_3054:()=>$lt,content_2247_3056:()=>Klt,content_2247_3058:()=>tut,content_2247_306:()=>eT,content_2247_3060:()=>nut,content_2247_3062:()=>put,content_2247_3064:()=>sut,content_2247_3066:()=>iut,content_2247_3068:()=>lut,content_2247_3070:()=>mut,content_2247_3072:()=>hut,content_2247_3074:()=>yut,content_2247_3076:()=>Mut,content_2247_3078:()=>wut,content_2247_308:()=>oT,content_2247_3080:()=>Xut,content_2247_3082:()=>Tut,content_2247_3084:()=>Cut,content_2247_3086:()=>Lut,content_2247_3088:()=>but,content_2247_3090:()=>zut,content_2247_3092:()=>Wut,content_2247_3094:()=>Iut,content_2247_3096:()=>Put,content_2247_3098:()=>But,content_2247_310:()=>rT,content_2247_3100:()=>Out,content_2247_3102:()=>Uut,content_2247_3104:()=>Vut,content_2247_3106:()=>Qut,content_2247_3108:()=>$ut,content_2247_3110:()=>Kut,content_2247_3112:()=>tmt,content_2247_3114:()=>nmt,content_2247_3116:()=>pmt,content_2247_3118:()=>smt,content_2247_312:()=>cT,content_2247_3120:()=>imt,content_2247_3122:()=>lmt,content_2247_3124:()=>mmt,content_2247_3126:()=>hmt,content_2247_3128:()=>ymt,content_2247_3130:()=>Mmt,content_2247_3132:()=>wmt,content_2247_3134:()=>Xmt,content_2247_3136:()=>Tmt,content_2247_3138:()=>Cmt,content_2247_314:()=>aT,content_2247_3140:()=>Lmt,content_2247_3142:()=>bmt,content_2247_3144:()=>zmt,content_2247_3146:()=>Wmt,content_2247_3148:()=>Imt,content_2247_3150:()=>Pmt,content_2247_3152:()=>Bmt,content_2247_3154:()=>Omt,content_2247_3156:()=>Umt,content_2247_3158:()=>Vmt,content_2247_316:()=>uT,content_2247_3160:()=>Qmt,content_2247_3162:()=>$mt,content_2247_3164:()=>Kmt,content_2247_3166:()=>tdt,content_2247_3168:()=>ndt,content_2247_3170:()=>pdt,content_2247_3172:()=>sdt,content_2247_3174:()=>idt,content_2247_3176:()=>ldt,content_2247_3178:()=>mdt,content_2247_318:()=>dT,content_2247_3180:()=>hdt,content_2247_3182:()=>ydt,content_2247_3184:()=>Mdt,content_2247_3186:()=>wdt,content_2247_3188:()=>Xdt,content_2247_3190:()=>Tdt,content_2247_3192:()=>Cdt,content_2247_3194:()=>Ldt,content_2247_3196:()=>bdt,content_2247_3198:()=>zdt,content_2247_32:()=>YM,content_2247_320:()=>kT,content_2247_3200:()=>Wdt,content_2247_3202:()=>Idt,content_2247_3204:()=>Pdt,content_2247_3206:()=>Bdt,content_2247_3208:()=>Odt,content_2247_3210:()=>Udt,content_2247_3212:()=>Vdt,content_2247_3214:()=>Qdt,content_2247_3216:()=>$dt,content_2247_3218:()=>Kdt,content_2247_322:()=>fT,content_2247_3220:()=>tht,content_2247_3222:()=>nht,content_2247_3224:()=>pht,content_2247_3226:()=>sht,content_2247_3228:()=>iht,content_2247_3230:()=>lht,content_2247_3232:()=>mht,content_2247_3234:()=>hht,content_2247_3236:()=>yht,content_2247_3238:()=>Mht,content_2247_324:()=>DT,content_2247_3240:()=>wht,content_2247_3242:()=>Xht,content_2247_3244:()=>Tht,content_2247_3246:()=>Cht,content_2247_3248:()=>Lht,content_2247_3250:()=>bht,content_2247_3252:()=>zht,content_2247_3254:()=>Wht,content_2247_3256:()=>Iht,content_2247_3258:()=>Pht,content_2247_326:()=>_T,content_2247_3260:()=>Bht,content_2247_3262:()=>Oht,content_2247_3264:()=>Uht,content_2247_3266:()=>Vht,content_2247_3268:()=>Qht,content_2247_3270:()=>$ht,content_2247_3272:()=>Kht,content_2247_3274:()=>tkt,content_2247_3276:()=>nkt,content_2247_3278:()=>pkt,content_2247_328:()=>gT,content_2247_3280:()=>skt,content_2247_3282:()=>ikt,content_2247_3284:()=>lkt,content_2247_3286:()=>mkt,content_2247_3288:()=>hkt,content_2247_3290:()=>ykt,content_2247_3292:()=>Mkt,content_2247_3294:()=>wkt,content_2247_3296:()=>Xkt,content_2247_3298:()=>Tkt,content_2247_330:()=>xT,content_2247_3300:()=>Ckt,content_2247_3302:()=>Lkt,content_2247_3304:()=>bkt,content_2247_3306:()=>zkt,content_2247_3308:()=>Wkt,content_2247_3310:()=>Ikt,content_2247_3312:()=>Pkt,content_2247_3314:()=>Bkt,content_2247_3316:()=>Okt,content_2247_3318:()=>Ukt,content_2247_332:()=>vT,content_2247_3320:()=>Vkt,content_2247_3322:()=>Qkt,content_2247_3324:()=>$kt,content_2247_3326:()=>Kkt,content_2247_3328:()=>tyt,content_2247_3330:()=>nyt,content_2247_3332:()=>pyt,content_2247_3334:()=>syt,content_2247_3336:()=>iyt,content_2247_3338:()=>lyt,content_2247_334:()=>ZT,content_2247_3340:()=>myt,content_2247_3342:()=>hyt,content_2247_3344:()=>yyt,content_2247_3346:()=>Myt,content_2247_3348:()=>wyt,content_2247_3350:()=>Xyt,content_2247_3352:()=>Tyt,content_2247_3354:()=>Cyt,content_2247_3356:()=>Lyt,content_2247_3358:()=>byt,content_2247_336:()=>NT,content_2247_3360:()=>zyt,content_2247_3362:()=>Wyt,content_2247_3364:()=>Iyt,content_2247_3366:()=>Pyt,content_2247_3368:()=>Byt,content_2247_3370:()=>Oyt,content_2247_3372:()=>Uyt,content_2247_3374:()=>Vyt,content_2247_3376:()=>Qyt,content_2247_3378:()=>$yt,content_2247_338:()=>AT,content_2247_3380:()=>Kyt,content_2247_3382:()=>tft,content_2247_3384:()=>nft,content_2247_3386:()=>pft,content_2247_3388:()=>sft,content_2247_3390:()=>ift,content_2247_3392:()=>lft,content_2247_3394:()=>mft,content_2247_3396:()=>hft,content_2247_3398:()=>yft,content_2247_34:()=>JM,content_2247_340:()=>RT,content_2247_3400:()=>Mft,content_2247_3402:()=>wft,content_2247_3404:()=>Xft,content_2247_3406:()=>Tft,content_2247_3408:()=>Cft,content_2247_3410:()=>Lft,content_2247_3412:()=>bft,content_2247_3414:()=>zft,content_2247_3416:()=>Wft,content_2247_3418:()=>Ift,content_2247_342:()=>ST,content_2247_3420:()=>Pft,content_2247_3422:()=>Bft,content_2247_3424:()=>Oft,content_2247_3426:()=>Uft,content_2247_3428:()=>Vft,content_2247_3430:()=>Qft,content_2247_3432:()=>$ft,content_2247_3434:()=>Kft,content_2247_3436:()=>tMt,content_2247_3438:()=>nMt,content_2247_344:()=>ET,content_2247_3440:()=>pMt,content_2247_3442:()=>sMt,content_2247_3444:()=>iMt,content_2247_3446:()=>lMt,content_2247_3448:()=>mMt,content_2247_3450:()=>hMt,content_2247_3452:()=>yMt,content_2247_3454:()=>MMt,content_2247_3456:()=>wMt,content_2247_3458:()=>XMt,content_2247_346:()=>GT,content_2247_3460:()=>TMt,content_2247_3462:()=>CMt,content_2247_3464:()=>LMt,content_2247_3466:()=>bMt,content_2247_3468:()=>zMt,content_2247_3470:()=>WMt,content_2247_3472:()=>IMt,content_2247_3474:()=>PMt,content_2247_3476:()=>BMt,content_2247_3478:()=>OMt,content_2247_348:()=>FT,content_2247_3480:()=>UMt,content_2247_3482:()=>VMt,content_2247_3484:()=>QMt,content_2247_3486:()=>$Mt,content_2247_3488:()=>KMt,content_2247_3490:()=>tDt,content_2247_3492:()=>nDt,content_2247_3494:()=>pDt,content_2247_3496:()=>sDt,content_2247_3498:()=>iDt,content_2247_350:()=>qT,content_2247_3500:()=>lDt,content_2247_3502:()=>mDt,content_2247_3504:()=>hDt,content_2247_3506:()=>yDt,content_2247_3508:()=>MDt,content_2247_3510:()=>wDt,content_2247_3512:()=>XDt,content_2247_3514:()=>TDt,content_2247_3516:()=>CDt,content_2247_3518:()=>LDt,content_2247_352:()=>jT,content_2247_3520:()=>bDt,content_2247_3522:()=>zDt,content_2247_3524:()=>WDt,content_2247_3526:()=>IDt,content_2247_3528:()=>PDt,content_2247_3530:()=>BDt,content_2247_3532:()=>ODt,content_2247_3534:()=>UDt,content_2247_3536:()=>VDt,content_2247_3538:()=>QDt,content_2247_354:()=>HT,content_2247_3540:()=>$Dt,content_2247_3542:()=>KDt,content_2247_3544:()=>twt,content_2247_3546:()=>nwt,content_2247_3548:()=>pwt,content_2247_3550:()=>swt,content_2247_3552:()=>iwt,content_2247_3554:()=>lwt,content_2247_3556:()=>mwt,content_2247_3558:()=>hwt,content_2247_356:()=>YT,content_2247_3560:()=>ywt,content_2247_3562:()=>Mwt,content_2247_3564:()=>wwt,content_2247_3566:()=>Xwt,content_2247_3568:()=>Twt,content_2247_3570:()=>Cwt,content_2247_3572:()=>Lwt,content_2247_3574:()=>bwt,content_2247_3576:()=>zwt,content_2247_3578:()=>Wwt,content_2247_358:()=>JT,content_2247_3580:()=>Iwt,content_2247_3582:()=>Pwt,content_2247_3584:()=>Bwt,content_2247_3586:()=>Owt,content_2247_3588:()=>Uwt,content_2247_3590:()=>Vwt,content_2247_3592:()=>Qwt,content_2247_3594:()=>$wt,content_2247_3596:()=>Kwt,content_2247_3598:()=>t_t,content_2247_36:()=>eD,content_2247_360:()=>ex,content_2247_3600:()=>n_t,content_2247_3602:()=>p_t,content_2247_3604:()=>s_t,content_2247_3606:()=>i_t,content_2247_3608:()=>l_t,content_2247_3610:()=>m_t,content_2247_3612:()=>h_t,content_2247_3614:()=>y_t,content_2247_3616:()=>M_t,content_2247_3618:()=>w_t,content_2247_362:()=>ox,content_2247_3620:()=>X_t,content_2247_3622:()=>T_t,content_2247_3624:()=>C_t,content_2247_3626:()=>L_t,content_2247_3628:()=>b_t,content_2247_3630:()=>z_t,content_2247_3632:()=>W_t,content_2247_3634:()=>I_t,content_2247_3636:()=>P_t,content_2247_3638:()=>B_t,content_2247_364:()=>rx,content_2247_3640:()=>O_t,content_2247_3642:()=>U_t,content_2247_3644:()=>V_t,content_2247_3646:()=>Q_t,content_2247_3648:()=>$_t,content_2247_3650:()=>K_t,content_2247_3652:()=>tXt,content_2247_3654:()=>nXt,content_2247_3656:()=>pXt,content_2247_3658:()=>sXt,content_2247_366:()=>cx,content_2247_3660:()=>iXt,content_2247_3662:()=>lXt,content_2247_3664:()=>mXt,content_2247_3666:()=>hXt,content_2247_3668:()=>yXt,content_2247_3670:()=>MXt,content_2247_3672:()=>wXt,content_2247_3674:()=>XXt,content_2247_3676:()=>TXt,content_2247_3678:()=>CXt,content_2247_368:()=>ax,content_2247_3680:()=>LXt,content_2247_3682:()=>bXt,content_2247_3684:()=>zXt,content_2247_3686:()=>WXt,content_2247_3688:()=>IXt,content_2247_3690:()=>PXt,content_2247_3692:()=>BXt,content_2247_3694:()=>OXt,content_2247_3696:()=>UXt,content_2247_3698:()=>VXt,content_2247_370:()=>ux,content_2247_3700:()=>QXt,content_2247_3702:()=>$Xt,content_2247_3704:()=>KXt,content_2247_3706:()=>tgt,content_2247_3708:()=>ngt,content_2247_3710:()=>pgt,content_2247_3712:()=>sgt,content_2247_3714:()=>igt,content_2247_3716:()=>lgt,content_2247_3718:()=>mgt,content_2247_372:()=>dx,content_2247_3720:()=>hgt,content_2247_3722:()=>ygt,content_2247_3724:()=>Mgt,content_2247_3726:()=>wgt,content_2247_3728:()=>Xgt,content_2247_3730:()=>Tgt,content_2247_3732:()=>Cgt,content_2247_3734:()=>Lgt,content_2247_3736:()=>bgt,content_2247_3738:()=>zgt,content_2247_374:()=>kx,content_2247_3740:()=>Wgt,content_2247_3742:()=>Igt,content_2247_3744:()=>Pgt,content_2247_3746:()=>Bgt,content_2247_3748:()=>Ogt,content_2247_3750:()=>Ugt,content_2247_3752:()=>Vgt,content_2247_3754:()=>Qgt,content_2247_3756:()=>$gt,content_2247_3758:()=>Kgt,content_2247_376:()=>fx,content_2247_3760:()=>tTt,content_2247_3762:()=>nTt,content_2247_3764:()=>pTt,content_2247_3766:()=>sTt,content_2247_3768:()=>iTt,content_2247_3770:()=>lTt,content_2247_3772:()=>mTt,content_2247_3774:()=>hTt,content_2247_3776:()=>yTt,content_2247_3778:()=>MTt,content_2247_378:()=>Dx,content_2247_3780:()=>wTt,content_2247_3782:()=>XTt,content_2247_3784:()=>TTt,content_2247_3786:()=>CTt,content_2247_3788:()=>LTt,content_2247_3790:()=>bTt,content_2247_3792:()=>zTt,content_2247_3794:()=>WTt,content_2247_3796:()=>ITt,content_2247_3798:()=>PTt,content_2247_38:()=>oD,content_2247_380:()=>_x,content_2247_3800:()=>BTt,content_2247_3802:()=>OTt,content_2247_3804:()=>UTt,content_2247_3806:()=>VTt,content_2247_3808:()=>QTt,content_2247_3810:()=>$Tt,content_2247_3812:()=>KTt,content_2247_3814:()=>txt,content_2247_3816:()=>nxt,content_2247_3818:()=>pxt,content_2247_382:()=>gx,content_2247_3820:()=>sxt,content_2247_3822:()=>ixt,content_2247_3824:()=>lxt,content_2247_3826:()=>mxt,content_2247_3828:()=>hxt,content_2247_3830:()=>yxt,content_2247_3832:()=>Mxt,content_2247_3834:()=>wxt,content_2247_3836:()=>Xxt,content_2247_3838:()=>Txt,content_2247_384:()=>xx,content_2247_3840:()=>Cxt,content_2247_3842:()=>Lxt,content_2247_3844:()=>bxt,content_2247_3846:()=>zxt,content_2247_3848:()=>Wxt,content_2247_3850:()=>Ixt,content_2247_3852:()=>Pxt,content_2247_3854:()=>Bxt,content_2247_3856:()=>Oxt,content_2247_3858:()=>Uxt,content_2247_386:()=>vx,content_2247_3860:()=>Vxt,content_2247_3862:()=>Qxt,content_2247_3864:()=>$xt,content_2247_3866:()=>Kxt,content_2247_3868:()=>tCt,content_2247_3870:()=>nCt,content_2247_3872:()=>pCt,content_2247_3874:()=>sCt,content_2247_3876:()=>iCt,content_2247_3878:()=>lCt,content_2247_388:()=>Zx,content_2247_3880:()=>mCt,content_2247_3882:()=>hCt,content_2247_3884:()=>yCt,content_2247_3886:()=>MCt,content_2247_3888:()=>wCt,content_2247_3890:()=>XCt,content_2247_3892:()=>TCt,content_2247_3894:()=>CCt,content_2247_3896:()=>LCt,content_2247_3898:()=>bCt,content_2247_390:()=>Nx,content_2247_3900:()=>zCt,content_2247_3902:()=>WCt,content_2247_3904:()=>ICt,content_2247_3906:()=>PCt,content_2247_3908:()=>BCt,content_2247_3910:()=>OCt,content_2247_3912:()=>UCt,content_2247_3914:()=>VCt,content_2247_3916:()=>QCt,content_2247_3918:()=>$Ct,content_2247_392:()=>Ax,content_2247_3920:()=>KCt,content_2247_3922:()=>tvt,content_2247_3924:()=>nvt,content_2247_3926:()=>pvt,content_2247_3928:()=>svt,content_2247_3930:()=>ivt,content_2247_3932:()=>lvt,content_2247_3934:()=>mvt,content_2247_3936:()=>hvt,content_2247_3938:()=>yvt,content_2247_394:()=>Rx,content_2247_3940:()=>Mvt,content_2247_3942:()=>wvt,content_2247_3944:()=>Xvt,content_2247_3946:()=>Tvt,content_2247_3948:()=>Cvt,content_2247_3950:()=>Lvt,content_2247_3952:()=>bvt,content_2247_3954:()=>zvt,content_2247_3956:()=>Wvt,content_2247_3958:()=>Ivt,content_2247_396:()=>Sx,content_2247_3960:()=>Pvt,content_2247_3962:()=>Bvt,content_2247_3964:()=>Ovt,content_2247_3966:()=>Uvt,content_2247_3968:()=>Vvt,content_2247_3970:()=>Qvt,content_2247_3972:()=>$vt,content_2247_3974:()=>Kvt,content_2247_3976:()=>tLt,content_2247_3978:()=>nLt,content_2247_398:()=>Ex,content_2247_3980:()=>pLt,content_2247_3982:()=>sLt,content_2247_3984:()=>iLt,content_2247_3986:()=>lLt,content_2247_3988:()=>mLt,content_2247_3990:()=>hLt,content_2247_3992:()=>yLt,content_2247_3994:()=>MLt,content_2247_3996:()=>wLt,content_2247_3998:()=>XLt,content_2247_4:()=>gM,content_2247_40:()=>rD,content_2247_400:()=>Gx,content_2247_4000:()=>TLt,content_2247_4002:()=>CLt,content_2247_4004:()=>LLt,content_2247_4006:()=>bLt,content_2247_4008:()=>zLt,content_2247_4010:()=>WLt,content_2247_4012:()=>ILt,content_2247_4014:()=>PLt,content_2247_4016:()=>BLt,content_2247_4018:()=>OLt,content_2247_402:()=>Fx,content_2247_4020:()=>ULt,content_2247_4022:()=>VLt,content_2247_4024:()=>QLt,content_2247_4026:()=>$Lt,content_2247_4028:()=>KLt,content_2247_4030:()=>tZt,content_2247_4032:()=>nZt,content_2247_4034:()=>pZt,content_2247_4036:()=>sZt,content_2247_4038:()=>iZt,content_2247_404:()=>qx,content_2247_4040:()=>lZt,content_2247_4042:()=>mZt,content_2247_4044:()=>hZt,content_2247_4046:()=>yZt,content_2247_4048:()=>MZt,content_2247_4050:()=>wZt,content_2247_4052:()=>XZt,content_2247_4054:()=>TZt,content_2247_4056:()=>CZt,content_2247_4058:()=>LZt,content_2247_406:()=>jx,content_2247_4060:()=>bZt,content_2247_4062:()=>zZt,content_2247_4064:()=>WZt,content_2247_4066:()=>IZt,content_2247_4068:()=>PZt,content_2247_4070:()=>BZt,content_2247_4072:()=>OZt,content_2247_4074:()=>UZt,content_2247_4076:()=>VZt,content_2247_4078:()=>QZt,content_2247_408:()=>Hx,content_2247_4080:()=>$Zt,content_2247_4082:()=>KZt,content_2247_4084:()=>tbt,content_2247_4086:()=>nbt,content_2247_4088:()=>pbt,content_2247_4090:()=>sbt,content_2247_4092:()=>ibt,content_2247_4094:()=>lbt,content_2247_4096:()=>mbt,content_2247_4098:()=>hbt,content_2247_410:()=>Yx,content_2247_4100:()=>ybt,content_2247_4102:()=>Mbt,content_2247_4104:()=>wbt,content_2247_4106:()=>Xbt,content_2247_4108:()=>Tbt,content_2247_4110:()=>Cbt,content_2247_4112:()=>Lbt,content_2247_4114:()=>bbt,content_2247_4116:()=>zbt,content_2247_4118:()=>Wbt,content_2247_412:()=>Jx,content_2247_4120:()=>Ibt,content_2247_4122:()=>Pbt,content_2247_4124:()=>Bbt,content_2247_4126:()=>Obt,content_2247_4128:()=>Ubt,content_2247_4130:()=>Vbt,content_2247_4132:()=>Qbt,content_2247_4134:()=>$bt,content_2247_4136:()=>Kbt,content_2247_4138:()=>tNt,content_2247_414:()=>eC,content_2247_4140:()=>nNt,content_2247_4142:()=>pNt,content_2247_4144:()=>sNt,content_2247_4146:()=>iNt,content_2247_4148:()=>lNt,content_2247_4150:()=>mNt,content_2247_4152:()=>hNt,content_2247_4154:()=>yNt,content_2247_4156:()=>MNt,content_2247_4158:()=>wNt,content_2247_416:()=>oC,content_2247_4160:()=>XNt,content_2247_4162:()=>TNt,content_2247_4164:()=>CNt,content_2247_4166:()=>LNt,content_2247_4168:()=>bNt,content_2247_4170:()=>zNt,content_2247_4172:()=>WNt,content_2247_4174:()=>INt,content_2247_4176:()=>PNt,content_2247_4178:()=>BNt,content_2247_418:()=>rC,content_2247_4180:()=>ONt,content_2247_4182:()=>UNt,content_2247_4184:()=>VNt,content_2247_4186:()=>QNt,content_2247_4188:()=>$Nt,content_2247_4190:()=>KNt,content_2247_4192:()=>tzt,content_2247_4194:()=>nzt,content_2247_4196:()=>pzt,content_2247_4198:()=>szt,content_2247_42:()=>cD,content_2247_420:()=>cC,content_2247_4200:()=>izt,content_2247_4202:()=>lzt,content_2247_4204:()=>mzt,content_2247_4206:()=>hzt,content_2247_4208:()=>yzt,content_2247_4210:()=>Mzt,content_2247_4212:()=>wzt,content_2247_4214:()=>Xzt,content_2247_4216:()=>Tzt,content_2247_4218:()=>Czt,content_2247_422:()=>aC,content_2247_4220:()=>Lzt,content_2247_4222:()=>bzt,content_2247_4224:()=>zzt,content_2247_4226:()=>Wzt,content_2247_4228:()=>Izt,content_2247_4230:()=>Pzt,content_2247_4232:()=>Bzt,content_2247_4234:()=>Ozt,content_2247_4236:()=>Uzt,content_2247_4238:()=>Vzt,content_2247_424:()=>uC,content_2247_4240:()=>Qzt,content_2247_4242:()=>$zt,content_2247_4244:()=>Kzt,content_2247_4246:()=>tAt,content_2247_4248:()=>nAt,content_2247_4250:()=>pAt,content_2247_4252:()=>sAt,content_2247_4254:()=>iAt,content_2247_4256:()=>lAt,content_2247_4258:()=>mAt,content_2247_426:()=>dC,content_2247_4260:()=>hAt,content_2247_4262:()=>yAt,content_2247_4264:()=>MAt,content_2247_4266:()=>wAt,content_2247_4268:()=>XAt,content_2247_4270:()=>TAt,content_2247_4272:()=>CAt,content_2247_4274:()=>LAt,content_2247_4276:()=>bAt,content_2247_4278:()=>zAt,content_2247_428:()=>kC,content_2247_4280:()=>WAt,content_2247_4282:()=>IAt,content_2247_4284:()=>PAt,content_2247_4286:()=>BAt,content_2247_4288:()=>OAt,content_2247_4290:()=>UAt,content_2247_4292:()=>VAt,content_2247_4294:()=>QAt,content_2247_4296:()=>$At,content_2247_4298:()=>KAt,content_2247_430:()=>fC,content_2247_4300:()=>tWt,content_2247_4302:()=>nWt,content_2247_4304:()=>pWt,content_2247_4306:()=>sWt,content_2247_4308:()=>iWt,content_2247_4310:()=>lWt,content_2247_4312:()=>mWt,content_2247_4314:()=>hWt,content_2247_4316:()=>yWt,content_2247_4318:()=>MWt,content_2247_432:()=>DC,content_2247_4320:()=>wWt,content_2247_4322:()=>XWt,content_2247_4324:()=>TWt,content_2247_4326:()=>CWt,content_2247_4328:()=>LWt,content_2247_4330:()=>bWt,content_2247_4332:()=>zWt,content_2247_4334:()=>WWt,content_2247_4336:()=>IWt,content_2247_4338:()=>PWt,content_2247_434:()=>_C,content_2247_4340:()=>BWt,content_2247_4342:()=>OWt,content_2247_4344:()=>UWt,content_2247_4346:()=>VWt,content_2247_4348:()=>QWt,content_2247_4350:()=>$Wt,content_2247_4352:()=>KWt,content_2247_4354:()=>tRt,content_2247_4356:()=>nRt,content_2247_4358:()=>pRt,content_2247_436:()=>gC,content_2247_4360:()=>sRt,content_2247_4362:()=>iRt,content_2247_4364:()=>lRt,content_2247_4366:()=>mRt,content_2247_4368:()=>hRt,content_2247_4370:()=>yRt,content_2247_4372:()=>MRt,content_2247_4374:()=>wRt,content_2247_4376:()=>XRt,content_2247_4378:()=>TRt,content_2247_438:()=>xC,content_2247_4380:()=>CRt,content_2247_4382:()=>LRt,content_2247_4384:()=>bRt,content_2247_4386:()=>zRt,content_2247_4388:()=>WRt,content_2247_4390:()=>IRt,content_2247_4392:()=>PRt,content_2247_4394:()=>BRt,content_2247_4396:()=>ORt,content_2247_4398:()=>URt,content_2247_44:()=>aD,content_2247_440:()=>vC,content_2247_4400:()=>VRt,content_2247_4402:()=>QRt,content_2247_4404:()=>$Rt,content_2247_4406:()=>KRt,content_2247_4408:()=>tIt,content_2247_4410:()=>nIt,content_2247_4412:()=>pIt,content_2247_4414:()=>sIt,content_2247_4416:()=>iIt,content_2247_4418:()=>lIt,content_2247_442:()=>ZC,content_2247_4420:()=>mIt,content_2247_4422:()=>hIt,content_2247_4424:()=>yIt,content_2247_4426:()=>MIt,content_2247_4428:()=>wIt,content_2247_4430:()=>XIt,content_2247_4432:()=>TIt,content_2247_4434:()=>CIt,content_2247_4436:()=>LIt,content_2247_4438:()=>bIt,content_2247_444:()=>NC,content_2247_4440:()=>zIt,content_2247_4442:()=>WIt,content_2247_4444:()=>IIt,content_2247_4446:()=>PIt,content_2247_4448:()=>BIt,content_2247_4450:()=>OIt,content_2247_4452:()=>UIt,content_2247_4454:()=>VIt,content_2247_4456:()=>QIt,content_2247_4458:()=>$It,content_2247_446:()=>AC,content_2247_4460:()=>KIt,content_2247_4462:()=>tSt,content_2247_4464:()=>nSt,content_2247_4466:()=>pSt,content_2247_4468:()=>sSt,content_2247_4470:()=>iSt,content_2247_4472:()=>lSt,content_2247_4474:()=>mSt,content_2247_4476:()=>hSt,content_2247_4478:()=>ySt,content_2247_448:()=>RC,content_2247_4480:()=>MSt,content_2247_4482:()=>wSt,content_2247_4484:()=>XSt,content_2247_4486:()=>TSt,content_2247_4488:()=>CSt,content_2247_4490:()=>LSt,content_2247_4492:()=>bSt,content_2247_4494:()=>zSt,content_2247_4496:()=>WSt,content_2247_4498:()=>ISt,content_2247_450:()=>SC,content_2247_4500:()=>PSt,content_2247_4502:()=>BSt,content_2247_4504:()=>OSt,content_2247_4506:()=>USt,content_2247_4508:()=>VSt,content_2247_4510:()=>QSt,content_2247_4512:()=>$St,content_2247_4514:()=>KSt,content_2247_4516:()=>tPt,content_2247_4518:()=>nPt,content_2247_452:()=>EC,content_2247_4520:()=>pPt,content_2247_4522:()=>sPt,content_2247_4524:()=>iPt,content_2247_4526:()=>lPt,content_2247_4528:()=>mPt,content_2247_4530:()=>hPt,content_2247_4532:()=>yPt,content_2247_4534:()=>MPt,content_2247_4536:()=>wPt,content_2247_4538:()=>XPt,content_2247_454:()=>GC,content_2247_4540:()=>TPt,content_2247_4542:()=>CPt,content_2247_4544:()=>LPt,content_2247_4546:()=>bPt,content_2247_4548:()=>zPt,content_2247_4550:()=>WPt,content_2247_4552:()=>IPt,content_2247_4554:()=>PPt,content_2247_4556:()=>BPt,content_2247_4558:()=>OPt,content_2247_456:()=>FC,content_2247_4560:()=>UPt,content_2247_4562:()=>VPt,content_2247_4564:()=>QPt,content_2247_4566:()=>$Pt,content_2247_4568:()=>KPt,content_2247_4570:()=>tEt,content_2247_4572:()=>nEt,content_2247_4574:()=>pEt,content_2247_4576:()=>sEt,content_2247_4578:()=>iEt,content_2247_458:()=>qC,content_2247_4580:()=>lEt,content_2247_4582:()=>mEt,content_2247_4584:()=>hEt,content_2247_4586:()=>yEt,content_2247_4588:()=>MEt,content_2247_4590:()=>wEt,content_2247_4592:()=>XEt,content_2247_4594:()=>TEt,content_2247_4596:()=>CEt,content_2247_4598:()=>LEt,content_2247_46:()=>uD,content_2247_460:()=>jC,content_2247_4600:()=>bEt,content_2247_4602:()=>zEt,content_2247_4604:()=>WEt,content_2247_4606:()=>IEt,content_2247_4608:()=>PEt,content_2247_4610:()=>BEt,content_2247_4612:()=>OEt,content_2247_4614:()=>UEt,content_2247_4616:()=>VEt,content_2247_4618:()=>QEt,content_2247_462:()=>HC,content_2247_4620:()=>$Et,content_2247_4622:()=>KEt,content_2247_4624:()=>tBt,content_2247_4626:()=>nBt,content_2247_4628:()=>pBt,content_2247_4630:()=>sBt,content_2247_4632:()=>iBt,content_2247_4634:()=>lBt,content_2247_4636:()=>mBt,content_2247_4638:()=>hBt,content_2247_464:()=>YC,content_2247_4640:()=>yBt,content_2247_4642:()=>MBt,content_2247_4644:()=>wBt,content_2247_4646:()=>XBt,content_2247_4648:()=>TBt,content_2247_4650:()=>CBt,content_2247_4652:()=>LBt,content_2247_4654:()=>bBt,content_2247_4656:()=>zBt,content_2247_4658:()=>WBt,content_2247_466:()=>JC,content_2247_4660:()=>IBt,content_2247_4662:()=>PBt,content_2247_4664:()=>BBt,content_2247_4666:()=>OBt,content_2247_4668:()=>UBt,content_2247_4670:()=>VBt,content_2247_4672:()=>QBt,content_2247_4674:()=>$Bt,content_2247_4676:()=>KBt,content_2247_4678:()=>tGt,content_2247_468:()=>ev,content_2247_4680:()=>nGt,content_2247_4682:()=>pGt,content_2247_4684:()=>sGt,content_2247_4686:()=>iGt,content_2247_4688:()=>lGt,content_2247_4690:()=>mGt,content_2247_4692:()=>hGt,content_2247_4694:()=>yGt,content_2247_4696:()=>MGt,content_2247_4698:()=>wGt,content_2247_470:()=>ov,content_2247_4700:()=>XGt,content_2247_4702:()=>TGt,content_2247_4704:()=>CGt,content_2247_4706:()=>LGt,content_2247_4708:()=>bGt,content_2247_4710:()=>zGt,content_2247_4712:()=>WGt,content_2247_4714:()=>IGt,content_2247_4716:()=>PGt,content_2247_4718:()=>BGt,content_2247_472:()=>rv,content_2247_4720:()=>OGt,content_2247_4722:()=>UGt,content_2247_4724:()=>VGt,content_2247_4726:()=>QGt,content_2247_4728:()=>$Gt,content_2247_4730:()=>KGt,content_2247_4732:()=>tOt,content_2247_4734:()=>nOt,content_2247_4736:()=>pOt,content_2247_4738:()=>sOt,content_2247_474:()=>cv,content_2247_4740:()=>iOt,content_2247_4742:()=>lOt,content_2247_4744:()=>mOt,content_2247_4746:()=>hOt,content_2247_4748:()=>yOt,content_2247_4750:()=>MOt,content_2247_4752:()=>wOt,content_2247_4754:()=>XOt,content_2247_4756:()=>TOt,content_2247_4758:()=>COt,content_2247_476:()=>av,content_2247_4760:()=>LOt,content_2247_4762:()=>bOt,content_2247_4764:()=>zOt,content_2247_4766:()=>WOt,content_2247_4768:()=>IOt,content_2247_4770:()=>POt,content_2247_4772:()=>BOt,content_2247_4774:()=>OOt,content_2247_4776:()=>UOt,content_2247_4778:()=>VOt,content_2247_478:()=>uv,content_2247_4780:()=>QOt,content_2247_4782:()=>$Ot,content_2247_4784:()=>KOt,content_2247_4786:()=>tFt,content_2247_4788:()=>nFt,content_2247_4790:()=>pFt,content_2247_4792:()=>sFt,content_2247_4794:()=>iFt,content_2247_4796:()=>lFt,content_2247_4798:()=>mFt,content_2247_48:()=>dD,content_2247_480:()=>dv,content_2247_4800:()=>hFt,content_2247_4802:()=>yFt,content_2247_4804:()=>MFt,content_2247_4806:()=>wFt,content_2247_4808:()=>XFt,content_2247_4810:()=>TFt,content_2247_4812:()=>CFt,content_2247_4814:()=>LFt,content_2247_4816:()=>bFt,content_2247_4818:()=>zFt,content_2247_482:()=>kv,content_2247_4820:()=>WFt,content_2247_4822:()=>IFt,content_2247_4824:()=>PFt,content_2247_4826:()=>BFt,content_2247_4828:()=>OFt,content_2247_4830:()=>UFt,content_2247_4832:()=>VFt,content_2247_4834:()=>QFt,content_2247_4836:()=>$Ft,content_2247_4838:()=>KFt,content_2247_484:()=>fv,content_2247_4840:()=>tUt,content_2247_4842:()=>nUt,content_2247_4844:()=>pUt,content_2247_4846:()=>sUt,content_2247_4848:()=>iUt,content_2247_4850:()=>lUt,content_2247_4852:()=>mUt,content_2247_4854:()=>hUt,content_2247_4856:()=>yUt,content_2247_4858:()=>MUt,content_2247_486:()=>Dv,content_2247_4860:()=>wUt,content_2247_4862:()=>XUt,content_2247_4864:()=>TUt,content_2247_4866:()=>CUt,content_2247_4868:()=>LUt,content_2247_4870:()=>bUt,content_2247_4872:()=>zUt,content_2247_4874:()=>WUt,content_2247_4876:()=>IUt,content_2247_4878:()=>PUt,content_2247_488:()=>_v,content_2247_4880:()=>BUt,content_2247_4882:()=>OUt,content_2247_4884:()=>UUt,content_2247_4886:()=>VUt,content_2247_4888:()=>QUt,content_2247_4890:()=>$Ut,content_2247_4892:()=>KUt,content_2247_4894:()=>tqt,content_2247_4896:()=>nqt,content_2247_4898:()=>pqt,content_2247_490:()=>gv,content_2247_4900:()=>sqt,content_2247_4902:()=>iqt,content_2247_4904:()=>lqt,content_2247_4906:()=>mqt,content_2247_4908:()=>hqt,content_2247_4910:()=>yqt,content_2247_4912:()=>Mqt,content_2247_4914:()=>wqt,content_2247_4916:()=>Xqt,content_2247_4918:()=>Tqt,content_2247_492:()=>xv,content_2247_4920:()=>Cqt,content_2247_4922:()=>Lqt,content_2247_4924:()=>bqt,content_2247_4926:()=>zqt,content_2247_4928:()=>Wqt,content_2247_4930:()=>Iqt,content_2247_4932:()=>Pqt,content_2247_4934:()=>Bqt,content_2247_4936:()=>Oqt,content_2247_4938:()=>Uqt,content_2247_494:()=>vv,content_2247_4940:()=>Vqt,content_2247_4942:()=>Qqt,content_2247_4944:()=>$qt,content_2247_4946:()=>Kqt,content_2247_4948:()=>tVt,content_2247_4950:()=>nVt,content_2247_4952:()=>pVt,content_2247_4954:()=>sVt,content_2247_4956:()=>iVt,content_2247_4958:()=>lVt,content_2247_496:()=>Zv,content_2247_4960:()=>mVt,content_2247_4962:()=>hVt,content_2247_4964:()=>yVt,content_2247_4966:()=>MVt,content_2247_4968:()=>wVt,content_2247_4970:()=>XVt,content_2247_4972:()=>TVt,content_2247_4974:()=>CVt,content_2247_4976:()=>LVt,content_2247_4978:()=>bVt,content_2247_498:()=>Nv,content_2247_4980:()=>zVt,content_2247_4982:()=>WVt,content_2247_4984:()=>IVt,content_2247_4986:()=>PVt,content_2247_4988:()=>BVt,content_2247_4990:()=>OVt,content_2247_4992:()=>UVt,content_2247_4994:()=>VVt,content_2247_4996:()=>QVt,content_2247_4998:()=>$Vt,content_2247_50:()=>kD,content_2247_500:()=>Av,content_2247_5000:()=>KVt,content_2247_5002:()=>tjt,content_2247_5004:()=>njt,content_2247_5006:()=>pjt,content_2247_5008:()=>sjt,content_2247_5010:()=>ijt,content_2247_5012:()=>ljt,content_2247_5014:()=>mjt,content_2247_5016:()=>hjt,content_2247_5018:()=>yjt,content_2247_502:()=>Rv,content_2247_5020:()=>Mjt,content_2247_5022:()=>wjt,content_2247_5024:()=>Xjt,content_2247_5026:()=>Tjt,content_2247_5028:()=>Cjt,content_2247_5030:()=>Ljt,content_2247_5032:()=>bjt,content_2247_5034:()=>zjt,content_2247_5036:()=>Wjt,content_2247_5038:()=>Ijt,content_2247_504:()=>Sv,content_2247_5040:()=>Pjt,content_2247_5042:()=>Bjt,content_2247_5044:()=>Ojt,content_2247_5046:()=>Ujt,content_2247_5048:()=>Vjt,content_2247_5050:()=>Qjt,content_2247_5052:()=>$jt,content_2247_5054:()=>Kjt,content_2247_5056:()=>tQt,content_2247_5058:()=>nQt,content_2247_506:()=>Ev,content_2247_5060:()=>pQt,content_2247_5062:()=>sQt,content_2247_5064:()=>iQt,content_2247_5066:()=>lQt,content_2247_5068:()=>mQt,content_2247_5070:()=>hQt,content_2247_5072:()=>yQt,content_2247_5074:()=>MQt,content_2247_5076:()=>wQt,content_2247_5078:()=>XQt,content_2247_508:()=>Gv,content_2247_5080:()=>TQt,content_2247_5082:()=>CQt,content_2247_5084:()=>LQt,content_2247_5086:()=>bQt,content_2247_5088:()=>zQt,content_2247_5090:()=>WQt,content_2247_5092:()=>IQt,content_2247_5094:()=>PQt,content_2247_5096:()=>BQt,content_2247_5098:()=>OQt,content_2247_510:()=>Fv,content_2247_5100:()=>UQt,content_2247_5102:()=>VQt,content_2247_5104:()=>QQt,content_2247_5106:()=>$Qt,content_2247_5108:()=>KQt,content_2247_5110:()=>tHt,content_2247_5112:()=>nHt,content_2247_5114:()=>pHt,content_2247_5116:()=>sHt,content_2247_5118:()=>iHt,content_2247_512:()=>qv,content_2247_5120:()=>lHt,content_2247_5122:()=>mHt,content_2247_5124:()=>hHt,content_2247_5126:()=>yHt,content_2247_5128:()=>MHt,content_2247_5130:()=>wHt,content_2247_5132:()=>XHt,content_2247_5134:()=>THt,content_2247_5136:()=>CHt,content_2247_5138:()=>LHt,content_2247_514:()=>jv,content_2247_5140:()=>bHt,content_2247_5142:()=>zHt,content_2247_5144:()=>WHt,content_2247_5146:()=>IHt,content_2247_5148:()=>PHt,content_2247_5150:()=>BHt,content_2247_5152:()=>OHt,content_2247_5154:()=>UHt,content_2247_5156:()=>VHt,content_2247_5158:()=>QHt,content_2247_516:()=>Hv,content_2247_5160:()=>$Ht,content_2247_5162:()=>KHt,content_2247_5164:()=>t$t,content_2247_5166:()=>n$t,content_2247_5168:()=>p$t,content_2247_5170:()=>s$t,content_2247_5172:()=>i$t,content_2247_5174:()=>l$t,content_2247_5176:()=>m$t,content_2247_5178:()=>h$t,content_2247_518:()=>Yv,content_2247_5180:()=>y$t,content_2247_5182:()=>M$t,content_2247_5184:()=>w$t,content_2247_5186:()=>X$t,content_2247_5188:()=>T$t,content_2247_5190:()=>C$t,content_2247_5192:()=>L$t,content_2247_5194:()=>b$t,content_2247_5196:()=>z$t,content_2247_5198:()=>W$t,content_2247_52:()=>fD,content_2247_520:()=>Jv,content_2247_5200:()=>I$t,content_2247_5202:()=>P$t,content_2247_5204:()=>B$t,content_2247_5206:()=>O$t,content_2247_5208:()=>U$t,content_2247_5210:()=>V$t,content_2247_5212:()=>Q$t,content_2247_5214:()=>$$t,content_2247_5216:()=>K$t,content_2247_5218:()=>tYt,content_2247_522:()=>eL,content_2247_5220:()=>nYt,content_2247_5222:()=>pYt,content_2247_5224:()=>sYt,content_2247_5226:()=>iYt,content_2247_5228:()=>lYt,content_2247_5230:()=>mYt,content_2247_5232:()=>hYt,content_2247_5234:()=>yYt,content_2247_5236:()=>MYt,content_2247_5238:()=>wYt,content_2247_524:()=>oL,content_2247_5240:()=>XYt,content_2247_5242:()=>TYt,content_2247_5244:()=>CYt,content_2247_5246:()=>LYt,content_2247_5248:()=>bYt,content_2247_5250:()=>zYt,content_2247_5252:()=>WYt,content_2247_5254:()=>IYt,content_2247_5256:()=>PYt,content_2247_5258:()=>BYt,content_2247_526:()=>rL,content_2247_5260:()=>OYt,content_2247_5262:()=>UYt,content_2247_5264:()=>VYt,content_2247_5266:()=>QYt,content_2247_5268:()=>$Yt,content_2247_5270:()=>KYt,content_2247_5272:()=>tKt,content_2247_5274:()=>nKt,content_2247_5276:()=>pKt,content_2247_5278:()=>sKt,content_2247_528:()=>cL,content_2247_5280:()=>iKt,content_2247_5282:()=>lKt,content_2247_5284:()=>mKt,content_2247_5286:()=>hKt,content_2247_5288:()=>yKt,content_2247_5290:()=>MKt,content_2247_5292:()=>wKt,content_2247_5294:()=>XKt,content_2247_5296:()=>TKt,content_2247_5298:()=>CKt,content_2247_530:()=>aL,content_2247_5300:()=>LKt,content_2247_5302:()=>bKt,content_2247_5304:()=>zKt,content_2247_5306:()=>WKt,content_2247_5308:()=>IKt,content_2247_5310:()=>PKt,content_2247_5312:()=>BKt,content_2247_5314:()=>OKt,content_2247_5316:()=>UKt,content_2247_5318:()=>VKt,content_2247_532:()=>uL,content_2247_5320:()=>QKt,content_2247_5322:()=>$Kt,content_2247_5324:()=>KKt,content_2247_5326:()=>tJt,content_2247_5328:()=>nJt,content_2247_5330:()=>pJt,content_2247_5332:()=>sJt,content_2247_5334:()=>iJt,content_2247_5336:()=>lJt,content_2247_5338:()=>mJt,content_2247_534:()=>dL,content_2247_5340:()=>hJt,content_2247_5342:()=>yJt,content_2247_5344:()=>MJt,content_2247_5346:()=>wJt,content_2247_5348:()=>XJt,content_2247_5350:()=>TJt,content_2247_5352:()=>CJt,content_2247_5354:()=>LJt,content_2247_5356:()=>bJt,content_2247_5358:()=>zJt,content_2247_536:()=>kL,content_2247_5360:()=>WJt,content_2247_5362:()=>IJt,content_2247_5364:()=>PJt,content_2247_5366:()=>BJt,content_2247_5368:()=>OJt,content_2247_5370:()=>UJt,content_2247_5372:()=>VJt,content_2247_5374:()=>QJt,content_2247_5376:()=>$Jt,content_2247_5378:()=>KJt,content_2247_538:()=>fL,content_2247_5380:()=>t0t,content_2247_5382:()=>n0t,content_2247_5384:()=>p0t,content_2247_5386:()=>s0t,content_2247_5388:()=>i0t,content_2247_5390:()=>l0t,content_2247_5392:()=>m0t,content_2247_5394:()=>h0t,content_2247_5396:()=>y0t,content_2247_5398:()=>M0t,content_2247_54:()=>DD,content_2247_540:()=>DL,content_2247_5400:()=>w0t,content_2247_5402:()=>X0t,content_2247_5404:()=>T0t,content_2247_5406:()=>C0t,content_2247_5408:()=>L0t,content_2247_5410:()=>b0t,content_2247_5412:()=>z0t,content_2247_5414:()=>W0t,content_2247_5416:()=>I0t,content_2247_5418:()=>P0t,content_2247_542:()=>_L,content_2247_5420:()=>B0t,content_2247_5422:()=>O0t,content_2247_5424:()=>U0t,content_2247_5426:()=>V0t,content_2247_5428:()=>Q0t,content_2247_5430:()=>$0t,content_2247_5432:()=>K0t,content_2247_5434:()=>t2t,content_2247_5436:()=>n2t,content_2247_5438:()=>p2t,content_2247_544:()=>gL,content_2247_5440:()=>s2t,content_2247_5442:()=>i2t,content_2247_5444:()=>l2t,content_2247_5446:()=>m2t,content_2247_5448:()=>h2t,content_2247_5450:()=>y2t,content_2247_5452:()=>M2t,content_2247_5454:()=>w2t,content_2247_5456:()=>X2t,content_2247_5458:()=>T2t,content_2247_546:()=>xL,content_2247_5460:()=>C2t,content_2247_5462:()=>L2t,content_2247_5464:()=>b2t,content_2247_5466:()=>z2t,content_2247_5468:()=>W2t,content_2247_5470:()=>I2t,content_2247_5472:()=>P2t,content_2247_5474:()=>B2t,content_2247_5476:()=>O2t,content_2247_5478:()=>U2t,content_2247_548:()=>vL,content_2247_5480:()=>V2t,content_2247_5482:()=>Q2t,content_2247_5484:()=>$2t,content_2247_5486:()=>K2t,content_2247_5488:()=>t4t,content_2247_5490:()=>n4t,content_2247_5492:()=>p4t,content_2247_5494:()=>s4t,content_2247_5496:()=>i4t,content_2247_5498:()=>l4t,content_2247_550:()=>ZL,content_2247_5500:()=>m4t,content_2247_5502:()=>h4t,content_2247_5504:()=>y4t,content_2247_5506:()=>M4t,content_2247_5508:()=>w4t,content_2247_5510:()=>X4t,content_2247_5512:()=>T4t,content_2247_5514:()=>C4t,content_2247_5516:()=>L4t,content_2247_5518:()=>b4t,content_2247_552:()=>NL,content_2247_5520:()=>z4t,content_2247_5522:()=>W4t,content_2247_5524:()=>I4t,content_2247_5526:()=>P4t,content_2247_5528:()=>B4t,content_2247_5530:()=>O4t,content_2247_5532:()=>U4t,content_2247_5534:()=>V4t,content_2247_5536:()=>Q4t,content_2247_5538:()=>$4t,content_2247_554:()=>AL,content_2247_5540:()=>K4t,content_2247_5542:()=>t7t,content_2247_5544:()=>n7t,content_2247_5546:()=>p7t,content_2247_5548:()=>s7t,content_2247_5550:()=>i7t,content_2247_5552:()=>l7t,content_2247_5554:()=>m7t,content_2247_5556:()=>h7t,content_2247_5558:()=>y7t,content_2247_556:()=>RL,content_2247_5560:()=>M7t,content_2247_5562:()=>w7t,content_2247_5564:()=>X7t,content_2247_5566:()=>T7t,content_2247_5568:()=>C7t,content_2247_5570:()=>L7t,content_2247_5572:()=>b7t,content_2247_5574:()=>z7t,content_2247_5576:()=>W7t,content_2247_5578:()=>I7t,content_2247_558:()=>SL,content_2247_5580:()=>P7t,content_2247_5582:()=>B7t,content_2247_5584:()=>O7t,content_2247_5586:()=>U7t,content_2247_5588:()=>V7t,content_2247_5590:()=>Q7t,content_2247_5592:()=>$7t,content_2247_5594:()=>K7t,content_2247_5596:()=>t6t,content_2247_5598:()=>n6t,content_2247_56:()=>_D,content_2247_560:()=>EL,content_2247_5600:()=>p6t,content_2247_5602:()=>s6t,content_2247_5604:()=>i6t,content_2247_5606:()=>l6t,content_2247_5608:()=>m6t,content_2247_5610:()=>h6t,content_2247_5612:()=>y6t,content_2247_5614:()=>M6t,content_2247_5616:()=>w6t,content_2247_5618:()=>X6t,content_2247_562:()=>GL,content_2247_5620:()=>T6t,content_2247_5622:()=>C6t,content_2247_5624:()=>L6t,content_2247_5626:()=>b6t,content_2247_5628:()=>z6t,content_2247_5630:()=>W6t,content_2247_5632:()=>I6t,content_2247_5634:()=>P6t,content_2247_5636:()=>B6t,content_2247_5638:()=>O6t,content_2247_564:()=>FL,content_2247_5640:()=>U6t,content_2247_5642:()=>V6t,content_2247_5644:()=>Q6t,content_2247_5646:()=>$6t,content_2247_5648:()=>K6t,content_2247_5650:()=>t1t,content_2247_5652:()=>n1t,content_2247_5654:()=>p1t,content_2247_5656:()=>s1t,content_2247_5658:()=>i1t,content_2247_566:()=>qL,content_2247_5660:()=>l1t,content_2247_5662:()=>m1t,content_2247_5664:()=>h1t,content_2247_5666:()=>y1t,content_2247_5668:()=>M1t,content_2247_5670:()=>w1t,content_2247_5672:()=>X1t,content_2247_5674:()=>T1t,content_2247_5676:()=>C1t,content_2247_5678:()=>L1t,content_2247_568:()=>jL,content_2247_5680:()=>b1t,content_2247_5682:()=>z1t,content_2247_5684:()=>W1t,content_2247_5686:()=>I1t,content_2247_5688:()=>P1t,content_2247_5690:()=>B1t,content_2247_5692:()=>O1t,content_2247_5694:()=>U1t,content_2247_5696:()=>V1t,content_2247_5698:()=>Q1t,content_2247_570:()=>HL,content_2247_5700:()=>$1t,content_2247_5702:()=>K1t,content_2247_5704:()=>t8t,content_2247_5706:()=>n8t,content_2247_5708:()=>p8t,content_2247_5710:()=>s8t,content_2247_5712:()=>i8t,content_2247_5714:()=>l8t,content_2247_5716:()=>m8t,content_2247_5718:()=>h8t,content_2247_572:()=>YL,content_2247_5720:()=>y8t,content_2247_5722:()=>M8t,content_2247_5724:()=>w8t,content_2247_5726:()=>X8t,content_2247_5728:()=>T8t,content_2247_5730:()=>C8t,content_2247_5732:()=>L8t,content_2247_5734:()=>b8t,content_2247_5736:()=>z8t,content_2247_5738:()=>W8t,content_2247_574:()=>JL,content_2247_5740:()=>I8t,content_2247_5742:()=>P8t,content_2247_5744:()=>B8t,content_2247_5746:()=>O8t,content_2247_5748:()=>U8t,content_2247_5750:()=>V8t,content_2247_5752:()=>Q8t,content_2247_5754:()=>$8t,content_2247_5756:()=>K8t,content_2247_5758:()=>t3t,content_2247_576:()=>eZ,content_2247_5760:()=>n3t,content_2247_5762:()=>p3t,content_2247_5764:()=>s3t,content_2247_5766:()=>i3t,content_2247_5768:()=>l3t,content_2247_5770:()=>m3t,content_2247_5772:()=>h3t,content_2247_5774:()=>y3t,content_2247_5776:()=>M3t,content_2247_5778:()=>w3t,content_2247_578:()=>oZ,content_2247_5780:()=>X3t,content_2247_5782:()=>T3t,content_2247_5784:()=>C3t,content_2247_5786:()=>L3t,content_2247_5788:()=>b3t,content_2247_5790:()=>z3t,content_2247_5792:()=>W3t,content_2247_5794:()=>I3t,content_2247_5796:()=>P3t,content_2247_5798:()=>B3t,content_2247_58:()=>gD,content_2247_580:()=>rZ,content_2247_5800:()=>O3t,content_2247_5802:()=>U3t,content_2247_5804:()=>V3t,content_2247_5806:()=>Q3t,content_2247_5808:()=>$3t,content_2247_5810:()=>K3t,content_2247_5812:()=>t5t,content_2247_5814:()=>n5t,content_2247_5816:()=>p5t,content_2247_5818:()=>s5t,content_2247_582:()=>cZ,content_2247_5820:()=>i5t,content_2247_5822:()=>l5t,content_2247_5824:()=>m5t,content_2247_5826:()=>h5t,content_2247_5828:()=>y5t,content_2247_5830:()=>M5t,content_2247_5832:()=>w5t,content_2247_5834:()=>X5t,content_2247_5836:()=>T5t,content_2247_5838:()=>C5t,content_2247_584:()=>aZ,content_2247_5840:()=>L5t,content_2247_5842:()=>b5t,content_2247_5844:()=>z5t,content_2247_5846:()=>W5t,content_2247_5848:()=>I5t,content_2247_5850:()=>P5t,content_2247_5852:()=>B5t,content_2247_5854:()=>O5t,content_2247_5856:()=>U5t,content_2247_5858:()=>V5t,content_2247_586:()=>uZ,content_2247_5860:()=>Q5t,content_2247_5862:()=>$5t,content_2247_5864:()=>K5t,content_2247_5866:()=>t9t,content_2247_5868:()=>n9t,content_2247_5870:()=>p9t,content_2247_5872:()=>s9t,content_2247_5874:()=>i9t,content_2247_5876:()=>l9t,content_2247_5878:()=>m9t,content_2247_588:()=>dZ,content_2247_5880:()=>h9t,content_2247_5882:()=>y9t,content_2247_5884:()=>M9t,content_2247_5886:()=>w9t,content_2247_5888:()=>X9t,content_2247_5890:()=>T9t,content_2247_5892:()=>C9t,content_2247_5894:()=>L9t,content_2247_5896:()=>b9t,content_2247_5898:()=>z9t,content_2247_590:()=>kZ,content_2247_5900:()=>W9t,content_2247_5902:()=>I9t,content_2247_5904:()=>P9t,content_2247_5906:()=>B9t,content_2247_5908:()=>O9t,content_2247_5910:()=>U9t,content_2247_5912:()=>V9t,content_2247_5914:()=>Q9t,content_2247_5916:()=>$9t,content_2247_5918:()=>K9t,content_2247_592:()=>fZ,content_2247_5920:()=>tte,content_2247_5922:()=>nte,content_2247_5924:()=>pte,content_2247_5926:()=>ste,content_2247_5928:()=>ite,content_2247_5930:()=>lte,content_2247_5932:()=>mte,content_2247_5934:()=>hte,content_2247_5936:()=>yte,content_2247_5938:()=>Mte,content_2247_594:()=>DZ,content_2247_5940:()=>wte,content_2247_5942:()=>Xte,content_2247_5944:()=>Tte,content_2247_5946:()=>Cte,content_2247_5948:()=>Lte,content_2247_5950:()=>bte,content_2247_5952:()=>zte,content_2247_5954:()=>Wte,content_2247_5956:()=>Ite,content_2247_5958:()=>Pte,content_2247_596:()=>_Z,content_2247_5960:()=>Bte,content_2247_5962:()=>Ote,content_2247_5964:()=>Ute,content_2247_5966:()=>Vte,content_2247_5968:()=>Qte,content_2247_5970:()=>$te,content_2247_5972:()=>Kte,content_2247_5974:()=>tee,content_2247_5976:()=>nee,content_2247_5978:()=>pee,content_2247_598:()=>gZ,content_2247_5980:()=>see,content_2247_5982:()=>iee,content_2247_5984:()=>lee,content_2247_5986:()=>mee,content_2247_5988:()=>hee,content_2247_5990:()=>yee,content_2247_5992:()=>Mee,content_2247_5994:()=>wee,content_2247_5996:()=>Xee,content_2247_5998:()=>Tee,content_2247_6:()=>xM,content_2247_60:()=>xD,content_2247_600:()=>xZ,content_2247_6000:()=>Cee,content_2247_6002:()=>Lee,content_2247_6004:()=>bee,content_2247_6006:()=>zee,content_2247_6008:()=>Wee,content_2247_6010:()=>Iee,content_2247_6012:()=>Pee,content_2247_6014:()=>Bee,content_2247_6016:()=>Oee,content_2247_6018:()=>Uee,content_2247_602:()=>vZ,content_2247_6020:()=>Vee,content_2247_6022:()=>Qee,content_2247_6024:()=>$ee,content_2247_6026:()=>Kee,content_2247_6028:()=>tne,content_2247_6030:()=>nne,content_2247_6032:()=>pne,content_2247_6034:()=>sne,content_2247_6036:()=>ine,content_2247_6038:()=>lne,content_2247_604:()=>ZZ,content_2247_6040:()=>mne,content_2247_6042:()=>hne,content_2247_6044:()=>yne,content_2247_6046:()=>Mne,content_2247_6048:()=>wne,content_2247_6050:()=>Xne,content_2247_6052:()=>Tne,content_2247_6054:()=>Cne,content_2247_6056:()=>Lne,content_2247_6058:()=>bne,content_2247_606:()=>NZ,content_2247_6060:()=>zne,content_2247_6062:()=>Wne,content_2247_6064:()=>Ine,content_2247_6066:()=>Pne,content_2247_6068:()=>Bne,content_2247_6070:()=>One,content_2247_6072:()=>Une,content_2247_6074:()=>Vne,content_2247_6076:()=>Qne,content_2247_6078:()=>$ne,content_2247_608:()=>AZ,content_2247_6080:()=>Kne,content_2247_6082:()=>toe,content_2247_6084:()=>noe,content_2247_6086:()=>poe,content_2247_6088:()=>soe,content_2247_6090:()=>ioe,content_2247_6092:()=>loe,content_2247_6094:()=>moe,content_2247_6096:()=>hoe,content_2247_6098:()=>yoe,content_2247_610:()=>RZ,content_2247_6100:()=>Moe,content_2247_6102:()=>woe,content_2247_6104:()=>Xoe,content_2247_6106:()=>Toe,content_2247_6108:()=>Coe,content_2247_6110:()=>Loe,content_2247_6112:()=>boe,content_2247_6114:()=>zoe,content_2247_6116:()=>Woe,content_2247_6118:()=>Ioe,content_2247_612:()=>SZ,content_2247_6120:()=>Poe,content_2247_6122:()=>Boe,content_2247_6124:()=>Ooe,content_2247_6126:()=>Uoe,content_2247_6128:()=>Voe,content_2247_6130:()=>Qoe,content_2247_6132:()=>$oe,content_2247_6134:()=>Koe,content_2247_6136:()=>tpe,content_2247_6138:()=>npe,content_2247_614:()=>EZ,content_2247_6140:()=>ppe,content_2247_6142:()=>spe,content_2247_6144:()=>ipe,content_2247_6146:()=>lpe,content_2247_6148:()=>mpe,content_2247_6150:()=>hpe,content_2247_6152:()=>ype,content_2247_6154:()=>Mpe,content_2247_6156:()=>wpe,content_2247_6158:()=>Xpe,content_2247_616:()=>GZ,content_2247_6160:()=>Tpe,content_2247_6162:()=>Cpe,content_2247_6164:()=>Lpe,content_2247_6166:()=>bpe,content_2247_6168:()=>zpe,content_2247_6170:()=>Wpe,content_2247_6172:()=>Ipe,content_2247_6174:()=>Ppe,content_2247_6176:()=>Bpe,content_2247_6178:()=>Ope,content_2247_618:()=>FZ,content_2247_6180:()=>Upe,content_2247_6182:()=>Vpe,content_2247_6184:()=>Qpe,content_2247_6186:()=>$pe,content_2247_6188:()=>Kpe,content_2247_6190:()=>tre,content_2247_6192:()=>nre,content_2247_6194:()=>pre,content_2247_6196:()=>sre,content_2247_6198:()=>ire,content_2247_62:()=>vD,content_2247_620:()=>qZ,content_2247_6200:()=>lre,content_2247_6202:()=>mre,content_2247_6204:()=>hre,content_2247_6206:()=>yre,content_2247_6208:()=>Mre,content_2247_6210:()=>wre,content_2247_6212:()=>Xre,content_2247_6214:()=>Tre,content_2247_6216:()=>Cre,content_2247_6218:()=>Lre,content_2247_622:()=>jZ,content_2247_6220:()=>bre,content_2247_6222:()=>zre,content_2247_6224:()=>Wre,content_2247_6226:()=>Ire,content_2247_6228:()=>Pre,content_2247_6230:()=>Bre,content_2247_6232:()=>Ore,content_2247_6234:()=>Ure,content_2247_6236:()=>Vre,content_2247_6238:()=>Qre,content_2247_624:()=>HZ,content_2247_6240:()=>$re,content_2247_6242:()=>Kre,content_2247_6244:()=>tse,content_2247_6246:()=>nse,content_2247_6248:()=>pse,content_2247_6250:()=>sse,content_2247_6252:()=>ise,content_2247_6254:()=>lse,content_2247_6256:()=>mse,content_2247_6258:()=>hse,content_2247_626:()=>YZ,content_2247_6260:()=>yse,content_2247_6262:()=>Mse,content_2247_6264:()=>wse,content_2247_6266:()=>Xse,content_2247_6268:()=>Tse,content_2247_6270:()=>Cse,content_2247_6272:()=>Lse,content_2247_6274:()=>bse,content_2247_6276:()=>zse,content_2247_6278:()=>Wse,content_2247_628:()=>JZ,content_2247_6280:()=>Ise,content_2247_6282:()=>Pse,content_2247_6284:()=>Bse,content_2247_6286:()=>Ose,content_2247_6288:()=>Use,content_2247_6290:()=>Vse,content_2247_6292:()=>Qse,content_2247_6294:()=>$se,content_2247_6296:()=>Kse,content_2247_6298:()=>tce,content_2247_630:()=>eb,content_2247_6300:()=>nce,content_2247_6302:()=>pce,content_2247_6304:()=>sce,content_2247_6306:()=>ice,content_2247_6308:()=>lce,content_2247_6310:()=>mce,content_2247_6312:()=>hce,content_2247_6314:()=>yce,content_2247_6316:()=>Mce,content_2247_6318:()=>wce,content_2247_632:()=>ob,content_2247_6320:()=>Xce,content_2247_6322:()=>Tce,content_2247_6324:()=>Cce,content_2247_6326:()=>Lce,content_2247_6328:()=>bce,content_2247_6330:()=>zce,content_2247_6332:()=>Wce,content_2247_6334:()=>Ice,content_2247_6336:()=>Pce,content_2247_6338:()=>Bce,content_2247_634:()=>rb,content_2247_6340:()=>Oce,content_2247_6342:()=>Uce,content_2247_6344:()=>Vce,content_2247_6346:()=>Qce,content_2247_6348:()=>$ce,content_2247_6350:()=>Kce,content_2247_6352:()=>tie,content_2247_6354:()=>nie,content_2247_6356:()=>pie,content_2247_6358:()=>sie,content_2247_636:()=>cb,content_2247_6360:()=>iie,content_2247_6362:()=>lie,content_2247_6364:()=>mie,content_2247_6366:()=>hie,content_2247_6368:()=>yie,content_2247_6370:()=>Mie,content_2247_6372:()=>wie,content_2247_6374:()=>Xie,content_2247_6376:()=>Tie,content_2247_6378:()=>Cie,content_2247_638:()=>ab,content_2247_6380:()=>Lie,content_2247_6382:()=>bie,content_2247_6384:()=>zie,content_2247_6386:()=>Wie,content_2247_6388:()=>Iie,content_2247_6390:()=>Pie,content_2247_6392:()=>Bie,content_2247_6394:()=>Oie,content_2247_6396:()=>Uie,content_2247_6398:()=>Vie,content_2247_64:()=>ZD,content_2247_640:()=>ub,content_2247_6400:()=>Qie,content_2247_6402:()=>$ie,content_2247_6404:()=>Kie,content_2247_6406:()=>tae,content_2247_6408:()=>nae,content_2247_6410:()=>pae,content_2247_6412:()=>sae,content_2247_6414:()=>iae,content_2247_6416:()=>lae,content_2247_6418:()=>mae,content_2247_642:()=>db,content_2247_6420:()=>hae,content_2247_6422:()=>yae,content_2247_6424:()=>Mae,content_2247_6426:()=>wae,content_2247_6428:()=>Xae,content_2247_6430:()=>Tae,content_2247_6432:()=>Cae,content_2247_6434:()=>Lae,content_2247_6436:()=>bae,content_2247_6438:()=>zae,content_2247_644:()=>kb,content_2247_6440:()=>Wae,content_2247_6442:()=>Iae,content_2247_6444:()=>Pae,content_2247_6446:()=>Bae,content_2247_6448:()=>Oae,content_2247_6450:()=>Uae,content_2247_6452:()=>Vae,content_2247_6454:()=>Qae,content_2247_6456:()=>$ae,content_2247_6458:()=>Kae,content_2247_646:()=>fb,content_2247_6460:()=>tle,content_2247_6462:()=>nle,content_2247_6464:()=>ple,content_2247_6466:()=>sle,content_2247_6468:()=>ile,content_2247_6470:()=>lle,content_2247_6472:()=>mle,content_2247_6474:()=>hle,content_2247_6476:()=>yle,content_2247_6478:()=>Mle,content_2247_648:()=>Db,content_2247_6480:()=>wle,content_2247_6482:()=>Xle,content_2247_6484:()=>Tle,content_2247_6486:()=>Cle,content_2247_6488:()=>Lle,content_2247_6490:()=>ble,content_2247_6492:()=>zle,content_2247_6494:()=>Wle,content_2247_6496:()=>Ile,content_2247_6498:()=>Ple,content_2247_650:()=>_b,content_2247_6500:()=>Ble,content_2247_6502:()=>Ole,content_2247_6504:()=>Ule,content_2247_6506:()=>Vle,content_2247_6508:()=>Qle,content_2247_6510:()=>$le,content_2247_6512:()=>Kle,content_2247_6514:()=>tue,content_2247_6516:()=>nue,content_2247_6518:()=>pue,content_2247_652:()=>gb,content_2247_6520:()=>sue,content_2247_6522:()=>iue,content_2247_6524:()=>lue,content_2247_6526:()=>mue,content_2247_6528:()=>hue,content_2247_6530:()=>yue,content_2247_6532:()=>Mue,content_2247_6534:()=>wue,content_2247_6536:()=>Xue,content_2247_6538:()=>Tue,content_2247_654:()=>xb,content_2247_6540:()=>Cue,content_2247_6542:()=>Lue,content_2247_6544:()=>bue,content_2247_6546:()=>zue,content_2247_6548:()=>Wue,content_2247_6550:()=>Iue,content_2247_6552:()=>Pue,content_2247_6554:()=>Bue,content_2247_6556:()=>Oue,content_2247_6558:()=>Uue,content_2247_656:()=>vb,content_2247_6560:()=>Vue,content_2247_6562:()=>Que,content_2247_6564:()=>$ue,content_2247_6566:()=>Kue,content_2247_6568:()=>tme,content_2247_6570:()=>nme,content_2247_6572:()=>pme,content_2247_6574:()=>sme,content_2247_6576:()=>ime,content_2247_6578:()=>lme,content_2247_658:()=>Zb,content_2247_6580:()=>mme,content_2247_6582:()=>hme,content_2247_6584:()=>yme,content_2247_6586:()=>Mme,content_2247_6588:()=>wme,content_2247_6590:()=>Xme,content_2247_6592:()=>Tme,content_2247_6594:()=>Cme,content_2247_6596:()=>Lme,content_2247_6598:()=>bme,content_2247_66:()=>ND,content_2247_660:()=>Nb,content_2247_6600:()=>zme,content_2247_6602:()=>Wme,content_2247_6604:()=>Ime,content_2247_6606:()=>Pme,content_2247_6608:()=>Bme,content_2247_6610:()=>Ome,content_2247_6612:()=>Ume,content_2247_6614:()=>Vme,content_2247_6616:()=>Qme,content_2247_6618:()=>$me,content_2247_662:()=>Ab,content_2247_6620:()=>Kme,content_2247_6622:()=>tde,content_2247_6624:()=>nde,content_2247_6626:()=>pde,content_2247_6628:()=>sde,content_2247_6630:()=>ide,content_2247_6632:()=>lde,content_2247_6634:()=>mde,content_2247_6636:()=>hde,content_2247_6638:()=>yde,content_2247_664:()=>Rb,content_2247_6640:()=>Mde,content_2247_6642:()=>wde,content_2247_6644:()=>Xde,content_2247_6646:()=>Tde,content_2247_6648:()=>Cde,content_2247_6650:()=>Lde,content_2247_6652:()=>bde,content_2247_6654:()=>zde,content_2247_6656:()=>Wde,content_2247_6658:()=>Ide,content_2247_666:()=>Sb,content_2247_6660:()=>Pde,content_2247_6662:()=>Bde,content_2247_6664:()=>Ode,content_2247_6666:()=>Ude,content_2247_6668:()=>Vde,content_2247_6670:()=>Qde,content_2247_6672:()=>$de,content_2247_6674:()=>Kde,content_2247_6676:()=>the,content_2247_6678:()=>nhe,content_2247_668:()=>Eb,content_2247_6680:()=>phe,content_2247_6682:()=>she,content_2247_6684:()=>ihe,content_2247_6686:()=>lhe,content_2247_6688:()=>mhe,content_2247_6690:()=>hhe,content_2247_6692:()=>yhe,content_2247_6694:()=>Mhe,content_2247_6696:()=>whe,content_2247_6698:()=>Xhe,content_2247_670:()=>Gb,content_2247_6700:()=>The,content_2247_6702:()=>Che,content_2247_6704:()=>Lhe,content_2247_6706:()=>bhe,content_2247_6708:()=>zhe,content_2247_6710:()=>Whe,content_2247_6712:()=>Ihe,content_2247_6714:()=>Phe,content_2247_6716:()=>Bhe,content_2247_6718:()=>Ohe,content_2247_672:()=>Fb,content_2247_6720:()=>Uhe,content_2247_6722:()=>Vhe,content_2247_6724:()=>Qhe,content_2247_6726:()=>$he,content_2247_6728:()=>Khe,content_2247_6730:()=>tke,content_2247_6732:()=>nke,content_2247_6734:()=>pke,content_2247_6736:()=>ske,content_2247_6738:()=>ike,content_2247_674:()=>qb,content_2247_6740:()=>lke,content_2247_6742:()=>mke,content_2247_6744:()=>hke,content_2247_6746:()=>yke,content_2247_6748:()=>Mke,content_2247_6750:()=>wke,content_2247_6752:()=>Xke,content_2247_6754:()=>Tke,content_2247_6756:()=>Cke,content_2247_6758:()=>Lke,content_2247_676:()=>jb,content_2247_6760:()=>bke,content_2247_6762:()=>zke,content_2247_6764:()=>Wke,content_2247_6766:()=>Ike,content_2247_6768:()=>Pke,content_2247_6770:()=>Bke,content_2247_6772:()=>Oke,content_2247_6774:()=>Uke,content_2247_6776:()=>Vke,content_2247_6778:()=>Qke,content_2247_678:()=>Hb,content_2247_6780:()=>$ke,content_2247_6782:()=>Kke,content_2247_6784:()=>tye,content_2247_6786:()=>nye,content_2247_6788:()=>pye,content_2247_6790:()=>sye,content_2247_6792:()=>iye,content_2247_6794:()=>lye,content_2247_6796:()=>mye,content_2247_6798:()=>hye,content_2247_68:()=>AD,content_2247_680:()=>Yb,content_2247_6800:()=>yye,content_2247_6802:()=>Mye,content_2247_6804:()=>wye,content_2247_6806:()=>Xye,content_2247_6808:()=>Tye,content_2247_6810:()=>Cye,content_2247_6812:()=>Lye,content_2247_6814:()=>bye,content_2247_6816:()=>zye,content_2247_6818:()=>Wye,content_2247_682:()=>Jb,content_2247_6820:()=>Iye,content_2247_6822:()=>Pye,content_2247_6824:()=>Bye,content_2247_6826:()=>Oye,content_2247_6828:()=>Uye,content_2247_6830:()=>Vye,content_2247_6832:()=>Qye,content_2247_6834:()=>$ye,content_2247_6836:()=>Kye,content_2247_6838:()=>tfe,content_2247_684:()=>eN,content_2247_6840:()=>nfe,content_2247_6842:()=>pfe,content_2247_6844:()=>sfe,content_2247_6846:()=>ife,content_2247_6848:()=>lfe,content_2247_6850:()=>mfe,content_2247_6852:()=>hfe,content_2247_6854:()=>yfe,content_2247_6856:()=>Mfe,content_2247_6858:()=>wfe,content_2247_686:()=>oN,content_2247_6860:()=>Xfe,content_2247_6862:()=>Tfe,content_2247_6864:()=>Cfe,content_2247_6866:()=>Lfe,content_2247_6868:()=>bfe,content_2247_6870:()=>zfe,content_2247_6872:()=>Wfe,content_2247_6874:()=>Ife,content_2247_6876:()=>Pfe,content_2247_6878:()=>Bfe,content_2247_688:()=>rN,content_2247_6880:()=>Ofe,content_2247_6882:()=>Ufe,content_2247_6884:()=>Vfe,content_2247_6886:()=>Qfe,content_2247_6888:()=>$fe,content_2247_6890:()=>Kfe,content_2247_6892:()=>tMe,content_2247_6894:()=>nMe,content_2247_6896:()=>pMe,content_2247_6898:()=>sMe,content_2247_690:()=>cN,content_2247_6900:()=>iMe,content_2247_6902:()=>lMe,content_2247_6904:()=>mMe,content_2247_6906:()=>hMe,content_2247_6908:()=>yMe,content_2247_6910:()=>MMe,content_2247_6912:()=>wMe,content_2247_6914:()=>XMe,content_2247_6916:()=>TMe,content_2247_6918:()=>CMe,content_2247_692:()=>aN,content_2247_6920:()=>LMe,content_2247_6922:()=>bMe,content_2247_6924:()=>zMe,content_2247_6926:()=>WMe,content_2247_6928:()=>IMe,content_2247_6930:()=>PMe,content_2247_6932:()=>BMe,content_2247_6934:()=>OMe,content_2247_6936:()=>UMe,content_2247_6938:()=>VMe,content_2247_694:()=>uN,content_2247_6940:()=>QMe,content_2247_6942:()=>$Me,content_2247_6944:()=>KMe,content_2247_6946:()=>tDe,content_2247_6948:()=>nDe,content_2247_6950:()=>pDe,content_2247_6952:()=>sDe,content_2247_6954:()=>iDe,content_2247_6956:()=>lDe,content_2247_6958:()=>mDe,content_2247_696:()=>dN,content_2247_6960:()=>hDe,content_2247_6962:()=>yDe,content_2247_6964:()=>MDe,content_2247_6966:()=>wDe,content_2247_6968:()=>XDe,content_2247_6970:()=>TDe,content_2247_6972:()=>CDe,content_2247_6974:()=>LDe,content_2247_6976:()=>bDe,content_2247_6978:()=>zDe,content_2247_698:()=>kN,content_2247_6980:()=>WDe,content_2247_6982:()=>IDe,content_2247_6984:()=>PDe,content_2247_6986:()=>BDe,content_2247_6988:()=>ODe,content_2247_6990:()=>UDe,content_2247_6992:()=>VDe,content_2247_6994:()=>QDe,content_2247_6996:()=>$De,content_2247_6998:()=>KDe,content_2247_70:()=>RD,content_2247_700:()=>fN,content_2247_7000:()=>twe,content_2247_7002:()=>nwe,content_2247_7004:()=>pwe,content_2247_7006:()=>swe,content_2247_7008:()=>iwe,content_2247_7010:()=>lwe,content_2247_7012:()=>mwe,content_2247_7014:()=>hwe,content_2247_7016:()=>ywe,content_2247_7018:()=>Mwe,content_2247_702:()=>DN,content_2247_7020:()=>wwe,content_2247_7022:()=>Xwe,content_2247_7024:()=>Twe,content_2247_7026:()=>Cwe,content_2247_7028:()=>Lwe,content_2247_7030:()=>bwe,content_2247_7032:()=>zwe,content_2247_7034:()=>Wwe,content_2247_7036:()=>Iwe,content_2247_7038:()=>Pwe,content_2247_704:()=>_N,content_2247_7040:()=>Bwe,content_2247_7042:()=>Owe,content_2247_7044:()=>Uwe,content_2247_7046:()=>Vwe,content_2247_7048:()=>Qwe,content_2247_7050:()=>$we,content_2247_7052:()=>Kwe,content_2247_7054:()=>t_e,content_2247_7056:()=>n_e,content_2247_7058:()=>p_e,content_2247_706:()=>gN,content_2247_7060:()=>s_e,content_2247_7062:()=>i_e,content_2247_7064:()=>l_e,content_2247_7066:()=>m_e,content_2247_7068:()=>h_e,content_2247_7070:()=>y_e,content_2247_7072:()=>M_e,content_2247_7074:()=>w_e,content_2247_7076:()=>X_e,content_2247_7078:()=>T_e,content_2247_708:()=>xN,content_2247_7080:()=>C_e,content_2247_7082:()=>L_e,content_2247_7084:()=>b_e,content_2247_7086:()=>z_e,content_2247_7088:()=>W_e,content_2247_7090:()=>I_e,content_2247_7092:()=>P_e,content_2247_7094:()=>B_e,content_2247_7096:()=>O_e,content_2247_7098:()=>U_e,content_2247_710:()=>vN,content_2247_7100:()=>V_e,content_2247_7102:()=>Q_e,content_2247_712:()=>ZN,content_2247_714:()=>NN,content_2247_716:()=>AN,content_2247_718:()=>RN,content_2247_72:()=>SD,content_2247_720:()=>SN,content_2247_722:()=>EN,content_2247_724:()=>GN,content_2247_726:()=>FN,content_2247_728:()=>qN,content_2247_730:()=>jN,content_2247_732:()=>HN,content_2247_734:()=>YN,content_2247_736:()=>JN,content_2247_738:()=>ez,content_2247_74:()=>ED,content_2247_740:()=>oz,content_2247_742:()=>rz,content_2247_744:()=>cz,content_2247_746:()=>az,content_2247_748:()=>uz,content_2247_750:()=>dz,content_2247_752:()=>kz,content_2247_754:()=>fz,content_2247_756:()=>Dz,content_2247_758:()=>_z,content_2247_76:()=>GD,content_2247_760:()=>gz,content_2247_762:()=>xz,content_2247_764:()=>vz,content_2247_766:()=>Zz,content_2247_768:()=>Nz,content_2247_770:()=>Az,content_2247_772:()=>Rz,content_2247_774:()=>Sz,content_2247_776:()=>Ez,content_2247_778:()=>Gz,content_2247_78:()=>FD,content_2247_780:()=>Fz,content_2247_782:()=>qz,content_2247_784:()=>jz,content_2247_786:()=>Hz,content_2247_788:()=>Yz,content_2247_790:()=>Jz,content_2247_792:()=>eA,content_2247_794:()=>oA,content_2247_796:()=>rA,content_2247_798:()=>cA,content_2247_8:()=>vM,content_2247_80:()=>qD,content_2247_800:()=>aA,content_2247_802:()=>uA,content_2247_804:()=>dA,content_2247_806:()=>kA,content_2247_808:()=>fA,content_2247_810:()=>DA,content_2247_812:()=>_A,content_2247_814:()=>gA,content_2247_816:()=>xA,content_2247_818:()=>vA,content_2247_82:()=>jD,content_2247_820:()=>ZA,content_2247_822:()=>NA,content_2247_824:()=>AA,content_2247_826:()=>RA,content_2247_828:()=>SA,content_2247_830:()=>EA,content_2247_832:()=>GA,content_2247_834:()=>FA,content_2247_836:()=>qA,content_2247_838:()=>jA,content_2247_84:()=>HD,content_2247_840:()=>HA,content_2247_842:()=>YA,content_2247_844:()=>JA,content_2247_846:()=>eW,content_2247_848:()=>oW,content_2247_850:()=>rW,content_2247_852:()=>cW,content_2247_854:()=>aW,content_2247_856:()=>uW,content_2247_858:()=>dW,content_2247_86:()=>YD,content_2247_860:()=>kW,content_2247_862:()=>fW,content_2247_864:()=>DW,content_2247_866:()=>_W,content_2247_868:()=>gW,content_2247_870:()=>xW,content_2247_872:()=>vW,content_2247_874:()=>ZW,content_2247_876:()=>NW,content_2247_878:()=>AW,content_2247_88:()=>JD,content_2247_880:()=>RW,content_2247_882:()=>SW,content_2247_884:()=>EW,content_2247_886:()=>GW,content_2247_888:()=>FW,content_2247_890:()=>qW,content_2247_892:()=>jW,content_2247_894:()=>HW,content_2247_896:()=>YW,content_2247_898:()=>JW,content_2247_90:()=>ew,content_2247_900:()=>eR,content_2247_902:()=>oR,content_2247_904:()=>rR,content_2247_906:()=>cR,content_2247_908:()=>aR,content_2247_910:()=>uR,content_2247_912:()=>dR,content_2247_914:()=>kR,content_2247_916:()=>fR,content_2247_918:()=>DR,content_2247_92:()=>ow,content_2247_920:()=>_R,content_2247_922:()=>gR,content_2247_924:()=>xR,content_2247_926:()=>vR,content_2247_928:()=>ZR,content_2247_930:()=>NR,content_2247_932:()=>AR,content_2247_934:()=>RR,content_2247_936:()=>SR,content_2247_938:()=>ER,content_2247_94:()=>rw,content_2247_940:()=>GR,content_2247_942:()=>FR,content_2247_944:()=>qR,content_2247_946:()=>jR,content_2247_948:()=>HR,content_2247_950:()=>YR,content_2247_952:()=>JR,content_2247_954:()=>eI,content_2247_956:()=>oI,content_2247_958:()=>rI,content_2247_96:()=>cw,content_2247_960:()=>cI,content_2247_962:()=>aI,content_2247_964:()=>uI,content_2247_966:()=>dI,content_2247_968:()=>kI,content_2247_970:()=>fI,content_2247_972:()=>DI,content_2247_974:()=>_I,content_2247_976:()=>gI,content_2247_978:()=>xI,content_2247_98:()=>aw,content_2247_980:()=>vI,content_2247_982:()=>ZI,content_2247_984:()=>NI,content_2247_986:()=>AI,content_2247_988:()=>RI,content_2247_990:()=>SI,content_2247_992:()=>EI,content_2247_994:()=>GI,content_2247_996:()=>FI,content_2247_998:()=>qI});var p=n(2784),r=n(7896),s=n(30876);const c={toc:[]};function i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}I.isMDXComponent=!0;const S={toc:[]};function P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}P.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}O.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}U.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}V.isMDXComponent=!0;const j={toc:[]};function Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Q.isMDXComponent=!0;const H={toc:[]};function $(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}$.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}nt.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}It.isMDXComponent=!0;const St={toc:[]};function Pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Pt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ot.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ut.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Qt.isMDXComponent=!0;const Ht={toc:[]};function $t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}$t.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const oe={toc:[]};function pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}pe.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}se.isMDXComponent=!0;const ce={toc:[]};function ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ie.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}he.isMDXComponent=!0;const ke={toc:[]};function ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ye.isMDXComponent=!0;const fe={toc:[]};function Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Me.isMDXComponent=!0;const De={toc:[]};function we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}we.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Xe.isMDXComponent=!0;const ge={toc:[]};function Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Te.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ce.isMDXComponent=!0;const ve={toc:[]};function Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}be.isMDXComponent=!0;const Ne={toc:[]};function ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ze.isMDXComponent=!0;const Ae={toc:[]};function We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}We.isMDXComponent=!0;const Re={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ie.isMDXComponent=!0;const Se={toc:[]};function Pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Pe.isMDXComponent=!0;const Ee={toc:[]};function Be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Be.isMDXComponent=!0;const Ge={toc:[]};function Oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Oe.isMDXComponent=!0;const Fe={toc:[]};function Ue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}Ue.isMDXComponent=!0;const qe={toc:[]};function Ve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ve.isMDXComponent=!0;const je={toc:[]};function Qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Qe.isMDXComponent=!0;const He={toc:[]};function $e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}$e.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ke.isMDXComponent=!0;const Je={toc:[]};function tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}nn.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Rn.isMDXComponent=!0;const In={toc:[]};function Sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Sn.isMDXComponent=!0;const Pn={toc:[]};function En(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Gn.isMDXComponent=!0;const On={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Fn.isMDXComponent=!0;const Un={toc:[]};function qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}jn.isMDXComponent=!0;const Qn={toc:[]};function Hn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Hn.isMDXComponent=!0;const $n={toc:[]};function Yn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Jn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Io.isMDXComponent=!0;const So={toc:[]};function Po(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},So,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Po.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Oo.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}Uo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Qo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Qo.isMDXComponent=!0;const Ho={toc:[]};function $o(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}$o.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}np.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Ip.isMDXComponent=!0;const Sp={toc:[]};function Pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Pp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Op.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}Up.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Qp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Qp.isMDXComponent=!0;const Hp={toc:[]};function $p(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}$p.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}nr.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Ir.isMDXComponent=!0;const Sr={toc:[]};function Pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Pr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Or.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Ur.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Vr.isMDXComponent=!0;const jr={toc:[]};function Qr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Qr.isMDXComponent=!0;const Hr={toc:[]};function $r(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}$r.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ns.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Is.isMDXComponent=!0;const Ss={toc:[]};function Ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ss,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Ps.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Os.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Us.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Vs.isMDXComponent=!0;const js={toc:[]};function Qs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Qs.isMDXComponent=!0;const Hs={toc:[]};function $s(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$s.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}nc.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}Ic.isMDXComponent=!0;const Sc={toc:[]};function Pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}Pc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}Oc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Uc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Qc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Qc.isMDXComponent=!0;const Hc={toc:[]};function $c(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}$c.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}ni.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Ii.isMDXComponent=!0;const Si={toc:[]};function Pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Si,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Pi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}Oi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Ui.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Qi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Qi.isMDXComponent=!0;const Hi={toc:[]};function $i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}$i.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}na.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Ia.isMDXComponent=!0;const Sa={toc:[]};function Pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Pa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Oa.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ua.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Va.isMDXComponent=!0;const ja={toc:[]};function Qa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Qa.isMDXComponent=!0;const Ha={toc:[]};function $a(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}$a.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}nl.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}Il.isMDXComponent=!0;const Sl={toc:[]};function Pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ol.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ul.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Ql(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Ql.isMDXComponent=!0;const Hl={toc:[]};function $l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}$l.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}nu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}Iu.isMDXComponent=!0;const Su={toc:[]};function Pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Su,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}Pu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}Ou.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}Uu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Qu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}Qu.isMDXComponent=!0;const Hu={toc:[]};function $u(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}$u.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}nm.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Im.isMDXComponent=!0;const Sm={toc:[]};function Pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Pm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Om.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Um.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Qm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Qm.isMDXComponent=!0;const Hm={toc:[]};function $m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}$m.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}nd.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}Id.isMDXComponent=!0;const Sd={toc:[]};function Pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}Pd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Od.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}Ud.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Qd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Qd.isMDXComponent=!0;const Hd={toc:[]};function $d(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}$d.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}nh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Ih.isMDXComponent=!0;const Sh={toc:[]};function Ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}Ph.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Oh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Uh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Qh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Qh.isMDXComponent=!0;const Hh={toc:[]};function $h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}$h.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}tk.isMDXComponent=!0;const ek={toc:[]};function nk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}nk.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ok,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}pk.isMDXComponent=!0;const rk={toc:[]};function sk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}sk.isMDXComponent=!0;const ck={toc:[]};function ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ik.isMDXComponent=!0;const ak={toc:[]};function lk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ak,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Mk.isMDXComponent=!0;const Dk={toc:[]};function wk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}wk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}Xk.isMDXComponent=!0;const gk={toc:[]};function Tk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Tk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}Ck.isMDXComponent=!0;const vk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}bk.isMDXComponent=!0;const Nk={toc:[]};function zk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}zk.isMDXComponent=!0;const Ak={toc:[]};function Wk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Wk.isMDXComponent=!0;const Rk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Ik.isMDXComponent=!0;const Sk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Pk.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}Ok.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}Vk.isMDXComponent=!0;const jk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}Qk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}$k.isMDXComponent=!0;const Yk={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Kk.isMDXComponent=!0;const Jk={toc:[]};function ty(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}ny.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}py.isMDXComponent=!0;const ry={toc:[]};function sy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}sy.isMDXComponent=!0;const cy={toc:[]};function iy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}iy.isMDXComponent=!0;const ay={toc:[]};function ly(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ay,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}My.isMDXComponent=!0;const Dy={toc:[]};function wy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}wy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Xy.isMDXComponent=!0;const gy={toc:[]};function Ty(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Ty.isMDXComponent=!0;const xy={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}Cy.isMDXComponent=!0;const vy={toc:[]};function Ly(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}Ly.isMDXComponent=!0;const Zy={toc:[]};function by(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}by.isMDXComponent=!0;const Ny={toc:[]};function zy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}zy.isMDXComponent=!0;const Ay={toc:[]};function Wy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}Wy.isMDXComponent=!0;const Ry={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Iy.isMDXComponent=!0;const Sy={toc:[]};function Py(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Py.isMDXComponent=!0;const Ey={toc:[]};function By(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}By.isMDXComponent=!0;const Gy={toc:[]};function Oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Oy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}Uy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}Vy.isMDXComponent=!0;const jy={toc:[]};function Qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}Qy.isMDXComponent=!0;const Hy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}$y.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Ky.isMDXComponent=!0;const Jy={toc:[]};function tf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}nf.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Rf.isMDXComponent=!0;const If={toc:[]};function Sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}Sf.isMDXComponent=!0;const Pf={toc:[]};function Ef(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}Gf.isMDXComponent=!0;const Of={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}jf.isMDXComponent=!0;const Qf={toc:[]};function Hf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}Hf.isMDXComponent=!0;const $f={toc:[]};function Yf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}Jf.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RM.isMDXComponent=!0;const IM={toc:[]};function SM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}SM.isMDXComponent=!0;const PM={toc:[]};function EM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}GM.isMDXComponent=!0;const OM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FM.isMDXComponent=!0;const UM={toc:[]};function qM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}jM.isMDXComponent=!0;const QM={toc:[]};function HM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}HM.isMDXComponent=!0;const $M={toc:[]};function YM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}YM.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}JM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}RD.isMDXComponent=!0;const ID={toc:[]};function SD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}SD.isMDXComponent=!0;const PD={toc:[]};function ED(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}GD.isMDXComponent=!0;const OD={toc:[]};function FD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}FD.isMDXComponent=!0;const UD={toc:[]};function qD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}jD.isMDXComponent=!0;const QD={toc:[]};function HD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}HD.isMDXComponent=!0;const $D={toc:[]};function YD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}YD.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}JD.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Sw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Sw.isMDXComponent=!0;const Pw={toc:[]};function Ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}jw.isMDXComponent=!0;const Qw={toc:[]};function Hw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Hw.isMDXComponent=!0;const $w={toc:[]};function Yw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Jw.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}R_.isMDXComponent=!0;const I_={toc:[]};function S_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}S_.isMDXComponent=!0;const P_={toc:[]};function E_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}G_.isMDXComponent=!0;const O_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}F_.isMDXComponent=!0;const U_={toc:[]};function q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}j_.isMDXComponent=!0;const Q_={toc:[]};function H_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}H_.isMDXComponent=!0;const $_={toc:[]};function Y_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Y_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}J_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}RX.isMDXComponent=!0;const IX={toc:[]};function SX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}SX.isMDXComponent=!0;const PX={toc:[]};function EX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}GX.isMDXComponent=!0;const OX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FX.isMDXComponent=!0;const UX={toc:[]};function qX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}jX.isMDXComponent=!0;const QX={toc:[]};function HX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}HX.isMDXComponent=!0;const $X={toc:[]};function YX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$X,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YX.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}JX.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Sg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Sg.isMDXComponent=!0;const Pg={toc:[]};function Eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Gg.isMDXComponent=!0;const Og={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ug,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}jg.isMDXComponent=!0;const Qg={toc:[]};function Hg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}Hg.isMDXComponent=!0;const $g={toc:[]};function Yg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Jg.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}RT.isMDXComponent=!0;const IT={toc:[]};function ST(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ST.isMDXComponent=!0;const PT={toc:[]};function ET(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GT.isMDXComponent=!0;const OT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FT.isMDXComponent=!0;const UT={toc:[]};function qT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jT.isMDXComponent=!0;const QT={toc:[]};function HT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}HT.isMDXComponent=!0;const $T={toc:[]};function YT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$T,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}YT.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}JT.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Sx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Sx.isMDXComponent=!0;const Px={toc:[]};function Ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ux,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}jx.isMDXComponent=!0;const Qx={toc:[]};function Hx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Hx.isMDXComponent=!0;const $x={toc:[]};function Yx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Jx.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}RC.isMDXComponent=!0;const IC={toc:[]};function SC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}SC.isMDXComponent=!0;const PC={toc:[]};function EC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GC.isMDXComponent=!0;const OC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FC.isMDXComponent=!0;const UC={toc:[]};function qC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jC.isMDXComponent=!0;const QC={toc:[]};function HC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}HC.isMDXComponent=!0;const $C={toc:[]};function YC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}YC.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}JC.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Sv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Sv.isMDXComponent=!0;const Pv={toc:[]};function Ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}jv.isMDXComponent=!0;const Qv={toc:[]};function Hv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Hv.isMDXComponent=!0;const $v={toc:[]};function Yv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jv.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RL.isMDXComponent=!0;const IL={toc:[]};function SL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}SL.isMDXComponent=!0;const PL={toc:[]};function EL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}GL.isMDXComponent=!0;const OL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}FL.isMDXComponent=!0;const UL={toc:[]};function qL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jL.isMDXComponent=!0;const QL={toc:[]};function HL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HL.isMDXComponent=!0;const $L={toc:[]};function YL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}YL.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}JL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function SZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SZ.isMDXComponent=!0;const PZ={toc:[]};function EZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}GZ.isMDXComponent=!0;const OZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function qZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}jZ.isMDXComponent=!0;const QZ={toc:[]};function HZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}HZ.isMDXComponent=!0;const $Z={toc:[]};function YZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}JZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Sb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Sb.isMDXComponent=!0;const Pb={toc:[]};function Eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ub,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jb.isMDXComponent=!0;const Qb={toc:[]};function Hb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Hb.isMDXComponent=!0;const $b={toc:[]};function Yb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$b,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Jb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}RN.isMDXComponent=!0;const IN={toc:[]};function SN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}SN.isMDXComponent=!0;const PN={toc:[]};function EN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}GN.isMDXComponent=!0;const ON={toc:[]};function FN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}FN.isMDXComponent=!0;const UN={toc:[]};function qN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jN.isMDXComponent=!0;const QN={toc:[]};function HN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}HN.isMDXComponent=!0;const $N={toc:[]};function YN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YN.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}JN.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Sz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Sz.isMDXComponent=!0;const Pz={toc:[]};function Ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}jz.isMDXComponent=!0;const Qz={toc:[]};function Hz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Hz.isMDXComponent=!0;const $z={toc:[]};function Yz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}RA.isMDXComponent=!0;const IA={toc:[]};function SA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SA.isMDXComponent=!0;const PA={toc:[]};function EA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}GA.isMDXComponent=!0;const OA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}FA.isMDXComponent=!0;const UA={toc:[]};function qA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jA.isMDXComponent=!0;const QA={toc:[]};function HA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}HA.isMDXComponent=!0;const $A={toc:[]};function YA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}YA.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}JA.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}RW.isMDXComponent=!0;const IW={toc:[]};function SW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}SW.isMDXComponent=!0;const PW={toc:[]};function EW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GW.isMDXComponent=!0;const OW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}FW.isMDXComponent=!0;const UW={toc:[]};function qW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}jW.isMDXComponent=!0;const QW={toc:[]};function HW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}HW.isMDXComponent=!0;const $W={toc:[]};function YW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$W,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}YW.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}JW.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}RR.isMDXComponent=!0;const IR={toc:[]};function SR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}SR.isMDXComponent=!0;const PR={toc:[]};function ER(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}GR.isMDXComponent=!0;const OR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}FR.isMDXComponent=!0;const UR={toc:[]};function qR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}jR.isMDXComponent=!0;const QR={toc:[]};function HR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}HR.isMDXComponent=!0;const $R={toc:[]};function YR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}YR.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}JR.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}RI.isMDXComponent=!0;const II={toc:[]};function SI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}SI.isMDXComponent=!0;const PI={toc:[]};function EI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}GI.isMDXComponent=!0;const OI={toc:[]};function FI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}FI.isMDXComponent=!0;const UI={toc:[]};function qI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}jI.isMDXComponent=!0;const QI={toc:[]};function HI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}HI.isMDXComponent=!0;const $I={toc:[]};function YI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}YI.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}JI.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}RS.isMDXComponent=!0;const IS={toc:[]};function SS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SS.isMDXComponent=!0;const PS={toc:[]};function ES(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GS.isMDXComponent=!0;const OS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FS.isMDXComponent=!0;const US={toc:[]};function qS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},US,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}jS.isMDXComponent=!0;const QS={toc:[]};function HS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}HS.isMDXComponent=!0;const $S={toc:[]};function YS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}YS.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}JS.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}RP.isMDXComponent=!0;const IP={toc:[]};function SP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}SP.isMDXComponent=!0;const PP={toc:[]};function EP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}GP.isMDXComponent=!0;const OP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}FP.isMDXComponent=!0;const UP={toc:[]};function qP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}jP.isMDXComponent=!0;const QP={toc:[]};function HP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}HP.isMDXComponent=!0;const $P={toc:[]};function YP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}YP.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}JP.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}RE.isMDXComponent=!0;const IE={toc:[]};function SE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}SE.isMDXComponent=!0;const PE={toc:[]};function EE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}GE.isMDXComponent=!0;const OE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}FE.isMDXComponent=!0;const UE={toc:[]};function qE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jE.isMDXComponent=!0;const QE={toc:[]};function HE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}HE.isMDXComponent=!0;const $E={toc:[]};function YE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}YE.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}JE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}RB.isMDXComponent=!0;const IB={toc:[]};function SB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}SB.isMDXComponent=!0;const PB={toc:[]};function EB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}GB.isMDXComponent=!0;const OB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FB.isMDXComponent=!0;const UB={toc:[]};function qB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jB.isMDXComponent=!0;const QB={toc:[]};function HB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}HB.isMDXComponent=!0;const $B={toc:[]};function YB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}YB.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}JB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}RG.isMDXComponent=!0;const IG={toc:[]};function SG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}SG.isMDXComponent=!0;const PG={toc:[]};function EG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}GG.isMDXComponent=!0;const OG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FG.isMDXComponent=!0;const UG={toc:[]};function qG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jG.isMDXComponent=!0;const QG={toc:[]};function HG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}HG.isMDXComponent=!0;const $G={toc:[]};function YG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YG.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}JG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}fO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}RO.isMDXComponent=!0;const IO={toc:[]};function SO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}SO.isMDXComponent=!0;const PO={toc:[]};function EO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GO.isMDXComponent=!0;const OO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FO.isMDXComponent=!0;const UO={toc:[]};function qO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jO.isMDXComponent=!0;const QO={toc:[]};function HO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}HO.isMDXComponent=!0;const $O={toc:[]};function YO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}YO.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}JO.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}RF.isMDXComponent=!0;const IF={toc:[]};function SF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}SF.isMDXComponent=!0;const PF={toc:[]};function EF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GF.isMDXComponent=!0;const OF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FF.isMDXComponent=!0;const UF={toc:[]};function qF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}jF.isMDXComponent=!0;const QF={toc:[]};function HF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}HF.isMDXComponent=!0;const $F={toc:[]};function YF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}YF.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}JF.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}RU.isMDXComponent=!0;const IU={toc:[]};function SU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}SU.isMDXComponent=!0;const PU={toc:[]};function EU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}GU.isMDXComponent=!0;const OU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}FU.isMDXComponent=!0;const UU={toc:[]};function qU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}jU.isMDXComponent=!0;const QU={toc:[]};function HU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}HU.isMDXComponent=!0;const $U={toc:[]};function YU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YU.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}JU.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}fq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Sq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Sq.isMDXComponent=!0;const Pq={toc:[]};function Eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}jq.isMDXComponent=!0;const Qq={toc:[]};function Hq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hq.isMDXComponent=!0;const $q={toc:[]};function Yq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Jq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}fV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}RV.isMDXComponent=!0;const IV={toc:[]};function SV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}SV.isMDXComponent=!0;const PV={toc:[]};function EV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GV.isMDXComponent=!0;const OV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}FV.isMDXComponent=!0;const UV={toc:[]};function qV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}jV.isMDXComponent=!0;const QV={toc:[]};function HV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}HV.isMDXComponent=!0;const $V={toc:[]};function YV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$V,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}YV.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}JV.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Sj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Sj.isMDXComponent=!0;const Pj={toc:[]};function Ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jj.isMDXComponent=!0;const Qj={toc:[]};function Hj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Hj.isMDXComponent=!0;const $j={toc:[]};function Yj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Jj.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function SQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}SQ.isMDXComponent=!0;const PQ={toc:[]};function EQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function qQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jQ.isMDXComponent=!0;const QQ={toc:[]};function HQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}HQ.isMDXComponent=!0;const $Q={toc:[]};function YQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}JQ.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}RH.isMDXComponent=!0;const IH={toc:[]};function SH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}SH.isMDXComponent=!0;const PH={toc:[]};function EH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GH.isMDXComponent=!0;const OH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FH.isMDXComponent=!0;const UH={toc:[]};function qH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}jH.isMDXComponent=!0;const QH={toc:[]};function HH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}HH.isMDXComponent=!0;const $H={toc:[]};function YH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}YH.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}JH.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}f$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}R$.isMDXComponent=!0;const I$={toc:[]};function S$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}S$.isMDXComponent=!0;const P$={toc:[]};function E$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}G$.isMDXComponent=!0;const O$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}F$.isMDXComponent=!0;const U$={toc:[]};function q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}j$.isMDXComponent=!0;const Q$={toc:[]};function H$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}H$.isMDXComponent=!0;const $$={toc:[]};function Y$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Y$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}J$.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}RY.isMDXComponent=!0;const IY={toc:[]};function SY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}SY.isMDXComponent=!0;const PY={toc:[]};function EY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}GY.isMDXComponent=!0;const OY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}FY.isMDXComponent=!0;const UY={toc:[]};function qY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jY.isMDXComponent=!0;const QY={toc:[]};function HY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}HY.isMDXComponent=!0;const $Y={toc:[]};function YY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}YY.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}JY.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}RK.isMDXComponent=!0;const IK={toc:[]};function SK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}SK.isMDXComponent=!0;const PK={toc:[]};function EK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}GK.isMDXComponent=!0;const OK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FK.isMDXComponent=!0;const UK={toc:[]};function qK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jK.isMDXComponent=!0;const QK={toc:[]};function HK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}HK.isMDXComponent=!0;const $K={toc:[]};function YK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$K,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}YK.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}JK.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}fJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function SJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}SJ.isMDXComponent=!0;const PJ={toc:[]};function EJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}GJ.isMDXComponent=!0;const OJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}FJ.isMDXComponent=!0;const UJ={toc:[]};function qJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}jJ.isMDXComponent=!0;const QJ={toc:[]};function HJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}HJ.isMDXComponent=!0;const $J={toc:[]};function YJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YJ.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}JJ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}f0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}R0.isMDXComponent=!0;const I0={toc:[]};function S0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}S0.isMDXComponent=!0;const P0={toc:[]};function E0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}G0.isMDXComponent=!0;const O0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}F0.isMDXComponent=!0;const U0={toc:[]};function q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}j0.isMDXComponent=!0;const Q0={toc:[]};function H0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}H0.isMDXComponent=!0;const $0={toc:[]};function Y0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Y0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}J0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}f2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}D2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}R2.isMDXComponent=!0;const I2={toc:[]};function S2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}S2.isMDXComponent=!0;const P2={toc:[]};function E2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}G2.isMDXComponent=!0;const O2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}F2.isMDXComponent=!0;const U2={toc:[]};function q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}j2.isMDXComponent=!0;const Q2={toc:[]};function H2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}H2.isMDXComponent=!0;const $2={toc:[]};function Y2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Y2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}J2.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}k4.isMDXComponent=!0;const y4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}f4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}D4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}R4.isMDXComponent=!0;const I4={toc:[]};function S4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}S4.isMDXComponent=!0;const P4={toc:[]};function E4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}G4.isMDXComponent=!0;const O4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}F4.isMDXComponent=!0;const U4={toc:[]};function q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}j4.isMDXComponent=!0;const Q4={toc:[]};function H4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}H4.isMDXComponent=!0;const $4={toc:[]};function Y4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Y4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}J4.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}k7.isMDXComponent=!0;const y7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}f7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}D7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}R7.isMDXComponent=!0;const I7={toc:[]};function S7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}S7.isMDXComponent=!0;const P7={toc:[]};function E7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}G7.isMDXComponent=!0;const O7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}F7.isMDXComponent=!0;const U7={toc:[]};function q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}j7.isMDXComponent=!0;const Q7={toc:[]};function H7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}H7.isMDXComponent=!0;const $7={toc:[]};function Y7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Y7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}J7.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}k6.isMDXComponent=!0;const y6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}f6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}D6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}R6.isMDXComponent=!0;const I6={toc:[]};function S6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}S6.isMDXComponent=!0;const P6={toc:[]};function E6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}G6.isMDXComponent=!0;const O6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}F6.isMDXComponent=!0;const U6={toc:[]};function q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}j6.isMDXComponent=!0;const Q6={toc:[]};function H6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}H6.isMDXComponent=!0;const $6={toc:[]};function Y6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Y6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}J6.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}f1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}R1.isMDXComponent=!0;const I1={toc:[]};function S1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}S1.isMDXComponent=!0;const P1={toc:[]};function E1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}G1.isMDXComponent=!0;const O1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}F1.isMDXComponent=!0;const U1={toc:[]};function q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}j1.isMDXComponent=!0;const Q1={toc:[]};function H1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}H1.isMDXComponent=!0;const $1={toc:[]};function Y1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Y1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}J1.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}k8.isMDXComponent=!0;const y8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}f8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}D8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}R8.isMDXComponent=!0;const I8={toc:[]};function S8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}S8.isMDXComponent=!0;const P8={toc:[]};function E8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}G8.isMDXComponent=!0;const O8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}F8.isMDXComponent=!0;const U8={toc:[]};function q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}j8.isMDXComponent=!0;const Q8={toc:[]};function H8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}H8.isMDXComponent=!0;const $8={toc:[]};function Y8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Y8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}J8.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}f3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}R3.isMDXComponent=!0;const I3={toc:[]};function S3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}S3.isMDXComponent=!0;const P3={toc:[]};function E3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}G3.isMDXComponent=!0;const O3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}F3.isMDXComponent=!0;const U3={toc:[]};function q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}j3.isMDXComponent=!0;const Q3={toc:[]};function H3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}H3.isMDXComponent=!0;const $3={toc:[]};function Y3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Y3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}J3.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}d5.isMDXComponent=!0;const h5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}k5.isMDXComponent=!0;const y5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}f5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}D5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}R5.isMDXComponent=!0;const I5={toc:[]};function S5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}S5.isMDXComponent=!0;const P5={toc:[]};function E5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}G5.isMDXComponent=!0;const O5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}F5.isMDXComponent=!0;const U5={toc:[]};function q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}j5.isMDXComponent=!0;const Q5={toc:[]};function H5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}H5.isMDXComponent=!0;const $5={toc:[]};function Y5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Y5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}J5.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d9.isMDXComponent=!0;const h9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}k9.isMDXComponent=!0;const y9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}f9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}D9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}R9.isMDXComponent=!0;const I9={toc:[]};function S9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}S9.isMDXComponent=!0;const P9={toc:[]};function E9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}G9.isMDXComponent=!0;const O9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}F9.isMDXComponent=!0;const U9={toc:[]};function q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}j9.isMDXComponent=!0;const Q9={toc:[]};function H9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}H9.isMDXComponent=!0;const $9={toc:[]};function Y9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Y9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}J9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}ktt.isMDXComponent=!0;const ytt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}ftt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Dtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Stt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Stt.isMDXComponent=!0;const Ptt={toc:[]};function Ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Ftt.isMDXComponent=!0;const Utt={toc:[]};function qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jtt.isMDXComponent=!0;const Qtt={toc:[]};function Htt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Htt.isMDXComponent=!0;const $tt={toc:[]};function Ytt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Jtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}het.isMDXComponent=!0;const ket={toc:[]};function yet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yet.isMDXComponent=!0;const fet={toc:[]};function Met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Met.isMDXComponent=!0;const Det={toc:[]};function wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Iet.isMDXComponent=!0;const Set={toc:[]};function Pet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Pet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Oet.isMDXComponent=!0;const Fet={toc:[]};function Uet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Uet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Qet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Qet.isMDXComponent=!0;const Het={toc:[]};function $et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$et.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}nnt.isMDXComponent=!0;const ont={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pnt.isMDXComponent=!0;const rnt={toc:[]};function snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}snt.isMDXComponent=!0;const cnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}int.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hnt.isMDXComponent=!0;const knt={toc:[]};function ynt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ynt.isMDXComponent=!0;const fnt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xnt.isMDXComponent=!0;const gnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Tnt.isMDXComponent=!0;const xnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Cnt.isMDXComponent=!0;const vnt={toc:[]};function Lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bnt.isMDXComponent=!0;const Nnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wnt.isMDXComponent=!0;const Rnt={toc:[]};function Int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Int.isMDXComponent=!0;const Snt={toc:[]};function Pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pnt.isMDXComponent=!0;const Ent={toc:[]};function Bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bnt.isMDXComponent=!0;const Gnt={toc:[]};function Ont(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ont.isMDXComponent=!0;const Fnt={toc:[]};function Unt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Unt.isMDXComponent=!0;const qnt={toc:[]};function Vnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Vnt.isMDXComponent=!0;const jnt={toc:[]};function Qnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qnt.isMDXComponent=!0;const Hnt={toc:[]};function $nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$nt.isMDXComponent=!0;const Ynt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Knt.isMDXComponent=!0;const Jnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}not.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hot.isMDXComponent=!0;const kot={toc:[]};function yot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yot.isMDXComponent=!0;const fot={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Iot.isMDXComponent=!0;const Sot={toc:[]};function Pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Pot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Oot.isMDXComponent=!0;const Fot={toc:[]};function Uot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Uot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Qot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qot.isMDXComponent=!0;const Hot={toc:[]};function $ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}$ot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}npt.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}hpt.isMDXComponent=!0;const kpt={toc:[]};function ypt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ypt.isMDXComponent=!0;const fpt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Ipt.isMDXComponent=!0;const Spt={toc:[]};function Ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ppt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Opt.isMDXComponent=!0;const Fpt={toc:[]};function Upt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Upt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Qpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qpt.isMDXComponent=!0;const Hpt={toc:[]};function $pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$pt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nrt.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hrt.isMDXComponent=!0;const krt={toc:[]};function yrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}yrt.isMDXComponent=!0;const frt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Irt.isMDXComponent=!0;const Srt={toc:[]};function Prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Prt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ort.isMDXComponent=!0;const Frt={toc:[]};function Urt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Urt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Qrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qrt.isMDXComponent=!0;const Hrt={toc:[]};function $rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}$rt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nst.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}hst.isMDXComponent=!0;const kst={toc:[]};function yst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}yst.isMDXComponent=!0;const fst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ist.isMDXComponent=!0;const Sst={toc:[]};function Pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Pst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ost.isMDXComponent=!0;const Fst={toc:[]};function Ust(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Ust.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Qst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Qst.isMDXComponent=!0;const Hst={toc:[]};function $st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}$st.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nct.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}hct.isMDXComponent=!0;const kct={toc:[]};function yct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yct.isMDXComponent=!0;const fct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Ict.isMDXComponent=!0;const Sct={toc:[]};function Pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Pct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Oct.isMDXComponent=!0;const Fct={toc:[]};function Uct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Uct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Qct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Qct.isMDXComponent=!0;const Hct={toc:[]};function $ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$ct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}nit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hit.isMDXComponent=!0;const kit={toc:[]};function yit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yit.isMDXComponent=!0;const fit={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Iit.isMDXComponent=!0;const Sit={toc:[]};function Pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Oit.isMDXComponent=!0;const Fit={toc:[]};function Uit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Uit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Vit.isMDXComponent=!0;const jit={toc:[]};function Qit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qit.isMDXComponent=!0;const Hit={toc:[]};function $it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$it.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}nat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}hat.isMDXComponent=!0;const kat={toc:[]};function yat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yat.isMDXComponent=!0;const fat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Iat.isMDXComponent=!0;const Sat={toc:[]};function Pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Pat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Oat.isMDXComponent=!0;const Fat={toc:[]};function Uat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Uat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Qat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Qat.isMDXComponent=!0;const Hat={toc:[]};function $at(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$at.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nlt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hlt.isMDXComponent=!0;const klt={toc:[]};function ylt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ylt.isMDXComponent=!0;const flt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ilt.isMDXComponent=!0;const Slt={toc:[]};function Plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Slt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Plt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Olt.isMDXComponent=!0;const Flt={toc:[]};function Ult(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ult.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Qlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Qlt.isMDXComponent=!0;const Hlt={toc:[]};function $lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}$lt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}hut.isMDXComponent=!0;const kut={toc:[]};function yut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}yut.isMDXComponent=!0;const fut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Iut.isMDXComponent=!0;const Sut={toc:[]};function Put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Put.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Out.isMDXComponent=!0;const Fut={toc:[]};function Uut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Uut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Qut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Qut.isMDXComponent=!0;const Hut={toc:[]};function $ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$ut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}nmt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hmt.isMDXComponent=!0;const kmt={toc:[]};function ymt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ymt.isMDXComponent=!0;const fmt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Imt.isMDXComponent=!0;const Smt={toc:[]};function Pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Omt.isMDXComponent=!0;const Fmt={toc:[]};function Umt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Umt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Qmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Qmt.isMDXComponent=!0;const Hmt={toc:[]};function $mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$mt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ndt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hdt.isMDXComponent=!0;const kdt={toc:[]};function ydt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ydt.isMDXComponent=!0;const fdt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Idt.isMDXComponent=!0;const Sdt={toc:[]};function Pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Pdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Odt.isMDXComponent=!0;const Fdt={toc:[]};function Udt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Udt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Qdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Qdt.isMDXComponent=!0;const Hdt={toc:[]};function $dt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$dt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}hht.isMDXComponent=!0;const kht={toc:[]};function yht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yht.isMDXComponent=!0;const fht={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticable if the number of sides is low, e.g. for a\ntriangle."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Iht.isMDXComponent=!0;const Sht={toc:[]};function Pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Pht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Oht.isMDXComponent=!0;const Fht={toc:[]};function Uht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Uht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Qht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qht.isMDXComponent=!0;const Hht={toc:[]};function $ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}$ht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nkt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hkt.isMDXComponent=!0;const kkt={toc:[]};function ykt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ykt.isMDXComponent=!0;const fkt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ikt.isMDXComponent=!0;const Skt={toc:[]};function Pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Pkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Okt.isMDXComponent=!0;const Fkt={toc:[]};function Ukt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ukt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Qkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qkt.isMDXComponent=!0;const Hkt={toc:[]};function $kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$kt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hyt.isMDXComponent=!0;const kyt={toc:[]};function yyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}yyt.isMDXComponent=!0;const fyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Iyt.isMDXComponent=!0;const Syt={toc:[]};function Pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Pyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Oyt.isMDXComponent=!0;const Fyt={toc:[]};function Uyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Uyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Qyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Qyt.isMDXComponent=!0;const Hyt={toc:[]};function $yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$yt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}nft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hft.isMDXComponent=!0;const kft={toc:[]};function yft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}yft.isMDXComponent=!0;const fft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ift.isMDXComponent=!0;const Sft={toc:[]};function Pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Pft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Oft.isMDXComponent=!0;const Fft={toc:[]};function Uft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Uft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Qft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Qft.isMDXComponent=!0;const Hft={toc:[]};function $ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$ft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hMt.isMDXComponent=!0;const kMt={toc:[]};function yMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}yMt.isMDXComponent=!0;const fMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}IMt.isMDXComponent=!0;const SMt={toc:[]};function PMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}OMt.isMDXComponent=!0;const FMt={toc:[]};function UMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}UMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}VMt.isMDXComponent=!0;const jMt={toc:[]};function QMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}QMt.isMDXComponent=!0;const HMt={toc:[]};function $Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}$Mt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hDt.isMDXComponent=!0;const kDt={toc:[]};function yDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yDt.isMDXComponent=!0;const fDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}IDt.isMDXComponent=!0;const SDt={toc:[]};function PDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}PDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ODt.isMDXComponent=!0;const FDt={toc:[]};function UDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}UDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function QDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}QDt.isMDXComponent=!0;const HDt={toc:[]};function $Dt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$Dt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nwt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}hwt.isMDXComponent=!0;const kwt={toc:[]};function ywt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ywt.isMDXComponent=!0;const fwt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Iwt.isMDXComponent=!0;const Swt={toc:[]};function Pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}Pwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}Owt.isMDXComponent=!0;const Fwt={toc:[]};function Uwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Uwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Qwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qwt.isMDXComponent=!0;const Hwt={toc:[]};function $wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$wt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h_t.isMDXComponent=!0;const k_t={toc:[]};function y_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}y_t.isMDXComponent=!0;const f_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}I_t.isMDXComponent=!0;const S_t={toc:[]};function P_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}P_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}O_t.isMDXComponent=!0;const F_t={toc:[]};function U_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}U_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function Q_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Q_t.isMDXComponent=!0;const H_t={toc:[]};function $_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hXt.isMDXComponent=!0;const kXt={toc:[]};function yXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}yXt.isMDXComponent=!0;const fXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}IXt.isMDXComponent=!0;const SXt={toc:[]};function PXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}PXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}OXt.isMDXComponent=!0;const FXt={toc:[]};function UXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}UXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function QXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QXt.isMDXComponent=!0;const HXt={toc:[]};function $Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$Xt.isMDXComponent=!0;const YXt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hgt.isMDXComponent=!0;const kgt={toc:[]};function ygt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ygt.isMDXComponent=!0;const fgt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Igt.isMDXComponent=!0;const Sgt={toc:[]};function Pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ogt.isMDXComponent=!0;const Fgt={toc:[]};function Ugt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Ugt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Qgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qgt.isMDXComponent=!0;const Hgt={toc:[]};function $gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$gt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}hTt.isMDXComponent=!0;const kTt={toc:[]};function yTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yTt.isMDXComponent=!0;const fTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ITt.isMDXComponent=!0;const STt={toc:[]};function PTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}PTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}OTt.isMDXComponent=!0;const FTt={toc:[]};function UTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function QTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}QTt.isMDXComponent=!0;const HTt={toc:[]};function $Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$Tt.isMDXComponent=!0;const YTt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hxt.isMDXComponent=!0;const kxt={toc:[]};function yxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}yxt.isMDXComponent=!0;const fxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Ixt.isMDXComponent=!0;const Sxt={toc:[]};function Pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Oxt.isMDXComponent=!0;const Fxt={toc:[]};function Uxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Uxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Qxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qxt.isMDXComponent=!0;const Hxt={toc:[]};function $xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}$xt.isMDXComponent=!0;const Yxt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}hCt.isMDXComponent=!0;const kCt={toc:[]};function yCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}yCt.isMDXComponent=!0;const fCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ICt.isMDXComponent=!0;const SCt={toc:[]};function PCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}PCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OCt.isMDXComponent=!0;const FCt={toc:[]};function UCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}UCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function QCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}QCt.isMDXComponent=!0;const HCt={toc:[]};function $Ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$Ct.isMDXComponent=!0;const YCt={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}hvt.isMDXComponent=!0;const kvt={toc:[]};function yvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}yvt.isMDXComponent=!0;const fvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Ivt.isMDXComponent=!0;const Svt={toc:[]};function Pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Svt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Pvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ovt.isMDXComponent=!0;const Fvt={toc:[]};function Uvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Uvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Qvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Qvt.isMDXComponent=!0;const Hvt={toc:[]};function $vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}$vt.isMDXComponent=!0;const Yvt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}hLt.isMDXComponent=!0;const kLt={toc:[]};function yLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yLt.isMDXComponent=!0;const fLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ILt.isMDXComponent=!0;const SLt={toc:[]};function PLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}OLt.isMDXComponent=!0;const FLt={toc:[]};function ULt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ULt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}VLt.isMDXComponent=!0;const jLt={toc:[]};function QLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}QLt.isMDXComponent=!0;const HLt={toc:[]};function $Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}$Lt.isMDXComponent=!0;const YLt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hZt.isMDXComponent=!0;const kZt={toc:[]};function yZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}yZt.isMDXComponent=!0;const fZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}IZt.isMDXComponent=!0;const SZt={toc:[]};function PZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}PZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}OZt.isMDXComponent=!0;const FZt={toc:[]};function UZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}UZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function QZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QZt.isMDXComponent=!0;const HZt={toc:[]};function $Zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}$Zt.isMDXComponent=!0;const YZt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nbt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}hbt.isMDXComponent=!0;const kbt={toc:[]};function ybt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ybt.isMDXComponent=!0;const fbt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ibt.isMDXComponent=!0;const Sbt={toc:[]};function Pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Pbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Obt.isMDXComponent=!0;const Fbt={toc:[]};function Ubt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ubt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Qbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qbt.isMDXComponent=!0;const Hbt={toc:[]};function $bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}$bt.isMDXComponent=!0;const Ybt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}nNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}hNt.isMDXComponent=!0;const kNt={toc:[]};function yNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}yNt.isMDXComponent=!0;const fNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}INt.isMDXComponent=!0;const SNt={toc:[]};function PNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}PNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ONt.isMDXComponent=!0;const FNt={toc:[]};function UNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}UNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function QNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}QNt.isMDXComponent=!0;const HNt={toc:[]};function $Nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$Nt.isMDXComponent=!0;const YNt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}hzt.isMDXComponent=!0;const kzt={toc:[]};function yzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}yzt.isMDXComponent=!0;const fzt={toc:[]};function Mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Izt.isMDXComponent=!0;const Szt={toc:[]};function Pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Szt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Pzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Ozt.isMDXComponent=!0;const Fzt={toc:[]};function Uzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Uzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Qzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Qzt.isMDXComponent=!0;const Hzt={toc:[]};function $zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$zt.isMDXComponent=!0;const Yzt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}hAt.isMDXComponent=!0;const kAt={toc:[]};function yAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yAt.isMDXComponent=!0;const fAt={toc:[]};function MAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}IAt.isMDXComponent=!0;const SAt={toc:[]};function PAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}PAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OAt.isMDXComponent=!0;const FAt={toc:[]};function UAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}UAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function QAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QAt.isMDXComponent=!0;const HAt={toc:[]};function $At(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}$At.isMDXComponent=!0;const YAt={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}hWt.isMDXComponent=!0;const kWt={toc:[]};function yWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}yWt.isMDXComponent=!0;const fWt={toc:[]};function MWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}MWt.isMDXComponent=!0;const DWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}IWt.isMDXComponent=!0;const SWt={toc:[]};function PWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}PWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}OWt.isMDXComponent=!0;const FWt={toc:[]};function UWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}UWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function QWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}QWt.isMDXComponent=!0;const HWt={toc:[]};function $Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$Wt.isMDXComponent=!0;const YWt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}hRt.isMDXComponent=!0;const kRt={toc:[]};function yRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yRt.isMDXComponent=!0;const fRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}IRt.isMDXComponent=!0;const SRt={toc:[]};function PRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}PRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ORt.isMDXComponent=!0;const FRt={toc:[]};function URt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}URt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function QRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}QRt.isMDXComponent=!0;const HRt={toc:[]};function $Rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Rt.isMDXComponent=!0;const YRt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}hIt.isMDXComponent=!0;const kIt={toc:[]};function yIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}yIt.isMDXComponent=!0;const fIt={toc:[]};function MIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}MIt.isMDXComponent=!0;const DIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}IIt.isMDXComponent=!0;const SIt={toc:[]};function PIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}OIt.isMDXComponent=!0;const FIt={toc:[]};function UIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}UIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function QIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QIt.isMDXComponent=!0;const HIt={toc:[]};function $It(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}$It.isMDXComponent=!0;const YIt={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hSt.isMDXComponent=!0;const kSt={toc:[]};function ySt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ySt.isMDXComponent=!0;const fSt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ISt.isMDXComponent=!0;const SSt={toc:[]};function PSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}PSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}OSt.isMDXComponent=!0;const FSt={toc:[]};function USt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}USt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function QSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QSt.isMDXComponent=!0;const HSt={toc:[]};function $St(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}$St.isMDXComponent=!0;const YSt={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hPt.isMDXComponent=!0;const kPt={toc:[]};function yPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}yPt.isMDXComponent=!0;const fPt={toc:[]};function MPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}IPt.isMDXComponent=!0;const SPt={toc:[]};function PPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}OPt.isMDXComponent=!0;const FPt={toc:[]};function UPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}UPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function QPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}QPt.isMDXComponent=!0;const HPt={toc:[]};function $Pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Pt.isMDXComponent=!0;const YPt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hEt.isMDXComponent=!0;const kEt={toc:[]};function yEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}yEt.isMDXComponent=!0;const fEt={toc:[]};function MEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}IEt.isMDXComponent=!0;const SEt={toc:[]};function PEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}PEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}OEt.isMDXComponent=!0;const FEt={toc:[]};function UEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}UEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function QEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QEt.isMDXComponent=!0;const HEt={toc:[]};function $Et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}$Et.isMDXComponent=!0;const YEt={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hBt.isMDXComponent=!0;const kBt={toc:[]};function yBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yBt.isMDXComponent=!0;const fBt={toc:[]};function MBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}IBt.isMDXComponent=!0;const SBt={toc:[]};function PBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OBt.isMDXComponent=!0;const FBt={toc:[]};function UBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}UBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function QBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}QBt.isMDXComponent=!0;const HBt={toc:[]};function $Bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}$Bt.isMDXComponent=!0;const YBt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hGt.isMDXComponent=!0;const kGt={toc:[]};function yGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}yGt.isMDXComponent=!0;const fGt={toc:[]};function MGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}IGt.isMDXComponent=!0;const SGt={toc:[]};function PGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OGt.isMDXComponent=!0;const FGt={toc:[]};function UGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}UGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function QGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QGt.isMDXComponent=!0;const HGt={toc:[]};function $Gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}$Gt.isMDXComponent=!0;const YGt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}hOt.isMDXComponent=!0;const kOt={toc:[]};function yOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yOt.isMDXComponent=!0;const fOt={toc:[]};function MOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}IOt.isMDXComponent=!0;const SOt={toc:[]};function POt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}POt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}OOt.isMDXComponent=!0;const FOt={toc:[]};function UOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}UOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function QOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QOt.isMDXComponent=!0;const HOt={toc:[]};function $Ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$Ot.isMDXComponent=!0;const YOt={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hFt.isMDXComponent=!0;const kFt={toc:[]};function yFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}yFt.isMDXComponent=!0;const fFt={toc:[]};function MFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}IFt.isMDXComponent=!0;const SFt={toc:[]};function PFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}PFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}OFt.isMDXComponent=!0;const FFt={toc:[]};function UFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}UFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function QFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}QFt.isMDXComponent=!0;const HFt={toc:[]};function $Ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$Ft.isMDXComponent=!0;const YFt={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hUt.isMDXComponent=!0;const kUt={toc:[]};function yUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}yUt.isMDXComponent=!0;const fUt={toc:[]};function MUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}IUt.isMDXComponent=!0;const SUt={toc:[]};function PUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}PUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}OUt.isMDXComponent=!0;const FUt={toc:[]};function UUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}UUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function QUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QUt.isMDXComponent=!0;const HUt={toc:[]};function $Ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$Ut.isMDXComponent=!0;const YUt={toc:[]};function KUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hqt.isMDXComponent=!0;const kqt={toc:[]};function yqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}yqt.isMDXComponent=!0;const fqt={toc:[]};function Mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Iqt.isMDXComponent=!0;const Sqt={toc:[]};function Pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Pqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Oqt.isMDXComponent=!0;const Fqt={toc:[]};function Uqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Uqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Qqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Qqt.isMDXComponent=!0;const Hqt={toc:[]};function $qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$qt.isMDXComponent=!0;const Yqt={toc:[]};function Kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hVt.isMDXComponent=!0;const kVt={toc:[]};function yVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}yVt.isMDXComponent=!0;const fVt={toc:[]};function MVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IVt.isMDXComponent=!0;const SVt={toc:[]};function PVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}PVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OVt.isMDXComponent=!0;const FVt={toc:[]};function UVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}UVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function QVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}QVt.isMDXComponent=!0;const HVt={toc:[]};function $Vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}$Vt.isMDXComponent=!0;const YVt={toc:[]};function KVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}njt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hjt.isMDXComponent=!0;const kjt={toc:[]};function yjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}yjt.isMDXComponent=!0;const fjt={toc:[]};function Mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ijt.isMDXComponent=!0;const Sjt={toc:[]};function Pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Pjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Ojt.isMDXComponent=!0;const Fjt={toc:[]};function Ujt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Ujt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Qjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Qjt.isMDXComponent=!0;const Hjt={toc:[]};function $jt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$jt.isMDXComponent=!0;const Yjt={toc:[]};function Kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hQt.isMDXComponent=!0;const kQt={toc:[]};function yQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}yQt.isMDXComponent=!0;const fQt={toc:[]};function MQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MQt.isMDXComponent=!0;const DQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IQt.isMDXComponent=!0;const SQt={toc:[]};function PQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}PQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}OQt.isMDXComponent=!0;const FQt={toc:[]};function UQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}UQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function QQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QQt.isMDXComponent=!0;const HQt={toc:[]};function $Qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$Qt.isMDXComponent=!0;const YQt={toc:[]};function KQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hHt.isMDXComponent=!0;const kHt={toc:[]};function yHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}yHt.isMDXComponent=!0;const fHt={toc:[]};function MHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}IHt.isMDXComponent=!0;const SHt={toc:[]};function PHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}OHt.isMDXComponent=!0;const FHt={toc:[]};function UHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}UHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function QHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}QHt.isMDXComponent=!0;const HHt={toc:[]};function $Ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}$Ht.isMDXComponent=!0;const YHt={toc:[]};function KHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}h$t.isMDXComponent=!0;const k$t={toc:[]};function y$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}y$t.isMDXComponent=!0;const f$t={toc:[]};function M$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}M$t.isMDXComponent=!0;const D$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}I$t.isMDXComponent=!0;const S$t={toc:[]};function P$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}P$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}O$t.isMDXComponent=!0;const F$t={toc:[]};function U$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}U$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function Q$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Q$t.isMDXComponent=!0;const H$t={toc:[]};function $$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$$t.isMDXComponent=!0;const Y$t={toc:[]};function K$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hYt.isMDXComponent=!0;const kYt={toc:[]};function yYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}yYt.isMDXComponent=!0;const fYt={toc:[]};function MYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}IYt.isMDXComponent=!0;const SYt={toc:[]};function PYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OYt.isMDXComponent=!0;const FYt={toc:[]};function UYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}UYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function QYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}QYt.isMDXComponent=!0;const HYt={toc:[]};function $Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}$Yt.isMDXComponent=!0;const YYt={toc:[]};function KYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hKt.isMDXComponent=!0;const kKt={toc:[]};function yKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}yKt.isMDXComponent=!0;const fKt={toc:[]};function MKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}IKt.isMDXComponent=!0;const SKt={toc:[]};function PKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}OKt.isMDXComponent=!0;const FKt={toc:[]};function UKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}VKt.isMDXComponent=!0;const jKt={toc:[]};function QKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}QKt.isMDXComponent=!0;const HKt={toc:[]};function $Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}$Kt.isMDXComponent=!0;const YKt={toc:[]};function KKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hJt.isMDXComponent=!0;const kJt={toc:[]};function yJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}yJt.isMDXComponent=!0;const fJt={toc:[]};function MJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}IJt.isMDXComponent=!0;const SJt={toc:[]};function PJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}OJt.isMDXComponent=!0;const FJt={toc:[]};function UJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}UJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function QJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QJt.isMDXComponent=!0;const HJt={toc:[]};function $Jt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$Jt.isMDXComponent=!0;const YJt={toc:[]};function KJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}h0t.isMDXComponent=!0;const k0t={toc:[]};function y0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}y0t.isMDXComponent=!0;const f0t={toc:[]};function M0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}M0t.isMDXComponent=!0;const D0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}I0t.isMDXComponent=!0;const S0t={toc:[]};function P0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}P0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}O0t.isMDXComponent=!0;const F0t={toc:[]};function U0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}U0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function Q0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Q0t.isMDXComponent=!0;const H0t={toc:[]};function $0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}$0t.isMDXComponent=!0;const Y0t={toc:[]};function K0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}h2t.isMDXComponent=!0;const k2t={toc:[]};function y2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}y2t.isMDXComponent=!0;const f2t={toc:[]};function M2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}M2t.isMDXComponent=!0;const D2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}I2t.isMDXComponent=!0;const S2t={toc:[]};function P2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}P2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}O2t.isMDXComponent=!0;const F2t={toc:[]};function U2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}U2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function Q2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Q2t.isMDXComponent=!0;const H2t={toc:[]};function $2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$2t.isMDXComponent=!0;const Y2t={toc:[]};function K2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}n4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}h4t.isMDXComponent=!0;const k4t={toc:[]};function y4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}y4t.isMDXComponent=!0;const f4t={toc:[]};function M4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}I4t.isMDXComponent=!0;const S4t={toc:[]};function P4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}P4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}O4t.isMDXComponent=!0;const F4t={toc:[]};function U4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}U4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function Q4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Q4t.isMDXComponent=!0;const H4t={toc:[]};function $4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}$4t.isMDXComponent=!0;const Y4t={toc:[]};function K4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}h7t.isMDXComponent=!0;const k7t={toc:[]};function y7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}y7t.isMDXComponent=!0;const f7t={toc:[]};function M7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}I7t.isMDXComponent=!0;const S7t={toc:[]};function P7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}P7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}O7t.isMDXComponent=!0;const F7t={toc:[]};function U7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}U7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function Q7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Q7t.isMDXComponent=!0;const H7t={toc:[]};function $7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$7t.isMDXComponent=!0;const Y7t={toc:[]};function K7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}h6t.isMDXComponent=!0;const k6t={toc:[]};function y6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}y6t.isMDXComponent=!0;const f6t={toc:[]};function M6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}I6t.isMDXComponent=!0;const S6t={toc:[]};function P6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}O6t.isMDXComponent=!0;const F6t={toc:[]};function U6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}U6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function Q6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Q6t.isMDXComponent=!0;const H6t={toc:[]};function $6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}$6t.isMDXComponent=!0;const Y6t={toc:[]};function K6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}n1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}h1t.isMDXComponent=!0;const k1t={toc:[]};function y1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}y1t.isMDXComponent=!0;const f1t={toc:[]};function M1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}I1t.isMDXComponent=!0;const S1t={toc:[]};function P1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}P1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}O1t.isMDXComponent=!0;const F1t={toc:[]};function U1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}U1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function Q1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Q1t.isMDXComponent=!0;const H1t={toc:[]};function $1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}$1t.isMDXComponent=!0;const Y1t={toc:[]};function K1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}h8t.isMDXComponent=!0;const k8t={toc:[]};function y8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}y8t.isMDXComponent=!0;const f8t={toc:[]};function M8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}I8t.isMDXComponent=!0;const S8t={toc:[]};function P8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}P8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}O8t.isMDXComponent=!0;const F8t={toc:[]};function U8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}U8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function Q8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Q8t.isMDXComponent=!0;const H8t={toc:[]};function $8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$8t.isMDXComponent=!0;const Y8t={toc:[]};function K8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}h3t.isMDXComponent=!0;const k3t={toc:[]};function y3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}y3t.isMDXComponent=!0;const f3t={toc:[]};function M3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}I3t.isMDXComponent=!0;const S3t={toc:[]};function P3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}P3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}O3t.isMDXComponent=!0;const F3t={toc:[]};function U3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}U3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}V3t.isMDXComponent=!0;const j3t={toc:[]};function Q3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Q3t.isMDXComponent=!0;const H3t={toc:[]};function $3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}$3t.isMDXComponent=!0;const Y3t={toc:[]};function K3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}h5t.isMDXComponent=!0;const k5t={toc:[]};function y5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}y5t.isMDXComponent=!0;const f5t={toc:[]};function M5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}I5t.isMDXComponent=!0;const S5t={toc:[]};function P5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}P5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}O5t.isMDXComponent=!0;const F5t={toc:[]};function U5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}U5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function Q5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Q5t.isMDXComponent=!0;const H5t={toc:[]};function $5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$5t.isMDXComponent=!0;const Y5t={toc:[]};function K5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}h9t.isMDXComponent=!0;const k9t={toc:[]};function y9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}y9t.isMDXComponent=!0;const f9t={toc:[]};function M9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}I9t.isMDXComponent=!0;const S9t={toc:[]};function P9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}P9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}O9t.isMDXComponent=!0;const F9t={toc:[]};function U9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}U9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function Q9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Q9t.isMDXComponent=!0;const H9t={toc:[]};function $9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$9t.isMDXComponent=!0;const Y9t={toc:[]};function K9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nte.isMDXComponent=!0;const ote={toc:[]};function pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pte.isMDXComponent=!0;const rte={toc:[]};function ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ste.isMDXComponent=!0;const cte={toc:[]};function ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ite.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hte.isMDXComponent=!0;const kte={toc:[]};function yte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yte.isMDXComponent=!0;const fte={toc:[]};function Mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Mte.isMDXComponent=!0;const Dte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}wte.isMDXComponent=!0;const _te={toc:[]};function Xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Xte.isMDXComponent=!0;const gte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Tte.isMDXComponent=!0;const xte={toc:[]};function Cte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cte.isMDXComponent=!0;const vte={toc:[]};function Lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lte.isMDXComponent=!0;const Zte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bte.isMDXComponent=!0;const Nte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zte.isMDXComponent=!0;const Ate={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wte.isMDXComponent=!0;const Rte={toc:[]};function Ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ite.isMDXComponent=!0;const Ste={toc:[]};function Pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ste,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Pte.isMDXComponent=!0;const Ete={toc:[]};function Bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}Bte.isMDXComponent=!0;const Gte={toc:[]};function Ote(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Ote.isMDXComponent=!0;const Fte={toc:[]};function Ute(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}Ute.isMDXComponent=!0;const qte={toc:[]};function Vte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vte.isMDXComponent=!0;const jte={toc:[]};function Qte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qte.isMDXComponent=!0;const Hte={toc:[]};function $te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$te.isMDXComponent=!0;const Yte={toc:[]};function Kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kte.isMDXComponent=!0;const Jte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}nee.isMDXComponent=!0;const oee={toc:[]};function pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pee.isMDXComponent=!0;const ree={toc:[]};function see(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}see.isMDXComponent=!0;const cee={toc:[]};function iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hee.isMDXComponent=!0;const kee={toc:[]};function yee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}yee.isMDXComponent=!0;const fee={toc:[]};function Mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Mee.isMDXComponent=!0;const Dee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wee.isMDXComponent=!0;const _ee={toc:[]};function Xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Xee.isMDXComponent=!0;const gee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tee.isMDXComponent=!0;const xee={toc:[]};function Cee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Cee.isMDXComponent=!0;const vee={toc:[]};function Lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lee.isMDXComponent=!0;const Zee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bee.isMDXComponent=!0;const Nee={toc:[]};function zee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}zee.isMDXComponent=!0;const Aee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Wee.isMDXComponent=!0;const Ree={toc:[]};function Iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Iee.isMDXComponent=!0;const See={toc:[]};function Pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},See,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Pee.isMDXComponent=!0;const Eee={toc:[]};function Bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Bee.isMDXComponent=!0;const Gee={toc:[]};function Oee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Oee.isMDXComponent=!0;const Fee={toc:[]};function Uee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Uee.isMDXComponent=!0;const qee={toc:[]};function Vee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Vee.isMDXComponent=!0;const jee={toc:[]};function Qee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qee.isMDXComponent=!0;const Hee={toc:[]};function $ee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$ee.isMDXComponent=!0;const Yee={toc:[]};function Kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kee.isMDXComponent=!0;const Jee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nne.isMDXComponent=!0;const one={toc:[]};function pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pne.isMDXComponent=!0;const rne={toc:[]};function sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sne.isMDXComponent=!0;const cne={toc:[]};function ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ine.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hne.isMDXComponent=!0;const kne={toc:[]};function yne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}yne.isMDXComponent=!0;const fne={toc:[]};function Mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mne.isMDXComponent=!0;const Dne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wne.isMDXComponent=!0;const _ne={toc:[]};function Xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xne.isMDXComponent=!0;const gne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tne.isMDXComponent=!0;const xne={toc:[]};function Cne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cne.isMDXComponent=!0;const vne={toc:[]};function Lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lne.isMDXComponent=!0;const Zne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bne.isMDXComponent=!0;const Nne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zne.isMDXComponent=!0;const Ane={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wne.isMDXComponent=!0;const Rne={toc:[]};function Ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ine.isMDXComponent=!0;const Sne={toc:[]};function Pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pne.isMDXComponent=!0;const Ene={toc:[]};function Bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bne.isMDXComponent=!0;const Gne={toc:[]};function One(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}One.isMDXComponent=!0;const Fne={toc:[]};function Une(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Une.isMDXComponent=!0;const qne={toc:[]};function Vne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Vne.isMDXComponent=!0;const jne={toc:[]};function Qne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Qne.isMDXComponent=!0;const Hne={toc:[]};function $ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$ne.isMDXComponent=!0;const Yne={toc:[]};function Kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kne.isMDXComponent=!0;const Jne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}noe.isMDXComponent=!0;const ooe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}poe.isMDXComponent=!0;const roe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}soe.isMDXComponent=!0;const coe={toc:[]};function ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ioe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hoe.isMDXComponent=!0;const koe={toc:[]};function yoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},koe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yoe.isMDXComponent=!0;const foe={toc:[]};function Moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Moe.isMDXComponent=!0;const Doe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}woe.isMDXComponent=!0;const _oe={toc:[]};function Xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Xoe.isMDXComponent=!0;const goe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Toe.isMDXComponent=!0;const xoe={toc:[]};function Coe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Coe.isMDXComponent=!0;const voe={toc:[]};function Loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Loe.isMDXComponent=!0;const Zoe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}boe.isMDXComponent=!0;const Noe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zoe.isMDXComponent=!0;const Aoe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Woe.isMDXComponent=!0;const Roe={toc:[]};function Ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ioe.isMDXComponent=!0;const Soe={toc:[]};function Poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Soe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Poe.isMDXComponent=!0;const Eoe={toc:[]};function Boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Boe.isMDXComponent=!0;const Goe={toc:[]};function Ooe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ooe.isMDXComponent=!0;const Foe={toc:[]};function Uoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uoe.isMDXComponent=!0;const qoe={toc:[]};function Voe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Voe.isMDXComponent=!0;const joe={toc:[]};function Qoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qoe.isMDXComponent=!0;const Hoe={toc:[]};function $oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$oe.isMDXComponent=!0;const Yoe={toc:[]};function Koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Koe.isMDXComponent=!0;const Joe={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}npe.isMDXComponent=!0;const ope={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ppe.isMDXComponent=!0;const rpe={toc:[]};function spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}spe.isMDXComponent=!0;const cpe={toc:[]};function ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ipe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}hpe.isMDXComponent=!0;const kpe={toc:[]};function ype(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}ype.isMDXComponent=!0;const fpe={toc:[]};function Mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mpe.isMDXComponent=!0;const Dpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wpe.isMDXComponent=!0;const _pe={toc:[]};function Xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xpe.isMDXComponent=!0;const gpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tpe.isMDXComponent=!0;const xpe={toc:[]};function Cpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cpe.isMDXComponent=!0;const vpe={toc:[]};function Lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}bpe.isMDXComponent=!0;const Npe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}zpe.isMDXComponent=!0;const Ape={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Wpe.isMDXComponent=!0;const Rpe={toc:[]};function Ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ipe.isMDXComponent=!0;const Spe={toc:[]};function Ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ppe.isMDXComponent=!0;const Epe={toc:[]};function Bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Bpe.isMDXComponent=!0;const Gpe={toc:[]};function Ope(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ope.isMDXComponent=!0;const Fpe={toc:[]};function Upe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Upe.isMDXComponent=!0;const qpe={toc:[]};function Vpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vpe.isMDXComponent=!0;const jpe={toc:[]};function Qpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qpe.isMDXComponent=!0;const Hpe={toc:[]};function $pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}$pe.isMDXComponent=!0;const Ype={toc:[]};function Kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}nre.isMDXComponent=!0;const ore={toc:[]};function pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}pre.isMDXComponent=!0;const rre={toc:[]};function sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sre.isMDXComponent=!0;const cre={toc:[]};function ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ire.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hre.isMDXComponent=!0;const kre={toc:[]};function yre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}yre.isMDXComponent=!0;const fre={toc:[]};function Mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Mre.isMDXComponent=!0;const Dre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}wre.isMDXComponent=!0;const _re={toc:[]};function Xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xre.isMDXComponent=!0;const gre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Tre.isMDXComponent=!0;const xre={toc:[]};function Cre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cre.isMDXComponent=!0;const vre={toc:[]};function Lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Lre.isMDXComponent=!0;const Zre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bre.isMDXComponent=!0;const Nre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zre.isMDXComponent=!0;const Are={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Wre.isMDXComponent=!0;const Rre={toc:[]};function Ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ire.isMDXComponent=!0;const Sre={toc:[]};function Pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pre.isMDXComponent=!0;const Ere={toc:[]};function Bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Bre.isMDXComponent=!0;const Gre={toc:[]};function Ore(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ore.isMDXComponent=!0;const Fre={toc:[]};function Ure(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ure.isMDXComponent=!0;const qre={toc:[]};function Vre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Vre.isMDXComponent=!0;const jre={toc:[]};function Qre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Qre.isMDXComponent=!0;const Hre={toc:[]};function $re(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}$re.isMDXComponent=!0;const Yre={toc:[]};function Kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Kre.isMDXComponent=!0;const Jre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nse.isMDXComponent=!0;const ose={toc:[]};function pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pse.isMDXComponent=!0;const rse={toc:[]};function sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sse.isMDXComponent=!0;const cse={toc:[]};function ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ise.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}hse.isMDXComponent=!0;const kse={toc:[]};function yse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}yse.isMDXComponent=!0;const fse={toc:[]};function Mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Mse.isMDXComponent=!0;const Dse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}wse.isMDXComponent=!0;const _se={toc:[]};function Xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Xse.isMDXComponent=!0;const gse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Tse.isMDXComponent=!0;const xse={toc:[]};function Cse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Cse.isMDXComponent=!0;const vse={toc:[]};function Lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lse.isMDXComponent=!0;const Zse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bse.isMDXComponent=!0;const Nse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zse.isMDXComponent=!0;const Ase={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wse.isMDXComponent=!0;const Rse={toc:[]};function Ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ise.isMDXComponent=!0;const Sse={toc:[]};function Pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pse.isMDXComponent=!0;const Ese={toc:[]};function Bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bse.isMDXComponent=!0;const Gse={toc:[]};function Ose(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ose.isMDXComponent=!0;const Fse={toc:[]};function Use(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Use.isMDXComponent=!0;const qse={toc:[]};function Vse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vse.isMDXComponent=!0;const jse={toc:[]};function Qse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qse.isMDXComponent=!0;const Hse={toc:[]};function $se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$se.isMDXComponent=!0;const Yse={toc:[]};function Kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kse.isMDXComponent=!0;const Jse={toc:[]};function tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}nce.isMDXComponent=!0;const oce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pce.isMDXComponent=!0;const rce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}sce.isMDXComponent=!0;const cce={toc:[]};function ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}ice.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hce.isMDXComponent=!0;const kce={toc:[]};function yce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}yce.isMDXComponent=!0;const fce={toc:[]};function Mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mce.isMDXComponent=!0;const Dce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wce.isMDXComponent=!0;const _ce={toc:[]};function Xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xce.isMDXComponent=!0;const gce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Tce.isMDXComponent=!0;const xce={toc:[]};function Cce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cce.isMDXComponent=!0;const vce={toc:[]};function Lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Lce.isMDXComponent=!0;const Zce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bce.isMDXComponent=!0;const Nce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zce.isMDXComponent=!0;const Ace={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wce.isMDXComponent=!0;const Rce={toc:[]};function Ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ice.isMDXComponent=!0;const Sce={toc:[]};function Pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pce.isMDXComponent=!0;const Ece={toc:[]};function Bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bce.isMDXComponent=!0;const Gce={toc:[]};function Oce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oce.isMDXComponent=!0;const Fce={toc:[]};function Uce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Uce.isMDXComponent=!0;const qce={toc:[]};function Vce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vce.isMDXComponent=!0;const jce={toc:[]};function Qce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qce.isMDXComponent=!0;const Hce={toc:[]};function $ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$ce.isMDXComponent=!0;const Yce={toc:[]};function Kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Kce.isMDXComponent=!0;const Jce={toc:[]};function tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}nie.isMDXComponent=!0;const oie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pie.isMDXComponent=!0;const rie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sie.isMDXComponent=!0;const cie={toc:[]};function iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hie.isMDXComponent=!0;const kie={toc:[]};function yie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}yie.isMDXComponent=!0;const fie={toc:[]};function Mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Mie.isMDXComponent=!0;const Die={toc:[]};function wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wie.isMDXComponent=!0;const _ie={toc:[]};function Xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Xie.isMDXComponent=!0;const gie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tie.isMDXComponent=!0;const xie={toc:[]};function Cie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cie.isMDXComponent=!0;const vie={toc:[]};function Lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Lie.isMDXComponent=!0;const Zie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}bie.isMDXComponent=!0;const Nie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zie.isMDXComponent=!0;const Aie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wie.isMDXComponent=!0;const Rie={toc:[]};function Iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iie.isMDXComponent=!0;const Sie={toc:[]};function Pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Pie.isMDXComponent=!0;const Eie={toc:[]};function Bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Bie.isMDXComponent=!0;const Gie={toc:[]};function Oie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Oie.isMDXComponent=!0;const Fie={toc:[]};function Uie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Uie.isMDXComponent=!0;const qie={toc:[]};function Vie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Vie.isMDXComponent=!0;const jie={toc:[]};function Qie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qie.isMDXComponent=!0;const Hie={toc:[]};function $ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$ie.isMDXComponent=!0;const Yie={toc:[]};function Kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kie.isMDXComponent=!0;const Jie={toc:[]};function tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nae.isMDXComponent=!0;const oae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pae.isMDXComponent=!0;const rae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sae.isMDXComponent=!0;const cae={toc:[]};function iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}iae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hae.isMDXComponent=!0;const kae={toc:[]};function yae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}yae.isMDXComponent=!0;const fae={toc:[]};function Mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mae.isMDXComponent=!0;const Dae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wae.isMDXComponent=!0;const _ae={toc:[]};function Xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xae.isMDXComponent=!0;const gae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Tae.isMDXComponent=!0;const xae={toc:[]};function Cae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cae.isMDXComponent=!0;const vae={toc:[]};function Lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Lae.isMDXComponent=!0;const Zae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}bae.isMDXComponent=!0;const Nae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}zae.isMDXComponent=!0;const Aae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wae.isMDXComponent=!0;const Rae={toc:[]};function Iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Iae.isMDXComponent=!0;const Sae={toc:[]};function Pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pae.isMDXComponent=!0;const Eae={toc:[]};function Bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bae.isMDXComponent=!0;const Gae={toc:[]};function Oae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oae.isMDXComponent=!0;const Fae={toc:[]};function Uae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Uae.isMDXComponent=!0;const qae={toc:[]};function Vae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Vae.isMDXComponent=!0;const jae={toc:[]};function Qae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Qae.isMDXComponent=!0;const Hae={toc:[]};function $ae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$ae.isMDXComponent=!0;const Yae={toc:[]};function Kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Kae.isMDXComponent=!0;const Jae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nle.isMDXComponent=!0;const ole={toc:[]};function ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ple.isMDXComponent=!0;const rle={toc:[]};function sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sle.isMDXComponent=!0;const cle={toc:[]};function ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ile.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hle.isMDXComponent=!0;const kle={toc:[]};function yle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yle.isMDXComponent=!0;const fle={toc:[]};function Mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mle.isMDXComponent=!0;const Dle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wle.isMDXComponent=!0;const _le={toc:[]};function Xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Xle.isMDXComponent=!0;const gle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tle.isMDXComponent=!0;const xle={toc:[]};function Cle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Cle.isMDXComponent=!0;const vle={toc:[]};function Lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lle.isMDXComponent=!0;const Zle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ble.isMDXComponent=!0;const Nle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zle.isMDXComponent=!0;const Ale={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Wle.isMDXComponent=!0;const Rle={toc:[]};function Ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ile.isMDXComponent=!0;const Sle={toc:[]};function Ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ple.isMDXComponent=!0;const Ele={toc:[]};function Ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ble.isMDXComponent=!0;const Gle={toc:[]};function Ole(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ole.isMDXComponent=!0;const Fle={toc:[]};function Ule(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ule.isMDXComponent=!0;const qle={toc:[]};function Vle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Vle.isMDXComponent=!0;const jle={toc:[]};function Qle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qle.isMDXComponent=!0;const Hle={toc:[]};function $le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$le.isMDXComponent=!0;const Yle={toc:[]};function Kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kle.isMDXComponent=!0;const Jle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nue.isMDXComponent=!0;const oue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}pue.isMDXComponent=!0;const rue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sue.isMDXComponent=!0;const cue={toc:[]};function iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hue.isMDXComponent=!0;const kue={toc:[]};function yue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yue.isMDXComponent=!0;const fue={toc:[]};function Mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Mue.isMDXComponent=!0;const Due={toc:[]};function wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wue.isMDXComponent=!0;const _ue={toc:[]};function Xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Xue.isMDXComponent=!0;const gue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Tue.isMDXComponent=!0;const xue={toc:[]};function Cue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cue.isMDXComponent=!0;const vue={toc:[]};function Lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lue.isMDXComponent=!0;const Zue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bue.isMDXComponent=!0;const Nue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}zue.isMDXComponent=!0;const Aue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Wue.isMDXComponent=!0;const Rue={toc:[]};function Iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iue.isMDXComponent=!0;const Sue={toc:[]};function Pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pue.isMDXComponent=!0;const Eue={toc:[]};function Bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bue.isMDXComponent=!0;const Gue={toc:[]};function Oue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Oue.isMDXComponent=!0;const Fue={toc:[]};function Uue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Uue.isMDXComponent=!0;const que={toc:[]};function Vue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Vue.isMDXComponent=!0;const jue={toc:[]};function Que(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Que.isMDXComponent=!0;const Hue={toc:[]};function $ue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$ue.isMDXComponent=!0;const Yue={toc:[]};function Kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Kue.isMDXComponent=!0;const Jue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}nme.isMDXComponent=!0;const ome={toc:[]};function pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pme.isMDXComponent=!0;const rme={toc:[]};function sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sme.isMDXComponent=!0;const cme={toc:[]};function ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ime.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hme.isMDXComponent=!0;const kme={toc:[]};function yme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yme.isMDXComponent=!0;const fme={toc:[]};function Mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mme.isMDXComponent=!0;const Dme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wme.isMDXComponent=!0;const _me={toc:[]};function Xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Xme.isMDXComponent=!0;const gme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tme.isMDXComponent=!0;const xme={toc:[]};function Cme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Cme.isMDXComponent=!0;const vme={toc:[]};function Lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Lme.isMDXComponent=!0;const Zme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}bme.isMDXComponent=!0;const Nme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zme.isMDXComponent=!0;const Ame={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wme.isMDXComponent=!0;const Rme={toc:[]};function Ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ime.isMDXComponent=!0;const Sme={toc:[]};function Pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Pme.isMDXComponent=!0;const Eme={toc:[]};function Bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Bme.isMDXComponent=!0;const Gme={toc:[]};function Ome(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ome.isMDXComponent=!0;const Fme={toc:[]};function Ume(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ume.isMDXComponent=!0;const qme={toc:[]};function Vme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Vme.isMDXComponent=!0;const jme={toc:[]};function Qme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qme.isMDXComponent=!0;const Hme={toc:[]};function $me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$me.isMDXComponent=!0;const Yme={toc:[]};function Kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kme.isMDXComponent=!0;const Jme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nde.isMDXComponent=!0;const ode={toc:[]};function pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pde.isMDXComponent=!0;const rde={toc:[]};function sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sde.isMDXComponent=!0;const cde={toc:[]};function ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ide.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hde.isMDXComponent=!0;const kde={toc:[]};function yde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}yde.isMDXComponent=!0;const fde={toc:[]};function Mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mde.isMDXComponent=!0;const Dde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wde.isMDXComponent=!0;const _de={toc:[]};function Xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xde.isMDXComponent=!0;const gde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Tde.isMDXComponent=!0;const xde={toc:[]};function Cde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cde.isMDXComponent=!0;const vde={toc:[]};function Lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lde.isMDXComponent=!0;const Zde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bde.isMDXComponent=!0;const Nde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zde.isMDXComponent=!0;const Ade={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wde.isMDXComponent=!0;const Rde={toc:[]};function Ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ide.isMDXComponent=!0;const Sde={toc:[]};function Pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pde.isMDXComponent=!0;const Ede={toc:[]};function Bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bde.isMDXComponent=!0;const Gde={toc:[]};function Ode(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ode.isMDXComponent=!0;const Fde={toc:[]};function Ude(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ude.isMDXComponent=!0;const qde={toc:[]};function Vde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vde.isMDXComponent=!0;const jde={toc:[]};function Qde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qde.isMDXComponent=!0;const Hde={toc:[]};function $de(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}$de.isMDXComponent=!0;const Yde={toc:[]};function Kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Kde.isMDXComponent=!0;const Jde={toc:[]};function the(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}phe.isMDXComponent=!0;const rhe={toc:[]};function she(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}she.isMDXComponent=!0;const che={toc:[]};function ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ihe.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hhe.isMDXComponent=!0;const khe={toc:[]};function yhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},khe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}yhe.isMDXComponent=!0;const fhe={toc:[]};function Mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mhe.isMDXComponent=!0;const Dhe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}whe.isMDXComponent=!0;const _he={toc:[]};function Xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Xhe.isMDXComponent=!0;const ghe={toc:[]};function The(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}The.isMDXComponent=!0;const xhe={toc:[]};function Che(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Che.isMDXComponent=!0;const vhe={toc:[]};function Lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bhe.isMDXComponent=!0;const Nhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}zhe.isMDXComponent=!0;const Ahe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Whe.isMDXComponent=!0;const Rhe={toc:[]};function Ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ihe.isMDXComponent=!0;const She={toc:[]};function Phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},She,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Phe.isMDXComponent=!0;const Ehe={toc:[]};function Bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bhe.isMDXComponent=!0;const Ghe={toc:[]};function Ohe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ohe.isMDXComponent=!0;const Fhe={toc:[]};function Uhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Uhe.isMDXComponent=!0;const qhe={toc:[]};function Vhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vhe.isMDXComponent=!0;const jhe={toc:[]};function Qhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Qhe.isMDXComponent=!0;const Hhe={toc:[]};function $he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$he.isMDXComponent=!0;const Yhe={toc:[]};function Khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Khe.isMDXComponent=!0;const Jhe={toc:[]};function tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nke.isMDXComponent=!0;const oke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pke.isMDXComponent=!0;const rke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ske.isMDXComponent=!0;const cke={toc:[]};function ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ike.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hke.isMDXComponent=!0;const kke={toc:[]};function yke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yke.isMDXComponent=!0;const fke={toc:[]};function Mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mke.isMDXComponent=!0;const Dke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wke.isMDXComponent=!0;const _ke={toc:[]};function Xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Xke.isMDXComponent=!0;const gke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tke.isMDXComponent=!0;const xke={toc:[]};function Cke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Cke.isMDXComponent=!0;const vke={toc:[]};function Lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Lke.isMDXComponent=!0;const Zke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}bke.isMDXComponent=!0;const Nke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zke.isMDXComponent=!0;const Ake={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wke.isMDXComponent=!0;const Rke={toc:[]};function Ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ike.isMDXComponent=!0;const Ske={toc:[]};function Pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ske,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Pke.isMDXComponent=!0;const Eke={toc:[]};function Bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bke.isMDXComponent=!0;const Gke={toc:[]};function Oke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Oke.isMDXComponent=!0;const Fke={toc:[]};function Uke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Uke.isMDXComponent=!0;const qke={toc:[]};function Vke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Vke.isMDXComponent=!0;const jke={toc:[]};function Qke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qke.isMDXComponent=!0;const Hke={toc:[]};function $ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$ke.isMDXComponent=!0;const Yke={toc:[]};function Kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Kke.isMDXComponent=!0;const Jke={toc:[]};function tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nye.isMDXComponent=!0;const oye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}pye.isMDXComponent=!0;const rye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}sye.isMDXComponent=!0;const cye={toc:[]};function iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}iye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}hye.isMDXComponent=!0;const kye={toc:[]};function yye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yye.isMDXComponent=!0;const fye={toc:[]};function Mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mye.isMDXComponent=!0;const Dye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wye.isMDXComponent=!0;const _ye={toc:[]};function Xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Xye.isMDXComponent=!0;const gye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tye.isMDXComponent=!0;const xye={toc:[]};function Cye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Cye.isMDXComponent=!0;const vye={toc:[]};function Lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lye.isMDXComponent=!0;const Zye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bye.isMDXComponent=!0;const Nye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zye.isMDXComponent=!0;const Aye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wye.isMDXComponent=!0;const Rye={toc:[]};function Iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iye.isMDXComponent=!0;const Sye={toc:[]};function Pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Pye.isMDXComponent=!0;const Eye={toc:[]};function Bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Bye.isMDXComponent=!0;const Gye={toc:[]};function Oye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Oye.isMDXComponent=!0;const Fye={toc:[]};function Uye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uye.isMDXComponent=!0;const qye={toc:[]};function Vye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vye.isMDXComponent=!0;const jye={toc:[]};function Qye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qye.isMDXComponent=!0;const Hye={toc:[]};function $ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$ye.isMDXComponent=!0;const Yye={toc:[]};function Kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Kye.isMDXComponent=!0;const Jye={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pfe.isMDXComponent=!0;const rfe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sfe.isMDXComponent=!0;const cfe={toc:[]};function ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ife.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}hfe.isMDXComponent=!0;const kfe={toc:[]};function yfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}yfe.isMDXComponent=!0;const ffe={toc:[]};function Mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Mfe.isMDXComponent=!0;const Dfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}wfe.isMDXComponent=!0;const _fe={toc:[]};function Xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Xfe.isMDXComponent=!0;const gfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}Tfe.isMDXComponent=!0;const xfe={toc:[]};function Cfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Cfe.isMDXComponent=!0;const vfe={toc:[]};function Lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Lfe.isMDXComponent=!0;const Zfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}bfe.isMDXComponent=!0;const Nfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}zfe.isMDXComponent=!0;const Afe={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Wfe.isMDXComponent=!0;const Rfe={toc:[]};function Ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Ife.isMDXComponent=!0;const Sfe={toc:[]};function Pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Pfe.isMDXComponent=!0;const Efe={toc:[]};function Bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Bfe.isMDXComponent=!0;const Gfe={toc:[]};function Ofe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Ofe.isMDXComponent=!0;const Ffe={toc:[]};function Ufe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Ufe.isMDXComponent=!0;const qfe={toc:[]};function Vfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}Vfe.isMDXComponent=!0;const jfe={toc:[]};function Qfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}Qfe.isMDXComponent=!0;const Hfe={toc:[]};function $fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}$fe.isMDXComponent=!0;const Yfe={toc:[]};function Kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}pMe.isMDXComponent=!0;const rMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}sMe.isMDXComponent=!0;const cMe={toc:[]};function iMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}iMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}hMe.isMDXComponent=!0;const kMe={toc:[]};function yMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}yMe.isMDXComponent=!0;const fMe={toc:[]};function MMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}MMe.isMDXComponent=!0;const DMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}wMe.isMDXComponent=!0;const _Me={toc:[]};function XMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}XMe.isMDXComponent=!0;const gMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}TMe.isMDXComponent=!0;const xMe={toc:[]};function CMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}CMe.isMDXComponent=!0;const vMe={toc:[]};function LMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}LMe.isMDXComponent=!0;const ZMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}bMe.isMDXComponent=!0;const NMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}zMe.isMDXComponent=!0;const AMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}WMe.isMDXComponent=!0;const RMe={toc:[]};function IMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}IMe.isMDXComponent=!0;const SMe={toc:[]};function PMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}PMe.isMDXComponent=!0;const EMe={toc:[]};function BMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}BMe.isMDXComponent=!0;const GMe={toc:[]};function OMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}OMe.isMDXComponent=!0;const FMe={toc:[]};function UMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}UMe.isMDXComponent=!0;const qMe={toc:[]};function VMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}VMe.isMDXComponent=!0;const jMe={toc:[]};function QMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}QMe.isMDXComponent=!0;const HMe={toc:[]};function $Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}$Me.isMDXComponent=!0;const YMe={toc:[]};function KMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}KMe.isMDXComponent=!0;const JMe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}pDe.isMDXComponent=!0;const rDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}sDe.isMDXComponent=!0;const cDe={toc:[]};function iDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}iDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}hDe.isMDXComponent=!0;const kDe={toc:[]};function yDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}yDe.isMDXComponent=!0;const fDe={toc:[]};function MDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}MDe.isMDXComponent=!0;const DDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}wDe.isMDXComponent=!0;const _De={toc:[]};function XDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}XDe.isMDXComponent=!0;const gDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}TDe.isMDXComponent=!0;const xDe={toc:[]};function CDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}CDe.isMDXComponent=!0;const vDe={toc:[]};function LDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}LDe.isMDXComponent=!0;const ZDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}bDe.isMDXComponent=!0;const NDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}zDe.isMDXComponent=!0;const ADe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WDe.isMDXComponent=!0;const RDe={toc:[]};function IDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}IDe.isMDXComponent=!0;const SDe={toc:[]};function PDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}PDe.isMDXComponent=!0;const EDe={toc:[]};function BDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BDe.isMDXComponent=!0;const GDe={toc:[]};function ODe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}ODe.isMDXComponent=!0;const FDe={toc:[]};function UDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}UDe.isMDXComponent=!0;const qDe={toc:[]};function VDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}VDe.isMDXComponent=!0;const jDe={toc:[]};function QDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}QDe.isMDXComponent=!0;const HDe={toc:[]};function $De(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}$De.isMDXComponent=!0;const YDe={toc:[]};function KDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}KDe.isMDXComponent=!0;const JDe={toc:[]};function twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}nwe.isMDXComponent=!0;const owe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}pwe.isMDXComponent=!0;const rwe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}swe.isMDXComponent=!0;const cwe={toc:[]};function iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}iwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}hwe.isMDXComponent=!0;const kwe={toc:[]};function ywe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}ywe.isMDXComponent=!0;const fwe={toc:[]};function Mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}Mwe.isMDXComponent=!0;const Dwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}wwe.isMDXComponent=!0;const _we={toc:[]};function Xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Xwe.isMDXComponent=!0;const gwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}Twe.isMDXComponent=!0;const xwe={toc:[]};function Cwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}Cwe.isMDXComponent=!0;const vwe={toc:[]};function Lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}bwe.isMDXComponent=!0;const Nwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}zwe.isMDXComponent=!0;const Awe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}Wwe.isMDXComponent=!0;const Rwe={toc:[]};function Iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}Iwe.isMDXComponent=!0;const Swe={toc:[]};function Pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}Pwe.isMDXComponent=!0;const Ewe={toc:[]};function Bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Bwe.isMDXComponent=!0;const Gwe={toc:[]};function Owe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}Owe.isMDXComponent=!0;const Fwe={toc:[]};function Uwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Uwe.isMDXComponent=!0;const qwe={toc:[]};function Vwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Vwe.isMDXComponent=!0;const jwe={toc:[]};function Qwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}Qwe.isMDXComponent=!0;const Hwe={toc:[]};function $we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}$we.isMDXComponent=!0;const Ywe={toc:[]};function Kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}p_e.isMDXComponent=!0;const r_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}s_e.isMDXComponent=!0;const c_e={toc:[]};function i_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}i_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}h_e.isMDXComponent=!0;const k_e={toc:[]};function y_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}y_e.isMDXComponent=!0;const f_e={toc:[]};function M_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}M_e.isMDXComponent=!0;const D_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}w_e.isMDXComponent=!0;const __e={toc:[]};function X_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}X_e.isMDXComponent=!0;const g_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}T_e.isMDXComponent=!0;const x_e={toc:[]};function C_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}C_e.isMDXComponent=!0;const v_e={toc:[]};function L_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}L_e.isMDXComponent=!0;const Z_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}b_e.isMDXComponent=!0;const N_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}z_e.isMDXComponent=!0;const A_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}W_e.isMDXComponent=!0;const R_e={toc:[]};function I_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}I_e.isMDXComponent=!0;const S_e={toc:[]};function P_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}P_e.isMDXComponent=!0;const E_e={toc:[]};function B_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}B_e.isMDXComponent=!0;const G_e={toc:[]};function O_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}O_e.isMDXComponent=!0;const F_e={toc:[]};function U_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}U_e.isMDXComponent=!0;const q_e={toc:[]};function V_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}V_e.isMDXComponent=!0;const j_e={toc:[]};function Q_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function H_e(t){let{id:e}=t;const n=o[e]??p.Fragment;return p.createElement(n,null)}Q_e.isMDXComponent=!0},79322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),p=n(3866),r=n(28698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==e?void 0:e.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,n&&c),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),k&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,k.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:y.contentId})),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:f.contentId})))}},31930:(t,e,n)=>{n.d(e,{Z:()=>Ot});var o=n(2784),p=n(37390),r=n(66835),s=n(80068),c=n(6277),i=n(68569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,n&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(39318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},e)}var k=n(89817);function y(t){let{children:e,type:n,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(n);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),e):o.createElement("span",(0,l.Z)({id:r},i),e)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:a.none,[f.Angle]:a.angle,[f.Curly]:a.curly,[f.Square]:a.square,[f.Parentheses]:a.parentheses};function w(t){let{children:e,type:n,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[n??f.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":p,key:e,className:a.element},t)))))}var _=n(88617);function X(t){var e;let{type:n}=t;const p=(0,_.RU)(n.project),r=null==p?void 0:p[n.id],s=n.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:s,type:s?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(w,{type:f.Angle},n.typeArguments.map(((t,e)=>o.createElement(E,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(y,{type:"keyword"},e.name)}function T(t){let{type:e}=t;return e.elements?o.createElement(w,{type:f.Square},e.elements.map(((t,e)=>o.createElement(E,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Pipe},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,p]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(y,{type:p},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,e.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(E,{type:e.targetType}))}function Z(t){let{type:e}=t;const n=(0,_.in)();return o.createElement($,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Ampersand},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:e,type:n}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(E,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(E,{type:e.extendsType})," ? ",o.createElement(E,{type:e.trueType})," : ",o.createElement(E,{type:e.falseType}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},e.name))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.objectType}),"[",o.createElement(E,{type:e.indexType}),"]")}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},e.operator," "),o.createElement(E,{type:e.target}))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},e.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(E,{type:e.parameterType}),"]: ",o.createElement(E,{type:e.templateType}))))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(E,{type:e.element}))}function E(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return S;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function B(t){let{flags:e,explicitAccessModifier:n}=t;const p=[];return null!=e&&e.isAbstract&&p.push("abstract"),null!=e&&e.isStatic&&p.push("static"),null!=e&&e.isConst&&p.push("const"),null!=e&&e.isReadonly&&p.push("readonly"),null!=e&&e.isPrivate&&p.push("private"),null!=e&&e.isProtected&&p.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(E,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},e.defaultValue)))}function O(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.varianceModifier&&o.createElement(y,{type:"keyword"},e.varianceModifier," "),o.createElement(y,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:e.default})))}function F(t){var e,n;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):i?"":o.createElement(y,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(w,{type:f.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(w,{type:f.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function U(t){let{reflection:e}=t;return o.createElement(G,{reflection:e})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var e,n,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(y,{type:"keyword"},q[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(w,{type:f.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))))}function j(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},e.name),e.typeParameters&&o.createElement(w,{type:f.Angle},e.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:n(t)}))))," = ",o.createElement(E,{type:e.type}))}function Q(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(F,{reflection:e.signatures[0]}):e.children?o.createElement(w,{type:f.Curly},e.children.map((t=>o.createElement($,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function H(t){var e;let{reflection:n}=t;const p=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(F,{reflection:p})}function $(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return F;case p.W.Property:return U;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return Q;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function Y(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,c.Z)(a.line,"token-line")},e),o.createElement("br",null))}var K=n(79322),J=n(3866);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>e.map(r)),[e]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},o.createElement(Y,null,o.createElement(F,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(et,{parameters:c.parameters}))}var ot=n(57708);function pt(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===p.W.Class||n===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(53181),ut=n(83851),mt=n(24126),dt=n(32424),ht=n(42244),kt=n(24155);function yt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function ft(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??yt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function Mt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Dt(t){let{queryString:e=!1,groupId:n}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(p.location.search);e.set(r,t),p.replace({...p.location,search:e.toString()})}),[r,p])]}function wt(t){const{defaultValue:e,queryString:n=!1,groupId:p}=t,r=ft(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!Mt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=Dt({queryString:n,groupId:p}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[p,r]=(0,kt.Nk)(n);return[p,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=n(89741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:e,block:n,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=i.indexOf(e),o=s[n].value;o!==p&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=i.indexOf(t.currentTarget)+1;n=i[e]??i[0];break}case"ArrowLeft":{const e=i.indexOf(t.currentTarget)-1;n=i[e]??i[i.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},e)},s.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===e?0:-1,"aria-selected":p===e,key:e,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===e})}),n??e)})))}function xt(t){let{lazy:e,children:n,selectedValue:p}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==p}))))}function Ct(t){const e=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,e)),o.createElement(xt,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:e,hidden:n,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:n},e)}function bt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Ot,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const p=(0,lt.TH)(),r=(0,_.RU)(n),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[e,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),i.length>1?o.createElement(vt,{groupId:e.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var e,n,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement($,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var e;let{reflection:n,headless:p}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:n.overwrites}))))}function Wt(t){var e,n;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(U,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Rt(t){var e,n,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement($,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=n(78128);function St(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const Pt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),p=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:return Gt;case p.W.Module:return St;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},37390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},88617:(t,e,n)=>{n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{var o;const p=t[n];return p?(null==(o=e[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},80068:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(2784),p=n(50822);const r=o.createContext(null);function s(t){let{children:e}=t;const n=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},57708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),p=n(31263),r=n(89741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const p=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},34127:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=n(7896),p=(n(2784),n(30876)),r=n(52665),s=n(42072);const c={sidebar_position:5,slug:"/layouts"},i="Layouts",a={unversionedId:"getting-started/layouts",id:"getting-started/layouts",title:"Layouts",description:"Layouts allow you to arrange your nodes using Flexbox. Any node",source:"@site/docs/getting-started/layouts.mdx",sourceDirName:"getting-started",slug:"/layouts",permalink:"/docs/layouts",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/layouts.mdx",tags:[],version:"current",lastUpdatedBy:"Nikita",sidebarPosition:5,frontMatter:{sidebar_position:5,slug:"/layouts"},sidebar:"docs",previous:{title:"Positioning",permalink:"/docs/positioning"},next:{title:"Signals",permalink:"/docs/signals"}},l={},u=[{value:"Layout root",id:"layout-root",level:2},{value:"Size and offset",id:"size-and-offset",level:2},{value:"<code>Layout.size</code>",id:"layoutsize",level:3},{value:"<code>Layout.offset</code>",id:"layoutoffset",level:3},{value:"Cardinal directions",id:"cardinal-directions",level:2},{value:"Flexbox configuration",id:"flexbox-configuration",level:2},{value:"<code>Layout.padding</code>",id:"layoutpadding",level:3},{value:"<code>Layout.margin</code>",id:"layoutmargin",level:3},{value:"<code>Layout.gap</code>",id:"layoutgap",level:3},{value:"<code>Layout.direction</code>",id:"layoutdirection",level:3},{value:"<code>Layout.alignItems</code>",id:"layoutalignitems",level:3},{value:"<code>Layout.justifyContent</code>",id:"layoutjustifycontent",level:3},{value:"Groups",id:"groups",level:2}],m={toc:u};function d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"layouts"},"Layouts"),(0,p.kt)(r.Z,{name:"layout",banner:!0,mdxType:"AnimationPlayer"}),(0,p.kt)("p",null,"Layouts allow you to arrange your nodes using ",(0,p.kt)("a",{parentName:"p",href:"https://css-tricks.com/snippets/css/a-guide-to-flexbox/"},"Flexbox"),". Any node\nextending the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout"},(0,p.kt)("inlineCode",{parentName:"a"},"Layout"))," node can become a part of\nthe layout. This includes, but is not limited to:\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect"},(0,p.kt)("inlineCode",{parentName:"a"},"Rect")),", ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle"},(0,p.kt)("inlineCode",{parentName:"a"},"Circle")),", and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,p.kt)("inlineCode",{parentName:"a"},"Img")),"."),(0,p.kt)("h2",{id:"layout-root"},"Layout root"),(0,p.kt)("p",null,"Layouts are an opt-in feature, meaning that they need to be enabled. It's done\nby setting the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," property on the Node\nthat we want to become the root of our layout:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// \u2193 layout root\n<Rect layout>\n  {/* \u2193 layout child */}\n  <Circle width={320} height={320} />\n</Rect>\n")),(0,p.kt)("p",null,"In the example above, we marked the ",(0,p.kt)("inlineCode",{parentName:"p"},"<Rect>")," as the layout root. This will cause\nthe position and size of its descendants to be controlled by Flexbox (In this\ncase there's only one valid descendant: ",(0,p.kt)("inlineCode",{parentName:"p"},"<Circle>"),"). The layout root itself is\ntreated differently than its children - its size is controlled by Flexbox, but\nthe position stays unaffected."),(0,p.kt)("admonition",{type:"info"},(0,p.kt)("p",{parentName:"admonition"},"Just setting the ",(0,p.kt)("inlineCode",{parentName:"p"},"layout")," property doesn't always turn the node into a layout\nroot. If the node is already a part of the layout, it will be treated like the\nrest of the descendants:"),(0,p.kt)("pre",{parentName:"admonition"},(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// \u2193 layout root\n<Rect layout>\n  {/* \u2193 layout child, NOT a layout root */}\n  <Rect layout>\n    {/* \u2193 layout child */}\n    <Circle width={320} height={320} />\n  </Rect>\n</Rect>\n"))),(0,p.kt)("h2",{id:"size-and-offset"},"Size and offset"),(0,p.kt)("p",null,"Aside from the position, rotation, and scale, any node extending the ",(0,p.kt)("inlineCode",{parentName:"p"},"Layout"),"\nclass has additional ",(0,p.kt)("inlineCode",{parentName:"p"},"size")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"offset")," properties:"),(0,p.kt)("h3",{id:"layoutsize"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.size")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#size",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutoffset"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.offset")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#offset",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"cardinal-directions"},"Cardinal directions"),(0,p.kt)("p",null,"Layout nodes come with a set of helper properties that let you position them in\nrespect to their edges/corners. In the example below we use them to place two\nsquares on the left and right side of a gray rectangle. The yellow square is\npositioned so that its right edge is in the same place as the left edge of the\nrectangle. Meanwhile, the red square is placed so that its bottom left corner\naligns with the bottom right corner of the rectangle. All possible directions\ninclude: ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#top"},(0,p.kt)("inlineCode",{parentName:"a"},"top")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#bottom"},(0,p.kt)("inlineCode",{parentName:"a"},"bottom")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#left"},(0,p.kt)("inlineCode",{parentName:"a"},"left")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#right"},(0,p.kt)("inlineCode",{parentName:"a"},"right")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#topLeft"},(0,p.kt)("inlineCode",{parentName:"a"},"topLeft")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#topRight"},(0,p.kt)("inlineCode",{parentName:"a"},"topRight")),",\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#bottomLeft"},(0,p.kt)("inlineCode",{parentName:"a"},"bottomLeft")),", and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#bottomRight"},(0,p.kt)("inlineCode",{parentName:"a"},"bottomRight")),"."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Rect} from '@motion-canvas/2d/lib';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const rect = createRef<Rect>();\n\n  view.add(\n    <>\n      <Rect\n        ref={rect}\n        width={200}\n        height={100}\n        rotation={-10}\n        fill={'#333333'}\n      />\n      <Rect\n        size={50}\n        fill={'#e6a700'}\n        rotation={rect().rotation}\n        // Try changing \"right\" to \"top\"\n        right={rect().left}\n      />\n      <Rect\n        size={100}\n        fill={'#e13238'}\n        rotation={10}\n        bottomLeft={rect().bottomRight}\n      />\n    </>,\n  );\n\n  yield* rect().rotation(10, 1).to(-10, 1);\n});\n")),(0,p.kt)("h2",{id:"flexbox-configuration"},"Flexbox configuration"),(0,p.kt)("p",null,"Most flexbox attributes available in CSS are available as\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#Properties"},(0,p.kt)("inlineCode",{parentName:"a"},"Layout")," properties"),". You can check out\nthis ",(0,p.kt)("a",{parentName:"p",href:"https://css-tricks.com/snippets/css/a-guide-to-flexbox/"},"Flexbox guide")," to better understand how they work. The most\nuseful properties are listed below:"),(0,p.kt)("h3",{id:"layoutpadding"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.padding")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#padding",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutmargin"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.margin")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#margin",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutgap"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.gap")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#gap",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutdirection"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.direction")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#direction",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutalignitems"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.alignItems")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#alignItems",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"layoutjustifycontent"},(0,p.kt)("inlineCode",{parentName:"h3"},"Layout.justifyContent")),(0,p.kt)(s.Z,{url:"/api/2d/components/Layout#justifyContent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"groups"},"Groups"),(0,p.kt)("p",null,"Nodes that don't extend the ",(0,p.kt)("inlineCode",{parentName:"p"},"Layout")," class, such as the ",(0,p.kt)("inlineCode",{parentName:"p"},"Node")," itself, are\nunaffected by the layout and are treated as if they were never there. This lets\nyou apply filters and transformations to layout nodes without affecting the\nhierarchy."),(0,p.kt)("p",null,"From the layout's perspective, all ",(0,p.kt)("inlineCode",{parentName:"p"},"<Rect>"),"s in the example below are siblings:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"<Layout direction={'column'} width={960} gap={40} layout>\n  <Node opacity={0.1}>\n    <Rect height={240} fill={'#ff6470'} />\n    <Rect height={240} fill={'#ff6470'} />\n  </Node>\n  <Rect height={240} fill={'#ff6470'} />\n</Layout>\n")),(0,p.kt)(r.Z,{name:"layout-group",small:!0,mdxType:"AnimationPlayer"}))}d.isMDXComponent=!0}}]);