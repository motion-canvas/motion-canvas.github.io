(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{1532:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=1532,t.exports=e},2009:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(2784),p=n(6277);const r={tabItem:"tabItem_OMyP"};function s(t){let{children:e,hidden:n,className:s}=t;return o.createElement("div",{role:"tabpanel",className:(0,p.Z)(r.tabItem,s),hidden:n},e)}},7336:(t,e,n)=>{"use strict";n.d(e,{Z:()=>_});var o=n(7896),p=n(2784),r=n(6277),s=n(4126),c=n(3181),i=n(2424),a=n(2244),l=n(4155);function u(t){return function(t){return p.Children.map(t,(t=>{if(!t||(0,p.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function m(t){const{values:e,children:n}=t;return(0,p.useMemo)((()=>{const t=e??u(n);return function(t){const e=(0,a.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function d(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function h(t){let{queryString:e=!1,groupId:n}=t;const o=(0,c.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,i._X)(r),(0,p.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(o.location.search);e.set(r,t),o.replace({...o.location,search:e.toString()})}),[r,o])]}function f(t){const{defaultValue:e,queryString:n=!1,groupId:o}=t,r=m(t),[s,c]=(0,p.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=h({queryString:n,groupId:o}),[u,f]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[o,r]=(0,l.Nk)(n);return[o,(0,p.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:o}),k=(()=>{const t=i??u;return d({value:t,tabValues:r})?t:null})();(0,p.useLayoutEffect)((()=>{k&&c(k)}),[k]);return{selectedValue:s,selectValue:(0,p.useCallback)((t=>{if(!d({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),f(t)}),[a,f,r]),tabValues:r}}var k=n(9741);const y={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function D(t){let{className:e,block:n,selectedValue:c,selectValue:i,tabValues:a}=t;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.o5)(),m=t=>{const e=t.currentTarget,n=l.indexOf(e),o=a[n].value;o!==c&&(u(e),i(o))},d=t=>{let e=null;switch(t.key){case"Enter":m(t);break;case"ArrowRight":{const n=l.indexOf(t.currentTarget)+1;e=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(t.currentTarget)-1;e=l[n]??l[l.length-1];break}}e?.focus()};return p.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},e)},a.map((t=>{let{value:e,label:n,attributes:s}=t;return p.createElement("li",(0,o.Z)({role:"tab",tabIndex:c===e?0:-1,"aria-selected":c===e,key:e,ref:t=>l.push(t),onKeyDown:d,onClick:m},s,{className:(0,r.Z)("tabs__item",y.tabItem,s?.className,{"tabs__item--active":c===e})}),n??e)})))}function M(t){let{lazy:e,children:n,selectedValue:o}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===o));return t?(0,p.cloneElement)(t,{className:"margin-top--md"}):null}return p.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,p.cloneElement)(t,{key:e,hidden:t.props.value!==o}))))}function X(t){const e=f(t);return p.createElement("div",{className:(0,r.Z)("tabs-container",y.tabList)},p.createElement(D,(0,o.Z)({},t,e)),p.createElement(M,(0,o.Z)({},t,e)))}function _(t){const e=(0,k.Z)();return p.createElement(X,(0,o.Z)({key:String(e)},t))}},9573:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(2784);function p(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"}))}},8046:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),p=n(2784);function r(t){let{width:e=24,height:n=24,...r}=t;return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}},700:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(2784);function p(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M3 15h8v-2H3v2zm0 4h8v-2H3v2zm0-8h8V9H3v2zm0-6v2h8V5H3zm10 0h8v14h-8V5z"}))}},8015:(t,e,n)=>{"use strict";n.d(e,{Z:()=>p});var o=n(2784);function p(){return o.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},o.createElement("path",{d:"M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"}))}},4415:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>f});var o=n(6183),p=n(9741),r=n(2830),s=n(532),c=n(8617),i=n(68),a=n(7708),l=n(9072),u=n(2104),m=n(2784),d=n(7390);const h='\n<svg \n  xmlns="http://www.w3.org/2000/svg" \n  viewBox="0 0 24 24" \n  fill="currentColor" \n  class="experimental" \n  data-experimental="data-experimental">\n  <path d="M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"/>\n</svg>';function f(t){let{route:e}=t;const n=(0,c.RU)(e.projectId),f=n[e.reflectionId],[k]=(0,a.mN)(),y=(0,p.Z)(),D=(0,m.useMemo)((()=>{const t=[];if(!f.groups||f.kind===d.W.Project)return t;for(const e of f.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const o of e.children){const e=n[o];!e||e.hasOwnPage||y&&!(0,a.It)(k,e)||t.push({value:`${e.experimental?h:""}<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[k,f,y]);return m.createElement(o.b,{content:{frontMatter:{},metadata:{id:f.docId,unversionedId:f.docId,version:"current",title:f.name,description:f.comment?.summaryText,slug:f.url,permalink:f.url,editUrl:f.sources?.[0]?.url??void 0,draft:!1,tags:[],frontMatter:{},next:f.next,previous:f.previous},toc:D,assets:{}}},m.createElement(i.Y0,null,m.createElement(u.Z,null),m.createElement(s.Z,null,m.createElement(l.Z,null,m.createElement(r.Z,{reflection:f})))))}},4237:(t,e,n)=>{"use strict";n.d(e,{Z:()=>iOp});var o={};n.r(o),n.d(o,{content_0_0:()=>a,content_0_10:()=>g,content_0_100:()=>$e,content_0_1000:()=>tv,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>av,content_0_1008:()=>mv,content_0_1010:()=>fv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>gv,content_0_1018:()=>vv,content_0_102:()=>tn,content_0_1020:()=>bv,content_0_1022:()=>zv,content_0_1024:()=>Rv,content_0_1026:()=>Ev,content_0_1028:()=>Fv,content_0_1030:()=>Vv,content_0_1032:()=>Yv,content_0_1034:()=>$v,content_0_1036:()=>tL,content_0_1038:()=>oL,content_0_104:()=>on,content_0_1040:()=>sL,content_0_1042:()=>aL,content_0_1044:()=>mL,content_0_1046:()=>fL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>gL,content_0_1054:()=>vL,content_0_1056:()=>bL,content_0_1058:()=>zL,content_0_106:()=>sn,content_0_1060:()=>RL,content_0_1062:()=>EL,content_0_1064:()=>FL,content_0_1066:()=>VL,content_0_1068:()=>YL,content_0_1070:()=>$L,content_0_1072:()=>tZ,content_0_1074:()=>oZ,content_0_1076:()=>sZ,content_0_1078:()=>aZ,content_0_108:()=>ln,content_0_1080:()=>mZ,content_0_1082:()=>fZ,content_0_1084:()=>DZ,content_0_1086:()=>_Z,content_0_1088:()=>gZ,content_0_1090:()=>vZ,content_0_1092:()=>bZ,content_0_1094:()=>zZ,content_0_1096:()=>RZ,content_0_1098:()=>EZ,content_0_110:()=>dn,content_0_1100:()=>FZ,content_0_1102:()=>VZ,content_0_1104:()=>YZ,content_0_1106:()=>$Z,content_0_1108:()=>tb,content_0_1110:()=>ob,content_0_1112:()=>sb,content_0_1114:()=>ab,content_0_1116:()=>mb,content_0_1118:()=>fb,content_0_112:()=>kn,content_0_1120:()=>Db,content_0_1122:()=>_b,content_0_1124:()=>gb,content_0_1126:()=>vb,content_0_1128:()=>bb,content_0_1130:()=>zb,content_0_1132:()=>Rb,content_0_1134:()=>Eb,content_0_1136:()=>Fb,content_0_1138:()=>Vb,content_0_114:()=>Mn,content_0_1140:()=>Yb,content_0_1142:()=>$b,content_0_1144:()=>tN,content_0_1146:()=>oN,content_0_1148:()=>sN,content_0_1150:()=>aN,content_0_1152:()=>mN,content_0_1154:()=>fN,content_0_1156:()=>DN,content_0_1158:()=>_N,content_0_116:()=>wn,content_0_1160:()=>gN,content_0_1162:()=>vN,content_0_1164:()=>bN,content_0_1166:()=>zN,content_0_1168:()=>RN,content_0_1170:()=>EN,content_0_1172:()=>FN,content_0_1174:()=>VN,content_0_1176:()=>YN,content_0_1178:()=>$N,content_0_118:()=>Cn,content_0_1180:()=>tA,content_0_1182:()=>oA,content_0_1184:()=>sA,content_0_1186:()=>aA,content_0_1188:()=>mA,content_0_1190:()=>fA,content_0_1192:()=>DA,content_0_1194:()=>_A,content_0_1196:()=>gA,content_0_1198:()=>vA,content_0_12:()=>v,content_0_120:()=>Ln,content_0_1200:()=>bA,content_0_1202:()=>zA,content_0_1204:()=>RA,content_0_1206:()=>EA,content_0_1208:()=>FA,content_0_1210:()=>VA,content_0_1212:()=>YA,content_0_1214:()=>$A,content_0_1216:()=>tz,content_0_1218:()=>oz,content_0_122:()=>Nn,content_0_1220:()=>sz,content_0_1222:()=>az,content_0_1224:()=>mz,content_0_1226:()=>fz,content_0_1228:()=>Dz,content_0_1230:()=>_z,content_0_1232:()=>gz,content_0_1234:()=>vz,content_0_1236:()=>bz,content_0_1238:()=>zz,content_0_124:()=>Wn,content_0_1240:()=>Rz,content_0_1242:()=>Ez,content_0_1244:()=>Fz,content_0_1246:()=>Vz,content_0_1248:()=>Yz,content_0_1250:()=>$z,content_0_1252:()=>tW,content_0_1254:()=>oW,content_0_1256:()=>sW,content_0_1258:()=>aW,content_0_126:()=>Sn,content_0_1260:()=>mW,content_0_1262:()=>fW,content_0_1264:()=>DW,content_0_1266:()=>_W,content_0_1268:()=>gW,content_0_1270:()=>vW,content_0_1272:()=>bW,content_0_1274:()=>zW,content_0_1276:()=>RW,content_0_1278:()=>EW,content_0_128:()=>On,content_0_1280:()=>FW,content_0_1282:()=>VW,content_0_1284:()=>YW,content_0_1286:()=>$W,content_0_1288:()=>tI,content_0_1290:()=>oI,content_0_1292:()=>sI,content_0_1294:()=>aI,content_0_1296:()=>mI,content_0_1298:()=>fI,content_0_130:()=>Bn,content_0_1300:()=>DI,content_0_1302:()=>_I,content_0_1304:()=>gI,content_0_1306:()=>vI,content_0_1308:()=>bI,content_0_1310:()=>zI,content_0_1312:()=>RI,content_0_1314:()=>EI,content_0_1316:()=>FI,content_0_1318:()=>VI,content_0_132:()=>qn,content_0_1320:()=>YI,content_0_1322:()=>$I,content_0_1324:()=>tR,content_0_1326:()=>oR,content_0_1328:()=>sR,content_0_1330:()=>aR,content_0_1332:()=>mR,content_0_1334:()=>fR,content_0_1336:()=>DR,content_0_1338:()=>_R,content_0_134:()=>Hn,content_0_1340:()=>gR,content_0_1342:()=>vR,content_0_1344:()=>bR,content_0_1346:()=>zR,content_0_1348:()=>RR,content_0_1350:()=>ER,content_0_1352:()=>FR,content_0_1354:()=>VR,content_0_1356:()=>YR,content_0_1358:()=>$R,content_0_136:()=>Jn,content_0_1360:()=>tS,content_0_1362:()=>oS,content_0_1364:()=>sS,content_0_1366:()=>aS,content_0_1368:()=>mS,content_0_1370:()=>fS,content_0_1372:()=>DS,content_0_1374:()=>_S,content_0_1376:()=>gS,content_0_1378:()=>vS,content_0_138:()=>eo,content_0_1380:()=>bS,content_0_1382:()=>zS,content_0_1384:()=>RS,content_0_1386:()=>ES,content_0_1388:()=>FS,content_0_1390:()=>VS,content_0_1392:()=>YS,content_0_1394:()=>$S,content_0_1396:()=>tP,content_0_1398:()=>oP,content_0_14:()=>b,content_0_140:()=>po,content_0_1400:()=>sP,content_0_1402:()=>aP,content_0_1404:()=>mP,content_0_1406:()=>fP,content_0_1408:()=>DP,content_0_1410:()=>_P,content_0_1412:()=>gP,content_0_1414:()=>vP,content_0_1416:()=>bP,content_0_1418:()=>zP,content_0_142:()=>co,content_0_1420:()=>RP,content_0_1422:()=>EP,content_0_1424:()=>FP,content_0_1426:()=>VP,content_0_1428:()=>YP,content_0_1430:()=>$P,content_0_1432:()=>tE,content_0_1434:()=>oE,content_0_1436:()=>sE,content_0_1438:()=>aE,content_0_144:()=>lo,content_0_1440:()=>mE,content_0_1442:()=>fE,content_0_1444:()=>DE,content_0_1446:()=>_E,content_0_1448:()=>gE,content_0_1450:()=>vE,content_0_1452:()=>bE,content_0_1454:()=>zE,content_0_1456:()=>RE,content_0_1458:()=>EE,content_0_146:()=>ho,content_0_1460:()=>FE,content_0_1462:()=>VE,content_0_1464:()=>YE,content_0_1466:()=>$E,content_0_1468:()=>tO,content_0_1470:()=>oO,content_0_1472:()=>sO,content_0_1474:()=>aO,content_0_1476:()=>mO,content_0_1478:()=>fO,content_0_148:()=>yo,content_0_1480:()=>DO,content_0_1482:()=>_O,content_0_1484:()=>gO,content_0_1486:()=>vO,content_0_1488:()=>bO,content_0_1490:()=>zO,content_0_1492:()=>RO,content_0_1494:()=>EO,content_0_1496:()=>FO,content_0_1498:()=>VO,content_0_150:()=>Xo,content_0_1500:()=>YO,content_0_1502:()=>$O,content_0_1504:()=>tG,content_0_1506:()=>oG,content_0_1508:()=>sG,content_0_1510:()=>aG,content_0_1512:()=>mG,content_0_1514:()=>fG,content_0_1516:()=>DG,content_0_1518:()=>_G,content_0_152:()=>To,content_0_1520:()=>gG,content_0_1522:()=>vG,content_0_1524:()=>bG,content_0_1526:()=>zG,content_0_1528:()=>RG,content_0_1530:()=>EG,content_0_1532:()=>FG,content_0_1534:()=>VG,content_0_1536:()=>YG,content_0_1538:()=>$G,content_0_154:()=>xo,content_0_1540:()=>tF,content_0_1542:()=>oF,content_0_1544:()=>sF,content_0_1546:()=>aF,content_0_1548:()=>mF,content_0_1550:()=>fF,content_0_1552:()=>DF,content_0_1554:()=>_F,content_0_1556:()=>gF,content_0_1558:()=>vF,content_0_156:()=>Zo,content_0_1560:()=>bF,content_0_1562:()=>zF,content_0_1564:()=>RF,content_0_1566:()=>EF,content_0_1568:()=>FF,content_0_1570:()=>VF,content_0_1572:()=>YF,content_0_1574:()=>$F,content_0_1576:()=>tB,content_0_1578:()=>oB,content_0_158:()=>Ao,content_0_1580:()=>sB,content_0_1582:()=>aB,content_0_1584:()=>mB,content_0_1586:()=>fB,content_0_1588:()=>DB,content_0_1590:()=>_B,content_0_1592:()=>gB,content_0_1594:()=>vB,content_0_1596:()=>bB,content_0_1598:()=>zB,content_0_16:()=>z,content_0_160:()=>Io,content_0_1600:()=>RB,content_0_1602:()=>EB,content_0_1604:()=>FB,content_0_1606:()=>VB,content_0_1608:()=>YB,content_0_1610:()=>$B,content_0_1612:()=>tU,content_0_1614:()=>oU,content_0_1616:()=>sU,content_0_1618:()=>aU,content_0_162:()=>Po,content_0_1620:()=>mU,content_0_1622:()=>fU,content_0_1624:()=>DU,content_0_1626:()=>_U,content_0_1628:()=>gU,content_0_1630:()=>vU,content_0_1632:()=>bU,content_0_1634:()=>zU,content_0_1636:()=>RU,content_0_1638:()=>EU,content_0_164:()=>Go,content_0_1640:()=>FU,content_0_1642:()=>VU,content_0_1644:()=>YU,content_0_1646:()=>$U,content_0_1648:()=>tV,content_0_1650:()=>oV,content_0_1652:()=>sV,content_0_1654:()=>aV,content_0_1656:()=>mV,content_0_1658:()=>fV,content_0_166:()=>Uo,content_0_1660:()=>DV,content_0_1662:()=>_V,content_0_1664:()=>gV,content_0_1666:()=>vV,content_0_1668:()=>bV,content_0_1670:()=>zV,content_0_1672:()=>RV,content_0_1674:()=>EV,content_0_1676:()=>FV,content_0_1678:()=>VV,content_0_168:()=>jo,content_0_1680:()=>YV,content_0_1682:()=>$V,content_0_1684:()=>tq,content_0_1686:()=>oq,content_0_1688:()=>sq,content_0_1690:()=>aq,content_0_1692:()=>mq,content_0_1694:()=>fq,content_0_1696:()=>Dq,content_0_1698:()=>_q,content_0_170:()=>Qo,content_0_1700:()=>gq,content_0_1702:()=>vq,content_0_1704:()=>bq,content_0_1706:()=>zq,content_0_1708:()=>Rq,content_0_1710:()=>Eq,content_0_1712:()=>Fq,content_0_1714:()=>Vq,content_0_1716:()=>Yq,content_0_1718:()=>$q,content_0_172:()=>Ko,content_0_1720:()=>tj,content_0_1722:()=>oj,content_0_1724:()=>sj,content_0_1726:()=>aj,content_0_1728:()=>mj,content_0_1730:()=>fj,content_0_1732:()=>Dj,content_0_1734:()=>_j,content_0_1736:()=>gj,content_0_1738:()=>vj,content_0_174:()=>np,content_0_1740:()=>bj,content_0_1742:()=>zj,content_0_1744:()=>Rj,content_0_1746:()=>Ej,content_0_1748:()=>Fj,content_0_1750:()=>Vj,content_0_1752:()=>Yj,content_0_1754:()=>$j,content_0_1756:()=>tY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>aY,content_0_1764:()=>mY,content_0_1766:()=>fY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>gY,content_0_1774:()=>vY,content_0_1776:()=>bY,content_0_1778:()=>zY,content_0_178:()=>ip,content_0_1780:()=>RY,content_0_1782:()=>EY,content_0_1784:()=>FY,content_0_1786:()=>VY,content_0_1788:()=>YY,content_0_1790:()=>$Y,content_0_1792:()=>tH,content_0_1794:()=>oH,content_0_1796:()=>sH,content_0_1798:()=>aH,content_0_18:()=>R,content_0_180:()=>up,content_0_1800:()=>mH,content_0_1802:()=>fH,content_0_1804:()=>DH,content_0_1806:()=>_H,content_0_1808:()=>gH,content_0_1810:()=>vH,content_0_1812:()=>bH,content_0_1814:()=>zH,content_0_1816:()=>RH,content_0_1818:()=>EH,content_0_182:()=>hp,content_0_1820:()=>FH,content_0_1822:()=>VH,content_0_1824:()=>YH,content_0_1826:()=>$H,content_0_1828:()=>tQ,content_0_1830:()=>oQ,content_0_1832:()=>sQ,content_0_1834:()=>aQ,content_0_184:()=>yp,content_0_186:()=>Xp,content_0_188:()=>Tp,content_0_190:()=>xp,content_0_192:()=>Zp,content_0_194:()=>Ap,content_0_196:()=>Ip,content_0_198:()=>Pp,content_0_2:()=>m,content_0_20:()=>E,content_0_200:()=>Gp,content_0_202:()=>Up,content_0_204:()=>jp,content_0_206:()=>Qp,content_0_208:()=>Kp,content_0_210:()=>nr,content_0_212:()=>rr,content_0_214:()=>ir,content_0_216:()=>ur,content_0_218:()=>hr,content_0_22:()=>F,content_0_220:()=>yr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>xr,content_0_228:()=>Zr,content_0_230:()=>Ar,content_0_232:()=>Ir,content_0_234:()=>Pr,content_0_236:()=>Gr,content_0_238:()=>Ur,content_0_24:()=>V,content_0_240:()=>jr,content_0_242:()=>Qr,content_0_244:()=>Kr,content_0_246:()=>ns,content_0_248:()=>rs,content_0_250:()=>is,content_0_252:()=>us,content_0_254:()=>hs,content_0_256:()=>ys,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>xs,content_0_264:()=>Zs,content_0_266:()=>As,content_0_268:()=>Is,content_0_270:()=>Ps,content_0_272:()=>Gs,content_0_274:()=>Us,content_0_276:()=>js,content_0_278:()=>Qs,content_0_28:()=>$,content_0_280:()=>Ks,content_0_282:()=>nc,content_0_284:()=>rc,content_0_286:()=>ic,content_0_288:()=>uc,content_0_290:()=>hc,content_0_292:()=>yc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>xc,content_0_30:()=>tt,content_0_300:()=>Zc,content_0_302:()=>Ac,content_0_304:()=>Ic,content_0_306:()=>Pc,content_0_308:()=>Gc,content_0_310:()=>Uc,content_0_312:()=>jc,content_0_314:()=>Qc,content_0_316:()=>Kc,content_0_318:()=>ni,content_0_32:()=>ot,content_0_320:()=>ri,content_0_322:()=>ii,content_0_324:()=>ui,content_0_326:()=>hi,content_0_328:()=>yi,content_0_330:()=>Xi,content_0_332:()=>Ti,content_0_334:()=>xi,content_0_336:()=>Zi,content_0_338:()=>Ai,content_0_34:()=>st,content_0_340:()=>Ii,content_0_342:()=>Pi,content_0_344:()=>Gi,content_0_346:()=>Ui,content_0_348:()=>ji,content_0_350:()=>Qi,content_0_352:()=>Ki,content_0_354:()=>na,content_0_356:()=>ra,content_0_358:()=>ia,content_0_36:()=>at,content_0_360:()=>ua,content_0_362:()=>ha,content_0_364:()=>ya,content_0_366:()=>Xa,content_0_368:()=>Ta,content_0_370:()=>xa,content_0_372:()=>Za,content_0_374:()=>Aa,content_0_376:()=>Ia,content_0_378:()=>Pa,content_0_38:()=>mt,content_0_380:()=>Ga,content_0_382:()=>Ua,content_0_384:()=>ja,content_0_386:()=>Qa,content_0_388:()=>Ka,content_0_390:()=>nl,content_0_392:()=>rl,content_0_394:()=>il,content_0_396:()=>ul,content_0_398:()=>hl,content_0_4:()=>f,content_0_40:()=>ft,content_0_400:()=>yl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>xl,content_0_408:()=>Zl,content_0_410:()=>Al,content_0_412:()=>Il,content_0_414:()=>Pl,content_0_416:()=>Gl,content_0_418:()=>Ul,content_0_42:()=>Dt,content_0_420:()=>jl,content_0_422:()=>Ql,content_0_424:()=>Kl,content_0_426:()=>nu,content_0_428:()=>ru,content_0_430:()=>iu,content_0_432:()=>uu,content_0_434:()=>hu,content_0_436:()=>yu,content_0_438:()=>Xu,content_0_44:()=>_t,content_0_440:()=>Tu,content_0_442:()=>xu,content_0_444:()=>Zu,content_0_446:()=>Au,content_0_448:()=>Iu,content_0_450:()=>Pu,content_0_452:()=>Gu,content_0_454:()=>Uu,content_0_456:()=>ju,content_0_458:()=>Qu,content_0_46:()=>gt,content_0_460:()=>Ku,content_0_462:()=>nm,content_0_464:()=>rm,content_0_466:()=>im,content_0_468:()=>um,content_0_470:()=>hm,content_0_472:()=>ym,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>xm,content_0_48:()=>vt,content_0_480:()=>Zm,content_0_482:()=>Am,content_0_484:()=>Im,content_0_486:()=>Pm,content_0_488:()=>Gm,content_0_490:()=>Um,content_0_492:()=>jm,content_0_494:()=>Qm,content_0_496:()=>Km,content_0_498:()=>nd,content_0_50:()=>bt,content_0_500:()=>rd,content_0_502:()=>id,content_0_504:()=>ud,content_0_506:()=>hd,content_0_508:()=>yd,content_0_510:()=>Xd,content_0_512:()=>Td,content_0_514:()=>xd,content_0_516:()=>Zd,content_0_518:()=>Ad,content_0_52:()=>zt,content_0_520:()=>Id,content_0_522:()=>Pd,content_0_524:()=>Gd,content_0_526:()=>Ud,content_0_528:()=>jd,content_0_530:()=>Qd,content_0_532:()=>Kd,content_0_534:()=>nh,content_0_536:()=>rh,content_0_538:()=>ih,content_0_54:()=>Rt,content_0_540:()=>uh,content_0_542:()=>hh,content_0_544:()=>yh,content_0_546:()=>Xh,content_0_548:()=>Th,content_0_550:()=>xh,content_0_552:()=>Zh,content_0_554:()=>Ah,content_0_556:()=>Ih,content_0_558:()=>Ph,content_0_56:()=>Et,content_0_560:()=>Gh,content_0_562:()=>Uh,content_0_564:()=>jh,content_0_566:()=>Qh,content_0_568:()=>Kh,content_0_570:()=>nf,content_0_572:()=>rf,content_0_574:()=>af,content_0_576:()=>mf,content_0_578:()=>ff,content_0_58:()=>Ft,content_0_580:()=>Df,content_0_582:()=>_f,content_0_584:()=>gf,content_0_586:()=>vf,content_0_588:()=>bf,content_0_590:()=>zf,content_0_592:()=>Rf,content_0_594:()=>Ef,content_0_596:()=>Ff,content_0_598:()=>Vf,content_0_6:()=>D,content_0_60:()=>Vt,content_0_600:()=>Yf,content_0_602:()=>$f,content_0_604:()=>tk,content_0_606:()=>ok,content_0_608:()=>sk,content_0_610:()=>ak,content_0_612:()=>mk,content_0_614:()=>fk,content_0_616:()=>Dk,content_0_618:()=>_k,content_0_62:()=>Yt,content_0_620:()=>gk,content_0_622:()=>vk,content_0_624:()=>bk,content_0_626:()=>zk,content_0_628:()=>Rk,content_0_630:()=>Ek,content_0_632:()=>Fk,content_0_634:()=>Vk,content_0_636:()=>Yk,content_0_638:()=>$k,content_0_64:()=>$t,content_0_640:()=>ty,content_0_642:()=>oy,content_0_644:()=>sy,content_0_646:()=>ay,content_0_648:()=>my,content_0_650:()=>fy,content_0_652:()=>Dy,content_0_654:()=>_y,content_0_656:()=>gy,content_0_658:()=>vy,content_0_66:()=>te,content_0_660:()=>by,content_0_662:()=>zy,content_0_664:()=>Ry,content_0_666:()=>Ey,content_0_668:()=>Fy,content_0_670:()=>Vy,content_0_672:()=>Yy,content_0_674:()=>$y,content_0_676:()=>tD,content_0_678:()=>oD,content_0_68:()=>oe,content_0_680:()=>sD,content_0_682:()=>aD,content_0_684:()=>mD,content_0_686:()=>fD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>gD,content_0_694:()=>vD,content_0_696:()=>bD,content_0_698:()=>zD,content_0_70:()=>se,content_0_700:()=>RD,content_0_702:()=>ED,content_0_704:()=>FD,content_0_706:()=>VD,content_0_708:()=>YD,content_0_710:()=>$D,content_0_712:()=>tM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>aM,content_0_72:()=>ae,content_0_720:()=>mM,content_0_722:()=>fM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>gM,content_0_730:()=>vM,content_0_732:()=>bM,content_0_734:()=>zM,content_0_736:()=>RM,content_0_738:()=>EM,content_0_74:()=>me,content_0_740:()=>FM,content_0_742:()=>VM,content_0_744:()=>YM,content_0_746:()=>$M,content_0_748:()=>tX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>aX,content_0_756:()=>mX,content_0_758:()=>fX,content_0_76:()=>fe,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>gX,content_0_766:()=>vX,content_0_768:()=>bX,content_0_770:()=>zX,content_0_772:()=>RX,content_0_774:()=>EX,content_0_776:()=>FX,content_0_778:()=>VX,content_0_78:()=>De,content_0_780:()=>YX,content_0_782:()=>$X,content_0_784:()=>t_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>a_,content_0_792:()=>m_,content_0_794:()=>f_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>_e,content_0_800:()=>g_,content_0_802:()=>v_,content_0_804:()=>b_,content_0_806:()=>z_,content_0_808:()=>R_,content_0_810:()=>E_,content_0_812:()=>F_,content_0_814:()=>V_,content_0_816:()=>Y_,content_0_818:()=>$_,content_0_82:()=>ge,content_0_820:()=>tw,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>aw,content_0_828:()=>mw,content_0_830:()=>fw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>gw,content_0_838:()=>vw,content_0_84:()=>ve,content_0_840:()=>bw,content_0_842:()=>zw,content_0_844:()=>Rw,content_0_846:()=>Ew,content_0_848:()=>Fw,content_0_850:()=>Vw,content_0_852:()=>Yw,content_0_854:()=>$w,content_0_856:()=>tT,content_0_858:()=>oT,content_0_86:()=>be,content_0_860:()=>sT,content_0_862:()=>aT,content_0_864:()=>mT,content_0_866:()=>fT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>gT,content_0_874:()=>vT,content_0_876:()=>bT,content_0_878:()=>zT,content_0_88:()=>ze,content_0_880:()=>RT,content_0_882:()=>ET,content_0_884:()=>FT,content_0_886:()=>VT,content_0_888:()=>YT,content_0_890:()=>$T,content_0_892:()=>tg,content_0_894:()=>og,content_0_896:()=>sg,content_0_898:()=>ag,content_0_90:()=>Re,content_0_900:()=>mg,content_0_902:()=>fg,content_0_904:()=>Dg,content_0_906:()=>_g,content_0_908:()=>gg,content_0_910:()=>vg,content_0_912:()=>bg,content_0_914:()=>zg,content_0_916:()=>Rg,content_0_918:()=>Eg,content_0_92:()=>Ee,content_0_920:()=>Fg,content_0_922:()=>Vg,content_0_924:()=>Yg,content_0_926:()=>$g,content_0_928:()=>tC,content_0_930:()=>oC,content_0_932:()=>sC,content_0_934:()=>aC,content_0_936:()=>mC,content_0_938:()=>fC,content_0_94:()=>Fe,content_0_940:()=>DC,content_0_942:()=>_C,content_0_944:()=>gC,content_0_946:()=>vC,content_0_948:()=>bC,content_0_950:()=>zC,content_0_952:()=>RC,content_0_954:()=>EC,content_0_956:()=>FC,content_0_958:()=>VC,content_0_96:()=>Ve,content_0_960:()=>YC,content_0_962:()=>$C,content_0_964:()=>tx,content_0_966:()=>ox,content_0_968:()=>sx,content_0_970:()=>ax,content_0_972:()=>mx,content_0_974:()=>fx,content_0_976:()=>Dx,content_0_978:()=>_x,content_0_98:()=>Ye,content_0_980:()=>gx,content_0_982:()=>vx,content_0_984:()=>bx,content_0_986:()=>zx,content_0_988:()=>Rx,content_0_990:()=>Ex,content_0_992:()=>Fx,content_0_994:()=>Vx,content_0_996:()=>Yx,content_0_998:()=>$x,content_3652_0:()=>mQ,content_3652_10:()=>vQ,content_3652_100:()=>tK,content_3652_1000:()=>eht,content_3652_10000:()=>eip,content_3652_10002:()=>pip,content_3652_10004:()=>cip,content_3652_10006:()=>lip,content_3652_10008:()=>dip,content_3652_10010:()=>kip,content_3652_10012:()=>Mip,content_3652_10014:()=>wip,content_3652_10016:()=>Cip,content_3652_10018:()=>Lip,content_3652_1002:()=>pht,content_3652_10020:()=>Nip,content_3652_10022:()=>Wip,content_3652_10024:()=>Sip,content_3652_10026:()=>Oip,content_3652_10028:()=>Bip,content_3652_10030:()=>qip,content_3652_10032:()=>Hip,content_3652_10034:()=>Jip,content_3652_10036:()=>eap,content_3652_10038:()=>pap,content_3652_1004:()=>cht,content_3652_10040:()=>cap,content_3652_10042:()=>lap,content_3652_10044:()=>dap,content_3652_10046:()=>kap,content_3652_10048:()=>Map,content_3652_10050:()=>wap,content_3652_10052:()=>Cap,content_3652_10054:()=>Lap,content_3652_10056:()=>Nap,content_3652_10058:()=>Wap,content_3652_1006:()=>lht,content_3652_10060:()=>Sap,content_3652_10062:()=>Oap,content_3652_10064:()=>Bap,content_3652_10066:()=>qap,content_3652_10068:()=>Hap,content_3652_10070:()=>Jap,content_3652_10072:()=>elp,content_3652_10074:()=>plp,content_3652_10076:()=>clp,content_3652_10078:()=>llp,content_3652_1008:()=>dht,content_3652_10080:()=>dlp,content_3652_10082:()=>klp,content_3652_10084:()=>Mlp,content_3652_10086:()=>wlp,content_3652_10088:()=>Clp,content_3652_10090:()=>Llp,content_3652_10092:()=>Nlp,content_3652_10094:()=>Wlp,content_3652_10096:()=>Slp,content_3652_10098:()=>Olp,content_3652_1010:()=>kht,content_3652_10100:()=>Blp,content_3652_10102:()=>qlp,content_3652_10104:()=>Hlp,content_3652_10106:()=>Jlp,content_3652_10108:()=>eup,content_3652_10110:()=>pup,content_3652_10112:()=>cup,content_3652_10114:()=>lup,content_3652_10116:()=>dup,content_3652_10118:()=>kup,content_3652_1012:()=>Mht,content_3652_10120:()=>Mup,content_3652_10122:()=>wup,content_3652_10124:()=>Cup,content_3652_10126:()=>Lup,content_3652_10128:()=>Nup,content_3652_10130:()=>Wup,content_3652_10132:()=>Sup,content_3652_10134:()=>Oup,content_3652_10136:()=>Bup,content_3652_10138:()=>qup,content_3652_1014:()=>wht,content_3652_10140:()=>Hup,content_3652_10142:()=>Jup,content_3652_10144:()=>emp,content_3652_10146:()=>pmp,content_3652_10148:()=>cmp,content_3652_10150:()=>lmp,content_3652_10152:()=>dmp,content_3652_10154:()=>kmp,content_3652_10156:()=>Mmp,content_3652_10158:()=>wmp,content_3652_1016:()=>Cht,content_3652_10160:()=>Cmp,content_3652_10162:()=>Lmp,content_3652_10164:()=>Nmp,content_3652_10166:()=>Wmp,content_3652_10168:()=>Smp,content_3652_10170:()=>Omp,content_3652_10172:()=>Bmp,content_3652_10174:()=>qmp,content_3652_10176:()=>Hmp,content_3652_10178:()=>Jmp,content_3652_1018:()=>Lht,content_3652_10180:()=>edp,content_3652_10182:()=>pdp,content_3652_10184:()=>cdp,content_3652_10186:()=>ldp,content_3652_10188:()=>ddp,content_3652_10190:()=>kdp,content_3652_10192:()=>Mdp,content_3652_10194:()=>wdp,content_3652_10196:()=>Cdp,content_3652_10198:()=>Ldp,content_3652_102:()=>oK,content_3652_1020:()=>Nht,content_3652_10200:()=>Ndp,content_3652_10202:()=>Wdp,content_3652_10204:()=>Sdp,content_3652_10206:()=>Odp,content_3652_10208:()=>Bdp,content_3652_10210:()=>qdp,content_3652_10212:()=>Hdp,content_3652_10214:()=>Jdp,content_3652_10216:()=>ehp,content_3652_10218:()=>php,content_3652_1022:()=>Wht,content_3652_10220:()=>chp,content_3652_10222:()=>lhp,content_3652_10224:()=>dhp,content_3652_10226:()=>khp,content_3652_10228:()=>Mhp,content_3652_10230:()=>whp,content_3652_10232:()=>Chp,content_3652_10234:()=>Lhp,content_3652_10236:()=>Nhp,content_3652_10238:()=>Whp,content_3652_1024:()=>Sht,content_3652_10240:()=>Shp,content_3652_10242:()=>Ohp,content_3652_10244:()=>Bhp,content_3652_10246:()=>qhp,content_3652_10248:()=>Hhp,content_3652_10250:()=>Jhp,content_3652_10252:()=>efp,content_3652_10254:()=>pfp,content_3652_10256:()=>cfp,content_3652_10258:()=>lfp,content_3652_1026:()=>Oht,content_3652_10260:()=>dfp,content_3652_10262:()=>kfp,content_3652_10264:()=>Mfp,content_3652_10266:()=>wfp,content_3652_10268:()=>Cfp,content_3652_10270:()=>Lfp,content_3652_10272:()=>Nfp,content_3652_10274:()=>Wfp,content_3652_10276:()=>Sfp,content_3652_10278:()=>Ofp,content_3652_1028:()=>Bht,content_3652_10280:()=>Bfp,content_3652_10282:()=>qfp,content_3652_10284:()=>Hfp,content_3652_10286:()=>Jfp,content_3652_10288:()=>ekp,content_3652_10290:()=>pkp,content_3652_10292:()=>ckp,content_3652_10294:()=>lkp,content_3652_10296:()=>dkp,content_3652_10298:()=>kkp,content_3652_1030:()=>qht,content_3652_10300:()=>Mkp,content_3652_10302:()=>wkp,content_3652_10304:()=>Ckp,content_3652_10306:()=>Lkp,content_3652_10308:()=>Nkp,content_3652_10310:()=>Wkp,content_3652_10312:()=>Skp,content_3652_10314:()=>Okp,content_3652_10316:()=>Bkp,content_3652_10318:()=>qkp,content_3652_1032:()=>Hht,content_3652_10320:()=>Hkp,content_3652_10322:()=>Jkp,content_3652_10324:()=>eyp,content_3652_10326:()=>pyp,content_3652_10328:()=>cyp,content_3652_10330:()=>lyp,content_3652_10332:()=>dyp,content_3652_10334:()=>kyp,content_3652_10336:()=>Myp,content_3652_10338:()=>wyp,content_3652_1034:()=>Jht,content_3652_10340:()=>Cyp,content_3652_10342:()=>Lyp,content_3652_10344:()=>Nyp,content_3652_10346:()=>Wyp,content_3652_10348:()=>Syp,content_3652_10350:()=>Oyp,content_3652_10352:()=>Byp,content_3652_10354:()=>qyp,content_3652_10356:()=>Hyp,content_3652_10358:()=>Jyp,content_3652_1036:()=>eft,content_3652_10360:()=>eDp,content_3652_10362:()=>pDp,content_3652_10364:()=>cDp,content_3652_10366:()=>lDp,content_3652_10368:()=>dDp,content_3652_10370:()=>kDp,content_3652_10372:()=>MDp,content_3652_10374:()=>wDp,content_3652_10376:()=>CDp,content_3652_10378:()=>LDp,content_3652_1038:()=>pft,content_3652_10380:()=>NDp,content_3652_10382:()=>WDp,content_3652_10384:()=>SDp,content_3652_10386:()=>ODp,content_3652_10388:()=>BDp,content_3652_10390:()=>qDp,content_3652_10392:()=>HDp,content_3652_10394:()=>JDp,content_3652_10396:()=>eMp,content_3652_10398:()=>pMp,content_3652_104:()=>sK,content_3652_1040:()=>cft,content_3652_10400:()=>cMp,content_3652_10402:()=>lMp,content_3652_10404:()=>dMp,content_3652_10406:()=>kMp,content_3652_10408:()=>MMp,content_3652_10410:()=>wMp,content_3652_10412:()=>CMp,content_3652_10414:()=>LMp,content_3652_10416:()=>NMp,content_3652_10418:()=>WMp,content_3652_1042:()=>lft,content_3652_10420:()=>SMp,content_3652_10422:()=>OMp,content_3652_10424:()=>BMp,content_3652_10426:()=>qMp,content_3652_10428:()=>HMp,content_3652_10430:()=>JMp,content_3652_10432:()=>eXp,content_3652_10434:()=>pXp,content_3652_10436:()=>cXp,content_3652_10438:()=>lXp,content_3652_1044:()=>dft,content_3652_10440:()=>dXp,content_3652_10442:()=>kXp,content_3652_10444:()=>MXp,content_3652_10446:()=>wXp,content_3652_10448:()=>CXp,content_3652_10450:()=>LXp,content_3652_10452:()=>NXp,content_3652_10454:()=>WXp,content_3652_10456:()=>SXp,content_3652_10458:()=>OXp,content_3652_1046:()=>kft,content_3652_10460:()=>BXp,content_3652_10462:()=>qXp,content_3652_10464:()=>HXp,content_3652_10466:()=>JXp,content_3652_10468:()=>e_p,content_3652_10470:()=>p_p,content_3652_10472:()=>c_p,content_3652_10474:()=>l_p,content_3652_10476:()=>d_p,content_3652_10478:()=>k_p,content_3652_1048:()=>Mft,content_3652_10480:()=>M_p,content_3652_10482:()=>w_p,content_3652_10484:()=>C_p,content_3652_10486:()=>L_p,content_3652_10488:()=>N_p,content_3652_10490:()=>W_p,content_3652_10492:()=>S_p,content_3652_10494:()=>O_p,content_3652_10496:()=>B_p,content_3652_10498:()=>q_p,content_3652_1050:()=>wft,content_3652_10500:()=>H_p,content_3652_10502:()=>J_p,content_3652_10504:()=>ewp,content_3652_10506:()=>pwp,content_3652_10508:()=>cwp,content_3652_10510:()=>lwp,content_3652_10512:()=>dwp,content_3652_10514:()=>kwp,content_3652_10516:()=>Mwp,content_3652_10518:()=>wwp,content_3652_1052:()=>Cft,content_3652_10520:()=>Cwp,content_3652_10522:()=>Lwp,content_3652_10524:()=>Nwp,content_3652_10526:()=>Wwp,content_3652_10528:()=>Swp,content_3652_10530:()=>Owp,content_3652_10532:()=>Bwp,content_3652_10534:()=>qwp,content_3652_10536:()=>Hwp,content_3652_10538:()=>Jwp,content_3652_1054:()=>Lft,content_3652_10540:()=>eTp,content_3652_10542:()=>pTp,content_3652_10544:()=>cTp,content_3652_10546:()=>lTp,content_3652_10548:()=>dTp,content_3652_10550:()=>kTp,content_3652_10552:()=>MTp,content_3652_10554:()=>wTp,content_3652_10556:()=>CTp,content_3652_10558:()=>LTp,content_3652_1056:()=>Nft,content_3652_10560:()=>NTp,content_3652_10562:()=>WTp,content_3652_10564:()=>STp,content_3652_10566:()=>OTp,content_3652_10568:()=>BTp,content_3652_10570:()=>qTp,content_3652_10572:()=>HTp,content_3652_10574:()=>JTp,content_3652_10576:()=>egp,content_3652_10578:()=>pgp,content_3652_1058:()=>Wft,content_3652_10580:()=>cgp,content_3652_10582:()=>lgp,content_3652_10584:()=>dgp,content_3652_10586:()=>kgp,content_3652_10588:()=>Mgp,content_3652_10590:()=>wgp,content_3652_10592:()=>Cgp,content_3652_10594:()=>Lgp,content_3652_10596:()=>Ngp,content_3652_10598:()=>Wgp,content_3652_106:()=>aK,content_3652_1060:()=>Sft,content_3652_10600:()=>Sgp,content_3652_10602:()=>Ogp,content_3652_10604:()=>Bgp,content_3652_10606:()=>qgp,content_3652_10608:()=>Hgp,content_3652_10610:()=>Jgp,content_3652_10612:()=>eCp,content_3652_10614:()=>pCp,content_3652_10616:()=>cCp,content_3652_10618:()=>lCp,content_3652_1062:()=>Oft,content_3652_10620:()=>dCp,content_3652_10622:()=>kCp,content_3652_10624:()=>MCp,content_3652_10626:()=>wCp,content_3652_10628:()=>CCp,content_3652_10630:()=>LCp,content_3652_10632:()=>NCp,content_3652_10634:()=>WCp,content_3652_10636:()=>SCp,content_3652_10638:()=>OCp,content_3652_1064:()=>Bft,content_3652_10640:()=>BCp,content_3652_10642:()=>qCp,content_3652_10644:()=>HCp,content_3652_10646:()=>JCp,content_3652_10648:()=>exp,content_3652_10650:()=>pxp,content_3652_10652:()=>cxp,content_3652_10654:()=>lxp,content_3652_10656:()=>dxp,content_3652_10658:()=>kxp,content_3652_1066:()=>qft,content_3652_10660:()=>Mxp,content_3652_10662:()=>wxp,content_3652_10664:()=>Cxp,content_3652_10666:()=>Lxp,content_3652_10668:()=>Nxp,content_3652_10670:()=>Wxp,content_3652_10672:()=>Sxp,content_3652_10674:()=>Oxp,content_3652_10676:()=>Bxp,content_3652_10678:()=>qxp,content_3652_1068:()=>Hft,content_3652_10680:()=>Hxp,content_3652_10682:()=>Jxp,content_3652_10684:()=>evp,content_3652_10686:()=>pvp,content_3652_10688:()=>cvp,content_3652_10690:()=>lvp,content_3652_10692:()=>dvp,content_3652_10694:()=>kvp,content_3652_10696:()=>Mvp,content_3652_10698:()=>wvp,content_3652_1070:()=>Jft,content_3652_10700:()=>Cvp,content_3652_10702:()=>Lvp,content_3652_10704:()=>Nvp,content_3652_10706:()=>Wvp,content_3652_10708:()=>Svp,content_3652_10710:()=>Ovp,content_3652_10712:()=>Bvp,content_3652_10714:()=>qvp,content_3652_10716:()=>Hvp,content_3652_10718:()=>Jvp,content_3652_1072:()=>ekt,content_3652_10720:()=>eLp,content_3652_10722:()=>pLp,content_3652_10724:()=>cLp,content_3652_10726:()=>lLp,content_3652_10728:()=>dLp,content_3652_10730:()=>kLp,content_3652_10732:()=>MLp,content_3652_10734:()=>wLp,content_3652_10736:()=>CLp,content_3652_10738:()=>LLp,content_3652_1074:()=>pkt,content_3652_10740:()=>NLp,content_3652_10742:()=>WLp,content_3652_10744:()=>SLp,content_3652_10746:()=>OLp,content_3652_10748:()=>BLp,content_3652_10750:()=>qLp,content_3652_10752:()=>HLp,content_3652_10754:()=>JLp,content_3652_10756:()=>eZp,content_3652_10758:()=>pZp,content_3652_1076:()=>ckt,content_3652_10760:()=>cZp,content_3652_10762:()=>lZp,content_3652_10764:()=>dZp,content_3652_10766:()=>kZp,content_3652_10768:()=>MZp,content_3652_10770:()=>wZp,content_3652_10772:()=>CZp,content_3652_10774:()=>LZp,content_3652_10776:()=>NZp,content_3652_10778:()=>WZp,content_3652_1078:()=>lkt,content_3652_10780:()=>SZp,content_3652_10782:()=>OZp,content_3652_10784:()=>BZp,content_3652_10786:()=>qZp,content_3652_10788:()=>HZp,content_3652_10790:()=>JZp,content_3652_10792:()=>ebp,content_3652_10794:()=>pbp,content_3652_10796:()=>cbp,content_3652_10798:()=>lbp,content_3652_108:()=>mK,content_3652_1080:()=>dkt,content_3652_10800:()=>dbp,content_3652_10802:()=>kbp,content_3652_10804:()=>Mbp,content_3652_10806:()=>wbp,content_3652_10808:()=>Cbp,content_3652_10810:()=>Lbp,content_3652_10812:()=>Nbp,content_3652_10814:()=>Wbp,content_3652_10816:()=>Sbp,content_3652_10818:()=>Obp,content_3652_1082:()=>kkt,content_3652_10820:()=>Bbp,content_3652_10822:()=>qbp,content_3652_10824:()=>Hbp,content_3652_10826:()=>Jbp,content_3652_10828:()=>eNp,content_3652_10830:()=>pNp,content_3652_10832:()=>cNp,content_3652_10834:()=>lNp,content_3652_10836:()=>dNp,content_3652_10838:()=>kNp,content_3652_1084:()=>Mkt,content_3652_10840:()=>MNp,content_3652_10842:()=>wNp,content_3652_10844:()=>CNp,content_3652_10846:()=>LNp,content_3652_10848:()=>NNp,content_3652_10850:()=>WNp,content_3652_10852:()=>SNp,content_3652_10854:()=>ONp,content_3652_10856:()=>BNp,content_3652_10858:()=>qNp,content_3652_1086:()=>wkt,content_3652_10860:()=>HNp,content_3652_10862:()=>JNp,content_3652_10864:()=>eAp,content_3652_10866:()=>pAp,content_3652_10868:()=>cAp,content_3652_10870:()=>lAp,content_3652_10872:()=>dAp,content_3652_10874:()=>kAp,content_3652_10876:()=>MAp,content_3652_10878:()=>wAp,content_3652_1088:()=>Ckt,content_3652_10880:()=>CAp,content_3652_10882:()=>LAp,content_3652_10884:()=>NAp,content_3652_10886:()=>WAp,content_3652_10888:()=>SAp,content_3652_10890:()=>OAp,content_3652_10892:()=>BAp,content_3652_10894:()=>qAp,content_3652_10896:()=>HAp,content_3652_10898:()=>JAp,content_3652_1090:()=>Lkt,content_3652_10900:()=>ezp,content_3652_10902:()=>pzp,content_3652_10904:()=>czp,content_3652_10906:()=>lzp,content_3652_10908:()=>dzp,content_3652_10910:()=>kzp,content_3652_10912:()=>Mzp,content_3652_10914:()=>wzp,content_3652_10916:()=>Czp,content_3652_10918:()=>Lzp,content_3652_1092:()=>Nkt,content_3652_10920:()=>Nzp,content_3652_10922:()=>Wzp,content_3652_10924:()=>Szp,content_3652_10926:()=>Ozp,content_3652_10928:()=>Bzp,content_3652_10930:()=>qzp,content_3652_10932:()=>Hzp,content_3652_10934:()=>Jzp,content_3652_10936:()=>eWp,content_3652_10938:()=>pWp,content_3652_1094:()=>Wkt,content_3652_10940:()=>cWp,content_3652_10942:()=>lWp,content_3652_10944:()=>dWp,content_3652_10946:()=>kWp,content_3652_10948:()=>MWp,content_3652_10950:()=>wWp,content_3652_10952:()=>CWp,content_3652_10954:()=>LWp,content_3652_10956:()=>NWp,content_3652_10958:()=>WWp,content_3652_1096:()=>Skt,content_3652_10960:()=>SWp,content_3652_10962:()=>OWp,content_3652_10964:()=>BWp,content_3652_10966:()=>qWp,content_3652_10968:()=>HWp,content_3652_10970:()=>JWp,content_3652_10972:()=>eIp,content_3652_10974:()=>pIp,content_3652_10976:()=>cIp,content_3652_10978:()=>lIp,content_3652_1098:()=>Okt,content_3652_10980:()=>dIp,content_3652_10982:()=>kIp,content_3652_10984:()=>MIp,content_3652_10986:()=>wIp,content_3652_10988:()=>CIp,content_3652_10990:()=>LIp,content_3652_10992:()=>NIp,content_3652_10994:()=>WIp,content_3652_10996:()=>SIp,content_3652_10998:()=>OIp,content_3652_110:()=>fK,content_3652_1100:()=>Bkt,content_3652_11000:()=>BIp,content_3652_11002:()=>qIp,content_3652_11004:()=>HIp,content_3652_11006:()=>JIp,content_3652_11008:()=>eRp,content_3652_11010:()=>pRp,content_3652_11012:()=>cRp,content_3652_11014:()=>lRp,content_3652_11016:()=>dRp,content_3652_11018:()=>kRp,content_3652_1102:()=>qkt,content_3652_11020:()=>MRp,content_3652_11022:()=>wRp,content_3652_11024:()=>CRp,content_3652_11026:()=>LRp,content_3652_11028:()=>NRp,content_3652_11030:()=>WRp,content_3652_11032:()=>SRp,content_3652_11034:()=>ORp,content_3652_11036:()=>BRp,content_3652_11038:()=>qRp,content_3652_1104:()=>Hkt,content_3652_11040:()=>HRp,content_3652_11042:()=>JRp,content_3652_11044:()=>eSp,content_3652_11046:()=>pSp,content_3652_11048:()=>cSp,content_3652_11050:()=>lSp,content_3652_11052:()=>dSp,content_3652_11054:()=>kSp,content_3652_11056:()=>MSp,content_3652_11058:()=>wSp,content_3652_1106:()=>Jkt,content_3652_11060:()=>CSp,content_3652_11062:()=>LSp,content_3652_11064:()=>NSp,content_3652_11066:()=>WSp,content_3652_11068:()=>SSp,content_3652_11070:()=>OSp,content_3652_11072:()=>BSp,content_3652_11074:()=>qSp,content_3652_11076:()=>HSp,content_3652_11078:()=>JSp,content_3652_1108:()=>eyt,content_3652_11080:()=>ePp,content_3652_11082:()=>pPp,content_3652_11084:()=>cPp,content_3652_11086:()=>lPp,content_3652_11088:()=>dPp,content_3652_11090:()=>kPp,content_3652_11092:()=>MPp,content_3652_11094:()=>wPp,content_3652_11096:()=>CPp,content_3652_11098:()=>LPp,content_3652_1110:()=>pyt,content_3652_11100:()=>NPp,content_3652_11102:()=>WPp,content_3652_11104:()=>SPp,content_3652_11106:()=>OPp,content_3652_11108:()=>BPp,content_3652_11110:()=>qPp,content_3652_11112:()=>HPp,content_3652_11114:()=>JPp,content_3652_11116:()=>eEp,content_3652_11118:()=>pEp,content_3652_1112:()=>cyt,content_3652_11120:()=>cEp,content_3652_11122:()=>lEp,content_3652_11124:()=>dEp,content_3652_11126:()=>kEp,content_3652_11128:()=>MEp,content_3652_11130:()=>wEp,content_3652_11132:()=>CEp,content_3652_11134:()=>LEp,content_3652_11136:()=>NEp,content_3652_11138:()=>WEp,content_3652_1114:()=>lyt,content_3652_11140:()=>SEp,content_3652_11142:()=>OEp,content_3652_11144:()=>BEp,content_3652_11146:()=>qEp,content_3652_11148:()=>HEp,content_3652_11150:()=>JEp,content_3652_11152:()=>eOp,content_3652_11154:()=>pOp,content_3652_11156:()=>cOp,content_3652_1116:()=>dyt,content_3652_1118:()=>kyt,content_3652_112:()=>DK,content_3652_1120:()=>Myt,content_3652_1122:()=>wyt,content_3652_1124:()=>Cyt,content_3652_1126:()=>Lyt,content_3652_1128:()=>Nyt,content_3652_1130:()=>Wyt,content_3652_1132:()=>Syt,content_3652_1134:()=>Oyt,content_3652_1136:()=>Byt,content_3652_1138:()=>qyt,content_3652_114:()=>_K,content_3652_1140:()=>Hyt,content_3652_1142:()=>Jyt,content_3652_1144:()=>eDt,content_3652_1146:()=>pDt,content_3652_1148:()=>cDt,content_3652_1150:()=>lDt,content_3652_1152:()=>dDt,content_3652_1154:()=>kDt,content_3652_1156:()=>MDt,content_3652_1158:()=>wDt,content_3652_116:()=>gK,content_3652_1160:()=>CDt,content_3652_1162:()=>LDt,content_3652_1164:()=>NDt,content_3652_1166:()=>WDt,content_3652_1168:()=>SDt,content_3652_1170:()=>ODt,content_3652_1172:()=>BDt,content_3652_1174:()=>qDt,content_3652_1176:()=>HDt,content_3652_1178:()=>JDt,content_3652_118:()=>vK,content_3652_1180:()=>eMt,content_3652_1182:()=>pMt,content_3652_1184:()=>cMt,content_3652_1186:()=>lMt,content_3652_1188:()=>dMt,content_3652_1190:()=>kMt,content_3652_1192:()=>MMt,content_3652_1194:()=>wMt,content_3652_1196:()=>CMt,content_3652_1198:()=>LMt,content_3652_12:()=>bQ,content_3652_120:()=>bK,content_3652_1200:()=>NMt,content_3652_1202:()=>WMt,content_3652_1204:()=>SMt,content_3652_1206:()=>OMt,content_3652_1208:()=>BMt,content_3652_1210:()=>qMt,content_3652_1212:()=>HMt,content_3652_1214:()=>JMt,content_3652_1216:()=>eXt,content_3652_1218:()=>pXt,content_3652_122:()=>zK,content_3652_1220:()=>cXt,content_3652_1222:()=>lXt,content_3652_1224:()=>dXt,content_3652_1226:()=>kXt,content_3652_1228:()=>MXt,content_3652_1230:()=>wXt,content_3652_1232:()=>CXt,content_3652_1234:()=>LXt,content_3652_1236:()=>NXt,content_3652_1238:()=>WXt,content_3652_124:()=>RK,content_3652_1240:()=>SXt,content_3652_1242:()=>OXt,content_3652_1244:()=>BXt,content_3652_1246:()=>qXt,content_3652_1248:()=>HXt,content_3652_1250:()=>JXt,content_3652_1252:()=>e_t,content_3652_1254:()=>p_t,content_3652_1256:()=>c_t,content_3652_1258:()=>l_t,content_3652_126:()=>EK,content_3652_1260:()=>d_t,content_3652_1262:()=>k_t,content_3652_1264:()=>M_t,content_3652_1266:()=>w_t,content_3652_1268:()=>C_t,content_3652_1270:()=>L_t,content_3652_1272:()=>N_t,content_3652_1274:()=>W_t,content_3652_1276:()=>S_t,content_3652_1278:()=>O_t,content_3652_128:()=>FK,content_3652_1280:()=>B_t,content_3652_1282:()=>q_t,content_3652_1284:()=>H_t,content_3652_1286:()=>J_t,content_3652_1288:()=>ewt,content_3652_1290:()=>pwt,content_3652_1292:()=>cwt,content_3652_1294:()=>lwt,content_3652_1296:()=>dwt,content_3652_1298:()=>kwt,content_3652_130:()=>VK,content_3652_1300:()=>Mwt,content_3652_1302:()=>wwt,content_3652_1304:()=>Cwt,content_3652_1306:()=>Lwt,content_3652_1308:()=>Nwt,content_3652_1310:()=>Wwt,content_3652_1312:()=>Swt,content_3652_1314:()=>Owt,content_3652_1316:()=>Bwt,content_3652_1318:()=>qwt,content_3652_132:()=>YK,content_3652_1320:()=>Hwt,content_3652_1322:()=>Jwt,content_3652_1324:()=>eTt,content_3652_1326:()=>pTt,content_3652_1328:()=>cTt,content_3652_1330:()=>lTt,content_3652_1332:()=>dTt,content_3652_1334:()=>kTt,content_3652_1336:()=>MTt,content_3652_1338:()=>wTt,content_3652_134:()=>$K,content_3652_1340:()=>CTt,content_3652_1342:()=>LTt,content_3652_1344:()=>NTt,content_3652_1346:()=>WTt,content_3652_1348:()=>STt,content_3652_1350:()=>OTt,content_3652_1352:()=>BTt,content_3652_1354:()=>qTt,content_3652_1356:()=>HTt,content_3652_1358:()=>JTt,content_3652_136:()=>t0,content_3652_1360:()=>egt,content_3652_1362:()=>pgt,content_3652_1364:()=>cgt,content_3652_1366:()=>lgt,content_3652_1368:()=>dgt,content_3652_1370:()=>kgt,content_3652_1372:()=>Mgt,content_3652_1374:()=>wgt,content_3652_1376:()=>Cgt,content_3652_1378:()=>Lgt,content_3652_138:()=>o0,content_3652_1380:()=>Ngt,content_3652_1382:()=>Wgt,content_3652_1384:()=>Sgt,content_3652_1386:()=>Ogt,content_3652_1388:()=>Bgt,content_3652_1390:()=>qgt,content_3652_1392:()=>Hgt,content_3652_1394:()=>Jgt,content_3652_1396:()=>eCt,content_3652_1398:()=>pCt,content_3652_14:()=>zQ,content_3652_140:()=>s0,content_3652_1400:()=>cCt,content_3652_1402:()=>lCt,content_3652_1404:()=>dCt,content_3652_1406:()=>kCt,content_3652_1408:()=>MCt,content_3652_1410:()=>wCt,content_3652_1412:()=>CCt,content_3652_1414:()=>LCt,content_3652_1416:()=>NCt,content_3652_1418:()=>WCt,content_3652_142:()=>a0,content_3652_1420:()=>SCt,content_3652_1422:()=>OCt,content_3652_1424:()=>BCt,content_3652_1426:()=>qCt,content_3652_1428:()=>HCt,content_3652_1430:()=>JCt,content_3652_1432:()=>ext,content_3652_1434:()=>pxt,content_3652_1436:()=>cxt,content_3652_1438:()=>lxt,content_3652_144:()=>m0,content_3652_1440:()=>dxt,content_3652_1442:()=>kxt,content_3652_1444:()=>Mxt,content_3652_1446:()=>wxt,content_3652_1448:()=>Cxt,content_3652_1450:()=>Lxt,content_3652_1452:()=>Nxt,content_3652_1454:()=>Wxt,content_3652_1456:()=>Sxt,content_3652_1458:()=>Oxt,content_3652_146:()=>f0,content_3652_1460:()=>Bxt,content_3652_1462:()=>qxt,content_3652_1464:()=>Hxt,content_3652_1466:()=>Jxt,content_3652_1468:()=>evt,content_3652_1470:()=>pvt,content_3652_1472:()=>cvt,content_3652_1474:()=>lvt,content_3652_1476:()=>dvt,content_3652_1478:()=>kvt,content_3652_148:()=>D0,content_3652_1480:()=>Mvt,content_3652_1482:()=>wvt,content_3652_1484:()=>Cvt,content_3652_1486:()=>Lvt,content_3652_1488:()=>Nvt,content_3652_1490:()=>Wvt,content_3652_1492:()=>Svt,content_3652_1494:()=>Ovt,content_3652_1496:()=>Bvt,content_3652_1498:()=>qvt,content_3652_150:()=>_0,content_3652_1500:()=>Hvt,content_3652_1502:()=>Jvt,content_3652_1504:()=>eLt,content_3652_1506:()=>pLt,content_3652_1508:()=>cLt,content_3652_1510:()=>lLt,content_3652_1512:()=>dLt,content_3652_1514:()=>kLt,content_3652_1516:()=>MLt,content_3652_1518:()=>wLt,content_3652_152:()=>g0,content_3652_1520:()=>CLt,content_3652_1522:()=>LLt,content_3652_1524:()=>NLt,content_3652_1526:()=>WLt,content_3652_1528:()=>SLt,content_3652_1530:()=>OLt,content_3652_1532:()=>BLt,content_3652_1534:()=>qLt,content_3652_1536:()=>HLt,content_3652_1538:()=>JLt,content_3652_154:()=>v0,content_3652_1540:()=>eZt,content_3652_1542:()=>pZt,content_3652_1544:()=>cZt,content_3652_1546:()=>lZt,content_3652_1548:()=>dZt,content_3652_1550:()=>kZt,content_3652_1552:()=>MZt,content_3652_1554:()=>wZt,content_3652_1556:()=>CZt,content_3652_1558:()=>LZt,content_3652_156:()=>b0,content_3652_1560:()=>NZt,content_3652_1562:()=>WZt,content_3652_1564:()=>SZt,content_3652_1566:()=>OZt,content_3652_1568:()=>BZt,content_3652_1570:()=>qZt,content_3652_1572:()=>HZt,content_3652_1574:()=>JZt,content_3652_1576:()=>ebt,content_3652_1578:()=>pbt,content_3652_158:()=>z0,content_3652_1580:()=>cbt,content_3652_1582:()=>lbt,content_3652_1584:()=>dbt,content_3652_1586:()=>kbt,content_3652_1588:()=>Mbt,content_3652_1590:()=>wbt,content_3652_1592:()=>Cbt,content_3652_1594:()=>Lbt,content_3652_1596:()=>Nbt,content_3652_1598:()=>Wbt,content_3652_16:()=>RQ,content_3652_160:()=>R0,content_3652_1600:()=>Sbt,content_3652_1602:()=>Obt,content_3652_1604:()=>Bbt,content_3652_1606:()=>qbt,content_3652_1608:()=>Hbt,content_3652_1610:()=>Jbt,content_3652_1612:()=>eNt,content_3652_1614:()=>pNt,content_3652_1616:()=>cNt,content_3652_1618:()=>lNt,content_3652_162:()=>E0,content_3652_1620:()=>dNt,content_3652_1622:()=>kNt,content_3652_1624:()=>MNt,content_3652_1626:()=>wNt,content_3652_1628:()=>CNt,content_3652_1630:()=>LNt,content_3652_1632:()=>NNt,content_3652_1634:()=>WNt,content_3652_1636:()=>SNt,content_3652_1638:()=>ONt,content_3652_164:()=>F0,content_3652_1640:()=>BNt,content_3652_1642:()=>qNt,content_3652_1644:()=>HNt,content_3652_1646:()=>JNt,content_3652_1648:()=>eAt,content_3652_1650:()=>pAt,content_3652_1652:()=>cAt,content_3652_1654:()=>lAt,content_3652_1656:()=>dAt,content_3652_1658:()=>kAt,content_3652_166:()=>V0,content_3652_1660:()=>MAt,content_3652_1662:()=>wAt,content_3652_1664:()=>CAt,content_3652_1666:()=>LAt,content_3652_1668:()=>NAt,content_3652_1670:()=>WAt,content_3652_1672:()=>SAt,content_3652_1674:()=>OAt,content_3652_1676:()=>BAt,content_3652_1678:()=>qAt,content_3652_168:()=>Y0,content_3652_1680:()=>HAt,content_3652_1682:()=>JAt,content_3652_1684:()=>ezt,content_3652_1686:()=>pzt,content_3652_1688:()=>czt,content_3652_1690:()=>lzt,content_3652_1692:()=>dzt,content_3652_1694:()=>kzt,content_3652_1696:()=>Mzt,content_3652_1698:()=>wzt,content_3652_170:()=>$0,content_3652_1700:()=>Czt,content_3652_1702:()=>Lzt,content_3652_1704:()=>Nzt,content_3652_1706:()=>Wzt,content_3652_1708:()=>Szt,content_3652_1710:()=>Ozt,content_3652_1712:()=>Bzt,content_3652_1714:()=>qzt,content_3652_1716:()=>Hzt,content_3652_1718:()=>Jzt,content_3652_172:()=>t2,content_3652_1720:()=>eWt,content_3652_1722:()=>pWt,content_3652_1724:()=>cWt,content_3652_1726:()=>lWt,content_3652_1728:()=>dWt,content_3652_1730:()=>kWt,content_3652_1732:()=>MWt,content_3652_1734:()=>wWt,content_3652_1736:()=>CWt,content_3652_1738:()=>LWt,content_3652_174:()=>o2,content_3652_1740:()=>NWt,content_3652_1742:()=>WWt,content_3652_1744:()=>SWt,content_3652_1746:()=>OWt,content_3652_1748:()=>BWt,content_3652_1750:()=>qWt,content_3652_1752:()=>HWt,content_3652_1754:()=>JWt,content_3652_1756:()=>eIt,content_3652_1758:()=>pIt,content_3652_176:()=>s2,content_3652_1760:()=>cIt,content_3652_1762:()=>lIt,content_3652_1764:()=>dIt,content_3652_1766:()=>kIt,content_3652_1768:()=>MIt,content_3652_1770:()=>wIt,content_3652_1772:()=>CIt,content_3652_1774:()=>LIt,content_3652_1776:()=>NIt,content_3652_1778:()=>WIt,content_3652_178:()=>a2,content_3652_1780:()=>SIt,content_3652_1782:()=>OIt,content_3652_1784:()=>BIt,content_3652_1786:()=>qIt,content_3652_1788:()=>HIt,content_3652_1790:()=>JIt,content_3652_1792:()=>eRt,content_3652_1794:()=>pRt,content_3652_1796:()=>cRt,content_3652_1798:()=>lRt,content_3652_18:()=>EQ,content_3652_180:()=>m2,content_3652_1800:()=>dRt,content_3652_1802:()=>kRt,content_3652_1804:()=>MRt,content_3652_1806:()=>wRt,content_3652_1808:()=>CRt,content_3652_1810:()=>LRt,content_3652_1812:()=>NRt,content_3652_1814:()=>WRt,content_3652_1816:()=>SRt,content_3652_1818:()=>ORt,content_3652_182:()=>f2,content_3652_1820:()=>BRt,content_3652_1822:()=>qRt,content_3652_1824:()=>HRt,content_3652_1826:()=>JRt,content_3652_1828:()=>eSt,content_3652_1830:()=>pSt,content_3652_1832:()=>cSt,content_3652_1834:()=>lSt,content_3652_1836:()=>dSt,content_3652_1838:()=>kSt,content_3652_184:()=>D2,content_3652_1840:()=>MSt,content_3652_1842:()=>wSt,content_3652_1844:()=>CSt,content_3652_1846:()=>LSt,content_3652_1848:()=>NSt,content_3652_1850:()=>WSt,content_3652_1852:()=>SSt,content_3652_1854:()=>OSt,content_3652_1856:()=>BSt,content_3652_1858:()=>qSt,content_3652_186:()=>_2,content_3652_1860:()=>HSt,content_3652_1862:()=>JSt,content_3652_1864:()=>ePt,content_3652_1866:()=>pPt,content_3652_1868:()=>cPt,content_3652_1870:()=>lPt,content_3652_1872:()=>dPt,content_3652_1874:()=>kPt,content_3652_1876:()=>MPt,content_3652_1878:()=>wPt,content_3652_188:()=>g2,content_3652_1880:()=>CPt,content_3652_1882:()=>LPt,content_3652_1884:()=>NPt,content_3652_1886:()=>WPt,content_3652_1888:()=>SPt,content_3652_1890:()=>OPt,content_3652_1892:()=>BPt,content_3652_1894:()=>qPt,content_3652_1896:()=>HPt,content_3652_1898:()=>JPt,content_3652_190:()=>v2,content_3652_1900:()=>eEt,content_3652_1902:()=>pEt,content_3652_1904:()=>cEt,content_3652_1906:()=>lEt,content_3652_1908:()=>dEt,content_3652_1910:()=>kEt,content_3652_1912:()=>MEt,content_3652_1914:()=>wEt,content_3652_1916:()=>CEt,content_3652_1918:()=>LEt,content_3652_192:()=>b2,content_3652_1920:()=>NEt,content_3652_1922:()=>WEt,content_3652_1924:()=>SEt,content_3652_1926:()=>OEt,content_3652_1928:()=>BEt,content_3652_1930:()=>qEt,content_3652_1932:()=>HEt,content_3652_1934:()=>JEt,content_3652_1936:()=>eOt,content_3652_1938:()=>pOt,content_3652_194:()=>z2,content_3652_1940:()=>cOt,content_3652_1942:()=>lOt,content_3652_1944:()=>dOt,content_3652_1946:()=>kOt,content_3652_1948:()=>MOt,content_3652_1950:()=>wOt,content_3652_1952:()=>COt,content_3652_1954:()=>LOt,content_3652_1956:()=>NOt,content_3652_1958:()=>WOt,content_3652_196:()=>R2,content_3652_1960:()=>SOt,content_3652_1962:()=>OOt,content_3652_1964:()=>BOt,content_3652_1966:()=>qOt,content_3652_1968:()=>HOt,content_3652_1970:()=>JOt,content_3652_1972:()=>eGt,content_3652_1974:()=>pGt,content_3652_1976:()=>cGt,content_3652_1978:()=>lGt,content_3652_198:()=>E2,content_3652_1980:()=>dGt,content_3652_1982:()=>kGt,content_3652_1984:()=>MGt,content_3652_1986:()=>wGt,content_3652_1988:()=>CGt,content_3652_1990:()=>LGt,content_3652_1992:()=>NGt,content_3652_1994:()=>WGt,content_3652_1996:()=>SGt,content_3652_1998:()=>OGt,content_3652_2:()=>fQ,content_3652_20:()=>FQ,content_3652_200:()=>F2,content_3652_2000:()=>BGt,content_3652_2002:()=>qGt,content_3652_2004:()=>HGt,content_3652_2006:()=>JGt,content_3652_2008:()=>eFt,content_3652_2010:()=>pFt,content_3652_2012:()=>cFt,content_3652_2014:()=>lFt,content_3652_2016:()=>dFt,content_3652_2018:()=>kFt,content_3652_202:()=>V2,content_3652_2020:()=>MFt,content_3652_2022:()=>wFt,content_3652_2024:()=>CFt,content_3652_2026:()=>LFt,content_3652_2028:()=>NFt,content_3652_2030:()=>WFt,content_3652_2032:()=>SFt,content_3652_2034:()=>OFt,content_3652_2036:()=>BFt,content_3652_2038:()=>qFt,content_3652_204:()=>Y2,content_3652_2040:()=>HFt,content_3652_2042:()=>JFt,content_3652_2044:()=>eBt,content_3652_2046:()=>pBt,content_3652_2048:()=>cBt,content_3652_2050:()=>lBt,content_3652_2052:()=>dBt,content_3652_2054:()=>kBt,content_3652_2056:()=>MBt,content_3652_2058:()=>wBt,content_3652_206:()=>$2,content_3652_2060:()=>CBt,content_3652_2062:()=>LBt,content_3652_2064:()=>NBt,content_3652_2066:()=>WBt,content_3652_2068:()=>SBt,content_3652_2070:()=>OBt,content_3652_2072:()=>BBt,content_3652_2074:()=>qBt,content_3652_2076:()=>HBt,content_3652_2078:()=>JBt,content_3652_208:()=>t6,content_3652_2080:()=>eUt,content_3652_2082:()=>pUt,content_3652_2084:()=>cUt,content_3652_2086:()=>lUt,content_3652_2088:()=>dUt,content_3652_2090:()=>kUt,content_3652_2092:()=>MUt,content_3652_2094:()=>wUt,content_3652_2096:()=>CUt,content_3652_2098:()=>LUt,content_3652_210:()=>o6,content_3652_2100:()=>NUt,content_3652_2102:()=>WUt,content_3652_2104:()=>SUt,content_3652_2106:()=>OUt,content_3652_2108:()=>BUt,content_3652_2110:()=>qUt,content_3652_2112:()=>HUt,content_3652_2114:()=>JUt,content_3652_2116:()=>eVt,content_3652_2118:()=>pVt,content_3652_212:()=>s6,content_3652_2120:()=>cVt,content_3652_2122:()=>lVt,content_3652_2124:()=>dVt,content_3652_2126:()=>kVt,content_3652_2128:()=>MVt,content_3652_2130:()=>wVt,content_3652_2132:()=>CVt,content_3652_2134:()=>LVt,content_3652_2136:()=>NVt,content_3652_2138:()=>WVt,content_3652_214:()=>a6,content_3652_2140:()=>SVt,content_3652_2142:()=>OVt,content_3652_2144:()=>BVt,content_3652_2146:()=>qVt,content_3652_2148:()=>HVt,content_3652_2150:()=>JVt,content_3652_2152:()=>eqt,content_3652_2154:()=>pqt,content_3652_2156:()=>cqt,content_3652_2158:()=>lqt,content_3652_216:()=>m6,content_3652_2160:()=>dqt,content_3652_2162:()=>kqt,content_3652_2164:()=>Mqt,content_3652_2166:()=>wqt,content_3652_2168:()=>Cqt,content_3652_2170:()=>Lqt,content_3652_2172:()=>Nqt,content_3652_2174:()=>Wqt,content_3652_2176:()=>Sqt,content_3652_2178:()=>Oqt,content_3652_218:()=>f6,content_3652_2180:()=>Bqt,content_3652_2182:()=>qqt,content_3652_2184:()=>Hqt,content_3652_2186:()=>Jqt,content_3652_2188:()=>ejt,content_3652_2190:()=>pjt,content_3652_2192:()=>cjt,content_3652_2194:()=>ljt,content_3652_2196:()=>djt,content_3652_2198:()=>kjt,content_3652_22:()=>VQ,content_3652_220:()=>D6,content_3652_2200:()=>Mjt,content_3652_2202:()=>wjt,content_3652_2204:()=>Cjt,content_3652_2206:()=>Ljt,content_3652_2208:()=>Njt,content_3652_2210:()=>Wjt,content_3652_2212:()=>Sjt,content_3652_2214:()=>Ojt,content_3652_2216:()=>Bjt,content_3652_2218:()=>qjt,content_3652_222:()=>_6,content_3652_2220:()=>Hjt,content_3652_2222:()=>Jjt,content_3652_2224:()=>eYt,content_3652_2226:()=>pYt,content_3652_2228:()=>cYt,content_3652_2230:()=>lYt,content_3652_2232:()=>dYt,content_3652_2234:()=>kYt,content_3652_2236:()=>MYt,content_3652_2238:()=>wYt,content_3652_224:()=>g6,content_3652_2240:()=>CYt,content_3652_2242:()=>LYt,content_3652_2244:()=>NYt,content_3652_2246:()=>WYt,content_3652_2248:()=>SYt,content_3652_2250:()=>OYt,content_3652_2252:()=>BYt,content_3652_2254:()=>qYt,content_3652_2256:()=>HYt,content_3652_2258:()=>JYt,content_3652_226:()=>v6,content_3652_2260:()=>eHt,content_3652_2262:()=>pHt,content_3652_2264:()=>cHt,content_3652_2266:()=>lHt,content_3652_2268:()=>dHt,content_3652_2270:()=>kHt,content_3652_2272:()=>MHt,content_3652_2274:()=>wHt,content_3652_2276:()=>CHt,content_3652_2278:()=>LHt,content_3652_228:()=>b6,content_3652_2280:()=>NHt,content_3652_2282:()=>WHt,content_3652_2284:()=>SHt,content_3652_2286:()=>OHt,content_3652_2288:()=>BHt,content_3652_2290:()=>qHt,content_3652_2292:()=>HHt,content_3652_2294:()=>JHt,content_3652_2296:()=>eQt,content_3652_2298:()=>pQt,content_3652_230:()=>z6,content_3652_2300:()=>cQt,content_3652_2302:()=>lQt,content_3652_2304:()=>dQt,content_3652_2306:()=>kQt,content_3652_2308:()=>MQt,content_3652_2310:()=>wQt,content_3652_2312:()=>CQt,content_3652_2314:()=>LQt,content_3652_2316:()=>NQt,content_3652_2318:()=>WQt,content_3652_232:()=>R6,content_3652_2320:()=>SQt,content_3652_2322:()=>OQt,content_3652_2324:()=>BQt,content_3652_2326:()=>qQt,content_3652_2328:()=>HQt,content_3652_2330:()=>JQt,content_3652_2332:()=>e$t,content_3652_2334:()=>p$t,content_3652_2336:()=>c$t,content_3652_2338:()=>l$t,content_3652_234:()=>E6,content_3652_2340:()=>d$t,content_3652_2342:()=>k$t,content_3652_2344:()=>M$t,content_3652_2346:()=>w$t,content_3652_2348:()=>C$t,content_3652_2350:()=>L$t,content_3652_2352:()=>N$t,content_3652_2354:()=>W$t,content_3652_2356:()=>S$t,content_3652_2358:()=>O$t,content_3652_236:()=>F6,content_3652_2360:()=>B$t,content_3652_2362:()=>q$t,content_3652_2364:()=>H$t,content_3652_2366:()=>J$t,content_3652_2368:()=>eJt,content_3652_2370:()=>pJt,content_3652_2372:()=>cJt,content_3652_2374:()=>lJt,content_3652_2376:()=>dJt,content_3652_2378:()=>kJt,content_3652_238:()=>V6,content_3652_2380:()=>MJt,content_3652_2382:()=>wJt,content_3652_2384:()=>CJt,content_3652_2386:()=>LJt,content_3652_2388:()=>NJt,content_3652_2390:()=>WJt,content_3652_2392:()=>SJt,content_3652_2394:()=>OJt,content_3652_2396:()=>BJt,content_3652_2398:()=>qJt,content_3652_24:()=>YQ,content_3652_240:()=>Y6,content_3652_2400:()=>HJt,content_3652_2402:()=>JJt,content_3652_2404:()=>eKt,content_3652_2406:()=>pKt,content_3652_2408:()=>cKt,content_3652_2410:()=>lKt,content_3652_2412:()=>dKt,content_3652_2414:()=>kKt,content_3652_2416:()=>MKt,content_3652_2418:()=>wKt,content_3652_242:()=>$6,content_3652_2420:()=>CKt,content_3652_2422:()=>LKt,content_3652_2424:()=>NKt,content_3652_2426:()=>WKt,content_3652_2428:()=>SKt,content_3652_2430:()=>OKt,content_3652_2432:()=>BKt,content_3652_2434:()=>qKt,content_3652_2436:()=>HKt,content_3652_2438:()=>JKt,content_3652_244:()=>t3,content_3652_2440:()=>e0t,content_3652_2442:()=>p0t,content_3652_2444:()=>c0t,content_3652_2446:()=>l0t,content_3652_2448:()=>d0t,content_3652_2450:()=>k0t,content_3652_2452:()=>M0t,content_3652_2454:()=>w0t,content_3652_2456:()=>C0t,content_3652_2458:()=>L0t,content_3652_246:()=>o3,content_3652_2460:()=>N0t,content_3652_2462:()=>W0t,content_3652_2464:()=>S0t,content_3652_2466:()=>O0t,content_3652_2468:()=>B0t,content_3652_2470:()=>q0t,content_3652_2472:()=>H0t,content_3652_2474:()=>J0t,content_3652_2476:()=>e2t,content_3652_2478:()=>p2t,content_3652_248:()=>s3,content_3652_2480:()=>c2t,content_3652_2482:()=>l2t,content_3652_2484:()=>d2t,content_3652_2486:()=>k2t,content_3652_2488:()=>M2t,content_3652_2490:()=>w2t,content_3652_2492:()=>C2t,content_3652_2494:()=>L2t,content_3652_2496:()=>N2t,content_3652_2498:()=>W2t,content_3652_250:()=>a3,content_3652_2500:()=>S2t,content_3652_2502:()=>O2t,content_3652_2504:()=>B2t,content_3652_2506:()=>q2t,content_3652_2508:()=>H2t,content_3652_2510:()=>J2t,content_3652_2512:()=>e6t,content_3652_2514:()=>p6t,content_3652_2516:()=>c6t,content_3652_2518:()=>l6t,content_3652_252:()=>m3,content_3652_2520:()=>d6t,content_3652_2522:()=>k6t,content_3652_2524:()=>M6t,content_3652_2526:()=>w6t,content_3652_2528:()=>C6t,content_3652_2530:()=>L6t,content_3652_2532:()=>N6t,content_3652_2534:()=>W6t,content_3652_2536:()=>S6t,content_3652_2538:()=>O6t,content_3652_254:()=>f3,content_3652_2540:()=>B6t,content_3652_2542:()=>q6t,content_3652_2544:()=>H6t,content_3652_2546:()=>J6t,content_3652_2548:()=>e3t,content_3652_2550:()=>p3t,content_3652_2552:()=>c3t,content_3652_2554:()=>l3t,content_3652_2556:()=>d3t,content_3652_2558:()=>k3t,content_3652_256:()=>D3,content_3652_2560:()=>M3t,content_3652_2562:()=>w3t,content_3652_2564:()=>C3t,content_3652_2566:()=>L3t,content_3652_2568:()=>N3t,content_3652_2570:()=>W3t,content_3652_2572:()=>S3t,content_3652_2574:()=>O3t,content_3652_2576:()=>B3t,content_3652_2578:()=>q3t,content_3652_258:()=>_3,content_3652_2580:()=>H3t,content_3652_2582:()=>J3t,content_3652_2584:()=>e5t,content_3652_2586:()=>p5t,content_3652_2588:()=>c5t,content_3652_2590:()=>l5t,content_3652_2592:()=>d5t,content_3652_2594:()=>k5t,content_3652_2596:()=>M5t,content_3652_2598:()=>w5t,content_3652_26:()=>$Q,content_3652_260:()=>g3,content_3652_2600:()=>C5t,content_3652_2602:()=>L5t,content_3652_2604:()=>N5t,content_3652_2606:()=>W5t,content_3652_2608:()=>S5t,content_3652_2610:()=>O5t,content_3652_2612:()=>B5t,content_3652_2614:()=>q5t,content_3652_2616:()=>H5t,content_3652_2618:()=>J5t,content_3652_262:()=>v3,content_3652_2620:()=>e1t,content_3652_2622:()=>p1t,content_3652_2624:()=>c1t,content_3652_2626:()=>l1t,content_3652_2628:()=>d1t,content_3652_2630:()=>k1t,content_3652_2632:()=>M1t,content_3652_2634:()=>w1t,content_3652_2636:()=>C1t,content_3652_2638:()=>L1t,content_3652_264:()=>b3,content_3652_2640:()=>N1t,content_3652_2642:()=>W1t,content_3652_2644:()=>S1t,content_3652_2646:()=>O1t,content_3652_2648:()=>B1t,content_3652_2650:()=>q1t,content_3652_2652:()=>H1t,content_3652_2654:()=>J1t,content_3652_2656:()=>e4t,content_3652_2658:()=>p4t,content_3652_266:()=>z3,content_3652_2660:()=>c4t,content_3652_2662:()=>l4t,content_3652_2664:()=>d4t,content_3652_2666:()=>k4t,content_3652_2668:()=>M4t,content_3652_2670:()=>w4t,content_3652_2672:()=>C4t,content_3652_2674:()=>L4t,content_3652_2676:()=>N4t,content_3652_2678:()=>W4t,content_3652_268:()=>R3,content_3652_2680:()=>S4t,content_3652_2682:()=>O4t,content_3652_2684:()=>B4t,content_3652_2686:()=>q4t,content_3652_2688:()=>H4t,content_3652_2690:()=>J4t,content_3652_2692:()=>e8t,content_3652_2694:()=>p8t,content_3652_2696:()=>c8t,content_3652_2698:()=>l8t,content_3652_270:()=>E3,content_3652_2700:()=>d8t,content_3652_2702:()=>k8t,content_3652_2704:()=>M8t,content_3652_2706:()=>w8t,content_3652_2708:()=>C8t,content_3652_2710:()=>L8t,content_3652_2712:()=>N8t,content_3652_2714:()=>W8t,content_3652_2716:()=>S8t,content_3652_2718:()=>O8t,content_3652_272:()=>F3,content_3652_2720:()=>B8t,content_3652_2722:()=>q8t,content_3652_2724:()=>H8t,content_3652_2726:()=>J8t,content_3652_2728:()=>e7t,content_3652_2730:()=>p7t,content_3652_2732:()=>c7t,content_3652_2734:()=>l7t,content_3652_2736:()=>d7t,content_3652_2738:()=>k7t,content_3652_274:()=>V3,content_3652_2740:()=>M7t,content_3652_2742:()=>w7t,content_3652_2744:()=>C7t,content_3652_2746:()=>L7t,content_3652_2748:()=>N7t,content_3652_2750:()=>W7t,content_3652_2752:()=>S7t,content_3652_2754:()=>O7t,content_3652_2756:()=>B7t,content_3652_2758:()=>q7t,content_3652_276:()=>Y3,content_3652_2760:()=>H7t,content_3652_2762:()=>J7t,content_3652_2764:()=>e9t,content_3652_2766:()=>p9t,content_3652_2768:()=>c9t,content_3652_2770:()=>l9t,content_3652_2772:()=>d9t,content_3652_2774:()=>k9t,content_3652_2776:()=>M9t,content_3652_2778:()=>w9t,content_3652_278:()=>$3,content_3652_2780:()=>C9t,content_3652_2782:()=>L9t,content_3652_2784:()=>N9t,content_3652_2786:()=>W9t,content_3652_2788:()=>S9t,content_3652_2790:()=>O9t,content_3652_2792:()=>B9t,content_3652_2794:()=>q9t,content_3652_2796:()=>H9t,content_3652_2798:()=>J9t,content_3652_28:()=>t$,content_3652_280:()=>t5,content_3652_2800:()=>ete,content_3652_2802:()=>pte,content_3652_2804:()=>cte,content_3652_2806:()=>lte,content_3652_2808:()=>dte,content_3652_2810:()=>kte,content_3652_2812:()=>Mte,content_3652_2814:()=>wte,content_3652_2816:()=>Cte,content_3652_2818:()=>Lte,content_3652_282:()=>o5,content_3652_2820:()=>Nte,content_3652_2822:()=>Wte,content_3652_2824:()=>Ste,content_3652_2826:()=>Ote,content_3652_2828:()=>Bte,content_3652_2830:()=>qte,content_3652_2832:()=>Hte,content_3652_2834:()=>Jte,content_3652_2836:()=>eee,content_3652_2838:()=>pee,content_3652_284:()=>s5,content_3652_2840:()=>cee,content_3652_2842:()=>lee,content_3652_2844:()=>dee,content_3652_2846:()=>kee,content_3652_2848:()=>Mee,content_3652_2850:()=>wee,content_3652_2852:()=>Cee,content_3652_2854:()=>Lee,content_3652_2856:()=>Nee,content_3652_2858:()=>Wee,content_3652_286:()=>a5,content_3652_2860:()=>See,content_3652_2862:()=>Oee,content_3652_2864:()=>Bee,content_3652_2866:()=>qee,content_3652_2868:()=>Hee,content_3652_2870:()=>Jee,content_3652_2872:()=>ene,content_3652_2874:()=>pne,content_3652_2876:()=>cne,content_3652_2878:()=>lne,content_3652_288:()=>m5,content_3652_2880:()=>dne,content_3652_2882:()=>kne,content_3652_2884:()=>Mne,content_3652_2886:()=>wne,content_3652_2888:()=>Cne,content_3652_2890:()=>Lne,content_3652_2892:()=>Nne,content_3652_2894:()=>Wne,content_3652_2896:()=>Sne,content_3652_2898:()=>One,content_3652_290:()=>f5,content_3652_2900:()=>Bne,content_3652_2902:()=>qne,content_3652_2904:()=>Hne,content_3652_2906:()=>Jne,content_3652_2908:()=>eoe,content_3652_2910:()=>poe,content_3652_2912:()=>coe,content_3652_2914:()=>loe,content_3652_2916:()=>doe,content_3652_2918:()=>koe,content_3652_292:()=>D5,content_3652_2920:()=>Moe,content_3652_2922:()=>woe,content_3652_2924:()=>Coe,content_3652_2926:()=>Loe,content_3652_2928:()=>Noe,content_3652_2930:()=>Woe,content_3652_2932:()=>Soe,content_3652_2934:()=>Ooe,content_3652_2936:()=>Boe,content_3652_2938:()=>qoe,content_3652_294:()=>_5,content_3652_2940:()=>Hoe,content_3652_2942:()=>Joe,content_3652_2944:()=>epe,content_3652_2946:()=>ppe,content_3652_2948:()=>cpe,content_3652_2950:()=>lpe,content_3652_2952:()=>dpe,content_3652_2954:()=>kpe,content_3652_2956:()=>Mpe,content_3652_2958:()=>wpe,content_3652_296:()=>g5,content_3652_2960:()=>Cpe,content_3652_2962:()=>Lpe,content_3652_2964:()=>Npe,content_3652_2966:()=>Wpe,content_3652_2968:()=>Spe,content_3652_2970:()=>Ope,content_3652_2972:()=>Bpe,content_3652_2974:()=>qpe,content_3652_2976:()=>Hpe,content_3652_2978:()=>Jpe,content_3652_298:()=>v5,content_3652_2980:()=>ere,content_3652_2982:()=>pre,content_3652_2984:()=>cre,content_3652_2986:()=>lre,content_3652_2988:()=>dre,content_3652_2990:()=>kre,content_3652_2992:()=>Mre,content_3652_2994:()=>wre,content_3652_2996:()=>Cre,content_3652_2998:()=>Lre,content_3652_30:()=>o$,content_3652_300:()=>b5,content_3652_3000:()=>Nre,content_3652_3002:()=>Wre,content_3652_3004:()=>Sre,content_3652_3006:()=>Ore,content_3652_3008:()=>Bre,content_3652_3010:()=>qre,content_3652_3012:()=>Hre,content_3652_3014:()=>Jre,content_3652_3016:()=>ese,content_3652_3018:()=>pse,content_3652_302:()=>z5,content_3652_3020:()=>cse,content_3652_3022:()=>lse,content_3652_3024:()=>dse,content_3652_3026:()=>kse,content_3652_3028:()=>Mse,content_3652_3030:()=>wse,content_3652_3032:()=>Cse,content_3652_3034:()=>Lse,content_3652_3036:()=>Nse,content_3652_3038:()=>Wse,content_3652_304:()=>R5,content_3652_3040:()=>Sse,content_3652_3042:()=>Ose,content_3652_3044:()=>Bse,content_3652_3046:()=>qse,content_3652_3048:()=>Hse,content_3652_3050:()=>Jse,content_3652_3052:()=>ece,content_3652_3054:()=>pce,content_3652_3056:()=>cce,content_3652_3058:()=>lce,content_3652_306:()=>E5,content_3652_3060:()=>dce,content_3652_3062:()=>kce,content_3652_3064:()=>Mce,content_3652_3066:()=>wce,content_3652_3068:()=>Cce,content_3652_3070:()=>Lce,content_3652_3072:()=>Nce,content_3652_3074:()=>Wce,content_3652_3076:()=>Sce,content_3652_3078:()=>Oce,content_3652_308:()=>F5,content_3652_3080:()=>Bce,content_3652_3082:()=>qce,content_3652_3084:()=>Hce,content_3652_3086:()=>Jce,content_3652_3088:()=>eie,content_3652_3090:()=>pie,content_3652_3092:()=>cie,content_3652_3094:()=>lie,content_3652_3096:()=>die,content_3652_3098:()=>kie,content_3652_310:()=>V5,content_3652_3100:()=>Mie,content_3652_3102:()=>wie,content_3652_3104:()=>Cie,content_3652_3106:()=>Lie,content_3652_3108:()=>Nie,content_3652_3110:()=>Wie,content_3652_3112:()=>Sie,content_3652_3114:()=>Oie,content_3652_3116:()=>Bie,content_3652_3118:()=>qie,content_3652_312:()=>Y5,content_3652_3120:()=>Hie,content_3652_3122:()=>Jie,content_3652_3124:()=>eae,content_3652_3126:()=>pae,content_3652_3128:()=>cae,content_3652_3130:()=>lae,content_3652_3132:()=>dae,content_3652_3134:()=>kae,content_3652_3136:()=>Mae,content_3652_3138:()=>wae,content_3652_314:()=>$5,content_3652_3140:()=>Cae,content_3652_3142:()=>Lae,content_3652_3144:()=>Nae,content_3652_3146:()=>Wae,content_3652_3148:()=>Sae,content_3652_3150:()=>Oae,content_3652_3152:()=>Bae,content_3652_3154:()=>qae,content_3652_3156:()=>Hae,content_3652_3158:()=>Jae,content_3652_316:()=>t1,content_3652_3160:()=>ele,content_3652_3162:()=>ple,content_3652_3164:()=>cle,content_3652_3166:()=>lle,content_3652_3168:()=>dle,content_3652_3170:()=>kle,content_3652_3172:()=>Mle,content_3652_3174:()=>wle,content_3652_3176:()=>Cle,content_3652_3178:()=>Lle,content_3652_318:()=>o1,content_3652_3180:()=>Nle,content_3652_3182:()=>Wle,content_3652_3184:()=>Sle,content_3652_3186:()=>Ole,content_3652_3188:()=>Ble,content_3652_3190:()=>qle,content_3652_3192:()=>Hle,content_3652_3194:()=>Jle,content_3652_3196:()=>eue,content_3652_3198:()=>pue,content_3652_32:()=>s$,content_3652_320:()=>s1,content_3652_3200:()=>cue,content_3652_3202:()=>lue,content_3652_3204:()=>due,content_3652_3206:()=>kue,content_3652_3208:()=>Mue,content_3652_3210:()=>wue,content_3652_3212:()=>Cue,content_3652_3214:()=>Lue,content_3652_3216:()=>Nue,content_3652_3218:()=>Wue,content_3652_322:()=>a1,content_3652_3220:()=>Sue,content_3652_3222:()=>Oue,content_3652_3224:()=>Bue,content_3652_3226:()=>que,content_3652_3228:()=>Hue,content_3652_3230:()=>Jue,content_3652_3232:()=>eme,content_3652_3234:()=>pme,content_3652_3236:()=>cme,content_3652_3238:()=>lme,content_3652_324:()=>m1,content_3652_3240:()=>dme,content_3652_3242:()=>kme,content_3652_3244:()=>Mme,content_3652_3246:()=>wme,content_3652_3248:()=>Cme,content_3652_3250:()=>Lme,content_3652_3252:()=>Nme,content_3652_3254:()=>Wme,content_3652_3256:()=>Sme,content_3652_3258:()=>Ome,content_3652_326:()=>f1,content_3652_3260:()=>Bme,content_3652_3262:()=>qme,content_3652_3264:()=>Hme,content_3652_3266:()=>Jme,content_3652_3268:()=>ede,content_3652_3270:()=>pde,content_3652_3272:()=>cde,content_3652_3274:()=>lde,content_3652_3276:()=>dde,content_3652_3278:()=>kde,content_3652_328:()=>D1,content_3652_3280:()=>Mde,content_3652_3282:()=>wde,content_3652_3284:()=>Cde,content_3652_3286:()=>Lde,content_3652_3288:()=>Nde,content_3652_3290:()=>Wde,content_3652_3292:()=>Sde,content_3652_3294:()=>Ode,content_3652_3296:()=>Bde,content_3652_3298:()=>qde,content_3652_330:()=>_1,content_3652_3300:()=>Hde,content_3652_3302:()=>Jde,content_3652_3304:()=>ehe,content_3652_3306:()=>phe,content_3652_3308:()=>che,content_3652_3310:()=>lhe,content_3652_3312:()=>dhe,content_3652_3314:()=>khe,content_3652_3316:()=>Mhe,content_3652_3318:()=>whe,content_3652_332:()=>g1,content_3652_3320:()=>Che,content_3652_3322:()=>Lhe,content_3652_3324:()=>Nhe,content_3652_3326:()=>Whe,content_3652_3328:()=>She,content_3652_3330:()=>Ohe,content_3652_3332:()=>Bhe,content_3652_3334:()=>qhe,content_3652_3336:()=>Hhe,content_3652_3338:()=>Jhe,content_3652_334:()=>v1,content_3652_3340:()=>efe,content_3652_3342:()=>pfe,content_3652_3344:()=>cfe,content_3652_3346:()=>lfe,content_3652_3348:()=>dfe,content_3652_3350:()=>kfe,content_3652_3352:()=>Mfe,content_3652_3354:()=>wfe,content_3652_3356:()=>Cfe,content_3652_3358:()=>Lfe,content_3652_336:()=>b1,content_3652_3360:()=>Nfe,content_3652_3362:()=>Wfe,content_3652_3364:()=>Sfe,content_3652_3366:()=>Ofe,content_3652_3368:()=>Bfe,content_3652_3370:()=>qfe,content_3652_3372:()=>Hfe,content_3652_3374:()=>Jfe,content_3652_3376:()=>eke,content_3652_3378:()=>pke,content_3652_338:()=>z1,content_3652_3380:()=>cke,content_3652_3382:()=>lke,content_3652_3384:()=>dke,content_3652_3386:()=>kke,content_3652_3388:()=>Mke,content_3652_3390:()=>wke,content_3652_3392:()=>Cke,content_3652_3394:()=>Lke,content_3652_3396:()=>Nke,content_3652_3398:()=>Wke,content_3652_34:()=>a$,content_3652_340:()=>R1,content_3652_3400:()=>Ske,content_3652_3402:()=>Oke,content_3652_3404:()=>Bke,content_3652_3406:()=>qke,content_3652_3408:()=>Hke,content_3652_3410:()=>Jke,content_3652_3412:()=>eye,content_3652_3414:()=>pye,content_3652_3416:()=>cye,content_3652_3418:()=>lye,content_3652_342:()=>E1,content_3652_3420:()=>dye,content_3652_3422:()=>kye,content_3652_3424:()=>Mye,content_3652_3426:()=>wye,content_3652_3428:()=>Cye,content_3652_3430:()=>Lye,content_3652_3432:()=>Nye,content_3652_3434:()=>Wye,content_3652_3436:()=>Sye,content_3652_3438:()=>Oye,content_3652_344:()=>F1,content_3652_3440:()=>Bye,content_3652_3442:()=>qye,content_3652_3444:()=>Hye,content_3652_3446:()=>Jye,content_3652_3448:()=>eDe,content_3652_3450:()=>pDe,content_3652_3452:()=>cDe,content_3652_3454:()=>lDe,content_3652_3456:()=>dDe,content_3652_3458:()=>kDe,content_3652_346:()=>V1,content_3652_3460:()=>MDe,content_3652_3462:()=>wDe,content_3652_3464:()=>CDe,content_3652_3466:()=>LDe,content_3652_3468:()=>NDe,content_3652_3470:()=>WDe,content_3652_3472:()=>SDe,content_3652_3474:()=>ODe,content_3652_3476:()=>BDe,content_3652_3478:()=>qDe,content_3652_348:()=>Y1,content_3652_3480:()=>HDe,content_3652_3482:()=>JDe,content_3652_3484:()=>eMe,content_3652_3486:()=>pMe,content_3652_3488:()=>cMe,content_3652_3490:()=>lMe,content_3652_3492:()=>dMe,content_3652_3494:()=>kMe,content_3652_3496:()=>MMe,content_3652_3498:()=>wMe,content_3652_350:()=>$1,content_3652_3500:()=>CMe,content_3652_3502:()=>LMe,content_3652_3504:()=>NMe,content_3652_3506:()=>WMe,content_3652_3508:()=>SMe,content_3652_3510:()=>OMe,content_3652_3512:()=>BMe,content_3652_3514:()=>qMe,content_3652_3516:()=>HMe,content_3652_3518:()=>JMe,content_3652_352:()=>t4,content_3652_3520:()=>eXe,content_3652_3522:()=>pXe,content_3652_3524:()=>cXe,content_3652_3526:()=>lXe,content_3652_3528:()=>dXe,content_3652_3530:()=>kXe,content_3652_3532:()=>MXe,content_3652_3534:()=>wXe,content_3652_3536:()=>CXe,content_3652_3538:()=>LXe,content_3652_354:()=>o4,content_3652_3540:()=>NXe,content_3652_3542:()=>WXe,content_3652_3544:()=>SXe,content_3652_3546:()=>OXe,content_3652_3548:()=>BXe,content_3652_3550:()=>qXe,content_3652_3552:()=>HXe,content_3652_3554:()=>JXe,content_3652_3556:()=>e_e,content_3652_3558:()=>p_e,content_3652_356:()=>s4,content_3652_3560:()=>c_e,content_3652_3562:()=>l_e,content_3652_3564:()=>d_e,content_3652_3566:()=>k_e,content_3652_3568:()=>M_e,content_3652_3570:()=>w_e,content_3652_3572:()=>C_e,content_3652_3574:()=>L_e,content_3652_3576:()=>N_e,content_3652_3578:()=>W_e,content_3652_358:()=>a4,content_3652_3580:()=>S_e,content_3652_3582:()=>O_e,content_3652_3584:()=>B_e,content_3652_3586:()=>q_e,content_3652_3588:()=>H_e,content_3652_3590:()=>J_e,content_3652_3592:()=>ewe,content_3652_3594:()=>pwe,content_3652_3596:()=>cwe,content_3652_3598:()=>lwe,content_3652_36:()=>m$,content_3652_360:()=>m4,content_3652_3600:()=>dwe,content_3652_3602:()=>kwe,content_3652_3604:()=>Mwe,content_3652_3606:()=>wwe,content_3652_3608:()=>Cwe,content_3652_3610:()=>Lwe,content_3652_3612:()=>Nwe,content_3652_3614:()=>Wwe,content_3652_3616:()=>Swe,content_3652_3618:()=>Owe,content_3652_362:()=>f4,content_3652_3620:()=>Bwe,content_3652_3622:()=>qwe,content_3652_3624:()=>Hwe,content_3652_3626:()=>Jwe,content_3652_3628:()=>eTe,content_3652_3630:()=>pTe,content_3652_3632:()=>cTe,content_3652_3634:()=>lTe,content_3652_3636:()=>dTe,content_3652_3638:()=>kTe,content_3652_364:()=>D4,content_3652_3640:()=>MTe,content_3652_3642:()=>wTe,content_3652_3644:()=>CTe,content_3652_3646:()=>LTe,content_3652_3648:()=>NTe,content_3652_3650:()=>WTe,content_3652_3652:()=>STe,content_3652_3654:()=>OTe,content_3652_3656:()=>BTe,content_3652_3658:()=>qTe,content_3652_366:()=>_4,content_3652_3660:()=>HTe,content_3652_3662:()=>JTe,content_3652_3664:()=>ege,content_3652_3666:()=>pge,content_3652_3668:()=>cge,content_3652_3670:()=>lge,content_3652_3672:()=>dge,content_3652_3674:()=>kge,content_3652_3676:()=>Mge,content_3652_3678:()=>wge,content_3652_368:()=>g4,content_3652_3680:()=>Cge,content_3652_3682:()=>Lge,content_3652_3684:()=>Nge,content_3652_3686:()=>Wge,content_3652_3688:()=>Sge,content_3652_3690:()=>Oge,content_3652_3692:()=>Bge,content_3652_3694:()=>qge,content_3652_3696:()=>Hge,content_3652_3698:()=>Jge,content_3652_370:()=>v4,content_3652_3700:()=>eCe,content_3652_3702:()=>pCe,content_3652_3704:()=>cCe,content_3652_3706:()=>lCe,content_3652_3708:()=>dCe,content_3652_3710:()=>kCe,content_3652_3712:()=>MCe,content_3652_3714:()=>wCe,content_3652_3716:()=>CCe,content_3652_3718:()=>LCe,content_3652_372:()=>b4,content_3652_3720:()=>NCe,content_3652_3722:()=>WCe,content_3652_3724:()=>SCe,content_3652_3726:()=>OCe,content_3652_3728:()=>BCe,content_3652_3730:()=>qCe,content_3652_3732:()=>HCe,content_3652_3734:()=>JCe,content_3652_3736:()=>exe,content_3652_3738:()=>pxe,content_3652_374:()=>z4,content_3652_3740:()=>cxe,content_3652_3742:()=>lxe,content_3652_3744:()=>dxe,content_3652_3746:()=>kxe,content_3652_3748:()=>Mxe,content_3652_3750:()=>wxe,content_3652_3752:()=>Cxe,content_3652_3754:()=>Lxe,content_3652_3756:()=>Nxe,content_3652_3758:()=>Wxe,content_3652_376:()=>R4,content_3652_3760:()=>Sxe,content_3652_3762:()=>Oxe,content_3652_3764:()=>Bxe,content_3652_3766:()=>qxe,content_3652_3768:()=>Hxe,content_3652_3770:()=>Jxe,content_3652_3772:()=>eve,content_3652_3774:()=>pve,content_3652_3776:()=>cve,content_3652_3778:()=>lve,content_3652_378:()=>E4,content_3652_3780:()=>dve,content_3652_3782:()=>kve,content_3652_3784:()=>Mve,content_3652_3786:()=>wve,content_3652_3788:()=>Cve,content_3652_3790:()=>Lve,content_3652_3792:()=>Nve,content_3652_3794:()=>Wve,content_3652_3796:()=>Sve,content_3652_3798:()=>Ove,content_3652_38:()=>f$,content_3652_380:()=>F4,content_3652_3800:()=>Bve,content_3652_3802:()=>qve,content_3652_3804:()=>Hve,content_3652_3806:()=>Jve,content_3652_3808:()=>eLe,content_3652_3810:()=>pLe,content_3652_3812:()=>cLe,content_3652_3814:()=>lLe,content_3652_3816:()=>dLe,content_3652_3818:()=>kLe,content_3652_382:()=>V4,content_3652_3820:()=>MLe,content_3652_3822:()=>wLe,content_3652_3824:()=>CLe,content_3652_3826:()=>LLe,content_3652_3828:()=>NLe,content_3652_3830:()=>WLe,content_3652_3832:()=>SLe,content_3652_3834:()=>OLe,content_3652_3836:()=>BLe,content_3652_3838:()=>qLe,content_3652_384:()=>Y4,content_3652_3840:()=>HLe,content_3652_3842:()=>JLe,content_3652_3844:()=>eZe,content_3652_3846:()=>pZe,content_3652_3848:()=>cZe,content_3652_3850:()=>lZe,content_3652_3852:()=>dZe,content_3652_3854:()=>kZe,content_3652_3856:()=>MZe,content_3652_3858:()=>wZe,content_3652_386:()=>$4,content_3652_3860:()=>CZe,content_3652_3862:()=>LZe,content_3652_3864:()=>NZe,content_3652_3866:()=>WZe,content_3652_3868:()=>SZe,content_3652_3870:()=>OZe,content_3652_3872:()=>BZe,content_3652_3874:()=>qZe,content_3652_3876:()=>HZe,content_3652_3878:()=>JZe,content_3652_388:()=>t8,content_3652_3880:()=>ebe,content_3652_3882:()=>pbe,content_3652_3884:()=>cbe,content_3652_3886:()=>lbe,content_3652_3888:()=>dbe,content_3652_3890:()=>kbe,content_3652_3892:()=>Mbe,content_3652_3894:()=>wbe,content_3652_3896:()=>Cbe,content_3652_3898:()=>Lbe,content_3652_390:()=>o8,content_3652_3900:()=>Nbe,content_3652_3902:()=>Wbe,content_3652_3904:()=>Sbe,content_3652_3906:()=>Obe,content_3652_3908:()=>Bbe,content_3652_3910:()=>qbe,content_3652_3912:()=>Hbe,content_3652_3914:()=>Jbe,content_3652_3916:()=>eNe,content_3652_3918:()=>pNe,content_3652_392:()=>s8,content_3652_3920:()=>cNe,content_3652_3922:()=>lNe,content_3652_3924:()=>dNe,content_3652_3926:()=>kNe,content_3652_3928:()=>MNe,content_3652_3930:()=>wNe,content_3652_3932:()=>CNe,content_3652_3934:()=>LNe,content_3652_3936:()=>NNe,content_3652_3938:()=>WNe,content_3652_394:()=>a8,content_3652_3940:()=>SNe,content_3652_3942:()=>ONe,content_3652_3944:()=>BNe,content_3652_3946:()=>qNe,content_3652_3948:()=>HNe,content_3652_3950:()=>JNe,content_3652_3952:()=>eAe,content_3652_3954:()=>pAe,content_3652_3956:()=>cAe,content_3652_3958:()=>lAe,content_3652_396:()=>m8,content_3652_3960:()=>dAe,content_3652_3962:()=>kAe,content_3652_3964:()=>MAe,content_3652_3966:()=>wAe,content_3652_3968:()=>CAe,content_3652_3970:()=>LAe,content_3652_3972:()=>NAe,content_3652_3974:()=>WAe,content_3652_3976:()=>SAe,content_3652_3978:()=>OAe,content_3652_398:()=>f8,content_3652_3980:()=>BAe,content_3652_3982:()=>qAe,content_3652_3984:()=>HAe,content_3652_3986:()=>JAe,content_3652_3988:()=>eze,content_3652_3990:()=>pze,content_3652_3992:()=>cze,content_3652_3994:()=>lze,content_3652_3996:()=>dze,content_3652_3998:()=>kze,content_3652_4:()=>DQ,content_3652_40:()=>D$,content_3652_400:()=>D8,content_3652_4000:()=>Mze,content_3652_4002:()=>wze,content_3652_4004:()=>Cze,content_3652_4006:()=>Lze,content_3652_4008:()=>Nze,content_3652_4010:()=>Wze,content_3652_4012:()=>Sze,content_3652_4014:()=>Oze,content_3652_4016:()=>Bze,content_3652_4018:()=>qze,content_3652_402:()=>_8,content_3652_4020:()=>Hze,content_3652_4022:()=>Jze,content_3652_4024:()=>eWe,content_3652_4026:()=>pWe,content_3652_4028:()=>cWe,content_3652_4030:()=>lWe,content_3652_4032:()=>dWe,content_3652_4034:()=>kWe,content_3652_4036:()=>MWe,content_3652_4038:()=>wWe,content_3652_404:()=>g8,content_3652_4040:()=>CWe,content_3652_4042:()=>LWe,content_3652_4044:()=>NWe,content_3652_4046:()=>WWe,content_3652_4048:()=>SWe,content_3652_4050:()=>OWe,content_3652_4052:()=>BWe,content_3652_4054:()=>qWe,content_3652_4056:()=>HWe,content_3652_4058:()=>JWe,content_3652_406:()=>v8,content_3652_4060:()=>eIe,content_3652_4062:()=>pIe,content_3652_4064:()=>cIe,content_3652_4066:()=>lIe,content_3652_4068:()=>dIe,content_3652_4070:()=>kIe,content_3652_4072:()=>MIe,content_3652_4074:()=>wIe,content_3652_4076:()=>CIe,content_3652_4078:()=>LIe,content_3652_408:()=>b8,content_3652_4080:()=>NIe,content_3652_4082:()=>WIe,content_3652_4084:()=>SIe,content_3652_4086:()=>OIe,content_3652_4088:()=>BIe,content_3652_4090:()=>qIe,content_3652_4092:()=>HIe,content_3652_4094:()=>JIe,content_3652_4096:()=>eRe,content_3652_4098:()=>pRe,content_3652_410:()=>z8,content_3652_4100:()=>cRe,content_3652_4102:()=>lRe,content_3652_4104:()=>dRe,content_3652_4106:()=>kRe,content_3652_4108:()=>MRe,content_3652_4110:()=>wRe,content_3652_4112:()=>CRe,content_3652_4114:()=>LRe,content_3652_4116:()=>NRe,content_3652_4118:()=>WRe,content_3652_412:()=>R8,content_3652_4120:()=>SRe,content_3652_4122:()=>ORe,content_3652_4124:()=>BRe,content_3652_4126:()=>qRe,content_3652_4128:()=>HRe,content_3652_4130:()=>JRe,content_3652_4132:()=>eSe,content_3652_4134:()=>pSe,content_3652_4136:()=>cSe,content_3652_4138:()=>lSe,content_3652_414:()=>E8,content_3652_4140:()=>dSe,content_3652_4142:()=>kSe,content_3652_4144:()=>MSe,content_3652_4146:()=>wSe,content_3652_4148:()=>CSe,content_3652_4150:()=>LSe,content_3652_4152:()=>NSe,content_3652_4154:()=>WSe,content_3652_4156:()=>SSe,content_3652_4158:()=>OSe,content_3652_416:()=>F8,content_3652_4160:()=>BSe,content_3652_4162:()=>qSe,content_3652_4164:()=>HSe,content_3652_4166:()=>JSe,content_3652_4168:()=>ePe,content_3652_4170:()=>pPe,content_3652_4172:()=>cPe,content_3652_4174:()=>lPe,content_3652_4176:()=>dPe,content_3652_4178:()=>kPe,content_3652_418:()=>V8,content_3652_4180:()=>MPe,content_3652_4182:()=>wPe,content_3652_4184:()=>CPe,content_3652_4186:()=>LPe,content_3652_4188:()=>NPe,content_3652_4190:()=>WPe,content_3652_4192:()=>SPe,content_3652_4194:()=>OPe,content_3652_4196:()=>BPe,content_3652_4198:()=>qPe,content_3652_42:()=>_$,content_3652_420:()=>Y8,content_3652_4200:()=>HPe,content_3652_4202:()=>JPe,content_3652_4204:()=>eEe,content_3652_4206:()=>pEe,content_3652_4208:()=>cEe,content_3652_4210:()=>lEe,content_3652_4212:()=>dEe,content_3652_4214:()=>kEe,content_3652_4216:()=>MEe,content_3652_4218:()=>wEe,content_3652_422:()=>$8,content_3652_4220:()=>CEe,content_3652_4222:()=>LEe,content_3652_4224:()=>NEe,content_3652_4226:()=>WEe,content_3652_4228:()=>SEe,content_3652_4230:()=>OEe,content_3652_4232:()=>BEe,content_3652_4234:()=>qEe,content_3652_4236:()=>HEe,content_3652_4238:()=>JEe,content_3652_424:()=>t7,content_3652_4240:()=>eOe,content_3652_4242:()=>pOe,content_3652_4244:()=>cOe,content_3652_4246:()=>lOe,content_3652_4248:()=>dOe,content_3652_4250:()=>kOe,content_3652_4252:()=>MOe,content_3652_4254:()=>wOe,content_3652_4256:()=>COe,content_3652_4258:()=>LOe,content_3652_426:()=>o7,content_3652_4260:()=>NOe,content_3652_4262:()=>WOe,content_3652_4264:()=>SOe,content_3652_4266:()=>OOe,content_3652_4268:()=>BOe,content_3652_4270:()=>qOe,content_3652_4272:()=>HOe,content_3652_4274:()=>JOe,content_3652_4276:()=>eGe,content_3652_4278:()=>pGe,content_3652_428:()=>s7,content_3652_4280:()=>cGe,content_3652_4282:()=>lGe,content_3652_4284:()=>dGe,content_3652_4286:()=>kGe,content_3652_4288:()=>MGe,content_3652_4290:()=>wGe,content_3652_4292:()=>CGe,content_3652_4294:()=>LGe,content_3652_4296:()=>NGe,content_3652_4298:()=>WGe,content_3652_430:()=>a7,content_3652_4300:()=>SGe,content_3652_4302:()=>OGe,content_3652_4304:()=>BGe,content_3652_4306:()=>qGe,content_3652_4308:()=>HGe,content_3652_4310:()=>JGe,content_3652_4312:()=>eFe,content_3652_4314:()=>pFe,content_3652_4316:()=>cFe,content_3652_4318:()=>lFe,content_3652_432:()=>m7,content_3652_4320:()=>dFe,content_3652_4322:()=>kFe,content_3652_4324:()=>MFe,content_3652_4326:()=>wFe,content_3652_4328:()=>CFe,content_3652_4330:()=>LFe,content_3652_4332:()=>NFe,content_3652_4334:()=>WFe,content_3652_4336:()=>SFe,content_3652_4338:()=>OFe,content_3652_434:()=>f7,content_3652_4340:()=>BFe,content_3652_4342:()=>qFe,content_3652_4344:()=>HFe,content_3652_4346:()=>JFe,content_3652_4348:()=>eBe,content_3652_4350:()=>pBe,content_3652_4352:()=>cBe,content_3652_4354:()=>lBe,content_3652_4356:()=>dBe,content_3652_4358:()=>kBe,content_3652_436:()=>D7,content_3652_4360:()=>MBe,content_3652_4362:()=>wBe,content_3652_4364:()=>CBe,content_3652_4366:()=>LBe,content_3652_4368:()=>NBe,content_3652_4370:()=>WBe,content_3652_4372:()=>SBe,content_3652_4374:()=>OBe,content_3652_4376:()=>BBe,content_3652_4378:()=>qBe,content_3652_438:()=>_7,content_3652_4380:()=>HBe,content_3652_4382:()=>JBe,content_3652_4384:()=>eUe,content_3652_4386:()=>pUe,content_3652_4388:()=>cUe,content_3652_4390:()=>lUe,content_3652_4392:()=>dUe,content_3652_4394:()=>kUe,content_3652_4396:()=>MUe,content_3652_4398:()=>wUe,content_3652_44:()=>g$,content_3652_440:()=>g7,content_3652_4400:()=>CUe,content_3652_4402:()=>LUe,content_3652_4404:()=>NUe,content_3652_4406:()=>WUe,content_3652_4408:()=>SUe,content_3652_4410:()=>OUe,content_3652_4412:()=>BUe,content_3652_4414:()=>qUe,content_3652_4416:()=>HUe,content_3652_4418:()=>JUe,content_3652_442:()=>v7,content_3652_4420:()=>eVe,content_3652_4422:()=>pVe,content_3652_4424:()=>cVe,content_3652_4426:()=>lVe,content_3652_4428:()=>dVe,content_3652_4430:()=>kVe,content_3652_4432:()=>MVe,content_3652_4434:()=>wVe,content_3652_4436:()=>CVe,content_3652_4438:()=>LVe,content_3652_444:()=>b7,content_3652_4440:()=>NVe,content_3652_4442:()=>WVe,content_3652_4444:()=>SVe,content_3652_4446:()=>OVe,content_3652_4448:()=>BVe,content_3652_4450:()=>qVe,content_3652_4452:()=>HVe,content_3652_4454:()=>JVe,content_3652_4456:()=>eqe,content_3652_4458:()=>pqe,content_3652_446:()=>z7,content_3652_4460:()=>cqe,content_3652_4462:()=>lqe,content_3652_4464:()=>dqe,content_3652_4466:()=>kqe,content_3652_4468:()=>Mqe,content_3652_4470:()=>wqe,content_3652_4472:()=>Cqe,content_3652_4474:()=>Lqe,content_3652_4476:()=>Nqe,content_3652_4478:()=>Wqe,content_3652_448:()=>R7,content_3652_4480:()=>Sqe,content_3652_4482:()=>Oqe,content_3652_4484:()=>Bqe,content_3652_4486:()=>qqe,content_3652_4488:()=>Hqe,content_3652_4490:()=>Jqe,content_3652_4492:()=>eje,content_3652_4494:()=>pje,content_3652_4496:()=>cje,content_3652_4498:()=>lje,content_3652_450:()=>E7,content_3652_4500:()=>dje,content_3652_4502:()=>kje,content_3652_4504:()=>Mje,content_3652_4506:()=>wje,content_3652_4508:()=>Cje,content_3652_4510:()=>Lje,content_3652_4512:()=>Nje,content_3652_4514:()=>Wje,content_3652_4516:()=>Sje,content_3652_4518:()=>Oje,content_3652_452:()=>F7,content_3652_4520:()=>Bje,content_3652_4522:()=>qje,content_3652_4524:()=>Hje,content_3652_4526:()=>Jje,content_3652_4528:()=>eYe,content_3652_4530:()=>pYe,content_3652_4532:()=>cYe,content_3652_4534:()=>lYe,content_3652_4536:()=>dYe,content_3652_4538:()=>kYe,content_3652_454:()=>V7,content_3652_4540:()=>MYe,content_3652_4542:()=>wYe,content_3652_4544:()=>CYe,content_3652_4546:()=>LYe,content_3652_4548:()=>NYe,content_3652_4550:()=>WYe,content_3652_4552:()=>SYe,content_3652_4554:()=>OYe,content_3652_4556:()=>BYe,content_3652_4558:()=>qYe,content_3652_456:()=>Y7,content_3652_4560:()=>HYe,content_3652_4562:()=>JYe,content_3652_4564:()=>eHe,content_3652_4566:()=>pHe,content_3652_4568:()=>cHe,content_3652_4570:()=>lHe,content_3652_4572:()=>dHe,content_3652_4574:()=>kHe,content_3652_4576:()=>MHe,content_3652_4578:()=>wHe,content_3652_458:()=>$7,content_3652_4580:()=>CHe,content_3652_4582:()=>LHe,content_3652_4584:()=>NHe,content_3652_4586:()=>WHe,content_3652_4588:()=>SHe,content_3652_4590:()=>OHe,content_3652_4592:()=>BHe,content_3652_4594:()=>qHe,content_3652_4596:()=>HHe,content_3652_4598:()=>JHe,content_3652_46:()=>v$,content_3652_460:()=>t9,content_3652_4600:()=>eQe,content_3652_4602:()=>pQe,content_3652_4604:()=>cQe,content_3652_4606:()=>lQe,content_3652_4608:()=>dQe,content_3652_4610:()=>kQe,content_3652_4612:()=>MQe,content_3652_4614:()=>wQe,content_3652_4616:()=>CQe,content_3652_4618:()=>LQe,content_3652_462:()=>o9,content_3652_4620:()=>NQe,content_3652_4622:()=>WQe,content_3652_4624:()=>SQe,content_3652_4626:()=>OQe,content_3652_4628:()=>BQe,content_3652_4630:()=>qQe,content_3652_4632:()=>HQe,content_3652_4634:()=>JQe,content_3652_4636:()=>e$e,content_3652_4638:()=>p$e,content_3652_464:()=>s9,content_3652_4640:()=>c$e,content_3652_4642:()=>l$e,content_3652_4644:()=>d$e,content_3652_4646:()=>k$e,content_3652_4648:()=>M$e,content_3652_4650:()=>w$e,content_3652_4652:()=>C$e,content_3652_4654:()=>L$e,content_3652_4656:()=>N$e,content_3652_4658:()=>W$e,content_3652_466:()=>a9,content_3652_4660:()=>S$e,content_3652_4662:()=>O$e,content_3652_4664:()=>B$e,content_3652_4666:()=>q$e,content_3652_4668:()=>H$e,content_3652_4670:()=>J$e,content_3652_4672:()=>eJe,content_3652_4674:()=>pJe,content_3652_4676:()=>cJe,content_3652_4678:()=>lJe,content_3652_468:()=>m9,content_3652_4680:()=>dJe,content_3652_4682:()=>kJe,content_3652_4684:()=>MJe,content_3652_4686:()=>wJe,content_3652_4688:()=>CJe,content_3652_4690:()=>LJe,content_3652_4692:()=>NJe,content_3652_4694:()=>WJe,content_3652_4696:()=>SJe,content_3652_4698:()=>OJe,content_3652_470:()=>f9,content_3652_4700:()=>BJe,content_3652_4702:()=>qJe,content_3652_4704:()=>HJe,content_3652_4706:()=>JJe,content_3652_4708:()=>eKe,content_3652_4710:()=>pKe,content_3652_4712:()=>cKe,content_3652_4714:()=>lKe,content_3652_4716:()=>dKe,content_3652_4718:()=>kKe,content_3652_472:()=>D9,content_3652_4720:()=>MKe,content_3652_4722:()=>wKe,content_3652_4724:()=>CKe,content_3652_4726:()=>LKe,content_3652_4728:()=>NKe,content_3652_4730:()=>WKe,content_3652_4732:()=>SKe,content_3652_4734:()=>OKe,content_3652_4736:()=>BKe,content_3652_4738:()=>qKe,content_3652_474:()=>_9,content_3652_4740:()=>HKe,content_3652_4742:()=>JKe,content_3652_4744:()=>e0e,content_3652_4746:()=>p0e,content_3652_4748:()=>c0e,content_3652_4750:()=>l0e,content_3652_4752:()=>d0e,content_3652_4754:()=>k0e,content_3652_4756:()=>M0e,content_3652_4758:()=>w0e,content_3652_476:()=>g9,content_3652_4760:()=>C0e,content_3652_4762:()=>L0e,content_3652_4764:()=>N0e,content_3652_4766:()=>W0e,content_3652_4768:()=>S0e,content_3652_4770:()=>O0e,content_3652_4772:()=>B0e,content_3652_4774:()=>q0e,content_3652_4776:()=>H0e,content_3652_4778:()=>J0e,content_3652_478:()=>v9,content_3652_4780:()=>e2e,content_3652_4782:()=>p2e,content_3652_4784:()=>c2e,content_3652_4786:()=>l2e,content_3652_4788:()=>d2e,content_3652_4790:()=>k2e,content_3652_4792:()=>M2e,content_3652_4794:()=>w2e,content_3652_4796:()=>C2e,content_3652_4798:()=>L2e,content_3652_48:()=>b$,content_3652_480:()=>b9,content_3652_4800:()=>N2e,content_3652_4802:()=>W2e,content_3652_4804:()=>S2e,content_3652_4806:()=>O2e,content_3652_4808:()=>B2e,content_3652_4810:()=>q2e,content_3652_4812:()=>H2e,content_3652_4814:()=>J2e,content_3652_4816:()=>e6e,content_3652_4818:()=>p6e,content_3652_482:()=>z9,content_3652_4820:()=>c6e,content_3652_4822:()=>l6e,content_3652_4824:()=>d6e,content_3652_4826:()=>k6e,content_3652_4828:()=>M6e,content_3652_4830:()=>w6e,content_3652_4832:()=>C6e,content_3652_4834:()=>L6e,content_3652_4836:()=>N6e,content_3652_4838:()=>W6e,content_3652_484:()=>R9,content_3652_4840:()=>S6e,content_3652_4842:()=>O6e,content_3652_4844:()=>B6e,content_3652_4846:()=>q6e,content_3652_4848:()=>H6e,content_3652_4850:()=>J6e,content_3652_4852:()=>e3e,content_3652_4854:()=>p3e,content_3652_4856:()=>c3e,content_3652_4858:()=>l3e,content_3652_486:()=>E9,content_3652_4860:()=>d3e,content_3652_4862:()=>k3e,content_3652_4864:()=>M3e,content_3652_4866:()=>w3e,content_3652_4868:()=>C3e,content_3652_4870:()=>L3e,content_3652_4872:()=>N3e,content_3652_4874:()=>W3e,content_3652_4876:()=>S3e,content_3652_4878:()=>O3e,content_3652_488:()=>F9,content_3652_4880:()=>B3e,content_3652_4882:()=>q3e,content_3652_4884:()=>H3e,content_3652_4886:()=>J3e,content_3652_4888:()=>e5e,content_3652_4890:()=>p5e,content_3652_4892:()=>c5e,content_3652_4894:()=>l5e,content_3652_4896:()=>d5e,content_3652_4898:()=>k5e,content_3652_490:()=>V9,content_3652_4900:()=>M5e,content_3652_4902:()=>w5e,content_3652_4904:()=>C5e,content_3652_4906:()=>L5e,content_3652_4908:()=>N5e,content_3652_4910:()=>W5e,content_3652_4912:()=>S5e,content_3652_4914:()=>O5e,content_3652_4916:()=>B5e,content_3652_4918:()=>q5e,content_3652_492:()=>Y9,content_3652_4920:()=>H5e,content_3652_4922:()=>J5e,content_3652_4924:()=>e1e,content_3652_4926:()=>p1e,content_3652_4928:()=>c1e,content_3652_4930:()=>l1e,content_3652_4932:()=>d1e,content_3652_4934:()=>k1e,content_3652_4936:()=>M1e,content_3652_4938:()=>w1e,content_3652_494:()=>$9,content_3652_4940:()=>C1e,content_3652_4942:()=>L1e,content_3652_4944:()=>N1e,content_3652_4946:()=>W1e,content_3652_4948:()=>S1e,content_3652_4950:()=>O1e,content_3652_4952:()=>B1e,content_3652_4954:()=>q1e,content_3652_4956:()=>H1e,content_3652_4958:()=>J1e,content_3652_496:()=>ttt,content_3652_4960:()=>e4e,content_3652_4962:()=>p4e,content_3652_4964:()=>c4e,content_3652_4966:()=>l4e,content_3652_4968:()=>d4e,content_3652_4970:()=>k4e,content_3652_4972:()=>M4e,content_3652_4974:()=>w4e,content_3652_4976:()=>C4e,content_3652_4978:()=>L4e,content_3652_498:()=>ott,content_3652_4980:()=>N4e,content_3652_4982:()=>W4e,content_3652_4984:()=>S4e,content_3652_4986:()=>O4e,content_3652_4988:()=>B4e,content_3652_4990:()=>q4e,content_3652_4992:()=>H4e,content_3652_4994:()=>J4e,content_3652_4996:()=>e8e,content_3652_4998:()=>p8e,content_3652_50:()=>z$,content_3652_500:()=>stt,content_3652_5000:()=>c8e,content_3652_5002:()=>l8e,content_3652_5004:()=>d8e,content_3652_5006:()=>k8e,content_3652_5008:()=>M8e,content_3652_5010:()=>w8e,content_3652_5012:()=>C8e,content_3652_5014:()=>L8e,content_3652_5016:()=>N8e,content_3652_5018:()=>W8e,content_3652_502:()=>att,content_3652_5020:()=>S8e,content_3652_5022:()=>O8e,content_3652_5024:()=>B8e,content_3652_5026:()=>q8e,content_3652_5028:()=>H8e,content_3652_5030:()=>J8e,content_3652_5032:()=>e7e,content_3652_5034:()=>p7e,content_3652_5036:()=>c7e,content_3652_5038:()=>l7e,content_3652_504:()=>mtt,content_3652_5040:()=>d7e,content_3652_5042:()=>k7e,content_3652_5044:()=>M7e,content_3652_5046:()=>w7e,content_3652_5048:()=>C7e,content_3652_5050:()=>L7e,content_3652_5052:()=>N7e,content_3652_5054:()=>W7e,content_3652_5056:()=>S7e,content_3652_5058:()=>O7e,content_3652_506:()=>ftt,content_3652_5060:()=>B7e,content_3652_5062:()=>q7e,content_3652_5064:()=>H7e,content_3652_5066:()=>J7e,content_3652_5068:()=>e9e,content_3652_5070:()=>p9e,content_3652_5072:()=>c9e,content_3652_5074:()=>l9e,content_3652_5076:()=>d9e,content_3652_5078:()=>k9e,content_3652_508:()=>Dtt,content_3652_5080:()=>M9e,content_3652_5082:()=>w9e,content_3652_5084:()=>C9e,content_3652_5086:()=>L9e,content_3652_5088:()=>N9e,content_3652_5090:()=>W9e,content_3652_5092:()=>S9e,content_3652_5094:()=>O9e,content_3652_5096:()=>B9e,content_3652_5098:()=>q9e,content_3652_510:()=>_tt,content_3652_5100:()=>H9e,content_3652_5102:()=>J9e,content_3652_5104:()=>etn,content_3652_5106:()=>ptn,content_3652_5108:()=>ctn,content_3652_5110:()=>ltn,content_3652_5112:()=>dtn,content_3652_5114:()=>ktn,content_3652_5116:()=>Mtn,content_3652_5118:()=>wtn,content_3652_512:()=>gtt,content_3652_5120:()=>Ctn,content_3652_5122:()=>Ltn,content_3652_5124:()=>Ntn,content_3652_5126:()=>Wtn,content_3652_5128:()=>Stn,content_3652_5130:()=>Otn,content_3652_5132:()=>Btn,content_3652_5134:()=>qtn,content_3652_5136:()=>Htn,content_3652_5138:()=>Jtn,content_3652_514:()=>vtt,content_3652_5140:()=>een,content_3652_5142:()=>pen,content_3652_5144:()=>cen,content_3652_5146:()=>len,content_3652_5148:()=>den,content_3652_5150:()=>ken,content_3652_5152:()=>Men,content_3652_5154:()=>wen,content_3652_5156:()=>Cen,content_3652_5158:()=>Len,content_3652_516:()=>btt,content_3652_5160:()=>Nen,content_3652_5162:()=>Wen,content_3652_5164:()=>Sen,content_3652_5166:()=>Oen,content_3652_5168:()=>Ben,content_3652_5170:()=>qen,content_3652_5172:()=>Hen,content_3652_5174:()=>Jen,content_3652_5176:()=>enn,content_3652_5178:()=>pnn,content_3652_518:()=>ztt,content_3652_5180:()=>cnn,content_3652_5182:()=>lnn,content_3652_5184:()=>dnn,content_3652_5186:()=>knn,content_3652_5188:()=>Mnn,content_3652_5190:()=>wnn,content_3652_5192:()=>Cnn,content_3652_5194:()=>Lnn,content_3652_5196:()=>Nnn,content_3652_5198:()=>Wnn,content_3652_52:()=>R$,content_3652_520:()=>Rtt,content_3652_5200:()=>Snn,content_3652_5202:()=>Onn,content_3652_5204:()=>Bnn,content_3652_5206:()=>qnn,content_3652_5208:()=>Hnn,content_3652_5210:()=>Jnn,content_3652_5212:()=>eon,content_3652_5214:()=>pon,content_3652_5216:()=>con,content_3652_5218:()=>lon,content_3652_522:()=>Ett,content_3652_5220:()=>don,content_3652_5222:()=>kon,content_3652_5224:()=>Mon,content_3652_5226:()=>won,content_3652_5228:()=>Con,content_3652_5230:()=>Lon,content_3652_5232:()=>Non,content_3652_5234:()=>Won,content_3652_5236:()=>Son,content_3652_5238:()=>Oon,content_3652_524:()=>Ftt,content_3652_5240:()=>Bon,content_3652_5242:()=>qon,content_3652_5244:()=>Hon,content_3652_5246:()=>Jon,content_3652_5248:()=>epn,content_3652_5250:()=>ppn,content_3652_5252:()=>cpn,content_3652_5254:()=>lpn,content_3652_5256:()=>dpn,content_3652_5258:()=>kpn,content_3652_526:()=>Vtt,content_3652_5260:()=>Mpn,content_3652_5262:()=>wpn,content_3652_5264:()=>Cpn,content_3652_5266:()=>Lpn,content_3652_5268:()=>Npn,content_3652_5270:()=>Wpn,content_3652_5272:()=>Spn,content_3652_5274:()=>Opn,content_3652_5276:()=>Bpn,content_3652_5278:()=>qpn,content_3652_528:()=>Ytt,content_3652_5280:()=>Hpn,content_3652_5282:()=>Jpn,content_3652_5284:()=>ern,content_3652_5286:()=>prn,content_3652_5288:()=>crn,content_3652_5290:()=>lrn,content_3652_5292:()=>drn,content_3652_5294:()=>krn,content_3652_5296:()=>Mrn,content_3652_5298:()=>wrn,content_3652_530:()=>$tt,content_3652_5300:()=>Crn,content_3652_5302:()=>Lrn,content_3652_5304:()=>Nrn,content_3652_5306:()=>Wrn,content_3652_5308:()=>Srn,content_3652_5310:()=>Orn,content_3652_5312:()=>Brn,content_3652_5314:()=>qrn,content_3652_5316:()=>Hrn,content_3652_5318:()=>Jrn,content_3652_532:()=>tet,content_3652_5320:()=>esn,content_3652_5322:()=>psn,content_3652_5324:()=>csn,content_3652_5326:()=>lsn,content_3652_5328:()=>dsn,content_3652_5330:()=>ksn,content_3652_5332:()=>Msn,content_3652_5334:()=>wsn,content_3652_5336:()=>Csn,content_3652_5338:()=>Lsn,content_3652_534:()=>oet,content_3652_5340:()=>Nsn,content_3652_5342:()=>Wsn,content_3652_5344:()=>Ssn,content_3652_5346:()=>Osn,content_3652_5348:()=>Bsn,content_3652_5350:()=>qsn,content_3652_5352:()=>Hsn,content_3652_5354:()=>Jsn,content_3652_5356:()=>ecn,content_3652_5358:()=>pcn,content_3652_536:()=>set,content_3652_5360:()=>ccn,content_3652_5362:()=>lcn,content_3652_5364:()=>dcn,content_3652_5366:()=>kcn,content_3652_5368:()=>Mcn,content_3652_5370:()=>wcn,content_3652_5372:()=>Ccn,content_3652_5374:()=>Lcn,content_3652_5376:()=>Ncn,content_3652_5378:()=>Wcn,content_3652_538:()=>aet,content_3652_5380:()=>Scn,content_3652_5382:()=>Ocn,content_3652_5384:()=>Bcn,content_3652_5386:()=>qcn,content_3652_5388:()=>Hcn,content_3652_5390:()=>Jcn,content_3652_5392:()=>ein,content_3652_5394:()=>pin,content_3652_5396:()=>cin,content_3652_5398:()=>lin,content_3652_54:()=>E$,content_3652_540:()=>det,content_3652_5400:()=>din,content_3652_5402:()=>kin,content_3652_5404:()=>Min,content_3652_5406:()=>win,content_3652_5408:()=>Cin,content_3652_5410:()=>Lin,content_3652_5412:()=>Nin,content_3652_5414:()=>Win,content_3652_5416:()=>Sin,content_3652_5418:()=>Oin,content_3652_542:()=>ket,content_3652_5420:()=>Bin,content_3652_5422:()=>qin,content_3652_5424:()=>Hin,content_3652_5426:()=>Jin,content_3652_5428:()=>ean,content_3652_5430:()=>pan,content_3652_5432:()=>can,content_3652_5434:()=>lan,content_3652_5436:()=>dan,content_3652_5438:()=>kan,content_3652_544:()=>Met,content_3652_5440:()=>Man,content_3652_5442:()=>wan,content_3652_5444:()=>Can,content_3652_5446:()=>Lan,content_3652_5448:()=>Nan,content_3652_5450:()=>Wan,content_3652_5452:()=>San,content_3652_5454:()=>Oan,content_3652_5456:()=>Ban,content_3652_5458:()=>qan,content_3652_546:()=>wet,content_3652_5460:()=>Han,content_3652_5462:()=>Jan,content_3652_5464:()=>eln,content_3652_5466:()=>pln,content_3652_5468:()=>cln,content_3652_5470:()=>lln,content_3652_5472:()=>dln,content_3652_5474:()=>kln,content_3652_5476:()=>Mln,content_3652_5478:()=>wln,content_3652_548:()=>Cet,content_3652_5480:()=>Cln,content_3652_5482:()=>Lln,content_3652_5484:()=>Nln,content_3652_5486:()=>Wln,content_3652_5488:()=>Sln,content_3652_5490:()=>Oln,content_3652_5492:()=>Bln,content_3652_5494:()=>qln,content_3652_5496:()=>Hln,content_3652_5498:()=>Jln,content_3652_550:()=>Let,content_3652_5500:()=>eun,content_3652_5502:()=>pun,content_3652_5504:()=>cun,content_3652_5506:()=>lun,content_3652_5508:()=>dun,content_3652_5510:()=>kun,content_3652_5512:()=>Mun,content_3652_5514:()=>wun,content_3652_5516:()=>Cun,content_3652_5518:()=>Lun,content_3652_552:()=>Net,content_3652_5520:()=>Nun,content_3652_5522:()=>Wun,content_3652_5524:()=>Sun,content_3652_5526:()=>Oun,content_3652_5528:()=>Bun,content_3652_5530:()=>qun,content_3652_5532:()=>Hun,content_3652_5534:()=>Jun,content_3652_5536:()=>emn,content_3652_5538:()=>pmn,content_3652_554:()=>Wet,content_3652_5540:()=>cmn,content_3652_5542:()=>lmn,content_3652_5544:()=>dmn,content_3652_5546:()=>kmn,content_3652_5548:()=>Mmn,content_3652_5550:()=>wmn,content_3652_5552:()=>Cmn,content_3652_5554:()=>Lmn,content_3652_5556:()=>Nmn,content_3652_5558:()=>Wmn,content_3652_556:()=>Set,content_3652_5560:()=>Smn,content_3652_5562:()=>Omn,content_3652_5564:()=>Bmn,content_3652_5566:()=>qmn,content_3652_5568:()=>Hmn,content_3652_5570:()=>Jmn,content_3652_5572:()=>edn,content_3652_5574:()=>pdn,content_3652_5576:()=>cdn,content_3652_5578:()=>ldn,content_3652_558:()=>Oet,content_3652_5580:()=>ddn,content_3652_5582:()=>kdn,content_3652_5584:()=>Mdn,content_3652_5586:()=>wdn,content_3652_5588:()=>Cdn,content_3652_5590:()=>Ldn,content_3652_5592:()=>Ndn,content_3652_5594:()=>Wdn,content_3652_5596:()=>Sdn,content_3652_5598:()=>Odn,content_3652_56:()=>F$,content_3652_560:()=>Bet,content_3652_5600:()=>Bdn,content_3652_5602:()=>qdn,content_3652_5604:()=>Hdn,content_3652_5606:()=>Jdn,content_3652_5608:()=>ehn,content_3652_5610:()=>phn,content_3652_5612:()=>chn,content_3652_5614:()=>lhn,content_3652_5616:()=>dhn,content_3652_5618:()=>khn,content_3652_562:()=>qet,content_3652_5620:()=>Mhn,content_3652_5622:()=>whn,content_3652_5624:()=>Chn,content_3652_5626:()=>Lhn,content_3652_5628:()=>Nhn,content_3652_5630:()=>Whn,content_3652_5632:()=>Shn,content_3652_5634:()=>Ohn,content_3652_5636:()=>Bhn,content_3652_5638:()=>qhn,content_3652_564:()=>Het,content_3652_5640:()=>Hhn,content_3652_5642:()=>Jhn,content_3652_5644:()=>efn,content_3652_5646:()=>pfn,content_3652_5648:()=>cfn,content_3652_5650:()=>lfn,content_3652_5652:()=>dfn,content_3652_5654:()=>kfn,content_3652_5656:()=>Mfn,content_3652_5658:()=>wfn,content_3652_566:()=>Jet,content_3652_5660:()=>Cfn,content_3652_5662:()=>Lfn,content_3652_5664:()=>Nfn,content_3652_5666:()=>Wfn,content_3652_5668:()=>Sfn,content_3652_5670:()=>Ofn,content_3652_5672:()=>Bfn,content_3652_5674:()=>qfn,content_3652_5676:()=>Hfn,content_3652_5678:()=>Jfn,content_3652_568:()=>ent,content_3652_5680:()=>ekn,content_3652_5682:()=>pkn,content_3652_5684:()=>ckn,content_3652_5686:()=>lkn,content_3652_5688:()=>dkn,content_3652_5690:()=>kkn,content_3652_5692:()=>Mkn,content_3652_5694:()=>wkn,content_3652_5696:()=>Ckn,content_3652_5698:()=>Lkn,content_3652_570:()=>pnt,content_3652_5700:()=>Nkn,content_3652_5702:()=>Wkn,content_3652_5704:()=>Skn,content_3652_5706:()=>Okn,content_3652_5708:()=>Bkn,content_3652_5710:()=>qkn,content_3652_5712:()=>Hkn,content_3652_5714:()=>Jkn,content_3652_5716:()=>eyn,content_3652_5718:()=>pyn,content_3652_572:()=>cnt,content_3652_5720:()=>cyn,content_3652_5722:()=>lyn,content_3652_5724:()=>dyn,content_3652_5726:()=>kyn,content_3652_5728:()=>Myn,content_3652_5730:()=>wyn,content_3652_5732:()=>Cyn,content_3652_5734:()=>Lyn,content_3652_5736:()=>Nyn,content_3652_5738:()=>Wyn,content_3652_574:()=>lnt,content_3652_5740:()=>Syn,content_3652_5742:()=>Oyn,content_3652_5744:()=>Byn,content_3652_5746:()=>qyn,content_3652_5748:()=>Hyn,content_3652_5750:()=>Jyn,content_3652_5752:()=>eDn,content_3652_5754:()=>pDn,content_3652_5756:()=>cDn,content_3652_5758:()=>lDn,content_3652_576:()=>dnt,content_3652_5760:()=>dDn,content_3652_5762:()=>kDn,content_3652_5764:()=>MDn,content_3652_5766:()=>wDn,content_3652_5768:()=>CDn,content_3652_5770:()=>LDn,content_3652_5772:()=>NDn,content_3652_5774:()=>WDn,content_3652_5776:()=>SDn,content_3652_5778:()=>ODn,content_3652_578:()=>knt,content_3652_5780:()=>BDn,content_3652_5782:()=>qDn,content_3652_5784:()=>HDn,content_3652_5786:()=>JDn,content_3652_5788:()=>eMn,content_3652_5790:()=>pMn,content_3652_5792:()=>cMn,content_3652_5794:()=>lMn,content_3652_5796:()=>dMn,content_3652_5798:()=>kMn,content_3652_58:()=>V$,content_3652_580:()=>Mnt,content_3652_5800:()=>MMn,content_3652_5802:()=>wMn,content_3652_5804:()=>CMn,content_3652_5806:()=>LMn,content_3652_5808:()=>NMn,content_3652_5810:()=>WMn,content_3652_5812:()=>SMn,content_3652_5814:()=>OMn,content_3652_5816:()=>BMn,content_3652_5818:()=>qMn,content_3652_582:()=>wnt,content_3652_5820:()=>HMn,content_3652_5822:()=>JMn,content_3652_5824:()=>eXn,content_3652_5826:()=>pXn,content_3652_5828:()=>cXn,content_3652_5830:()=>lXn,content_3652_5832:()=>dXn,content_3652_5834:()=>kXn,content_3652_5836:()=>MXn,content_3652_5838:()=>wXn,content_3652_584:()=>Cnt,content_3652_5840:()=>CXn,content_3652_5842:()=>LXn,content_3652_5844:()=>NXn,content_3652_5846:()=>WXn,content_3652_5848:()=>SXn,content_3652_5850:()=>OXn,content_3652_5852:()=>BXn,content_3652_5854:()=>qXn,content_3652_5856:()=>HXn,content_3652_5858:()=>JXn,content_3652_586:()=>Lnt,content_3652_5860:()=>e_n,content_3652_5862:()=>p_n,content_3652_5864:()=>c_n,content_3652_5866:()=>l_n,content_3652_5868:()=>d_n,content_3652_5870:()=>k_n,content_3652_5872:()=>M_n,content_3652_5874:()=>w_n,content_3652_5876:()=>C_n,content_3652_5878:()=>L_n,content_3652_588:()=>Nnt,content_3652_5880:()=>N_n,content_3652_5882:()=>W_n,content_3652_5884:()=>S_n,content_3652_5886:()=>O_n,content_3652_5888:()=>B_n,content_3652_5890:()=>q_n,content_3652_5892:()=>H_n,content_3652_5894:()=>J_n,content_3652_5896:()=>ewn,content_3652_5898:()=>pwn,content_3652_590:()=>Wnt,content_3652_5900:()=>cwn,content_3652_5902:()=>lwn,content_3652_5904:()=>dwn,content_3652_5906:()=>kwn,content_3652_5908:()=>Mwn,content_3652_5910:()=>wwn,content_3652_5912:()=>Cwn,content_3652_5914:()=>Lwn,content_3652_5916:()=>Nwn,content_3652_5918:()=>Wwn,content_3652_592:()=>Snt,content_3652_5920:()=>Swn,content_3652_5922:()=>Own,content_3652_5924:()=>Bwn,content_3652_5926:()=>qwn,content_3652_5928:()=>Hwn,content_3652_5930:()=>Jwn,content_3652_5932:()=>eTn,content_3652_5934:()=>pTn,content_3652_5936:()=>cTn,content_3652_5938:()=>lTn,content_3652_594:()=>Ont,content_3652_5940:()=>dTn,content_3652_5942:()=>kTn,content_3652_5944:()=>MTn,content_3652_5946:()=>wTn,content_3652_5948:()=>CTn,content_3652_5950:()=>LTn,content_3652_5952:()=>NTn,content_3652_5954:()=>WTn,content_3652_5956:()=>STn,content_3652_5958:()=>OTn,content_3652_596:()=>Bnt,content_3652_5960:()=>BTn,content_3652_5962:()=>qTn,content_3652_5964:()=>HTn,content_3652_5966:()=>JTn,content_3652_5968:()=>egn,content_3652_5970:()=>pgn,content_3652_5972:()=>cgn,content_3652_5974:()=>lgn,content_3652_5976:()=>dgn,content_3652_5978:()=>kgn,content_3652_598:()=>qnt,content_3652_5980:()=>Mgn,content_3652_5982:()=>wgn,content_3652_5984:()=>Cgn,content_3652_5986:()=>Lgn,content_3652_5988:()=>Ngn,content_3652_5990:()=>Wgn,content_3652_5992:()=>Sgn,content_3652_5994:()=>Ogn,content_3652_5996:()=>Bgn,content_3652_5998:()=>qgn,content_3652_6:()=>_Q,content_3652_60:()=>Y$,content_3652_600:()=>Hnt,content_3652_6000:()=>Hgn,content_3652_6002:()=>Jgn,content_3652_6004:()=>eCn,content_3652_6006:()=>pCn,content_3652_6008:()=>cCn,content_3652_6010:()=>lCn,content_3652_6012:()=>dCn,content_3652_6014:()=>kCn,content_3652_6016:()=>MCn,content_3652_6018:()=>wCn,content_3652_602:()=>Jnt,content_3652_6020:()=>CCn,content_3652_6022:()=>LCn,content_3652_6024:()=>NCn,content_3652_6026:()=>WCn,content_3652_6028:()=>SCn,content_3652_6030:()=>OCn,content_3652_6032:()=>BCn,content_3652_6034:()=>qCn,content_3652_6036:()=>HCn,content_3652_6038:()=>JCn,content_3652_604:()=>eot,content_3652_6040:()=>exn,content_3652_6042:()=>pxn,content_3652_6044:()=>cxn,content_3652_6046:()=>lxn,content_3652_6048:()=>dxn,content_3652_6050:()=>kxn,content_3652_6052:()=>Mxn,content_3652_6054:()=>wxn,content_3652_6056:()=>Cxn,content_3652_6058:()=>Lxn,content_3652_606:()=>pot,content_3652_6060:()=>Nxn,content_3652_6062:()=>Wxn,content_3652_6064:()=>Sxn,content_3652_6066:()=>Oxn,content_3652_6068:()=>Bxn,content_3652_6070:()=>qxn,content_3652_6072:()=>Hxn,content_3652_6074:()=>Jxn,content_3652_6076:()=>evn,content_3652_6078:()=>pvn,content_3652_608:()=>cot,content_3652_6080:()=>cvn,content_3652_6082:()=>lvn,content_3652_6084:()=>dvn,content_3652_6086:()=>kvn,content_3652_6088:()=>Mvn,content_3652_6090:()=>wvn,content_3652_6092:()=>Cvn,content_3652_6094:()=>Lvn,content_3652_6096:()=>Nvn,content_3652_6098:()=>Wvn,content_3652_610:()=>lot,content_3652_6100:()=>Svn,content_3652_6102:()=>Ovn,content_3652_6104:()=>Bvn,content_3652_6106:()=>qvn,content_3652_6108:()=>Hvn,content_3652_6110:()=>Jvn,content_3652_6112:()=>eLn,content_3652_6114:()=>pLn,content_3652_6116:()=>cLn,content_3652_6118:()=>lLn,content_3652_612:()=>dot,content_3652_6120:()=>dLn,content_3652_6122:()=>kLn,content_3652_6124:()=>MLn,content_3652_6126:()=>wLn,content_3652_6128:()=>CLn,content_3652_6130:()=>LLn,content_3652_6132:()=>NLn,content_3652_6134:()=>WLn,content_3652_6136:()=>SLn,content_3652_6138:()=>OLn,content_3652_614:()=>kot,content_3652_6140:()=>BLn,content_3652_6142:()=>qLn,content_3652_6144:()=>HLn,content_3652_6146:()=>JLn,content_3652_6148:()=>eZn,content_3652_6150:()=>pZn,content_3652_6152:()=>cZn,content_3652_6154:()=>lZn,content_3652_6156:()=>dZn,content_3652_6158:()=>kZn,content_3652_616:()=>Mot,content_3652_6160:()=>MZn,content_3652_6162:()=>wZn,content_3652_6164:()=>CZn,content_3652_6166:()=>LZn,content_3652_6168:()=>NZn,content_3652_6170:()=>WZn,content_3652_6172:()=>SZn,content_3652_6174:()=>OZn,content_3652_6176:()=>BZn,content_3652_6178:()=>qZn,content_3652_618:()=>wot,content_3652_6180:()=>HZn,content_3652_6182:()=>JZn,content_3652_6184:()=>ebn,content_3652_6186:()=>pbn,content_3652_6188:()=>cbn,content_3652_6190:()=>lbn,content_3652_6192:()=>dbn,content_3652_6194:()=>kbn,content_3652_6196:()=>Mbn,content_3652_6198:()=>wbn,content_3652_62:()=>$$,content_3652_620:()=>Cot,content_3652_6200:()=>Cbn,content_3652_6202:()=>Lbn,content_3652_6204:()=>Nbn,content_3652_6206:()=>Wbn,content_3652_6208:()=>Sbn,content_3652_6210:()=>Obn,content_3652_6212:()=>Bbn,content_3652_6214:()=>qbn,content_3652_6216:()=>Hbn,content_3652_6218:()=>Jbn,content_3652_622:()=>Lot,content_3652_6220:()=>eNn,content_3652_6222:()=>pNn,content_3652_6224:()=>cNn,content_3652_6226:()=>lNn,content_3652_6228:()=>dNn,content_3652_6230:()=>kNn,content_3652_6232:()=>MNn,content_3652_6234:()=>wNn,content_3652_6236:()=>CNn,content_3652_6238:()=>LNn,content_3652_624:()=>Not,content_3652_6240:()=>NNn,content_3652_6242:()=>WNn,content_3652_6244:()=>SNn,content_3652_6246:()=>ONn,content_3652_6248:()=>BNn,content_3652_6250:()=>qNn,content_3652_6252:()=>HNn,content_3652_6254:()=>JNn,content_3652_6256:()=>eAn,content_3652_6258:()=>pAn,content_3652_626:()=>Wot,content_3652_6260:()=>cAn,content_3652_6262:()=>lAn,content_3652_6264:()=>dAn,content_3652_6266:()=>kAn,content_3652_6268:()=>MAn,content_3652_6270:()=>wAn,content_3652_6272:()=>CAn,content_3652_6274:()=>LAn,content_3652_6276:()=>NAn,content_3652_6278:()=>WAn,content_3652_628:()=>Sot,content_3652_6280:()=>SAn,content_3652_6282:()=>OAn,content_3652_6284:()=>BAn,content_3652_6286:()=>qAn,content_3652_6288:()=>HAn,content_3652_6290:()=>JAn,content_3652_6292:()=>ezn,content_3652_6294:()=>pzn,content_3652_6296:()=>czn,content_3652_6298:()=>lzn,content_3652_630:()=>Oot,content_3652_6300:()=>dzn,content_3652_6302:()=>kzn,content_3652_6304:()=>Mzn,content_3652_6306:()=>wzn,content_3652_6308:()=>Czn,content_3652_6310:()=>Lzn,content_3652_6312:()=>Nzn,content_3652_6314:()=>Wzn,content_3652_6316:()=>Szn,content_3652_6318:()=>Ozn,content_3652_632:()=>Bot,content_3652_6320:()=>Bzn,content_3652_6322:()=>qzn,content_3652_6324:()=>Hzn,content_3652_6326:()=>Jzn,content_3652_6328:()=>eWn,content_3652_6330:()=>pWn,content_3652_6332:()=>cWn,content_3652_6334:()=>lWn,content_3652_6336:()=>dWn,content_3652_6338:()=>kWn,content_3652_634:()=>qot,content_3652_6340:()=>MWn,content_3652_6342:()=>wWn,content_3652_6344:()=>CWn,content_3652_6346:()=>LWn,content_3652_6348:()=>NWn,content_3652_6350:()=>WWn,content_3652_6352:()=>SWn,content_3652_6354:()=>OWn,content_3652_6356:()=>BWn,content_3652_6358:()=>qWn,content_3652_636:()=>Hot,content_3652_6360:()=>HWn,content_3652_6362:()=>JWn,content_3652_6364:()=>eIn,content_3652_6366:()=>pIn,content_3652_6368:()=>cIn,content_3652_6370:()=>lIn,content_3652_6372:()=>dIn,content_3652_6374:()=>kIn,content_3652_6376:()=>MIn,content_3652_6378:()=>wIn,content_3652_638:()=>Jot,content_3652_6380:()=>CIn,content_3652_6382:()=>LIn,content_3652_6384:()=>NIn,content_3652_6386:()=>WIn,content_3652_6388:()=>SIn,content_3652_6390:()=>OIn,content_3652_6392:()=>BIn,content_3652_6394:()=>qIn,content_3652_6396:()=>HIn,content_3652_6398:()=>JIn,content_3652_64:()=>tJ,content_3652_640:()=>ept,content_3652_6400:()=>eRn,content_3652_6402:()=>pRn,content_3652_6404:()=>cRn,content_3652_6406:()=>lRn,content_3652_6408:()=>dRn,content_3652_6410:()=>kRn,content_3652_6412:()=>MRn,content_3652_6414:()=>wRn,content_3652_6416:()=>CRn,content_3652_6418:()=>LRn,content_3652_642:()=>ppt,content_3652_6420:()=>NRn,content_3652_6422:()=>WRn,content_3652_6424:()=>SRn,content_3652_6426:()=>ORn,content_3652_6428:()=>BRn,content_3652_6430:()=>qRn,content_3652_6432:()=>HRn,content_3652_6434:()=>JRn,content_3652_6436:()=>eSn,content_3652_6438:()=>pSn,content_3652_644:()=>cpt,content_3652_6440:()=>cSn,content_3652_6442:()=>lSn,content_3652_6444:()=>dSn,content_3652_6446:()=>kSn,content_3652_6448:()=>MSn,content_3652_6450:()=>wSn,content_3652_6452:()=>CSn,content_3652_6454:()=>LSn,content_3652_6456:()=>NSn,content_3652_6458:()=>WSn,content_3652_646:()=>lpt,content_3652_6460:()=>SSn,content_3652_6462:()=>OSn,content_3652_6464:()=>BSn,content_3652_6466:()=>qSn,content_3652_6468:()=>HSn,content_3652_6470:()=>JSn,content_3652_6472:()=>ePn,content_3652_6474:()=>pPn,content_3652_6476:()=>cPn,content_3652_6478:()=>lPn,content_3652_648:()=>dpt,content_3652_6480:()=>dPn,content_3652_6482:()=>kPn,content_3652_6484:()=>MPn,content_3652_6486:()=>wPn,content_3652_6488:()=>CPn,content_3652_6490:()=>LPn,content_3652_6492:()=>NPn,content_3652_6494:()=>WPn,content_3652_6496:()=>SPn,content_3652_6498:()=>OPn,content_3652_650:()=>kpt,content_3652_6500:()=>BPn,content_3652_6502:()=>qPn,content_3652_6504:()=>HPn,content_3652_6506:()=>JPn,content_3652_6508:()=>eEn,content_3652_6510:()=>pEn,content_3652_6512:()=>cEn,content_3652_6514:()=>lEn,content_3652_6516:()=>dEn,content_3652_6518:()=>kEn,content_3652_652:()=>Mpt,content_3652_6520:()=>MEn,content_3652_6522:()=>wEn,content_3652_6524:()=>CEn,content_3652_6526:()=>LEn,content_3652_6528:()=>NEn,content_3652_6530:()=>WEn,content_3652_6532:()=>SEn,content_3652_6534:()=>OEn,content_3652_6536:()=>BEn,content_3652_6538:()=>qEn,content_3652_654:()=>wpt,content_3652_6540:()=>HEn,content_3652_6542:()=>JEn,content_3652_6544:()=>eOn,content_3652_6546:()=>pOn,content_3652_6548:()=>cOn,content_3652_6550:()=>lOn,content_3652_6552:()=>dOn,content_3652_6554:()=>kOn,content_3652_6556:()=>MOn,content_3652_6558:()=>wOn,content_3652_656:()=>Cpt,content_3652_6560:()=>COn,content_3652_6562:()=>LOn,content_3652_6564:()=>NOn,content_3652_6566:()=>WOn,content_3652_6568:()=>SOn,content_3652_6570:()=>OOn,content_3652_6572:()=>BOn,content_3652_6574:()=>qOn,content_3652_6576:()=>HOn,content_3652_6578:()=>JOn,content_3652_658:()=>Lpt,content_3652_6580:()=>eGn,content_3652_6582:()=>pGn,content_3652_6584:()=>cGn,content_3652_6586:()=>lGn,content_3652_6588:()=>dGn,content_3652_6590:()=>kGn,content_3652_6592:()=>MGn,content_3652_6594:()=>wGn,content_3652_6596:()=>CGn,content_3652_6598:()=>LGn,content_3652_66:()=>oJ,content_3652_660:()=>Npt,content_3652_6600:()=>NGn,content_3652_6602:()=>WGn,content_3652_6604:()=>SGn,content_3652_6606:()=>OGn,content_3652_6608:()=>BGn,content_3652_6610:()=>qGn,content_3652_6612:()=>HGn,content_3652_6614:()=>JGn,content_3652_6616:()=>eFn,content_3652_6618:()=>pFn,content_3652_662:()=>Wpt,content_3652_6620:()=>cFn,content_3652_6622:()=>lFn,content_3652_6624:()=>dFn,content_3652_6626:()=>kFn,content_3652_6628:()=>MFn,content_3652_6630:()=>wFn,content_3652_6632:()=>CFn,content_3652_6634:()=>LFn,content_3652_6636:()=>NFn,content_3652_6638:()=>WFn,content_3652_664:()=>Spt,content_3652_6640:()=>SFn,content_3652_6642:()=>OFn,content_3652_6644:()=>BFn,content_3652_6646:()=>qFn,content_3652_6648:()=>HFn,content_3652_6650:()=>JFn,content_3652_6652:()=>eBn,content_3652_6654:()=>pBn,content_3652_6656:()=>cBn,content_3652_6658:()=>lBn,content_3652_666:()=>Opt,content_3652_6660:()=>dBn,content_3652_6662:()=>kBn,content_3652_6664:()=>MBn,content_3652_6666:()=>wBn,content_3652_6668:()=>CBn,content_3652_6670:()=>LBn,content_3652_6672:()=>NBn,content_3652_6674:()=>WBn,content_3652_6676:()=>SBn,content_3652_6678:()=>OBn,content_3652_668:()=>Bpt,content_3652_6680:()=>BBn,content_3652_6682:()=>qBn,content_3652_6684:()=>HBn,content_3652_6686:()=>JBn,content_3652_6688:()=>eUn,content_3652_6690:()=>pUn,content_3652_6692:()=>cUn,content_3652_6694:()=>lUn,content_3652_6696:()=>dUn,content_3652_6698:()=>kUn,content_3652_670:()=>qpt,content_3652_6700:()=>MUn,content_3652_6702:()=>wUn,content_3652_6704:()=>CUn,content_3652_6706:()=>LUn,content_3652_6708:()=>NUn,content_3652_6710:()=>WUn,content_3652_6712:()=>SUn,content_3652_6714:()=>OUn,content_3652_6716:()=>BUn,content_3652_6718:()=>qUn,content_3652_672:()=>Hpt,content_3652_6720:()=>HUn,content_3652_6722:()=>JUn,content_3652_6724:()=>eVn,content_3652_6726:()=>pVn,content_3652_6728:()=>cVn,content_3652_6730:()=>lVn,content_3652_6732:()=>dVn,content_3652_6734:()=>kVn,content_3652_6736:()=>MVn,content_3652_6738:()=>wVn,content_3652_674:()=>Jpt,content_3652_6740:()=>CVn,content_3652_6742:()=>LVn,content_3652_6744:()=>NVn,content_3652_6746:()=>WVn,content_3652_6748:()=>SVn,content_3652_6750:()=>OVn,content_3652_6752:()=>BVn,content_3652_6754:()=>qVn,content_3652_6756:()=>HVn,content_3652_6758:()=>JVn,content_3652_676:()=>ert,content_3652_6760:()=>eqn,content_3652_6762:()=>pqn,content_3652_6764:()=>cqn,content_3652_6766:()=>lqn,content_3652_6768:()=>dqn,content_3652_6770:()=>kqn,content_3652_6772:()=>Mqn,content_3652_6774:()=>wqn,content_3652_6776:()=>Cqn,content_3652_6778:()=>Lqn,content_3652_678:()=>prt,content_3652_6780:()=>Nqn,content_3652_6782:()=>Wqn,content_3652_6784:()=>Sqn,content_3652_6786:()=>Oqn,content_3652_6788:()=>Bqn,content_3652_6790:()=>qqn,content_3652_6792:()=>Hqn,content_3652_6794:()=>Jqn,content_3652_6796:()=>ejn,content_3652_6798:()=>pjn,content_3652_68:()=>sJ,content_3652_680:()=>crt,content_3652_6800:()=>cjn,content_3652_6802:()=>ljn,content_3652_6804:()=>djn,content_3652_6806:()=>kjn,content_3652_6808:()=>Mjn,content_3652_6810:()=>wjn,content_3652_6812:()=>Cjn,content_3652_6814:()=>Ljn,content_3652_6816:()=>Njn,content_3652_6818:()=>Wjn,content_3652_682:()=>lrt,content_3652_6820:()=>Sjn,content_3652_6822:()=>Ojn,content_3652_6824:()=>Bjn,content_3652_6826:()=>qjn,content_3652_6828:()=>Hjn,content_3652_6830:()=>Jjn,content_3652_6832:()=>eYn,content_3652_6834:()=>pYn,content_3652_6836:()=>cYn,content_3652_6838:()=>lYn,content_3652_684:()=>drt,content_3652_6840:()=>dYn,content_3652_6842:()=>kYn,content_3652_6844:()=>MYn,content_3652_6846:()=>wYn,content_3652_6848:()=>CYn,content_3652_6850:()=>LYn,content_3652_6852:()=>NYn,content_3652_6854:()=>WYn,content_3652_6856:()=>SYn,content_3652_6858:()=>OYn,content_3652_686:()=>krt,content_3652_6860:()=>BYn,content_3652_6862:()=>qYn,content_3652_6864:()=>HYn,content_3652_6866:()=>JYn,content_3652_6868:()=>eHn,content_3652_6870:()=>pHn,content_3652_6872:()=>cHn,content_3652_6874:()=>lHn,content_3652_6876:()=>dHn,content_3652_6878:()=>kHn,content_3652_688:()=>Mrt,content_3652_6880:()=>MHn,content_3652_6882:()=>wHn,content_3652_6884:()=>CHn,content_3652_6886:()=>LHn,content_3652_6888:()=>NHn,content_3652_6890:()=>WHn,content_3652_6892:()=>SHn,content_3652_6894:()=>OHn,content_3652_6896:()=>BHn,content_3652_6898:()=>qHn,content_3652_690:()=>wrt,content_3652_6900:()=>HHn,content_3652_6902:()=>JHn,content_3652_6904:()=>eQn,content_3652_6906:()=>pQn,content_3652_6908:()=>cQn,content_3652_6910:()=>lQn,content_3652_6912:()=>dQn,content_3652_6914:()=>kQn,content_3652_6916:()=>MQn,content_3652_6918:()=>wQn,content_3652_692:()=>Crt,content_3652_6920:()=>CQn,content_3652_6922:()=>LQn,content_3652_6924:()=>NQn,content_3652_6926:()=>WQn,content_3652_6928:()=>SQn,content_3652_6930:()=>OQn,content_3652_6932:()=>BQn,content_3652_6934:()=>qQn,content_3652_6936:()=>HQn,content_3652_6938:()=>JQn,content_3652_694:()=>Lrt,content_3652_6940:()=>e$n,content_3652_6942:()=>p$n,content_3652_6944:()=>c$n,content_3652_6946:()=>l$n,content_3652_6948:()=>d$n,content_3652_6950:()=>k$n,content_3652_6952:()=>M$n,content_3652_6954:()=>w$n,content_3652_6956:()=>C$n,content_3652_6958:()=>L$n,content_3652_696:()=>Nrt,content_3652_6960:()=>N$n,content_3652_6962:()=>W$n,content_3652_6964:()=>S$n,content_3652_6966:()=>O$n,content_3652_6968:()=>B$n,content_3652_6970:()=>q$n,content_3652_6972:()=>H$n,content_3652_6974:()=>J$n,content_3652_6976:()=>eJn,content_3652_6978:()=>pJn,content_3652_698:()=>Wrt,content_3652_6980:()=>cJn,content_3652_6982:()=>lJn,content_3652_6984:()=>dJn,content_3652_6986:()=>kJn,content_3652_6988:()=>MJn,content_3652_6990:()=>wJn,content_3652_6992:()=>CJn,content_3652_6994:()=>LJn,content_3652_6996:()=>NJn,content_3652_6998:()=>WJn,content_3652_70:()=>aJ,content_3652_700:()=>Srt,content_3652_7000:()=>SJn,content_3652_7002:()=>OJn,content_3652_7004:()=>BJn,content_3652_7006:()=>qJn,content_3652_7008:()=>HJn,content_3652_7010:()=>JJn,content_3652_7012:()=>eKn,content_3652_7014:()=>pKn,content_3652_7016:()=>cKn,content_3652_7018:()=>lKn,content_3652_702:()=>Ort,content_3652_7020:()=>dKn,content_3652_7022:()=>kKn,content_3652_7024:()=>MKn,content_3652_7026:()=>wKn,content_3652_7028:()=>CKn,content_3652_7030:()=>LKn,content_3652_7032:()=>NKn,content_3652_7034:()=>WKn,content_3652_7036:()=>SKn,content_3652_7038:()=>OKn,content_3652_704:()=>Brt,content_3652_7040:()=>BKn,content_3652_7042:()=>qKn,content_3652_7044:()=>HKn,content_3652_7046:()=>JKn,content_3652_7048:()=>e0n,content_3652_7050:()=>p0n,content_3652_7052:()=>c0n,content_3652_7054:()=>l0n,content_3652_7056:()=>d0n,content_3652_7058:()=>k0n,content_3652_706:()=>qrt,content_3652_7060:()=>M0n,content_3652_7062:()=>w0n,content_3652_7064:()=>C0n,content_3652_7066:()=>L0n,content_3652_7068:()=>N0n,content_3652_7070:()=>W0n,content_3652_7072:()=>S0n,content_3652_7074:()=>O0n,content_3652_7076:()=>B0n,content_3652_7078:()=>q0n,content_3652_708:()=>Hrt,content_3652_7080:()=>H0n,content_3652_7082:()=>J0n,content_3652_7084:()=>e2n,content_3652_7086:()=>p2n,content_3652_7088:()=>c2n,content_3652_7090:()=>l2n,content_3652_7092:()=>d2n,content_3652_7094:()=>k2n,content_3652_7096:()=>M2n,content_3652_7098:()=>w2n,content_3652_710:()=>Jrt,content_3652_7100:()=>C2n,content_3652_7102:()=>L2n,content_3652_7104:()=>N2n,content_3652_7106:()=>W2n,content_3652_7108:()=>S2n,content_3652_7110:()=>O2n,content_3652_7112:()=>B2n,content_3652_7114:()=>q2n,content_3652_7116:()=>H2n,content_3652_7118:()=>J2n,content_3652_712:()=>est,content_3652_7120:()=>e6n,content_3652_7122:()=>p6n,content_3652_7124:()=>c6n,content_3652_7126:()=>l6n,content_3652_7128:()=>d6n,content_3652_7130:()=>k6n,content_3652_7132:()=>M6n,content_3652_7134:()=>w6n,content_3652_7136:()=>C6n,content_3652_7138:()=>L6n,content_3652_714:()=>pst,content_3652_7140:()=>N6n,content_3652_7142:()=>W6n,content_3652_7144:()=>S6n,content_3652_7146:()=>O6n,content_3652_7148:()=>B6n,content_3652_7150:()=>q6n,content_3652_7152:()=>H6n,content_3652_7154:()=>J6n,content_3652_7156:()=>e3n,content_3652_7158:()=>p3n,content_3652_716:()=>cst,content_3652_7160:()=>c3n,content_3652_7162:()=>l3n,content_3652_7164:()=>d3n,content_3652_7166:()=>k3n,content_3652_7168:()=>M3n,content_3652_7170:()=>w3n,content_3652_7172:()=>C3n,content_3652_7174:()=>L3n,content_3652_7176:()=>N3n,content_3652_7178:()=>W3n,content_3652_718:()=>lst,content_3652_7180:()=>S3n,content_3652_7182:()=>O3n,content_3652_7184:()=>B3n,content_3652_7186:()=>q3n,content_3652_7188:()=>H3n,content_3652_7190:()=>J3n,content_3652_7192:()=>e5n,content_3652_7194:()=>p5n,content_3652_7196:()=>c5n,content_3652_7198:()=>l5n,content_3652_72:()=>mJ,content_3652_720:()=>dst,content_3652_7200:()=>d5n,content_3652_7202:()=>k5n,content_3652_7204:()=>M5n,content_3652_7206:()=>w5n,content_3652_7208:()=>C5n,content_3652_7210:()=>L5n,content_3652_7212:()=>N5n,content_3652_7214:()=>W5n,content_3652_7216:()=>S5n,content_3652_7218:()=>O5n,content_3652_722:()=>kst,content_3652_7220:()=>B5n,content_3652_7222:()=>q5n,content_3652_7224:()=>H5n,content_3652_7226:()=>J5n,content_3652_7228:()=>e1n,content_3652_7230:()=>p1n,content_3652_7232:()=>c1n,content_3652_7234:()=>l1n,content_3652_7236:()=>d1n,content_3652_7238:()=>k1n,content_3652_724:()=>Mst,content_3652_7240:()=>M1n,content_3652_7242:()=>w1n,content_3652_7244:()=>C1n,content_3652_7246:()=>L1n,content_3652_7248:()=>N1n,content_3652_7250:()=>W1n,content_3652_7252:()=>S1n,content_3652_7254:()=>O1n,content_3652_7256:()=>B1n,content_3652_7258:()=>q1n,content_3652_726:()=>wst,content_3652_7260:()=>H1n,content_3652_7262:()=>J1n,content_3652_7264:()=>e4n,content_3652_7266:()=>p4n,content_3652_7268:()=>c4n,content_3652_7270:()=>l4n,content_3652_7272:()=>d4n,content_3652_7274:()=>k4n,content_3652_7276:()=>M4n,content_3652_7278:()=>w4n,content_3652_728:()=>Cst,content_3652_7280:()=>C4n,content_3652_7282:()=>L4n,content_3652_7284:()=>N4n,content_3652_7286:()=>W4n,content_3652_7288:()=>S4n,content_3652_7290:()=>O4n,content_3652_7292:()=>B4n,content_3652_7294:()=>q4n,content_3652_7296:()=>H4n,content_3652_7298:()=>J4n,content_3652_730:()=>Lst,content_3652_7300:()=>e8n,content_3652_7302:()=>p8n,content_3652_7304:()=>c8n,content_3652_7306:()=>l8n,content_3652_7308:()=>d8n,content_3652_7310:()=>k8n,content_3652_7312:()=>M8n,content_3652_7314:()=>w8n,content_3652_7316:()=>C8n,content_3652_7318:()=>L8n,content_3652_732:()=>Nst,content_3652_7320:()=>N8n,content_3652_7322:()=>W8n,content_3652_7324:()=>S8n,content_3652_7326:()=>O8n,content_3652_7328:()=>B8n,content_3652_7330:()=>q8n,content_3652_7332:()=>H8n,content_3652_7334:()=>J8n,content_3652_7336:()=>e7n,content_3652_7338:()=>p7n,content_3652_734:()=>Wst,content_3652_7340:()=>c7n,content_3652_7342:()=>l7n,content_3652_7344:()=>d7n,content_3652_7346:()=>k7n,content_3652_7348:()=>M7n,content_3652_7350:()=>w7n,content_3652_7352:()=>C7n,content_3652_7354:()=>L7n,content_3652_7356:()=>N7n,content_3652_7358:()=>W7n,content_3652_736:()=>Sst,content_3652_7360:()=>S7n,content_3652_7362:()=>O7n,content_3652_7364:()=>B7n,content_3652_7366:()=>q7n,content_3652_7368:()=>H7n,content_3652_7370:()=>J7n,content_3652_7372:()=>e9n,content_3652_7374:()=>p9n,content_3652_7376:()=>c9n,content_3652_7378:()=>l9n,content_3652_738:()=>Ost,content_3652_7380:()=>d9n,content_3652_7382:()=>k9n,content_3652_7384:()=>M9n,content_3652_7386:()=>w9n,content_3652_7388:()=>C9n,content_3652_7390:()=>L9n,content_3652_7392:()=>N9n,content_3652_7394:()=>W9n,content_3652_7396:()=>S9n,content_3652_7398:()=>O9n,content_3652_74:()=>fJ,content_3652_740:()=>Bst,content_3652_7400:()=>B9n,content_3652_7402:()=>q9n,content_3652_7404:()=>H9n,content_3652_7406:()=>J9n,content_3652_7408:()=>eto,content_3652_7410:()=>pto,content_3652_7412:()=>cto,content_3652_7414:()=>lto,content_3652_7416:()=>dto,content_3652_7418:()=>kto,content_3652_742:()=>qst,content_3652_7420:()=>Mto,content_3652_7422:()=>wto,content_3652_7424:()=>Cto,content_3652_7426:()=>Lto,content_3652_7428:()=>Nto,content_3652_7430:()=>Wto,content_3652_7432:()=>Sto,content_3652_7434:()=>Oto,content_3652_7436:()=>Bto,content_3652_7438:()=>qto,content_3652_744:()=>Hst,content_3652_7440:()=>Hto,content_3652_7442:()=>Jto,content_3652_7444:()=>eeo,content_3652_7446:()=>peo,content_3652_7448:()=>ceo,content_3652_7450:()=>leo,content_3652_7452:()=>deo,content_3652_7454:()=>keo,content_3652_7456:()=>Meo,content_3652_7458:()=>weo,content_3652_746:()=>Jst,content_3652_7460:()=>Ceo,content_3652_7462:()=>Leo,content_3652_7464:()=>Neo,content_3652_7466:()=>Weo,content_3652_7468:()=>Seo,content_3652_7470:()=>Oeo,content_3652_7472:()=>Beo,content_3652_7474:()=>qeo,content_3652_7476:()=>Heo,content_3652_7478:()=>Jeo,content_3652_748:()=>ect,content_3652_7480:()=>eno,content_3652_7482:()=>pno,content_3652_7484:()=>cno,content_3652_7486:()=>lno,content_3652_7488:()=>dno,content_3652_7490:()=>kno,content_3652_7492:()=>Mno,content_3652_7494:()=>wno,content_3652_7496:()=>Cno,content_3652_7498:()=>Lno,content_3652_750:()=>pct,content_3652_7500:()=>Nno,content_3652_7502:()=>Wno,content_3652_7504:()=>Sno,content_3652_7506:()=>Ono,content_3652_7508:()=>Bno,content_3652_7510:()=>qno,content_3652_7512:()=>Hno,content_3652_7514:()=>Jno,content_3652_7516:()=>eoo,content_3652_7518:()=>poo,content_3652_752:()=>cct,content_3652_7520:()=>coo,content_3652_7522:()=>loo,content_3652_7524:()=>doo,content_3652_7526:()=>koo,content_3652_7528:()=>Moo,content_3652_7530:()=>woo,content_3652_7532:()=>Coo,content_3652_7534:()=>Loo,content_3652_7536:()=>Noo,content_3652_7538:()=>Woo,content_3652_754:()=>lct,content_3652_7540:()=>Soo,content_3652_7542:()=>Ooo,content_3652_7544:()=>Boo,content_3652_7546:()=>qoo,content_3652_7548:()=>Hoo,content_3652_7550:()=>Joo,content_3652_7552:()=>epo,content_3652_7554:()=>ppo,content_3652_7556:()=>cpo,content_3652_7558:()=>lpo,content_3652_756:()=>dct,content_3652_7560:()=>dpo,content_3652_7562:()=>kpo,content_3652_7564:()=>Mpo,content_3652_7566:()=>wpo,content_3652_7568:()=>Cpo,content_3652_7570:()=>Lpo,content_3652_7572:()=>Npo,content_3652_7574:()=>Wpo,content_3652_7576:()=>Spo,content_3652_7578:()=>Opo,content_3652_758:()=>kct,content_3652_7580:()=>Bpo,content_3652_7582:()=>qpo,content_3652_7584:()=>Hpo,content_3652_7586:()=>Jpo,content_3652_7588:()=>ero,content_3652_7590:()=>pro,content_3652_7592:()=>cro,content_3652_7594:()=>lro,content_3652_7596:()=>dro,content_3652_7598:()=>kro,content_3652_76:()=>DJ,content_3652_760:()=>Mct,content_3652_7600:()=>Mro,content_3652_7602:()=>wro,content_3652_7604:()=>Cro,content_3652_7606:()=>Lro,content_3652_7608:()=>Nro,content_3652_7610:()=>Wro,content_3652_7612:()=>Sro,content_3652_7614:()=>Oro,content_3652_7616:()=>Bro,content_3652_7618:()=>qro,content_3652_762:()=>wct,content_3652_7620:()=>Hro,content_3652_7622:()=>Jro,content_3652_7624:()=>eso,content_3652_7626:()=>pso,content_3652_7628:()=>cso,content_3652_7630:()=>lso,content_3652_7632:()=>dso,content_3652_7634:()=>kso,content_3652_7636:()=>Mso,content_3652_7638:()=>wso,content_3652_764:()=>Cct,content_3652_7640:()=>Cso,content_3652_7642:()=>Lso,content_3652_7644:()=>Nso,content_3652_7646:()=>Wso,content_3652_7648:()=>Sso,content_3652_7650:()=>Oso,content_3652_7652:()=>Bso,content_3652_7654:()=>qso,content_3652_7656:()=>Hso,content_3652_7658:()=>Jso,content_3652_766:()=>Lct,content_3652_7660:()=>eco,content_3652_7662:()=>pco,content_3652_7664:()=>cco,content_3652_7666:()=>lco,content_3652_7668:()=>dco,content_3652_7670:()=>kco,content_3652_7672:()=>Mco,content_3652_7674:()=>wco,content_3652_7676:()=>Cco,content_3652_7678:()=>Lco,content_3652_768:()=>Nct,content_3652_7680:()=>Nco,content_3652_7682:()=>Wco,content_3652_7684:()=>Sco,content_3652_7686:()=>Oco,content_3652_7688:()=>Bco,content_3652_7690:()=>qco,content_3652_7692:()=>Hco,content_3652_7694:()=>Jco,content_3652_7696:()=>eio,content_3652_7698:()=>pio,content_3652_770:()=>Wct,content_3652_7700:()=>cio,content_3652_7702:()=>lio,content_3652_7704:()=>dio,content_3652_7706:()=>kio,content_3652_7708:()=>Mio,content_3652_7710:()=>wio,content_3652_7712:()=>Cio,content_3652_7714:()=>Lio,content_3652_7716:()=>Nio,content_3652_7718:()=>Wio,content_3652_772:()=>Sct,content_3652_7720:()=>Sio,content_3652_7722:()=>Oio,content_3652_7724:()=>Bio,content_3652_7726:()=>qio,content_3652_7728:()=>Hio,content_3652_7730:()=>Jio,content_3652_7732:()=>eao,content_3652_7734:()=>pao,content_3652_7736:()=>cao,content_3652_7738:()=>lao,content_3652_774:()=>Oct,content_3652_7740:()=>dao,content_3652_7742:()=>kao,content_3652_7744:()=>Mao,content_3652_7746:()=>wao,content_3652_7748:()=>Cao,content_3652_7750:()=>Lao,content_3652_7752:()=>Nao,content_3652_7754:()=>Wao,content_3652_7756:()=>Sao,content_3652_7758:()=>Oao,content_3652_776:()=>Bct,content_3652_7760:()=>Bao,content_3652_7762:()=>qao,content_3652_7764:()=>Hao,content_3652_7766:()=>Jao,content_3652_7768:()=>elo,content_3652_7770:()=>plo,content_3652_7772:()=>clo,content_3652_7774:()=>llo,content_3652_7776:()=>dlo,content_3652_7778:()=>klo,content_3652_778:()=>qct,content_3652_7780:()=>Mlo,content_3652_7782:()=>wlo,content_3652_7784:()=>Clo,content_3652_7786:()=>Llo,content_3652_7788:()=>Nlo,content_3652_7790:()=>Wlo,content_3652_7792:()=>Slo,content_3652_7794:()=>Olo,content_3652_7796:()=>Blo,content_3652_7798:()=>qlo,content_3652_78:()=>_J,content_3652_780:()=>Hct,content_3652_7800:()=>Hlo,content_3652_7802:()=>Jlo,content_3652_7804:()=>euo,content_3652_7806:()=>puo,content_3652_7808:()=>cuo,content_3652_7810:()=>luo,content_3652_7812:()=>duo,content_3652_7814:()=>kuo,content_3652_7816:()=>Muo,content_3652_7818:()=>wuo,content_3652_782:()=>Jct,content_3652_7820:()=>Cuo,content_3652_7822:()=>Luo,content_3652_7824:()=>Nuo,content_3652_7826:()=>Wuo,content_3652_7828:()=>Suo,content_3652_7830:()=>Ouo,content_3652_7832:()=>Buo,content_3652_7834:()=>quo,content_3652_7836:()=>Huo,content_3652_7838:()=>Juo,content_3652_784:()=>eit,content_3652_7840:()=>emo,content_3652_7842:()=>pmo,content_3652_7844:()=>cmo,content_3652_7846:()=>lmo,content_3652_7848:()=>dmo,content_3652_7850:()=>kmo,content_3652_7852:()=>Mmo,content_3652_7854:()=>wmo,content_3652_7856:()=>Cmo,content_3652_7858:()=>Lmo,content_3652_786:()=>pit,content_3652_7860:()=>Nmo,content_3652_7862:()=>Wmo,content_3652_7864:()=>Smo,content_3652_7866:()=>Omo,content_3652_7868:()=>Bmo,content_3652_7870:()=>qmo,content_3652_7872:()=>Hmo,content_3652_7874:()=>Jmo,content_3652_7876:()=>edo,content_3652_7878:()=>pdo,content_3652_788:()=>cit,content_3652_7880:()=>cdo,content_3652_7882:()=>ldo,content_3652_7884:()=>ddo,content_3652_7886:()=>kdo,content_3652_7888:()=>Mdo,content_3652_7890:()=>wdo,content_3652_7892:()=>Cdo,content_3652_7894:()=>Ldo,content_3652_7896:()=>Ndo,content_3652_7898:()=>Wdo,content_3652_790:()=>lit,content_3652_7900:()=>Sdo,content_3652_7902:()=>Odo,content_3652_7904:()=>Bdo,content_3652_7906:()=>qdo,content_3652_7908:()=>Hdo,content_3652_7910:()=>Jdo,content_3652_7912:()=>eho,content_3652_7914:()=>pho,content_3652_7916:()=>cho,content_3652_7918:()=>lho,content_3652_792:()=>dit,content_3652_7920:()=>dho,content_3652_7922:()=>kho,content_3652_7924:()=>Mho,content_3652_7926:()=>who,content_3652_7928:()=>Cho,content_3652_7930:()=>Lho,content_3652_7932:()=>Nho,content_3652_7934:()=>Who,content_3652_7936:()=>Sho,content_3652_7938:()=>Oho,content_3652_794:()=>kit,content_3652_7940:()=>Bho,content_3652_7942:()=>qho,content_3652_7944:()=>Hho,content_3652_7946:()=>Jho,content_3652_7948:()=>efo,content_3652_7950:()=>pfo,content_3652_7952:()=>cfo,content_3652_7954:()=>lfo,content_3652_7956:()=>dfo,content_3652_7958:()=>kfo,content_3652_796:()=>Mit,content_3652_7960:()=>Mfo,content_3652_7962:()=>wfo,content_3652_7964:()=>Cfo,content_3652_7966:()=>Lfo,content_3652_7968:()=>Nfo,content_3652_7970:()=>Wfo,content_3652_7972:()=>Sfo,content_3652_7974:()=>Ofo,content_3652_7976:()=>Bfo,content_3652_7978:()=>qfo,content_3652_798:()=>wit,content_3652_7980:()=>Hfo,content_3652_7982:()=>Jfo,content_3652_7984:()=>eko,content_3652_7986:()=>pko,content_3652_7988:()=>cko,content_3652_7990:()=>lko,content_3652_7992:()=>dko,content_3652_7994:()=>kko,content_3652_7996:()=>Mko,content_3652_7998:()=>wko,content_3652_8:()=>gQ,content_3652_80:()=>gJ,content_3652_800:()=>Cit,content_3652_8000:()=>Cko,content_3652_8002:()=>Lko,content_3652_8004:()=>Nko,content_3652_8006:()=>Wko,content_3652_8008:()=>Sko,content_3652_8010:()=>Oko,content_3652_8012:()=>Bko,content_3652_8014:()=>qko,content_3652_8016:()=>Hko,content_3652_8018:()=>Jko,content_3652_802:()=>Lit,content_3652_8020:()=>eyo,content_3652_8022:()=>pyo,content_3652_8024:()=>cyo,content_3652_8026:()=>lyo,content_3652_8028:()=>dyo,content_3652_8030:()=>kyo,content_3652_8032:()=>Myo,content_3652_8034:()=>wyo,content_3652_8036:()=>Cyo,content_3652_8038:()=>Lyo,content_3652_804:()=>Nit,content_3652_8040:()=>Nyo,content_3652_8042:()=>Wyo,content_3652_8044:()=>Syo,content_3652_8046:()=>Oyo,content_3652_8048:()=>Byo,content_3652_8050:()=>qyo,content_3652_8052:()=>Hyo,content_3652_8054:()=>Jyo,content_3652_8056:()=>eDo,content_3652_8058:()=>pDo,content_3652_806:()=>Wit,content_3652_8060:()=>cDo,content_3652_8062:()=>lDo,content_3652_8064:()=>dDo,content_3652_8066:()=>kDo,content_3652_8068:()=>MDo,content_3652_8070:()=>wDo,content_3652_8072:()=>CDo,content_3652_8074:()=>LDo,content_3652_8076:()=>NDo,content_3652_8078:()=>WDo,content_3652_808:()=>Sit,content_3652_8080:()=>SDo,content_3652_8082:()=>ODo,content_3652_8084:()=>BDo,content_3652_8086:()=>qDo,content_3652_8088:()=>HDo,content_3652_8090:()=>JDo,content_3652_8092:()=>eMo,content_3652_8094:()=>pMo,content_3652_8096:()=>cMo,content_3652_8098:()=>lMo,content_3652_810:()=>Oit,content_3652_8100:()=>dMo,content_3652_8102:()=>kMo,content_3652_8104:()=>MMo,content_3652_8106:()=>wMo,content_3652_8108:()=>CMo,content_3652_8110:()=>LMo,content_3652_8112:()=>NMo,content_3652_8114:()=>WMo,content_3652_8116:()=>SMo,content_3652_8118:()=>OMo,content_3652_812:()=>Bit,content_3652_8120:()=>BMo,content_3652_8122:()=>qMo,content_3652_8124:()=>HMo,content_3652_8126:()=>JMo,content_3652_8128:()=>eXo,content_3652_8130:()=>pXo,content_3652_8132:()=>cXo,content_3652_8134:()=>lXo,content_3652_8136:()=>dXo,content_3652_8138:()=>kXo,content_3652_814:()=>qit,content_3652_8140:()=>MXo,content_3652_8142:()=>wXo,content_3652_8144:()=>CXo,content_3652_8146:()=>LXo,content_3652_8148:()=>NXo,content_3652_8150:()=>WXo,content_3652_8152:()=>SXo,content_3652_8154:()=>OXo,content_3652_8156:()=>BXo,content_3652_8158:()=>qXo,content_3652_816:()=>Hit,content_3652_8160:()=>HXo,content_3652_8162:()=>JXo,content_3652_8164:()=>e_o,content_3652_8166:()=>p_o,content_3652_8168:()=>c_o,content_3652_8170:()=>l_o,content_3652_8172:()=>d_o,content_3652_8174:()=>k_o,content_3652_8176:()=>M_o,content_3652_8178:()=>w_o,content_3652_818:()=>Jit,content_3652_8180:()=>C_o,content_3652_8182:()=>L_o,content_3652_8184:()=>N_o,content_3652_8186:()=>W_o,content_3652_8188:()=>S_o,content_3652_8190:()=>O_o,content_3652_8192:()=>B_o,content_3652_8194:()=>q_o,content_3652_8196:()=>H_o,content_3652_8198:()=>J_o,content_3652_82:()=>vJ,content_3652_820:()=>eat,content_3652_8200:()=>ewo,content_3652_8202:()=>pwo,content_3652_8204:()=>cwo,content_3652_8206:()=>lwo,content_3652_8208:()=>dwo,content_3652_8210:()=>kwo,content_3652_8212:()=>Mwo,content_3652_8214:()=>wwo,content_3652_8216:()=>Cwo,content_3652_8218:()=>Lwo,content_3652_822:()=>pat,content_3652_8220:()=>Nwo,content_3652_8222:()=>Wwo,content_3652_8224:()=>Swo,content_3652_8226:()=>Owo,content_3652_8228:()=>Bwo,content_3652_8230:()=>qwo,content_3652_8232:()=>Hwo,content_3652_8234:()=>Jwo,content_3652_8236:()=>eTo,content_3652_8238:()=>pTo,content_3652_824:()=>cat,content_3652_8240:()=>cTo,content_3652_8242:()=>lTo,content_3652_8244:()=>dTo,content_3652_8246:()=>kTo,content_3652_8248:()=>MTo,content_3652_8250:()=>wTo,content_3652_8252:()=>CTo,content_3652_8254:()=>LTo,content_3652_8256:()=>NTo,content_3652_8258:()=>WTo,content_3652_826:()=>lat,content_3652_8260:()=>STo,content_3652_8262:()=>OTo,content_3652_8264:()=>BTo,content_3652_8266:()=>qTo,content_3652_8268:()=>HTo,content_3652_8270:()=>JTo,content_3652_8272:()=>ego,content_3652_8274:()=>pgo,content_3652_8276:()=>cgo,content_3652_8278:()=>lgo,content_3652_828:()=>dat,content_3652_8280:()=>dgo,content_3652_8282:()=>kgo,content_3652_8284:()=>Mgo,content_3652_8286:()=>wgo,content_3652_8288:()=>Cgo,content_3652_8290:()=>Lgo,content_3652_8292:()=>Ngo,content_3652_8294:()=>Wgo,content_3652_8296:()=>Sgo,content_3652_8298:()=>Ogo,content_3652_830:()=>kat,content_3652_8300:()=>Bgo,content_3652_8302:()=>qgo,content_3652_8304:()=>Hgo,content_3652_8306:()=>Jgo,content_3652_8308:()=>eCo,content_3652_8310:()=>pCo,content_3652_8312:()=>cCo,content_3652_8314:()=>lCo,content_3652_8316:()=>dCo,content_3652_8318:()=>kCo,content_3652_832:()=>Mat,content_3652_8320:()=>MCo,content_3652_8322:()=>wCo,content_3652_8324:()=>CCo,content_3652_8326:()=>LCo,content_3652_8328:()=>NCo,content_3652_8330:()=>WCo,content_3652_8332:()=>SCo,content_3652_8334:()=>OCo,content_3652_8336:()=>BCo,content_3652_8338:()=>qCo,content_3652_834:()=>wat,content_3652_8340:()=>HCo,content_3652_8342:()=>JCo,content_3652_8344:()=>exo,content_3652_8346:()=>pxo,content_3652_8348:()=>cxo,content_3652_8350:()=>lxo,content_3652_8352:()=>dxo,content_3652_8354:()=>kxo,content_3652_8356:()=>Mxo,content_3652_8358:()=>wxo,content_3652_836:()=>Cat,content_3652_8360:()=>Cxo,content_3652_8362:()=>Lxo,content_3652_8364:()=>Nxo,content_3652_8366:()=>Wxo,content_3652_8368:()=>Sxo,content_3652_8370:()=>Oxo,content_3652_8372:()=>Bxo,content_3652_8374:()=>qxo,content_3652_8376:()=>Hxo,content_3652_8378:()=>Jxo,content_3652_838:()=>Lat,content_3652_8380:()=>evo,content_3652_8382:()=>pvo,content_3652_8384:()=>cvo,content_3652_8386:()=>lvo,content_3652_8388:()=>dvo,content_3652_8390:()=>kvo,content_3652_8392:()=>Mvo,content_3652_8394:()=>wvo,content_3652_8396:()=>Cvo,content_3652_8398:()=>Lvo,content_3652_84:()=>bJ,content_3652_840:()=>Nat,content_3652_8400:()=>Nvo,content_3652_8402:()=>Wvo,content_3652_8404:()=>Svo,content_3652_8406:()=>Ovo,content_3652_8408:()=>Bvo,content_3652_8410:()=>qvo,content_3652_8412:()=>Hvo,content_3652_8414:()=>Jvo,content_3652_8416:()=>eLo,content_3652_8418:()=>pLo,content_3652_842:()=>Wat,content_3652_8420:()=>cLo,content_3652_8422:()=>lLo,content_3652_8424:()=>dLo,content_3652_8426:()=>kLo,content_3652_8428:()=>MLo,content_3652_8430:()=>wLo,content_3652_8432:()=>CLo,content_3652_8434:()=>LLo,content_3652_8436:()=>NLo,content_3652_8438:()=>WLo,content_3652_844:()=>Sat,content_3652_8440:()=>SLo,content_3652_8442:()=>OLo,content_3652_8444:()=>BLo,content_3652_8446:()=>qLo,content_3652_8448:()=>HLo,content_3652_8450:()=>JLo,content_3652_8452:()=>eZo,content_3652_8454:()=>pZo,content_3652_8456:()=>cZo,content_3652_8458:()=>lZo,content_3652_846:()=>Oat,content_3652_8460:()=>dZo,content_3652_8462:()=>kZo,content_3652_8464:()=>MZo,content_3652_8466:()=>wZo,content_3652_8468:()=>CZo,content_3652_8470:()=>LZo,content_3652_8472:()=>NZo,content_3652_8474:()=>WZo,content_3652_8476:()=>SZo,content_3652_8478:()=>OZo,content_3652_848:()=>Bat,content_3652_8480:()=>BZo,content_3652_8482:()=>qZo,content_3652_8484:()=>HZo,content_3652_8486:()=>JZo,content_3652_8488:()=>ebo,content_3652_8490:()=>pbo,content_3652_8492:()=>cbo,content_3652_8494:()=>lbo,content_3652_8496:()=>dbo,content_3652_8498:()=>kbo,content_3652_850:()=>qat,content_3652_8500:()=>Mbo,content_3652_8502:()=>wbo,content_3652_8504:()=>Cbo,content_3652_8506:()=>Lbo,content_3652_8508:()=>Nbo,content_3652_8510:()=>Wbo,content_3652_8512:()=>Sbo,content_3652_8514:()=>Obo,content_3652_8516:()=>Bbo,content_3652_8518:()=>qbo,content_3652_852:()=>Hat,content_3652_8520:()=>Hbo,content_3652_8522:()=>Jbo,content_3652_8524:()=>eNo,content_3652_8526:()=>pNo,content_3652_8528:()=>cNo,content_3652_8530:()=>lNo,content_3652_8532:()=>dNo,content_3652_8534:()=>kNo,content_3652_8536:()=>MNo,content_3652_8538:()=>wNo,content_3652_854:()=>Jat,content_3652_8540:()=>CNo,content_3652_8542:()=>LNo,content_3652_8544:()=>NNo,content_3652_8546:()=>WNo,content_3652_8548:()=>SNo,content_3652_8550:()=>ONo,content_3652_8552:()=>BNo,content_3652_8554:()=>qNo,content_3652_8556:()=>HNo,content_3652_8558:()=>JNo,content_3652_856:()=>elt,content_3652_8560:()=>eAo,content_3652_8562:()=>pAo,content_3652_8564:()=>cAo,content_3652_8566:()=>lAo,content_3652_8568:()=>dAo,content_3652_8570:()=>kAo,content_3652_8572:()=>MAo,content_3652_8574:()=>wAo,content_3652_8576:()=>CAo,content_3652_8578:()=>LAo,content_3652_858:()=>plt,content_3652_8580:()=>NAo,content_3652_8582:()=>WAo,content_3652_8584:()=>SAo,content_3652_8586:()=>OAo,content_3652_8588:()=>BAo,content_3652_8590:()=>qAo,content_3652_8592:()=>HAo,content_3652_8594:()=>JAo,content_3652_8596:()=>ezo,content_3652_8598:()=>pzo,content_3652_86:()=>zJ,content_3652_860:()=>clt,content_3652_8600:()=>czo,content_3652_8602:()=>lzo,content_3652_8604:()=>dzo,content_3652_8606:()=>kzo,content_3652_8608:()=>Mzo,content_3652_8610:()=>wzo,content_3652_8612:()=>Czo,content_3652_8614:()=>Lzo,content_3652_8616:()=>Nzo,content_3652_8618:()=>Wzo,content_3652_862:()=>llt,content_3652_8620:()=>Szo,content_3652_8622:()=>Ozo,content_3652_8624:()=>Bzo,content_3652_8626:()=>qzo,content_3652_8628:()=>Hzo,content_3652_8630:()=>Jzo,content_3652_8632:()=>eWo,content_3652_8634:()=>pWo,content_3652_8636:()=>cWo,content_3652_8638:()=>lWo,content_3652_864:()=>dlt,content_3652_8640:()=>dWo,content_3652_8642:()=>kWo,content_3652_8644:()=>MWo,content_3652_8646:()=>wWo,content_3652_8648:()=>CWo,content_3652_8650:()=>LWo,content_3652_8652:()=>NWo,content_3652_8654:()=>WWo,content_3652_8656:()=>SWo,content_3652_8658:()=>OWo,content_3652_866:()=>klt,content_3652_8660:()=>BWo,content_3652_8662:()=>qWo,content_3652_8664:()=>HWo,content_3652_8666:()=>JWo,content_3652_8668:()=>eIo,content_3652_8670:()=>pIo,content_3652_8672:()=>cIo,content_3652_8674:()=>lIo,content_3652_8676:()=>dIo,content_3652_8678:()=>kIo,content_3652_868:()=>Mlt,content_3652_8680:()=>MIo,content_3652_8682:()=>wIo,content_3652_8684:()=>CIo,content_3652_8686:()=>LIo,content_3652_8688:()=>NIo,content_3652_8690:()=>WIo,content_3652_8692:()=>SIo,content_3652_8694:()=>OIo,content_3652_8696:()=>BIo,content_3652_8698:()=>qIo,content_3652_870:()=>wlt,content_3652_8700:()=>HIo,content_3652_8702:()=>JIo,content_3652_8704:()=>eRo,content_3652_8706:()=>pRo,content_3652_8708:()=>cRo,content_3652_8710:()=>lRo,content_3652_8712:()=>dRo,content_3652_8714:()=>kRo,content_3652_8716:()=>MRo,content_3652_8718:()=>wRo,content_3652_872:()=>Clt,content_3652_8720:()=>CRo,content_3652_8722:()=>LRo,content_3652_8724:()=>NRo,content_3652_8726:()=>WRo,content_3652_8728:()=>SRo,content_3652_8730:()=>ORo,content_3652_8732:()=>BRo,content_3652_8734:()=>qRo,content_3652_8736:()=>HRo,content_3652_8738:()=>JRo,content_3652_874:()=>Llt,content_3652_8740:()=>eSo,content_3652_8742:()=>pSo,content_3652_8744:()=>cSo,content_3652_8746:()=>lSo,content_3652_8748:()=>dSo,content_3652_8750:()=>kSo,content_3652_8752:()=>MSo,content_3652_8754:()=>wSo,content_3652_8756:()=>CSo,content_3652_8758:()=>LSo,content_3652_876:()=>Nlt,content_3652_8760:()=>NSo,content_3652_8762:()=>WSo,content_3652_8764:()=>SSo,content_3652_8766:()=>OSo,content_3652_8768:()=>BSo,content_3652_8770:()=>qSo,content_3652_8772:()=>HSo,content_3652_8774:()=>JSo,content_3652_8776:()=>ePo,content_3652_8778:()=>pPo,content_3652_878:()=>Wlt,content_3652_8780:()=>cPo,content_3652_8782:()=>lPo,content_3652_8784:()=>dPo,content_3652_8786:()=>kPo,content_3652_8788:()=>MPo,content_3652_8790:()=>wPo,content_3652_8792:()=>CPo,content_3652_8794:()=>LPo,content_3652_8796:()=>NPo,content_3652_8798:()=>WPo,content_3652_88:()=>RJ,content_3652_880:()=>Slt,content_3652_8800:()=>SPo,content_3652_8802:()=>OPo,content_3652_8804:()=>BPo,content_3652_8806:()=>qPo,content_3652_8808:()=>HPo,content_3652_8810:()=>JPo,content_3652_8812:()=>eEo,content_3652_8814:()=>pEo,content_3652_8816:()=>cEo,content_3652_8818:()=>lEo,content_3652_882:()=>Olt,content_3652_8820:()=>dEo,content_3652_8822:()=>kEo,content_3652_8824:()=>MEo,content_3652_8826:()=>wEo,content_3652_8828:()=>CEo,content_3652_8830:()=>LEo,content_3652_8832:()=>NEo,content_3652_8834:()=>WEo,content_3652_8836:()=>SEo,content_3652_8838:()=>OEo,content_3652_884:()=>Blt,content_3652_8840:()=>BEo,content_3652_8842:()=>qEo,content_3652_8844:()=>HEo,content_3652_8846:()=>JEo,content_3652_8848:()=>eOo,content_3652_8850:()=>pOo,content_3652_8852:()=>cOo,content_3652_8854:()=>lOo,content_3652_8856:()=>dOo,content_3652_8858:()=>kOo,content_3652_886:()=>qlt,content_3652_8860:()=>MOo,content_3652_8862:()=>wOo,content_3652_8864:()=>COo,content_3652_8866:()=>LOo,content_3652_8868:()=>NOo,content_3652_8870:()=>WOo,content_3652_8872:()=>SOo,content_3652_8874:()=>OOo,content_3652_8876:()=>BOo,content_3652_8878:()=>qOo,content_3652_888:()=>Hlt,content_3652_8880:()=>HOo,content_3652_8882:()=>JOo,content_3652_8884:()=>eGo,content_3652_8886:()=>pGo,content_3652_8888:()=>cGo,content_3652_8890:()=>lGo,content_3652_8892:()=>dGo,content_3652_8894:()=>kGo,content_3652_8896:()=>MGo,content_3652_8898:()=>wGo,content_3652_890:()=>Jlt,content_3652_8900:()=>CGo,content_3652_8902:()=>LGo,content_3652_8904:()=>NGo,content_3652_8906:()=>WGo,content_3652_8908:()=>SGo,content_3652_8910:()=>OGo,content_3652_8912:()=>BGo,content_3652_8914:()=>qGo,content_3652_8916:()=>HGo,content_3652_8918:()=>JGo,content_3652_892:()=>eut,content_3652_8920:()=>eFo,content_3652_8922:()=>pFo,content_3652_8924:()=>cFo,content_3652_8926:()=>lFo,content_3652_8928:()=>dFo,content_3652_8930:()=>kFo,content_3652_8932:()=>MFo,content_3652_8934:()=>wFo,content_3652_8936:()=>CFo,content_3652_8938:()=>LFo,content_3652_894:()=>put,content_3652_8940:()=>NFo,content_3652_8942:()=>WFo,content_3652_8944:()=>SFo,content_3652_8946:()=>OFo,content_3652_8948:()=>BFo,content_3652_8950:()=>qFo,content_3652_8952:()=>HFo,content_3652_8954:()=>JFo,content_3652_8956:()=>eBo,content_3652_8958:()=>pBo,content_3652_896:()=>cut,content_3652_8960:()=>cBo,content_3652_8962:()=>lBo,content_3652_8964:()=>dBo,content_3652_8966:()=>kBo,content_3652_8968:()=>MBo,content_3652_8970:()=>wBo,content_3652_8972:()=>CBo,content_3652_8974:()=>LBo,content_3652_8976:()=>NBo,content_3652_8978:()=>WBo,content_3652_898:()=>lut,content_3652_8980:()=>SBo,content_3652_8982:()=>OBo,content_3652_8984:()=>BBo,content_3652_8986:()=>qBo,content_3652_8988:()=>HBo,content_3652_8990:()=>JBo,content_3652_8992:()=>eUo,content_3652_8994:()=>pUo,content_3652_8996:()=>cUo,content_3652_8998:()=>lUo,content_3652_90:()=>EJ,content_3652_900:()=>dut,content_3652_9000:()=>dUo,content_3652_9002:()=>kUo,content_3652_9004:()=>MUo,content_3652_9006:()=>wUo,content_3652_9008:()=>CUo,content_3652_9010:()=>LUo,content_3652_9012:()=>NUo,content_3652_9014:()=>WUo,content_3652_9016:()=>SUo,content_3652_9018:()=>OUo,content_3652_902:()=>kut,content_3652_9020:()=>BUo,content_3652_9022:()=>qUo,content_3652_9024:()=>HUo,content_3652_9026:()=>JUo,content_3652_9028:()=>eVo,content_3652_9030:()=>pVo,content_3652_9032:()=>cVo,content_3652_9034:()=>lVo,content_3652_9036:()=>dVo,content_3652_9038:()=>kVo,content_3652_904:()=>Mut,content_3652_9040:()=>MVo,content_3652_9042:()=>wVo,content_3652_9044:()=>CVo,content_3652_9046:()=>LVo,content_3652_9048:()=>NVo,content_3652_9050:()=>WVo,content_3652_9052:()=>SVo,content_3652_9054:()=>OVo,content_3652_9056:()=>BVo,content_3652_9058:()=>qVo,content_3652_906:()=>wut,content_3652_9060:()=>HVo,content_3652_9062:()=>JVo,content_3652_9064:()=>eqo,content_3652_9066:()=>pqo,content_3652_9068:()=>cqo,content_3652_9070:()=>lqo,content_3652_9072:()=>dqo,content_3652_9074:()=>kqo,content_3652_9076:()=>Mqo,content_3652_9078:()=>wqo,content_3652_908:()=>Cut,content_3652_9080:()=>Cqo,content_3652_9082:()=>Lqo,content_3652_9084:()=>Nqo,content_3652_9086:()=>Wqo,content_3652_9088:()=>Sqo,content_3652_9090:()=>Oqo,content_3652_9092:()=>Bqo,content_3652_9094:()=>qqo,content_3652_9096:()=>Hqo,content_3652_9098:()=>Jqo,content_3652_910:()=>Lut,content_3652_9100:()=>ejo,content_3652_9102:()=>pjo,content_3652_9104:()=>cjo,content_3652_9106:()=>ljo,content_3652_9108:()=>djo,content_3652_9110:()=>kjo,content_3652_9112:()=>Mjo,content_3652_9114:()=>wjo,content_3652_9116:()=>Cjo,content_3652_9118:()=>Ljo,content_3652_912:()=>Nut,content_3652_9120:()=>Njo,content_3652_9122:()=>Wjo,content_3652_9124:()=>Sjo,content_3652_9126:()=>Ojo,content_3652_9128:()=>Bjo,content_3652_9130:()=>qjo,content_3652_9132:()=>Hjo,content_3652_9134:()=>Jjo,content_3652_9136:()=>eYo,content_3652_9138:()=>pYo,content_3652_914:()=>Wut,content_3652_9140:()=>cYo,content_3652_9142:()=>lYo,content_3652_9144:()=>dYo,content_3652_9146:()=>kYo,content_3652_9148:()=>MYo,content_3652_9150:()=>wYo,content_3652_9152:()=>CYo,content_3652_9154:()=>LYo,content_3652_9156:()=>NYo,content_3652_9158:()=>WYo,content_3652_916:()=>Sut,content_3652_9160:()=>SYo,content_3652_9162:()=>OYo,content_3652_9164:()=>BYo,content_3652_9166:()=>qYo,content_3652_9168:()=>HYo,content_3652_9170:()=>JYo,content_3652_9172:()=>eHo,content_3652_9174:()=>pHo,content_3652_9176:()=>cHo,content_3652_9178:()=>lHo,content_3652_918:()=>Out,content_3652_9180:()=>dHo,content_3652_9182:()=>kHo,content_3652_9184:()=>MHo,content_3652_9186:()=>wHo,content_3652_9188:()=>CHo,content_3652_9190:()=>LHo,content_3652_9192:()=>NHo,content_3652_9194:()=>WHo,content_3652_9196:()=>SHo,content_3652_9198:()=>OHo,content_3652_92:()=>FJ,content_3652_920:()=>But,content_3652_9200:()=>BHo,content_3652_9202:()=>qHo,content_3652_9204:()=>HHo,content_3652_9206:()=>JHo,content_3652_9208:()=>eQo,content_3652_9210:()=>pQo,content_3652_9212:()=>cQo,content_3652_9214:()=>lQo,content_3652_9216:()=>dQo,content_3652_9218:()=>kQo,content_3652_922:()=>qut,content_3652_9220:()=>MQo,content_3652_9222:()=>wQo,content_3652_9224:()=>CQo,content_3652_9226:()=>LQo,content_3652_9228:()=>NQo,content_3652_9230:()=>WQo,content_3652_9232:()=>SQo,content_3652_9234:()=>OQo,content_3652_9236:()=>BQo,content_3652_9238:()=>qQo,content_3652_924:()=>Hut,content_3652_9240:()=>HQo,content_3652_9242:()=>JQo,content_3652_9244:()=>e$o,content_3652_9246:()=>p$o,content_3652_9248:()=>c$o,content_3652_9250:()=>l$o,content_3652_9252:()=>d$o,content_3652_9254:()=>k$o,content_3652_9256:()=>M$o,content_3652_9258:()=>w$o,content_3652_926:()=>Jut,content_3652_9260:()=>C$o,content_3652_9262:()=>L$o,content_3652_9264:()=>N$o,content_3652_9266:()=>W$o,content_3652_9268:()=>S$o,content_3652_9270:()=>O$o,content_3652_9272:()=>B$o,content_3652_9274:()=>q$o,content_3652_9276:()=>H$o,content_3652_9278:()=>J$o,content_3652_928:()=>emt,content_3652_9280:()=>eJo,content_3652_9282:()=>pJo,content_3652_9284:()=>cJo,content_3652_9286:()=>lJo,content_3652_9288:()=>dJo,content_3652_9290:()=>kJo,content_3652_9292:()=>MJo,content_3652_9294:()=>wJo,content_3652_9296:()=>CJo,content_3652_9298:()=>LJo,content_3652_930:()=>pmt,content_3652_9300:()=>NJo,content_3652_9302:()=>WJo,content_3652_9304:()=>SJo,content_3652_9306:()=>OJo,content_3652_9308:()=>BJo,content_3652_9310:()=>qJo,content_3652_9312:()=>HJo,content_3652_9314:()=>JJo,content_3652_9316:()=>eKo,content_3652_9318:()=>pKo,content_3652_932:()=>cmt,content_3652_9320:()=>cKo,content_3652_9322:()=>lKo,content_3652_9324:()=>dKo,content_3652_9326:()=>kKo,content_3652_9328:()=>MKo,content_3652_9330:()=>wKo,content_3652_9332:()=>CKo,content_3652_9334:()=>LKo,content_3652_9336:()=>NKo,content_3652_9338:()=>WKo,content_3652_934:()=>lmt,content_3652_9340:()=>SKo,content_3652_9342:()=>OKo,content_3652_9344:()=>BKo,content_3652_9346:()=>qKo,content_3652_9348:()=>HKo,content_3652_9350:()=>JKo,content_3652_9352:()=>e0o,content_3652_9354:()=>p0o,content_3652_9356:()=>c0o,content_3652_9358:()=>l0o,content_3652_936:()=>dmt,content_3652_9360:()=>d0o,content_3652_9362:()=>k0o,content_3652_9364:()=>M0o,content_3652_9366:()=>w0o,content_3652_9368:()=>C0o,content_3652_9370:()=>L0o,content_3652_9372:()=>N0o,content_3652_9374:()=>W0o,content_3652_9376:()=>S0o,content_3652_9378:()=>O0o,content_3652_938:()=>kmt,content_3652_9380:()=>B0o,content_3652_9382:()=>q0o,content_3652_9384:()=>H0o,content_3652_9386:()=>J0o,content_3652_9388:()=>e2o,content_3652_9390:()=>p2o,content_3652_9392:()=>c2o,content_3652_9394:()=>l2o,content_3652_9396:()=>d2o,content_3652_9398:()=>k2o,content_3652_94:()=>VJ,content_3652_940:()=>Mmt,content_3652_9400:()=>M2o,content_3652_9402:()=>w2o,content_3652_9404:()=>C2o,content_3652_9406:()=>L2o,content_3652_9408:()=>N2o,content_3652_9410:()=>W2o,content_3652_9412:()=>S2o,content_3652_9414:()=>O2o,content_3652_9416:()=>B2o,content_3652_9418:()=>q2o,content_3652_942:()=>wmt,content_3652_9420:()=>H2o,content_3652_9422:()=>J2o,content_3652_9424:()=>e6o,content_3652_9426:()=>p6o,content_3652_9428:()=>c6o,content_3652_9430:()=>l6o,content_3652_9432:()=>d6o,content_3652_9434:()=>k6o,content_3652_9436:()=>M6o,content_3652_9438:()=>w6o,content_3652_944:()=>Cmt,content_3652_9440:()=>C6o,content_3652_9442:()=>L6o,content_3652_9444:()=>N6o,content_3652_9446:()=>W6o,content_3652_9448:()=>S6o,content_3652_9450:()=>O6o,content_3652_9452:()=>B6o,content_3652_9454:()=>q6o,content_3652_9456:()=>H6o,content_3652_9458:()=>J6o,content_3652_946:()=>Lmt,content_3652_9460:()=>e3o,content_3652_9462:()=>p3o,content_3652_9464:()=>c3o,content_3652_9466:()=>l3o,content_3652_9468:()=>d3o,content_3652_9470:()=>k3o,content_3652_9472:()=>M3o,content_3652_9474:()=>w3o,content_3652_9476:()=>C3o,content_3652_9478:()=>L3o,content_3652_948:()=>Nmt,content_3652_9480:()=>N3o,content_3652_9482:()=>W3o,content_3652_9484:()=>S3o,content_3652_9486:()=>O3o,content_3652_9488:()=>B3o,content_3652_9490:()=>q3o,content_3652_9492:()=>H3o,content_3652_9494:()=>J3o,content_3652_9496:()=>e5o,content_3652_9498:()=>p5o,content_3652_950:()=>Wmt,content_3652_9500:()=>c5o,content_3652_9502:()=>l5o,content_3652_9504:()=>d5o,content_3652_9506:()=>k5o,content_3652_9508:()=>M5o,content_3652_9510:()=>w5o,content_3652_9512:()=>C5o,content_3652_9514:()=>L5o,content_3652_9516:()=>N5o,content_3652_9518:()=>W5o,content_3652_952:()=>Smt,content_3652_9520:()=>S5o,content_3652_9522:()=>O5o,content_3652_9524:()=>B5o,content_3652_9526:()=>q5o,content_3652_9528:()=>H5o,content_3652_9530:()=>J5o,content_3652_9532:()=>e1o,content_3652_9534:()=>p1o,content_3652_9536:()=>c1o,content_3652_9538:()=>l1o,content_3652_954:()=>Omt,content_3652_9540:()=>d1o,content_3652_9542:()=>k1o,content_3652_9544:()=>M1o,content_3652_9546:()=>w1o,content_3652_9548:()=>C1o,content_3652_9550:()=>L1o,content_3652_9552:()=>N1o,content_3652_9554:()=>W1o,content_3652_9556:()=>S1o,content_3652_9558:()=>O1o,content_3652_956:()=>Bmt,content_3652_9560:()=>B1o,content_3652_9562:()=>q1o,content_3652_9564:()=>H1o,content_3652_9566:()=>J1o,content_3652_9568:()=>e4o,content_3652_9570:()=>p4o,content_3652_9572:()=>c4o,content_3652_9574:()=>l4o,content_3652_9576:()=>d4o,content_3652_9578:()=>k4o,content_3652_958:()=>qmt,content_3652_9580:()=>M4o,content_3652_9582:()=>w4o,content_3652_9584:()=>C4o,content_3652_9586:()=>L4o,content_3652_9588:()=>N4o,content_3652_9590:()=>W4o,content_3652_9592:()=>S4o,content_3652_9594:()=>O4o,content_3652_9596:()=>B4o,content_3652_9598:()=>q4o,content_3652_96:()=>YJ,content_3652_960:()=>Hmt,content_3652_9600:()=>H4o,content_3652_9602:()=>J4o,content_3652_9604:()=>e8o,content_3652_9606:()=>p8o,content_3652_9608:()=>c8o,content_3652_9610:()=>l8o,content_3652_9612:()=>d8o,content_3652_9614:()=>k8o,content_3652_9616:()=>M8o,content_3652_9618:()=>w8o,content_3652_962:()=>Jmt,content_3652_9620:()=>C8o,content_3652_9622:()=>L8o,content_3652_9624:()=>N8o,content_3652_9626:()=>W8o,content_3652_9628:()=>S8o,content_3652_9630:()=>O8o,content_3652_9632:()=>B8o,content_3652_9634:()=>q8o,content_3652_9636:()=>H8o,content_3652_9638:()=>J8o,content_3652_964:()=>edt,content_3652_9640:()=>e7o,content_3652_9642:()=>p7o,content_3652_9644:()=>c7o,content_3652_9646:()=>l7o,content_3652_9648:()=>d7o,content_3652_9650:()=>k7o,content_3652_9652:()=>M7o,content_3652_9654:()=>w7o,content_3652_9656:()=>C7o,content_3652_9658:()=>L7o,content_3652_966:()=>pdt,content_3652_9660:()=>N7o,content_3652_9662:()=>W7o,content_3652_9664:()=>S7o,content_3652_9666:()=>O7o,content_3652_9668:()=>B7o,content_3652_9670:()=>q7o,content_3652_9672:()=>H7o,content_3652_9674:()=>J7o,content_3652_9676:()=>e9o,content_3652_9678:()=>p9o,content_3652_968:()=>cdt,content_3652_9680:()=>c9o,content_3652_9682:()=>l9o,content_3652_9684:()=>d9o,content_3652_9686:()=>k9o,content_3652_9688:()=>M9o,content_3652_9690:()=>w9o,content_3652_9692:()=>C9o,content_3652_9694:()=>L9o,content_3652_9696:()=>N9o,content_3652_9698:()=>W9o,content_3652_970:()=>ldt,content_3652_9700:()=>S9o,content_3652_9702:()=>O9o,content_3652_9704:()=>B9o,content_3652_9706:()=>q9o,content_3652_9708:()=>H9o,content_3652_9710:()=>J9o,content_3652_9712:()=>etp,content_3652_9714:()=>ptp,content_3652_9716:()=>ctp,content_3652_9718:()=>ltp,content_3652_972:()=>ddt,content_3652_9720:()=>dtp,content_3652_9722:()=>ktp,content_3652_9724:()=>Mtp,content_3652_9726:()=>wtp,content_3652_9728:()=>Ctp,content_3652_9730:()=>Ltp,content_3652_9732:()=>Ntp,content_3652_9734:()=>Wtp,content_3652_9736:()=>Stp,content_3652_9738:()=>Otp,content_3652_974:()=>kdt,content_3652_9740:()=>Btp,content_3652_9742:()=>qtp,content_3652_9744:()=>Htp,content_3652_9746:()=>Jtp,content_3652_9748:()=>eep,content_3652_9750:()=>pep,content_3652_9752:()=>cep,content_3652_9754:()=>lep,content_3652_9756:()=>dep,content_3652_9758:()=>kep,content_3652_976:()=>Mdt,content_3652_9760:()=>Mep,content_3652_9762:()=>wep,content_3652_9764:()=>Cep,content_3652_9766:()=>Lep,content_3652_9768:()=>Nep,content_3652_9770:()=>Wep,content_3652_9772:()=>Sep,content_3652_9774:()=>Oep,content_3652_9776:()=>Bep,content_3652_9778:()=>qep,content_3652_978:()=>wdt,content_3652_9780:()=>Hep,content_3652_9782:()=>Jep,content_3652_9784:()=>enp,content_3652_9786:()=>pnp,content_3652_9788:()=>cnp,content_3652_9790:()=>lnp,content_3652_9792:()=>dnp,content_3652_9794:()=>knp,content_3652_9796:()=>Mnp,content_3652_9798:()=>wnp,content_3652_98:()=>$J,content_3652_980:()=>Cdt,content_3652_9800:()=>Cnp,content_3652_9802:()=>Lnp,content_3652_9804:()=>Nnp,content_3652_9806:()=>Wnp,content_3652_9808:()=>Snp,content_3652_9810:()=>Onp,content_3652_9812:()=>Bnp,content_3652_9814:()=>qnp,content_3652_9816:()=>Hnp,content_3652_9818:()=>Jnp,content_3652_982:()=>Ldt,content_3652_9820:()=>eop,content_3652_9822:()=>pop,content_3652_9824:()=>cop,content_3652_9826:()=>lop,content_3652_9828:()=>dop,content_3652_9830:()=>kop,content_3652_9832:()=>Mop,content_3652_9834:()=>wop,content_3652_9836:()=>Cop,content_3652_9838:()=>Lop,content_3652_984:()=>Ndt,content_3652_9840:()=>Nop,content_3652_9842:()=>Wop,content_3652_9844:()=>Sop,content_3652_9846:()=>Oop,content_3652_9848:()=>Bop,content_3652_9850:()=>qop,content_3652_9852:()=>Hop,content_3652_9854:()=>Jop,content_3652_9856:()=>epp,content_3652_9858:()=>ppp,content_3652_986:()=>Wdt,content_3652_9860:()=>cpp,content_3652_9862:()=>lpp,content_3652_9864:()=>dpp,content_3652_9866:()=>kpp,content_3652_9868:()=>Mpp,content_3652_9870:()=>wpp,content_3652_9872:()=>Cpp,content_3652_9874:()=>Lpp,content_3652_9876:()=>Npp,content_3652_9878:()=>Wpp,content_3652_988:()=>Sdt,content_3652_9880:()=>Spp,content_3652_9882:()=>Opp,content_3652_9884:()=>Bpp,content_3652_9886:()=>qpp,content_3652_9888:()=>Hpp,content_3652_9890:()=>Jpp,content_3652_9892:()=>erp,content_3652_9894:()=>prp,content_3652_9896:()=>crp,content_3652_9898:()=>lrp,content_3652_990:()=>Odt,content_3652_9900:()=>drp,content_3652_9902:()=>krp,content_3652_9904:()=>Mrp,content_3652_9906:()=>wrp,content_3652_9908:()=>Crp,content_3652_9910:()=>Lrp,content_3652_9912:()=>Nrp,content_3652_9914:()=>Wrp,content_3652_9916:()=>Srp,content_3652_9918:()=>Orp,content_3652_992:()=>Bdt,content_3652_9920:()=>Brp,content_3652_9922:()=>qrp,content_3652_9924:()=>Hrp,content_3652_9926:()=>Jrp,content_3652_9928:()=>esp,content_3652_9930:()=>psp,content_3652_9932:()=>csp,content_3652_9934:()=>lsp,content_3652_9936:()=>dsp,content_3652_9938:()=>ksp,content_3652_994:()=>qdt,content_3652_9940:()=>Msp,content_3652_9942:()=>wsp,content_3652_9944:()=>Csp,content_3652_9946:()=>Lsp,content_3652_9948:()=>Nsp,content_3652_9950:()=>Wsp,content_3652_9952:()=>Ssp,content_3652_9954:()=>Osp,content_3652_9956:()=>Bsp,content_3652_9958:()=>qsp,content_3652_996:()=>Hdt,content_3652_9960:()=>Hsp,content_3652_9962:()=>Jsp,content_3652_9964:()=>ecp,content_3652_9966:()=>pcp,content_3652_9968:()=>ccp,content_3652_9970:()=>lcp,content_3652_9972:()=>dcp,content_3652_9974:()=>kcp,content_3652_9976:()=>Mcp,content_3652_9978:()=>wcp,content_3652_998:()=>Jdt,content_3652_9980:()=>Ccp,content_3652_9982:()=>Lcp,content_3652_9984:()=>Ncp,content_3652_9986:()=>Wcp,content_3652_9988:()=>Scp,content_3652_9990:()=>Ocp,content_3652_9992:()=>Bcp,content_3652_9994:()=>qcp,content_3652_9996:()=>Hcp,content_3652_9998:()=>Jcp});var p=n(7896),r=n(2784),s=n(876);const c={toc:[]},i="wrapper";function a(t){let{components:e,...n}=t;return(0,s.kt)(i,(0,p.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}a.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(t){let{components:e,...n}=t;return(0,s.kt)(u,(0,p.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const d={toc:[]},h="wrapper";function f(t){let{components:e,...n}=t;return(0,s.kt)(h,(0,p.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}f.isMDXComponent=!0;const k={toc:[]},y="wrapper";function D(t){let{components:e,...n}=t;return(0,s.kt)(y,(0,p.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(t){let{components:e,...n}=t;return(0,s.kt)(X,(0,p.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function g(t){let{components:e,...n}=t;return(0,s.kt)(T,(0,p.Z)({},w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}g.isMDXComponent=!0;const C={toc:[]},x="wrapper";function v(t){let{components:e,...n}=t;return(0,s.kt)(x,(0,p.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}v.isMDXComponent=!0;const L={toc:[]},Z="wrapper";function b(t){let{components:e,...n}=t;return(0,s.kt)(Z,(0,p.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}b.isMDXComponent=!0;const N={toc:[]},A="wrapper";function z(t){let{components:e,...n}=t;return(0,s.kt)(A,(0,p.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}z.isMDXComponent=!0;const W={toc:[]},I="wrapper";function R(t){let{components:e,...n}=t;return(0,s.kt)(I,(0,p.Z)({},W,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}R.isMDXComponent=!0;const S={toc:[]},P="wrapper";function E(t){let{components:e,...n}=t;return(0,s.kt)(P,(0,p.Z)({},S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}E.isMDXComponent=!0;const O={toc:[]},G="wrapper";function F(t){let{components:e,...n}=t;return(0,s.kt)(G,(0,p.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}F.isMDXComponent=!0;const B={toc:[]},U="wrapper";function V(t){let{components:e,...n}=t;return(0,s.kt)(U,(0,p.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}V.isMDXComponent=!0;const q={toc:[]},j="wrapper";function Y(t){let{components:e,...n}=t;return(0,s.kt)(j,(0,p.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}Y.isMDXComponent=!0;const H={toc:[]},Q="wrapper";function $(t){let{components:e,...n}=t;return(0,s.kt)(Q,(0,p.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}$.isMDXComponent=!0;const J={toc:[]},K="wrapper";function tt(t){let{components:e,...n}=t;return(0,s.kt)(K,(0,p.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}tt.isMDXComponent=!0;const et={toc:[]},nt="wrapper";function ot(t){let{components:e,...n}=t;return(0,s.kt)(nt,(0,p.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}ot.isMDXComponent=!0;const pt={toc:[]},rt="wrapper";function st(t){let{components:e,...n}=t;return(0,s.kt)(rt,(0,p.Z)({},pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the animation range."))}st.isMDXComponent=!0;const ct={toc:[]},it="wrapper";function at(t){let{components:e,...n}=t;return(0,s.kt)(it,(0,p.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}at.isMDXComponent=!0;const lt={toc:[]},ut="wrapper";function mt(t){let{components:e,...n}=t;return(0,s.kt)(ut,(0,p.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the user-defined range."))}mt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function ft(t){let{components:e,...n}=t;return(0,s.kt)(ht,(0,p.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}ft.isMDXComponent=!0;const kt={toc:[]},yt="wrapper";function Dt(t){let{components:e,...n}=t;return(0,s.kt)(yt,(0,p.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}Dt.isMDXComponent=!0;const Mt={toc:[]},Xt="wrapper";function _t(t){let{components:e,...n}=t;return(0,s.kt)(Xt,(0,p.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}_t.isMDXComponent=!0;const wt={toc:[]},Tt="wrapper";function gt(t){let{components:e,...n}=t;return(0,s.kt)(Tt,(0,p.Z)({},wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}gt.isMDXComponent=!0;const Ct={toc:[]},xt="wrapper";function vt(t){let{components:e,...n}=t;return(0,s.kt)(xt,(0,p.Z)({},Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}vt.isMDXComponent=!0;const Lt={toc:[]},Zt="wrapper";function bt(t){let{components:e,...n}=t;return(0,s.kt)(Zt,(0,p.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bt.isMDXComponent=!0;const Nt={toc:[]},At="wrapper";function zt(t){let{components:e,...n}=t;return(0,s.kt)(At,(0,p.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zt.isMDXComponent=!0;const Wt={toc:[]},It="wrapper";function Rt(t){let{components:e,...n}=t;return(0,s.kt)(It,(0,p.Z)({},Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rt.isMDXComponent=!0;const St={toc:[]},Pt="wrapper";function Et(t){let{components:e,...n}=t;return(0,s.kt)(Pt,(0,p.Z)({},St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Et.isMDXComponent=!0;const Ot={toc:[]},Gt="wrapper";function Ft(t){let{components:e,...n}=t;return(0,s.kt)(Gt,(0,p.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}Ft.isMDXComponent=!0;const Bt={toc:[]},Ut="wrapper";function Vt(t){let{components:e,...n}=t;return(0,s.kt)(Ut,(0,p.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Vt.isMDXComponent=!0;const qt={toc:[]},jt="wrapper";function Yt(t){let{components:e,...n}=t;return(0,s.kt)(jt,(0,p.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yt.isMDXComponent=!0;const Ht={toc:[]},Qt="wrapper";function $t(t){let{components:e,...n}=t;return(0,s.kt)(Qt,(0,p.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}$t.isMDXComponent=!0;const Jt={toc:[]},Kt="wrapper";function te(t){let{components:e,...n}=t;return(0,s.kt)(Kt,(0,p.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}te.isMDXComponent=!0;const ee={toc:[]},ne="wrapper";function oe(t){let{components:e,...n}=t;return(0,s.kt)(ne,(0,p.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(t){let{components:e,...n}=t;return(0,s.kt)(re,(0,p.Z)({},pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}se.isMDXComponent=!0;const ce={toc:[]},ie="wrapper";function ae(t){let{components:e,...n}=t;return(0,s.kt)(ie,(0,p.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}ae.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(t){let{components:e,...n}=t;return(0,s.kt)(ue,(0,p.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}me.isMDXComponent=!0;const de={toc:[]},he="wrapper";function fe(t){let{components:e,...n}=t;return(0,s.kt)(he,(0,p.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}fe.isMDXComponent=!0;const ke={toc:[]},ye="wrapper";function De(t){let{components:e,...n}=t;return(0,s.kt)(ye,(0,p.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(t){let{components:e,...n}=t;return(0,s.kt)(Xe,(0,p.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function ge(t){let{components:e,...n}=t;return(0,s.kt)(Te,(0,p.Z)({},we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}ge.isMDXComponent=!0;const Ce={toc:[]},xe="wrapper";function ve(t){let{components:e,...n}=t;return(0,s.kt)(xe,(0,p.Z)({},Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}ve.isMDXComponent=!0;const Le={toc:[]},Ze="wrapper";function be(t){let{components:e,...n}=t;return(0,s.kt)(Ze,(0,p.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}be.isMDXComponent=!0;const Ne={toc:[]},Ae="wrapper";function ze(t){let{components:e,...n}=t;return(0,s.kt)(Ae,(0,p.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}ze.isMDXComponent=!0;const We={toc:[]},Ie="wrapper";function Re(t){let{components:e,...n}=t;return(0,s.kt)(Ie,(0,p.Z)({},We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Re.isMDXComponent=!0;const Se={toc:[]},Pe="wrapper";function Ee(t){let{components:e,...n}=t;return(0,s.kt)(Pe,(0,p.Z)({},Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Ee.isMDXComponent=!0;const Oe={toc:[]},Ge="wrapper";function Fe(t){let{components:e,...n}=t;return(0,s.kt)(Ge,(0,p.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Fe.isMDXComponent=!0;const Be={toc:[]},Ue="wrapper";function Ve(t){let{components:e,...n}=t;return(0,s.kt)(Ue,(0,p.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ve.isMDXComponent=!0;const qe={toc:[]},je="wrapper";function Ye(t){let{components:e,...n}=t;return(0,s.kt)(je,(0,p.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ye.isMDXComponent=!0;const He={toc:[]},Qe="wrapper";function $e(t){let{components:e,...n}=t;return(0,s.kt)(Qe,(0,p.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}$e.isMDXComponent=!0;const Je={toc:[]},Ke="wrapper";function tn(t){let{components:e,...n}=t;return(0,s.kt)(Ke,(0,p.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}tn.isMDXComponent=!0;const en={toc:[]},nn="wrapper";function on(t){let{components:e,...n}=t;return(0,s.kt)(nn,(0,p.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(t){let{components:e,...n}=t;return(0,s.kt)(rn,(0,p.Z)({},pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(t){let{components:e,...n}=t;return(0,s.kt)(an,(0,p.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function dn(t){let{components:e,...n}=t;return(0,s.kt)(mn,(0,p.Z)({},un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}dn.isMDXComponent=!0;const hn={toc:[]},fn="wrapper";function kn(t){let{components:e,...n}=t;return(0,s.kt)(fn,(0,p.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}kn.isMDXComponent=!0;const yn={toc:[]},Dn="wrapper";function Mn(t){let{components:e,...n}=t;return(0,s.kt)(Dn,(0,p.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(t){let{components:e,...n}=t;return(0,s.kt)(_n,(0,p.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}wn.isMDXComponent=!0;const Tn={toc:[]},gn="wrapper";function Cn(t){let{components:e,...n}=t;return(0,s.kt)(gn,(0,p.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Cn.isMDXComponent=!0;const xn={toc:[]},vn="wrapper";function Ln(t){let{components:e,...n}=t;return(0,s.kt)(vn,(0,p.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}Ln.isMDXComponent=!0;const Zn={toc:[]},bn="wrapper";function Nn(t){let{components:e,...n}=t;return(0,s.kt)(bn,(0,p.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}Nn.isMDXComponent=!0;const An={toc:[]},zn="wrapper";function Wn(t){let{components:e,...n}=t;return(0,s.kt)(zn,(0,p.Z)({},An,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}Wn.isMDXComponent=!0;const In={toc:[]},Rn="wrapper";function Sn(t){let{components:e,...n}=t;return(0,s.kt)(Rn,(0,p.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Sn.isMDXComponent=!0;const Pn={toc:[]},En="wrapper";function On(t){let{components:e,...n}=t;return(0,s.kt)(En,(0,p.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}On.isMDXComponent=!0;const Gn={toc:[]},Fn="wrapper";function Bn(t){let{components:e,...n}=t;return(0,s.kt)(Fn,(0,p.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Bn.isMDXComponent=!0;const Un={toc:[]},Vn="wrapper";function qn(t){let{components:e,...n}=t;return(0,s.kt)(Vn,(0,p.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}qn.isMDXComponent=!0;const jn={toc:[]},Yn="wrapper";function Hn(t){let{components:e,...n}=t;return(0,s.kt)(Yn,(0,p.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}Hn.isMDXComponent=!0;const Qn={toc:[]},$n="wrapper";function Jn(t){let{components:e,...n}=t;return(0,s.kt)($n,(0,p.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Jn.isMDXComponent=!0;const Kn={toc:[]},to="wrapper";function eo(t){let{components:e,...n}=t;return(0,s.kt)(to,(0,p.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}eo.isMDXComponent=!0;const no={toc:[]},oo="wrapper";function po(t){let{components:e,...n}=t;return(0,s.kt)(oo,(0,p.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(t){let{components:e,...n}=t;return(0,s.kt)(so,(0,p.Z)({},ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}co.isMDXComponent=!0;const io={toc:[]},ao="wrapper";function lo(t){let{components:e,...n}=t;return(0,s.kt)(ao,(0,p.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function ho(t){let{components:e,...n}=t;return(0,s.kt)(mo,(0,p.Z)({},uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}ho.isMDXComponent=!0;const fo={toc:[]},ko="wrapper";function yo(t){let{components:e,...n}=t;return(0,s.kt)(ko,(0,p.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}yo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(t){let{components:e,...n}=t;return(0,s.kt)(Mo,(0,p.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an individual log entry."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(t){let{components:e,...n}=t;return(0,s.kt)(wo,(0,p.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}To.isMDXComponent=!0;const go={toc:[]},Co="wrapper";function xo(t){let{components:e,...n}=t;return(0,s.kt)(Co,(0,p.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}xo.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function Zo(t){let{components:e,...n}=t;return(0,s.kt)(Lo,(0,p.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Zo.isMDXComponent=!0;const bo={toc:[]},No="wrapper";function Ao(t){let{components:e,...n}=t;return(0,s.kt)(No,(0,p.Z)({},bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}Ao.isMDXComponent=!0;const zo={toc:[]},Wo="wrapper";function Io(t){let{components:e,...n}=t;return(0,s.kt)(Wo,(0,p.Z)({},zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log level."))}Io.isMDXComponent=!0;const Ro={toc:[]},So="wrapper";function Po(t){let{components:e,...n}=t;return(0,s.kt)(So,(0,p.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Po.isMDXComponent=!0;const Eo={toc:[]},Oo="wrapper";function Go(t){let{components:e,...n}=t;return(0,s.kt)(Oo,(0,p.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}Go.isMDXComponent=!0;const Fo={toc:[]},Bo="wrapper";function Uo(t){let{components:e,...n}=t;return(0,s.kt)(Bo,(0,p.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Uo.isMDXComponent=!0;const Vo={toc:[]},qo="wrapper";function jo(t){let{components:e,...n}=t;return(0,s.kt)(qo,(0,p.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}jo.isMDXComponent=!0;const Yo={toc:[]},Ho="wrapper";function Qo(t){let{components:e,...n}=t;return(0,s.kt)(Ho,(0,p.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Qo.isMDXComponent=!0;const $o={toc:[]},Jo="wrapper";function Ko(t){let{components:e,...n}=t;return(0,s.kt)(Jo,(0,p.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional information about the log."))}Ko.isMDXComponent=!0;const tp={toc:[]},ep="wrapper";function np(t){let{components:e,...n}=t;return(0,s.kt)(ep,(0,p.Z)({},tp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.kt)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}np.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(t){let{components:e,...n}=t;return(0,s.kt)(pp,(0,p.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace of the log."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ip(t){let{components:e,...n}=t;return(0,s.kt)(cp,(0,p.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}ip.isMDXComponent=!0;const ap={toc:[]},lp="wrapper";function up(t){let{components:e,...n}=t;return(0,s.kt)(lp,(0,p.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An url for the audio track to play alongside the animation."))}up.isMDXComponent=!0;const mp={toc:[]},dp="wrapper";function hp(t){let{components:e,...n}=t;return(0,s.kt)(dp,(0,p.Z)({},mp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}hp.isMDXComponent=!0;const fp={toc:[]},kp="wrapper";function yp(t){let{components:e,...n}=t;return(0,s.kt)(kp,(0,p.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}))}yp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(t){let{components:e,...n}=t;return(0,s.kt)(Mp,(0,p.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(t){let{components:e,...n}=t;return(0,s.kt)(wp,(0,p.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enable experimental features."))}Tp.isMDXComponent=!0;const gp={toc:[]},Cp="wrapper";function xp(t){let{components:e,...n}=t;return(0,s.kt)(Cp,(0,p.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A custom logger instance to use."))}xp.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function Zp(t){let{components:e,...n}=t;return(0,s.kt)(Lp,(0,p.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the project."))}Zp.isMDXComponent=!0;const bp={toc:[]},Np="wrapper";function Ap(t){let{components:e,...n}=t;return(0,s.kt)(Np,(0,p.Z)({},bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Ap.isMDXComponent=!0;const zp={toc:[]},Wp="wrapper";function Ip(t){let{components:e,...n}=t;return(0,s.kt)(Wp,(0,p.Z)({},zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}Ip.isMDXComponent=!0;const Rp={toc:[]},Sp="wrapper";function Pp(t){let{components:e,...n}=t;return(0,s.kt)(Sp,(0,p.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.kt)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}Pp.isMDXComponent=!0;const Ep={toc:[]},Op="wrapper";function Gp(t){let{components:e,...n}=t;return(0,s.kt)(Op,(0,p.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}Gp.isMDXComponent=!0;const Fp={toc:[]},Bp="wrapper";function Up(t){let{components:e,...n}=t;return(0,s.kt)(Bp,(0,p.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of scene descriptions that make up the project."))}Up.isMDXComponent=!0;const Vp={toc:[]},qp="wrapper";function jp(t){let{components:e,...n}=t;return(0,s.kt)(qp,(0,p.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}jp.isMDXComponent=!0;const Yp={toc:[]},Hp="wrapper";function Qp(t){let{components:e,...n}=t;return(0,s.kt)(Hp,(0,p.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default values for project variables."))}Qp.isMDXComponent=!0;const $p={toc:[]},Jp="wrapper";function Kp(t){let{components:e,...n}=t;return(0,s.kt)(Jp,(0,p.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Kp.isMDXComponent=!0;const tr={toc:[]},er="wrapper";function nr(t){let{components:e,...n}=t;return(0,s.kt)(er,(0,p.Z)({},tr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}nr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(t){let{components:e,...n}=t;return(0,s.kt)(pr,(0,p.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ir(t){let{components:e,...n}=t;return(0,s.kt)(cr,(0,p.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}ir.isMDXComponent=!0;const ar={toc:[]},lr="wrapper";function ur(t){let{components:e,...n}=t;return(0,s.kt)(lr,(0,p.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}ur.isMDXComponent=!0;const mr={toc:[]},dr="wrapper";function hr(t){let{components:e,...n}=t;return(0,s.kt)(dr,(0,p.Z)({},mr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}hr.isMDXComponent=!0;const fr={toc:[]},kr="wrapper";function yr(t){let{components:e,...n}=t;return(0,s.kt)(kr,(0,p.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}yr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(t){let{components:e,...n}=t;return(0,s.kt)(Mr,(0,p.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(t){let{components:e,...n}=t;return(0,s.kt)(wr,(0,p.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Tr.isMDXComponent=!0;const gr={toc:[]},Cr="wrapper";function xr(t){let{components:e,...n}=t;return(0,s.kt)(Cr,(0,p.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}xr.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function Zr(t){let{components:e,...n}=t;return(0,s.kt)(Lr,(0,p.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zr.isMDXComponent=!0;const br={toc:[]},Nr="wrapper";function Ar(t){let{components:e,...n}=t;return(0,s.kt)(Nr,(0,p.Z)({},br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ar.isMDXComponent=!0;const zr={toc:[]},Wr="wrapper";function Ir(t){let{components:e,...n}=t;return(0,s.kt)(Wr,(0,p.Z)({},zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ir.isMDXComponent=!0;const Rr={toc:[]},Sr="wrapper";function Pr(t){let{components:e,...n}=t;return(0,s.kt)(Sr,(0,p.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Pr.isMDXComponent=!0;const Er={toc:[]},Or="wrapper";function Gr(t){let{components:e,...n}=t;return(0,s.kt)(Or,(0,p.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Gr.isMDXComponent=!0;const Fr={toc:[]},Br="wrapper";function Ur(t){let{components:e,...n}=t;return(0,s.kt)(Br,(0,p.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ur.isMDXComponent=!0;const Vr={toc:[]},qr="wrapper";function jr(t){let{components:e,...n}=t;return(0,s.kt)(qr,(0,p.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}jr.isMDXComponent=!0;const Yr={toc:[]},Hr="wrapper";function Qr(t){let{components:e,...n}=t;return(0,s.kt)(Hr,(0,p.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}Qr.isMDXComponent=!0;const $r={toc:[]},Jr="wrapper";function Kr(t){let{components:e,...n}=t;return(0,s.kt)(Jr,(0,p.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Kr.isMDXComponent=!0;const ts={toc:[]},es="wrapper";function ns(t){let{components:e,...n}=t;return(0,s.kt)(es,(0,p.Z)({},ts,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ns.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(t){let{components:e,...n}=t;return(0,s.kt)(ps,(0,p.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function is(t){let{components:e,...n}=t;return(0,s.kt)(cs,(0,p.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}is.isMDXComponent=!0;const as={toc:[]},ls="wrapper";function us(t){let{components:e,...n}=t;return(0,s.kt)(ls,(0,p.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}us.isMDXComponent=!0;const ms={toc:[]},ds="wrapper";function hs(t){let{components:e,...n}=t;return(0,s.kt)(ds,(0,p.Z)({},ms,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hs.isMDXComponent=!0;const fs={toc:[]},ks="wrapper";function ys(t){let{components:e,...n}=t;return(0,s.kt)(ks,(0,p.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ys.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(t){let{components:e,...n}=t;return(0,s.kt)(Ms,(0,p.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(t){let{components:e,...n}=t;return(0,s.kt)(ws,(0,p.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Ts.isMDXComponent=!0;const gs={toc:[]},Cs="wrapper";function xs(t){let{components:e,...n}=t;return(0,s.kt)(Cs,(0,p.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}xs.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function Zs(t){let{components:e,...n}=t;return(0,s.kt)(Ls,(0,p.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Zs.isMDXComponent=!0;const bs={toc:[]},Ns="wrapper";function As(t){let{components:e,...n}=t;return(0,s.kt)(Ns,(0,p.Z)({},bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}As.isMDXComponent=!0;const zs={toc:[]},Ws="wrapper";function Is(t){let{components:e,...n}=t;return(0,s.kt)(Ws,(0,p.Z)({},zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Is.isMDXComponent=!0;const Rs={toc:[]},Ss="wrapper";function Ps(t){let{components:e,...n}=t;return(0,s.kt)(Ss,(0,p.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ps.isMDXComponent=!0;const Es={toc:[]},Os="wrapper";function Gs(t){let{components:e,...n}=t;return(0,s.kt)(Os,(0,p.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Gs.isMDXComponent=!0;const Fs={toc:[]},Bs="wrapper";function Us(t){let{components:e,...n}=t;return(0,s.kt)(Bs,(0,p.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Us.isMDXComponent=!0;const Vs={toc:[]},qs="wrapper";function js(t){let{components:e,...n}=t;return(0,s.kt)(qs,(0,p.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}js.isMDXComponent=!0;const Ys={toc:[]},Hs="wrapper";function Qs(t){let{components:e,...n}=t;return(0,s.kt)(Hs,(0,p.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Qs.isMDXComponent=!0;const $s={toc:[]},Js="wrapper";function Ks(t){let{components:e,...n}=t;return(0,s.kt)(Js,(0,p.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Ks.isMDXComponent=!0;const tc={toc:[]},ec="wrapper";function nc(t){let{components:e,...n}=t;return(0,s.kt)(ec,(0,p.Z)({},tc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}nc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(t){let{components:e,...n}=t;return(0,s.kt)(pc,(0,p.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ic(t){let{components:e,...n}=t;return(0,s.kt)(cc,(0,p.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ic.isMDXComponent=!0;const ac={toc:[]},lc="wrapper";function uc(t){let{components:e,...n}=t;return(0,s.kt)(lc,(0,p.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}uc.isMDXComponent=!0;const mc={toc:[]},dc="wrapper";function hc(t){let{components:e,...n}=t;return(0,s.kt)(dc,(0,p.Z)({},mc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}hc.isMDXComponent=!0;const fc={toc:[]},kc="wrapper";function yc(t){let{components:e,...n}=t;return(0,s.kt)(kc,(0,p.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}yc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(t){let{components:e,...n}=t;return(0,s.kt)(Mc,(0,p.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(t){let{components:e,...n}=t;return(0,s.kt)(wc,(0,p.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Tc.isMDXComponent=!0;const gc={toc:[]},Cc="wrapper";function xc(t){let{components:e,...n}=t;return(0,s.kt)(Cc,(0,p.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}xc.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function Zc(t){let{components:e,...n}=t;return(0,s.kt)(Lc,(0,p.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Zc.isMDXComponent=!0;const bc={toc:[]},Nc="wrapper";function Ac(t){let{components:e,...n}=t;return(0,s.kt)(Nc,(0,p.Z)({},bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ac.isMDXComponent=!0;const zc={toc:[]},Wc="wrapper";function Ic(t){let{components:e,...n}=t;return(0,s.kt)(Wc,(0,p.Z)({},zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Ic.isMDXComponent=!0;const Rc={toc:[]},Sc="wrapper";function Pc(t){let{components:e,...n}=t;return(0,s.kt)(Sc,(0,p.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Pc.isMDXComponent=!0;const Ec={toc:[]},Oc="wrapper";function Gc(t){let{components:e,...n}=t;return(0,s.kt)(Oc,(0,p.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Gc.isMDXComponent=!0;const Fc={toc:[]},Bc="wrapper";function Uc(t){let{components:e,...n}=t;return(0,s.kt)(Bc,(0,p.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Uc.isMDXComponent=!0;const Vc={toc:[]},qc="wrapper";function jc(t){let{components:e,...n}=t;return(0,s.kt)(qc,(0,p.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}jc.isMDXComponent=!0;const Yc={toc:[]},Hc="wrapper";function Qc(t){let{components:e,...n}=t;return(0,s.kt)(Hc,(0,p.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Qc.isMDXComponent=!0;const $c={toc:[]},Jc="wrapper";function Kc(t){let{components:e,...n}=t;return(0,s.kt)(Jc,(0,p.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Kc.isMDXComponent=!0;const ti={toc:[]},ei="wrapper";function ni(t){let{components:e,...n}=t;return(0,s.kt)(ei,(0,p.Z)({},ti,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ni.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(t){let{components:e,...n}=t;return(0,s.kt)(pi,(0,p.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ii(t){let{components:e,...n}=t;return(0,s.kt)(ci,(0,p.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ii.isMDXComponent=!0;const ai={toc:[]},li="wrapper";function ui(t){let{components:e,...n}=t;return(0,s.kt)(li,(0,p.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ui.isMDXComponent=!0;const mi={toc:[]},di="wrapper";function hi(t){let{components:e,...n}=t;return(0,s.kt)(di,(0,p.Z)({},mi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}hi.isMDXComponent=!0;const fi={toc:[]},ki="wrapper";function yi(t){let{components:e,...n}=t;return(0,s.kt)(ki,(0,p.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}yi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(t){let{components:e,...n}=t;return(0,s.kt)(Mi,(0,p.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(t){let{components:e,...n}=t;return(0,s.kt)(wi,(0,p.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ti.isMDXComponent=!0;const gi={toc:[]},Ci="wrapper";function xi(t){let{components:e,...n}=t;return(0,s.kt)(Ci,(0,p.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}xi.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function Zi(t){let{components:e,...n}=t;return(0,s.kt)(Li,(0,p.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Zi.isMDXComponent=!0;const bi={toc:[]},Ni="wrapper";function Ai(t){let{components:e,...n}=t;return(0,s.kt)(Ni,(0,p.Z)({},bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ai.isMDXComponent=!0;const zi={toc:[]},Wi="wrapper";function Ii(t){let{components:e,...n}=t;return(0,s.kt)(Wi,(0,p.Z)({},zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ii.isMDXComponent=!0;const Ri={toc:[]},Si="wrapper";function Pi(t){let{components:e,...n}=t;return(0,s.kt)(Si,(0,p.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Pi.isMDXComponent=!0;const Ei={toc:[]},Oi="wrapper";function Gi(t){let{components:e,...n}=t;return(0,s.kt)(Oi,(0,p.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Gi.isMDXComponent=!0;const Fi={toc:[]},Bi="wrapper";function Ui(t){let{components:e,...n}=t;return(0,s.kt)(Bi,(0,p.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ui.isMDXComponent=!0;const Vi={toc:[]},qi="wrapper";function ji(t){let{components:e,...n}=t;return(0,s.kt)(qi,(0,p.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ji.isMDXComponent=!0;const Yi={toc:[]},Hi="wrapper";function Qi(t){let{components:e,...n}=t;return(0,s.kt)(Hi,(0,p.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Qi.isMDXComponent=!0;const $i={toc:[]},Ji="wrapper";function Ki(t){let{components:e,...n}=t;return(0,s.kt)(Ji,(0,p.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Ki.isMDXComponent=!0;const ta={toc:[]},ea="wrapper";function na(t){let{components:e,...n}=t;return(0,s.kt)(ea,(0,p.Z)({},ta,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}na.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(t){let{components:e,...n}=t;return(0,s.kt)(pa,(0,p.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function ia(t){let{components:e,...n}=t;return(0,s.kt)(ca,(0,p.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ia.isMDXComponent=!0;const aa={toc:[]},la="wrapper";function ua(t){let{components:e,...n}=t;return(0,s.kt)(la,(0,p.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ua.isMDXComponent=!0;const ma={toc:[]},da="wrapper";function ha(t){let{components:e,...n}=t;return(0,s.kt)(da,(0,p.Z)({},ma,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}ha.isMDXComponent=!0;const fa={toc:[]},ka="wrapper";function ya(t){let{components:e,...n}=t;return(0,s.kt)(ka,(0,p.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ya.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(t){let{components:e,...n}=t;return(0,s.kt)(Ma,(0,p.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(t){let{components:e,...n}=t;return(0,s.kt)(wa,(0,p.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ta.isMDXComponent=!0;const ga={toc:[]},Ca="wrapper";function xa(t){let{components:e,...n}=t;return(0,s.kt)(Ca,(0,p.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}xa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function Za(t){let{components:e,...n}=t;return(0,s.kt)(La,(0,p.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Za.isMDXComponent=!0;const ba={toc:[]},Na="wrapper";function Aa(t){let{components:e,...n}=t;return(0,s.kt)(Na,(0,p.Z)({},ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Aa.isMDXComponent=!0;const za={toc:[]},Wa="wrapper";function Ia(t){let{components:e,...n}=t;return(0,s.kt)(Wa,(0,p.Z)({},za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ia.isMDXComponent=!0;const Ra={toc:[]},Sa="wrapper";function Pa(t){let{components:e,...n}=t;return(0,s.kt)(Sa,(0,p.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}Pa.isMDXComponent=!0;const Ea={toc:[]},Oa="wrapper";function Ga(t){let{components:e,...n}=t;return(0,s.kt)(Oa,(0,p.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Ga.isMDXComponent=!0;const Fa={toc:[]},Ba="wrapper";function Ua(t){let{components:e,...n}=t;return(0,s.kt)(Ba,(0,p.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ua.isMDXComponent=!0;const Va={toc:[]},qa="wrapper";function ja(t){let{components:e,...n}=t;return(0,s.kt)(qa,(0,p.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}ja.isMDXComponent=!0;const Ya={toc:[]},Ha="wrapper";function Qa(t){let{components:e,...n}=t;return(0,s.kt)(Ha,(0,p.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Qa.isMDXComponent=!0;const $a={toc:[]},Ja="wrapper";function Ka(t){let{components:e,...n}=t;return(0,s.kt)(Ja,(0,p.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ka.isMDXComponent=!0;const tl={toc:[]},el="wrapper";function nl(t){let{components:e,...n}=t;return(0,s.kt)(el,(0,p.Z)({},tl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}nl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(t){let{components:e,...n}=t;return(0,s.kt)(pl,(0,p.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function il(t){let{components:e,...n}=t;return(0,s.kt)(cl,(0,p.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}il.isMDXComponent=!0;const al={toc:[]},ll="wrapper";function ul(t){let{components:e,...n}=t;return(0,s.kt)(ll,(0,p.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}ul.isMDXComponent=!0;const ml={toc:[]},dl="wrapper";function hl(t){let{components:e,...n}=t;return(0,s.kt)(dl,(0,p.Z)({},ml,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}hl.isMDXComponent=!0;const fl={toc:[]},kl="wrapper";function yl(t){let{components:e,...n}=t;return(0,s.kt)(kl,(0,p.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}yl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(t){let{components:e,...n}=t;return(0,s.kt)(Ml,(0,p.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(t){let{components:e,...n}=t;return(0,s.kt)(wl,(0,p.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Tl.isMDXComponent=!0;const gl={toc:[]},Cl="wrapper";function xl(t){let{components:e,...n}=t;return(0,s.kt)(Cl,(0,p.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}xl.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function Zl(t){let{components:e,...n}=t;return(0,s.kt)(Ll,(0,p.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Zl.isMDXComponent=!0;const bl={toc:[]},Nl="wrapper";function Al(t){let{components:e,...n}=t;return(0,s.kt)(Nl,(0,p.Z)({},bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Al.isMDXComponent=!0;const zl={toc:[]},Wl="wrapper";function Il(t){let{components:e,...n}=t;return(0,s.kt)(Wl,(0,p.Z)({},zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Il.isMDXComponent=!0;const Rl={toc:[]},Sl="wrapper";function Pl(t){let{components:e,...n}=t;return(0,s.kt)(Sl,(0,p.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Pl.isMDXComponent=!0;const El={toc:[]},Ol="wrapper";function Gl(t){let{components:e,...n}=t;return(0,s.kt)(Ol,(0,p.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Gl.isMDXComponent=!0;const Fl={toc:[]},Bl="wrapper";function Ul(t){let{components:e,...n}=t;return(0,s.kt)(Bl,(0,p.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Ul.isMDXComponent=!0;const Vl={toc:[]},ql="wrapper";function jl(t){let{components:e,...n}=t;return(0,s.kt)(ql,(0,p.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}jl.isMDXComponent=!0;const Yl={toc:[]},Hl="wrapper";function Ql(t){let{components:e,...n}=t;return(0,s.kt)(Hl,(0,p.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ql.isMDXComponent=!0;const $l={toc:[]},Jl="wrapper";function Kl(t){let{components:e,...n}=t;return(0,s.kt)(Jl,(0,p.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Kl.isMDXComponent=!0;const tu={toc:[]},eu="wrapper";function nu(t){let{components:e,...n}=t;return(0,s.kt)(eu,(0,p.Z)({},tu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}nu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(t){let{components:e,...n}=t;return(0,s.kt)(pu,(0,p.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function iu(t){let{components:e,...n}=t;return(0,s.kt)(cu,(0,p.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}iu.isMDXComponent=!0;const au={toc:[]},lu="wrapper";function uu(t){let{components:e,...n}=t;return(0,s.kt)(lu,(0,p.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}uu.isMDXComponent=!0;const mu={toc:[]},du="wrapper";function hu(t){let{components:e,...n}=t;return(0,s.kt)(du,(0,p.Z)({},mu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}hu.isMDXComponent=!0;const fu={toc:[]},ku="wrapper";function yu(t){let{components:e,...n}=t;return(0,s.kt)(ku,(0,p.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}yu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(t){let{components:e,...n}=t;return(0,s.kt)(Mu,(0,p.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(t){let{components:e,...n}=t;return(0,s.kt)(wu,(0,p.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}Tu.isMDXComponent=!0;const gu={toc:[]},Cu="wrapper";function xu(t){let{components:e,...n}=t;return(0,s.kt)(Cu,(0,p.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}xu.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function Zu(t){let{components:e,...n}=t;return(0,s.kt)(Lu,(0,p.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Zu.isMDXComponent=!0;const bu={toc:[]},Nu="wrapper";function Au(t){let{components:e,...n}=t;return(0,s.kt)(Nu,(0,p.Z)({},bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Au.isMDXComponent=!0;const zu={toc:[]},Wu="wrapper";function Iu(t){let{components:e,...n}=t;return(0,s.kt)(Wu,(0,p.Z)({},zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Iu.isMDXComponent=!0;const Ru={toc:[]},Su="wrapper";function Pu(t){let{components:e,...n}=t;return(0,s.kt)(Su,(0,p.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Pu.isMDXComponent=!0;const Eu={toc:[]},Ou="wrapper";function Gu(t){let{components:e,...n}=t;return(0,s.kt)(Ou,(0,p.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}Gu.isMDXComponent=!0;const Fu={toc:[]},Bu="wrapper";function Uu(t){let{components:e,...n}=t;return(0,s.kt)(Bu,(0,p.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Uu.isMDXComponent=!0;const Vu={toc:[]},qu="wrapper";function ju(t){let{components:e,...n}=t;return(0,s.kt)(qu,(0,p.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}ju.isMDXComponent=!0;const Yu={toc:[]},Hu="wrapper";function Qu(t){let{components:e,...n}=t;return(0,s.kt)(Hu,(0,p.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Qu.isMDXComponent=!0;const $u={toc:[]},Ju="wrapper";function Ku(t){let{components:e,...n}=t;return(0,s.kt)(Ju,(0,p.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ku.isMDXComponent=!0;const tm={toc:[]},em="wrapper";function nm(t){let{components:e,...n}=t;return(0,s.kt)(em,(0,p.Z)({},tm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}nm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(t){let{components:e,...n}=t;return(0,s.kt)(pm,(0,p.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function im(t){let{components:e,...n}=t;return(0,s.kt)(cm,(0,p.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}im.isMDXComponent=!0;const am={toc:[]},lm="wrapper";function um(t){let{components:e,...n}=t;return(0,s.kt)(lm,(0,p.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}um.isMDXComponent=!0;const mm={toc:[]},dm="wrapper";function hm(t){let{components:e,...n}=t;return(0,s.kt)(dm,(0,p.Z)({},mm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}hm.isMDXComponent=!0;const fm={toc:[]},km="wrapper";function ym(t){let{components:e,...n}=t;return(0,s.kt)(km,(0,p.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}ym.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(t){let{components:e,...n}=t;return(0,s.kt)(Mm,(0,p.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(t){let{components:e,...n}=t;return(0,s.kt)(wm,(0,p.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Tm.isMDXComponent=!0;const gm={toc:[]},Cm="wrapper";function xm(t){let{components:e,...n}=t;return(0,s.kt)(Cm,(0,p.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}xm.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function Zm(t){let{components:e,...n}=t;return(0,s.kt)(Lm,(0,p.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Zm.isMDXComponent=!0;const bm={toc:[]},Nm="wrapper";function Am(t){let{components:e,...n}=t;return(0,s.kt)(Nm,(0,p.Z)({},bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Am.isMDXComponent=!0;const zm={toc:[]},Wm="wrapper";function Im(t){let{components:e,...n}=t;return(0,s.kt)(Wm,(0,p.Z)({},zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Im.isMDXComponent=!0;const Rm={toc:[]},Sm="wrapper";function Pm(t){let{components:e,...n}=t;return(0,s.kt)(Sm,(0,p.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Pm.isMDXComponent=!0;const Em={toc:[]},Om="wrapper";function Gm(t){let{components:e,...n}=t;return(0,s.kt)(Om,(0,p.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}Gm.isMDXComponent=!0;const Fm={toc:[]},Bm="wrapper";function Um(t){let{components:e,...n}=t;return(0,s.kt)(Bm,(0,p.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Um.isMDXComponent=!0;const Vm={toc:[]},qm="wrapper";function jm(t){let{components:e,...n}=t;return(0,s.kt)(qm,(0,p.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}jm.isMDXComponent=!0;const Ym={toc:[]},Hm="wrapper";function Qm(t){let{components:e,...n}=t;return(0,s.kt)(Hm,(0,p.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}Qm.isMDXComponent=!0;const $m={toc:[]},Jm="wrapper";function Km(t){let{components:e,...n}=t;return(0,s.kt)(Jm,(0,p.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}Km.isMDXComponent=!0;const td={toc:[]},ed="wrapper";function nd(t){let{components:e,...n}=t;return(0,s.kt)(ed,(0,p.Z)({},td,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}nd.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(t){let{components:e,...n}=t;return(0,s.kt)(pd,(0,p.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function id(t){let{components:e,...n}=t;return(0,s.kt)(cd,(0,p.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}id.isMDXComponent=!0;const ad={toc:[]},ld="wrapper";function ud(t){let{components:e,...n}=t;return(0,s.kt)(ld,(0,p.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}ud.isMDXComponent=!0;const md={toc:[]},dd="wrapper";function hd(t){let{components:e,...n}=t;return(0,s.kt)(dd,(0,p.Z)({},md,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}hd.isMDXComponent=!0;const fd={toc:[]},kd="wrapper";function yd(t){let{components:e,...n}=t;return(0,s.kt)(kd,(0,p.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}yd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(t){let{components:e,...n}=t;return(0,s.kt)(Md,(0,p.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(t){let{components:e,...n}=t;return(0,s.kt)(wd,(0,p.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Td.isMDXComponent=!0;const gd={toc:[]},Cd="wrapper";function xd(t){let{components:e,...n}=t;return(0,s.kt)(Cd,(0,p.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}xd.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function Zd(t){let{components:e,...n}=t;return(0,s.kt)(Ld,(0,p.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}Zd.isMDXComponent=!0;const bd={toc:[]},Nd="wrapper";function Ad(t){let{components:e,...n}=t;return(0,s.kt)(Nd,(0,p.Z)({},bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}Ad.isMDXComponent=!0;const zd={toc:[]},Wd="wrapper";function Id(t){let{components:e,...n}=t;return(0,s.kt)(Wd,(0,p.Z)({},zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Id.isMDXComponent=!0;const Rd={toc:[]},Sd="wrapper";function Pd(t){let{components:e,...n}=t;return(0,s.kt)(Sd,(0,p.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Pd.isMDXComponent=!0;const Ed={toc:[]},Od="wrapper";function Gd(t){let{components:e,...n}=t;return(0,s.kt)(Od,(0,p.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Gd.isMDXComponent=!0;const Fd={toc:[]},Bd="wrapper";function Ud(t){let{components:e,...n}=t;return(0,s.kt)(Bd,(0,p.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Ud.isMDXComponent=!0;const Vd={toc:[]},qd="wrapper";function jd(t){let{components:e,...n}=t;return(0,s.kt)(qd,(0,p.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}jd.isMDXComponent=!0;const Yd={toc:[]},Hd="wrapper";function Qd(t){let{components:e,...n}=t;return(0,s.kt)(Hd,(0,p.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Qd.isMDXComponent=!0;const $d={toc:[]},Jd="wrapper";function Kd(t){let{components:e,...n}=t;return(0,s.kt)(Jd,(0,p.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Kd.isMDXComponent=!0;const th={toc:[]},eh="wrapper";function nh(t){let{components:e,...n}=t;return(0,s.kt)(eh,(0,p.Z)({},th,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}nh.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(t){let{components:e,...n}=t;return(0,s.kt)(ph,(0,p.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ih(t){let{components:e,...n}=t;return(0,s.kt)(ch,(0,p.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}ih.isMDXComponent=!0;const ah={toc:[]},lh="wrapper";function uh(t){let{components:e,...n}=t;return(0,s.kt)(lh,(0,p.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}uh.isMDXComponent=!0;const mh={toc:[]},dh="wrapper";function hh(t){let{components:e,...n}=t;return(0,s.kt)(dh,(0,p.Z)({},mh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}hh.isMDXComponent=!0;const fh={toc:[]},kh="wrapper";function yh(t){let{components:e,...n}=t;return(0,s.kt)(kh,(0,p.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}yh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(t){let{components:e,...n}=t;return(0,s.kt)(Mh,(0,p.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(t){let{components:e,...n}=t;return(0,s.kt)(wh,(0,p.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Th.isMDXComponent=!0;const gh={toc:[]},Ch="wrapper";function xh(t){let{components:e,...n}=t;return(0,s.kt)(Ch,(0,p.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}xh.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function Zh(t){let{components:e,...n}=t;return(0,s.kt)(Lh,(0,p.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Zh.isMDXComponent=!0;const bh={toc:[]},Nh="wrapper";function Ah(t){let{components:e,...n}=t;return(0,s.kt)(Nh,(0,p.Z)({},bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ah.isMDXComponent=!0;const zh={toc:[]},Wh="wrapper";function Ih(t){let{components:e,...n}=t;return(0,s.kt)(Wh,(0,p.Z)({},zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ih.isMDXComponent=!0;const Rh={toc:[]},Sh="wrapper";function Ph(t){let{components:e,...n}=t;return(0,s.kt)(Sh,(0,p.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Ph.isMDXComponent=!0;const Eh={toc:[]},Oh="wrapper";function Gh(t){let{components:e,...n}=t;return(0,s.kt)(Oh,(0,p.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Gh.isMDXComponent=!0;const Fh={toc:[]},Bh="wrapper";function Uh(t){let{components:e,...n}=t;return(0,s.kt)(Bh,(0,p.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Uh.isMDXComponent=!0;const Vh={toc:[]},qh="wrapper";function jh(t){let{components:e,...n}=t;return(0,s.kt)(qh,(0,p.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}jh.isMDXComponent=!0;const Yh={toc:[]},Hh="wrapper";function Qh(t){let{components:e,...n}=t;return(0,s.kt)(Hh,(0,p.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Qh.isMDXComponent=!0;const $h={toc:[]},Jh="wrapper";function Kh(t){let{components:e,...n}=t;return(0,s.kt)(Jh,(0,p.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const tf={toc:[]},ef="wrapper";function nf(t){let{components:e,...n}=t;return(0,s.kt)(ef,(0,p.Z)({},tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}nf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(t){let{components:e,...n}=t;return(0,s.kt)(pf,(0,p.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(t){let{components:e,...n}=t;return(0,s.kt)(cf,(0,p.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(t){let{components:e,...n}=t;return(0,s.kt)(uf,(0,p.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}mf.isMDXComponent=!0;const df={toc:[]},hf="wrapper";function ff(t){let{components:e,...n}=t;return(0,s.kt)(hf,(0,p.Z)({},df,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}ff.isMDXComponent=!0;const kf={toc:[]},yf="wrapper";function Df(t){let{components:e,...n}=t;return(0,s.kt)(yf,(0,p.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(t){let{components:e,...n}=t;return(0,s.kt)(Xf,(0,p.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function gf(t){let{components:e,...n}=t;return(0,s.kt)(Tf,(0,p.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}gf.isMDXComponent=!0;const Cf={toc:[]},xf="wrapper";function vf(t){let{components:e,...n}=t;return(0,s.kt)(xf,(0,p.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}vf.isMDXComponent=!0;const Lf={toc:[]},Zf="wrapper";function bf(t){let{components:e,...n}=t;return(0,s.kt)(Zf,(0,p.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bf.isMDXComponent=!0;const Nf={toc:[]},Af="wrapper";function zf(t){let{components:e,...n}=t;return(0,s.kt)(Af,(0,p.Z)({},Nf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zf.isMDXComponent=!0;const Wf={toc:[]},If="wrapper";function Rf(t){let{components:e,...n}=t;return(0,s.kt)(If,(0,p.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Rf.isMDXComponent=!0;const Sf={toc:[]},Pf="wrapper";function Ef(t){let{components:e,...n}=t;return(0,s.kt)(Pf,(0,p.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ef.isMDXComponent=!0;const Of={toc:[]},Gf="wrapper";function Ff(t){let{components:e,...n}=t;return(0,s.kt)(Gf,(0,p.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ff.isMDXComponent=!0;const Bf={toc:[]},Uf="wrapper";function Vf(t){let{components:e,...n}=t;return(0,s.kt)(Uf,(0,p.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Vf.isMDXComponent=!0;const qf={toc:[]},jf="wrapper";function Yf(t){let{components:e,...n}=t;return(0,s.kt)(jf,(0,p.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Yf.isMDXComponent=!0;const Hf={toc:[]},Qf="wrapper";function $f(t){let{components:e,...n}=t;return(0,s.kt)(Qf,(0,p.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}$f.isMDXComponent=!0;const Jf={toc:[]},Kf="wrapper";function tk(t){let{components:e,...n}=t;return(0,s.kt)(Kf,(0,p.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}tk.isMDXComponent=!0;const ek={toc:[]},nk="wrapper";function ok(t){let{components:e,...n}=t;return(0,s.kt)(nk,(0,p.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(t){let{components:e,...n}=t;return(0,s.kt)(rk,(0,p.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}sk.isMDXComponent=!0;const ck={toc:[]},ik="wrapper";function ak(t){let{components:e,...n}=t;return(0,s.kt)(ik,(0,p.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ak.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(t){let{components:e,...n}=t;return(0,s.kt)(uk,(0,p.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}mk.isMDXComponent=!0;const dk={toc:[]},hk="wrapper";function fk(t){let{components:e,...n}=t;return(0,s.kt)(hk,(0,p.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}fk.isMDXComponent=!0;const kk={toc:[]},yk="wrapper";function Dk(t){let{components:e,...n}=t;return(0,s.kt)(yk,(0,p.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(t){let{components:e,...n}=t;return(0,s.kt)(Xk,(0,p.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function gk(t){let{components:e,...n}=t;return(0,s.kt)(Tk,(0,p.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}gk.isMDXComponent=!0;const Ck={toc:[]},xk="wrapper";function vk(t){let{components:e,...n}=t;return(0,s.kt)(xk,(0,p.Z)({},Ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}vk.isMDXComponent=!0;const Lk={toc:[]},Zk="wrapper";function bk(t){let{components:e,...n}=t;return(0,s.kt)(Zk,(0,p.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}bk.isMDXComponent=!0;const Nk={toc:[]},Ak="wrapper";function zk(t){let{components:e,...n}=t;return(0,s.kt)(Ak,(0,p.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}zk.isMDXComponent=!0;const Wk={toc:[]},Ik="wrapper";function Rk(t){let{components:e,...n}=t;return(0,s.kt)(Ik,(0,p.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Rk.isMDXComponent=!0;const Sk={toc:[]},Pk="wrapper";function Ek(t){let{components:e,...n}=t;return(0,s.kt)(Pk,(0,p.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ek.isMDXComponent=!0;const Ok={toc:[]},Gk="wrapper";function Fk(t){let{components:e,...n}=t;return(0,s.kt)(Gk,(0,p.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Fk.isMDXComponent=!0;const Bk={toc:[]},Uk="wrapper";function Vk(t){let{components:e,...n}=t;return(0,s.kt)(Uk,(0,p.Z)({},Bk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Vk.isMDXComponent=!0;const qk={toc:[]},jk="wrapper";function Yk(t){let{components:e,...n}=t;return(0,s.kt)(jk,(0,p.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Yk.isMDXComponent=!0;const Hk={toc:[]},Qk="wrapper";function $k(t){let{components:e,...n}=t;return(0,s.kt)(Qk,(0,p.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}$k.isMDXComponent=!0;const Jk={toc:[]},Kk="wrapper";function ty(t){let{components:e,...n}=t;return(0,s.kt)(Kk,(0,p.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ty.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function oy(t){let{components:e,...n}=t;return(0,s.kt)(ny,(0,p.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}oy.isMDXComponent=!0;const py={toc:[]},ry="wrapper";function sy(t){let{components:e,...n}=t;return(0,s.kt)(ry,(0,p.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sy.isMDXComponent=!0;const cy={toc:[]},iy="wrapper";function ay(t){let{components:e,...n}=t;return(0,s.kt)(iy,(0,p.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ay.isMDXComponent=!0;const ly={toc:[]},uy="wrapper";function my(t){let{components:e,...n}=t;return(0,s.kt)(uy,(0,p.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}my.isMDXComponent=!0;const dy={toc:[]},hy="wrapper";function fy(t){let{components:e,...n}=t;return(0,s.kt)(hy,(0,p.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}fy.isMDXComponent=!0;const ky={toc:[]},yy="wrapper";function Dy(t){let{components:e,...n}=t;return(0,s.kt)(yy,(0,p.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Dy.isMDXComponent=!0;const My={toc:[]},Xy="wrapper";function _y(t){let{components:e,...n}=t;return(0,s.kt)(Xy,(0,p.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_y.isMDXComponent=!0;const wy={toc:[]},Ty="wrapper";function gy(t){let{components:e,...n}=t;return(0,s.kt)(Ty,(0,p.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}gy.isMDXComponent=!0;const Cy={toc:[]},xy="wrapper";function vy(t){let{components:e,...n}=t;return(0,s.kt)(xy,(0,p.Z)({},Cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}vy.isMDXComponent=!0;const Ly={toc:[]},Zy="wrapper";function by(t){let{components:e,...n}=t;return(0,s.kt)(Zy,(0,p.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}by.isMDXComponent=!0;const Ny={toc:[]},Ay="wrapper";function zy(t){let{components:e,...n}=t;return(0,s.kt)(Ay,(0,p.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}zy.isMDXComponent=!0;const Wy={toc:[]},Iy="wrapper";function Ry(t){let{components:e,...n}=t;return(0,s.kt)(Iy,(0,p.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Ry.isMDXComponent=!0;const Sy={toc:[]},Py="wrapper";function Ey(t){let{components:e,...n}=t;return(0,s.kt)(Py,(0,p.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ey.isMDXComponent=!0;const Oy={toc:[]},Gy="wrapper";function Fy(t){let{components:e,...n}=t;return(0,s.kt)(Gy,(0,p.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fy.isMDXComponent=!0;const By={toc:[]},Uy="wrapper";function Vy(t){let{components:e,...n}=t;return(0,s.kt)(Uy,(0,p.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Yy(t){let{components:e,...n}=t;return(0,s.kt)(jy,(0,p.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Yy.isMDXComponent=!0;const Hy={toc:[]},Qy="wrapper";function $y(t){let{components:e,...n}=t;return(0,s.kt)(Qy,(0,p.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}$y.isMDXComponent=!0;const Jy={toc:[]},Ky="wrapper";function tD(t){let{components:e,...n}=t;return(0,s.kt)(Ky,(0,p.Z)({},Jy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}tD.isMDXComponent=!0;const eD={toc:[]},nD="wrapper";function oD(t){let{components:e,...n}=t;return(0,s.kt)(nD,(0,p.Z)({},eD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(t){let{components:e,...n}=t;return(0,s.kt)(rD,(0,p.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}sD.isMDXComponent=!0;const cD={toc:[]},iD="wrapper";function aD(t){let{components:e,...n}=t;return(0,s.kt)(iD,(0,p.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}aD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(t){let{components:e,...n}=t;return(0,s.kt)(uD,(0,p.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}mD.isMDXComponent=!0;const dD={toc:[]},hD="wrapper";function fD(t){let{components:e,...n}=t;return(0,s.kt)(hD,(0,p.Z)({},dD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}fD.isMDXComponent=!0;const kD={toc:[]},yD="wrapper";function DD(t){let{components:e,...n}=t;return(0,s.kt)(yD,(0,p.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(t){let{components:e,...n}=t;return(0,s.kt)(XD,(0,p.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function gD(t){let{components:e,...n}=t;return(0,s.kt)(TD,(0,p.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}gD.isMDXComponent=!0;const CD={toc:[]},xD="wrapper";function vD(t){let{components:e,...n}=t;return(0,s.kt)(xD,(0,p.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}vD.isMDXComponent=!0;const LD={toc:[]},ZD="wrapper";function bD(t){let{components:e,...n}=t;return(0,s.kt)(ZD,(0,p.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bD.isMDXComponent=!0;const ND={toc:[]},AD="wrapper";function zD(t){let{components:e,...n}=t;return(0,s.kt)(AD,(0,p.Z)({},ND,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zD.isMDXComponent=!0;const WD={toc:[]},ID="wrapper";function RD(t){let{components:e,...n}=t;return(0,s.kt)(ID,(0,p.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}RD.isMDXComponent=!0;const SD={toc:[]},PD="wrapper";function ED(t){let{components:e,...n}=t;return(0,s.kt)(PD,(0,p.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ED.isMDXComponent=!0;const OD={toc:[]},GD="wrapper";function FD(t){let{components:e,...n}=t;return(0,s.kt)(GD,(0,p.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}FD.isMDXComponent=!0;const BD={toc:[]},UD="wrapper";function VD(t){let{components:e,...n}=t;return(0,s.kt)(UD,(0,p.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}VD.isMDXComponent=!0;const qD={toc:[]},jD="wrapper";function YD(t){let{components:e,...n}=t;return(0,s.kt)(jD,(0,p.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}YD.isMDXComponent=!0;const HD={toc:[]},QD="wrapper";function $D(t){let{components:e,...n}=t;return(0,s.kt)(QD,(0,p.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$D.isMDXComponent=!0;const JD={toc:[]},KD="wrapper";function tM(t){let{components:e,...n}=t;return(0,s.kt)(KD,(0,p.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}tM.isMDXComponent=!0;const eM={toc:[]},nM="wrapper";function oM(t){let{components:e,...n}=t;return(0,s.kt)(nM,(0,p.Z)({},eM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(t){let{components:e,...n}=t;return(0,s.kt)(rM,(0,p.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sM.isMDXComponent=!0;const cM={toc:[]},iM="wrapper";function aM(t){let{components:e,...n}=t;return(0,s.kt)(iM,(0,p.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}aM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(t){let{components:e,...n}=t;return(0,s.kt)(uM,(0,p.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}mM.isMDXComponent=!0;const dM={toc:[]},hM="wrapper";function fM(t){let{components:e,...n}=t;return(0,s.kt)(hM,(0,p.Z)({},dM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}fM.isMDXComponent=!0;const kM={toc:[]},yM="wrapper";function DM(t){let{components:e,...n}=t;return(0,s.kt)(yM,(0,p.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(t){let{components:e,...n}=t;return(0,s.kt)(XM,(0,p.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function gM(t){let{components:e,...n}=t;return(0,s.kt)(TM,(0,p.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}gM.isMDXComponent=!0;const CM={toc:[]},xM="wrapper";function vM(t){let{components:e,...n}=t;return(0,s.kt)(xM,(0,p.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}vM.isMDXComponent=!0;const LM={toc:[]},ZM="wrapper";function bM(t){let{components:e,...n}=t;return(0,s.kt)(ZM,(0,p.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bM.isMDXComponent=!0;const NM={toc:[]},AM="wrapper";function zM(t){let{components:e,...n}=t;return(0,s.kt)(AM,(0,p.Z)({},NM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zM.isMDXComponent=!0;const WM={toc:[]},IM="wrapper";function RM(t){let{components:e,...n}=t;return(0,s.kt)(IM,(0,p.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}RM.isMDXComponent=!0;const SM={toc:[]},PM="wrapper";function EM(t){let{components:e,...n}=t;return(0,s.kt)(PM,(0,p.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}EM.isMDXComponent=!0;const OM={toc:[]},GM="wrapper";function FM(t){let{components:e,...n}=t;return(0,s.kt)(GM,(0,p.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}FM.isMDXComponent=!0;const BM={toc:[]},UM="wrapper";function VM(t){let{components:e,...n}=t;return(0,s.kt)(UM,(0,p.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}VM.isMDXComponent=!0;const qM={toc:[]},jM="wrapper";function YM(t){let{components:e,...n}=t;return(0,s.kt)(jM,(0,p.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}YM.isMDXComponent=!0;const HM={toc:[]},QM="wrapper";function $M(t){let{components:e,...n}=t;return(0,s.kt)(QM,(0,p.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}$M.isMDXComponent=!0;const JM={toc:[]},KM="wrapper";function tX(t){let{components:e,...n}=t;return(0,s.kt)(KM,(0,p.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tX.isMDXComponent=!0;const eX={toc:[]},nX="wrapper";function oX(t){let{components:e,...n}=t;return(0,s.kt)(nX,(0,p.Z)({},eX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(t){let{components:e,...n}=t;return(0,s.kt)(rX,(0,p.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}sX.isMDXComponent=!0;const cX={toc:[]},iX="wrapper";function aX(t){let{components:e,...n}=t;return(0,s.kt)(iX,(0,p.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}aX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(t){let{components:e,...n}=t;return(0,s.kt)(uX,(0,p.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}mX.isMDXComponent=!0;const dX={toc:[]},hX="wrapper";function fX(t){let{components:e,...n}=t;return(0,s.kt)(hX,(0,p.Z)({},dX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}fX.isMDXComponent=!0;const kX={toc:[]},yX="wrapper";function DX(t){let{components:e,...n}=t;return(0,s.kt)(yX,(0,p.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(t){let{components:e,...n}=t;return(0,s.kt)(XX,(0,p.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function gX(t){let{components:e,...n}=t;return(0,s.kt)(TX,(0,p.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}gX.isMDXComponent=!0;const CX={toc:[]},xX="wrapper";function vX(t){let{components:e,...n}=t;return(0,s.kt)(xX,(0,p.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}vX.isMDXComponent=!0;const LX={toc:[]},ZX="wrapper";function bX(t){let{components:e,...n}=t;return(0,s.kt)(ZX,(0,p.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}bX.isMDXComponent=!0;const NX={toc:[]},AX="wrapper";function zX(t){let{components:e,...n}=t;return(0,s.kt)(AX,(0,p.Z)({},NX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}zX.isMDXComponent=!0;const WX={toc:[]},IX="wrapper";function RX(t){let{components:e,...n}=t;return(0,s.kt)(IX,(0,p.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}RX.isMDXComponent=!0;const SX={toc:[]},PX="wrapper";function EX(t){let{components:e,...n}=t;return(0,s.kt)(PX,(0,p.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}EX.isMDXComponent=!0;const OX={toc:[]},GX="wrapper";function FX(t){let{components:e,...n}=t;return(0,s.kt)(GX,(0,p.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}FX.isMDXComponent=!0;const BX={toc:[]},UX="wrapper";function VX(t){let{components:e,...n}=t;return(0,s.kt)(UX,(0,p.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}VX.isMDXComponent=!0;const qX={toc:[]},jX="wrapper";function YX(t){let{components:e,...n}=t;return(0,s.kt)(jX,(0,p.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}YX.isMDXComponent=!0;const HX={toc:[]},QX="wrapper";function $X(t){let{components:e,...n}=t;return(0,s.kt)(QX,(0,p.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}$X.isMDXComponent=!0;const JX={toc:[]},KX="wrapper";function t_(t){let{components:e,...n}=t;return(0,s.kt)(KX,(0,p.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}t_.isMDXComponent=!0;const e_={toc:[]},n_="wrapper";function o_(t){let{components:e,...n}=t;return(0,s.kt)(n_,(0,p.Z)({},e_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(t){let{components:e,...n}=t;return(0,s.kt)(r_,(0,p.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}s_.isMDXComponent=!0;const c_={toc:[]},i_="wrapper";function a_(t){let{components:e,...n}=t;return(0,s.kt)(i_,(0,p.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}a_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(t){let{components:e,...n}=t;return(0,s.kt)(u_,(0,p.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}m_.isMDXComponent=!0;const d_={toc:[]},h_="wrapper";function f_(t){let{components:e,...n}=t;return(0,s.kt)(h_,(0,p.Z)({},d_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}f_.isMDXComponent=!0;const k_={toc:[]},y_="wrapper";function D_(t){let{components:e,...n}=t;return(0,s.kt)(y_,(0,p.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(t){let{components:e,...n}=t;return(0,s.kt)(X_,(0,p.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function g_(t){let{components:e,...n}=t;return(0,s.kt)(T_,(0,p.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}g_.isMDXComponent=!0;const C_={toc:[]},x_="wrapper";function v_(t){let{components:e,...n}=t;return(0,s.kt)(x_,(0,p.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}v_.isMDXComponent=!0;const L_={toc:[]},Z_="wrapper";function b_(t){let{components:e,...n}=t;return(0,s.kt)(Z_,(0,p.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}b_.isMDXComponent=!0;const N_={toc:[]},A_="wrapper";function z_(t){let{components:e,...n}=t;return(0,s.kt)(A_,(0,p.Z)({},N_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}z_.isMDXComponent=!0;const W_={toc:[]},I_="wrapper";function R_(t){let{components:e,...n}=t;return(0,s.kt)(I_,(0,p.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}R_.isMDXComponent=!0;const S_={toc:[]},P_="wrapper";function E_(t){let{components:e,...n}=t;return(0,s.kt)(P_,(0,p.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}E_.isMDXComponent=!0;const O_={toc:[]},G_="wrapper";function F_(t){let{components:e,...n}=t;return(0,s.kt)(G_,(0,p.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}F_.isMDXComponent=!0;const B_={toc:[]},U_="wrapper";function V_(t){let{components:e,...n}=t;return(0,s.kt)(U_,(0,p.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}V_.isMDXComponent=!0;const q_={toc:[]},j_="wrapper";function Y_(t){let{components:e,...n}=t;return(0,s.kt)(j_,(0,p.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Y_.isMDXComponent=!0;const H_={toc:[]},Q_="wrapper";function $_(t){let{components:e,...n}=t;return(0,s.kt)(Q_,(0,p.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}$_.isMDXComponent=!0;const J_={toc:[]},K_="wrapper";function tw(t){let{components:e,...n}=t;return(0,s.kt)(K_,(0,p.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tw.isMDXComponent=!0;const ew={toc:[]},nw="wrapper";function ow(t){let{components:e,...n}=t;return(0,s.kt)(nw,(0,p.Z)({},ew,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(t){let{components:e,...n}=t;return(0,s.kt)(rw,(0,p.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}sw.isMDXComponent=!0;const cw={toc:[]},iw="wrapper";function aw(t){let{components:e,...n}=t;return(0,s.kt)(iw,(0,p.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}aw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(t){let{components:e,...n}=t;return(0,s.kt)(uw,(0,p.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}mw.isMDXComponent=!0;const dw={toc:[]},hw="wrapper";function fw(t){let{components:e,...n}=t;return(0,s.kt)(hw,(0,p.Z)({},dw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}fw.isMDXComponent=!0;const kw={toc:[]},yw="wrapper";function Dw(t){let{components:e,...n}=t;return(0,s.kt)(yw,(0,p.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(t){let{components:e,...n}=t;return(0,s.kt)(Xw,(0,p.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function gw(t){let{components:e,...n}=t;return(0,s.kt)(Tw,(0,p.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}gw.isMDXComponent=!0;const Cw={toc:[]},xw="wrapper";function vw(t){let{components:e,...n}=t;return(0,s.kt)(xw,(0,p.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}vw.isMDXComponent=!0;const Lw={toc:[]},Zw="wrapper";function bw(t){let{components:e,...n}=t;return(0,s.kt)(Zw,(0,p.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bw.isMDXComponent=!0;const Nw={toc:[]},Aw="wrapper";function zw(t){let{components:e,...n}=t;return(0,s.kt)(Aw,(0,p.Z)({},Nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zw.isMDXComponent=!0;const Ww={toc:[]},Iw="wrapper";function Rw(t){let{components:e,...n}=t;return(0,s.kt)(Iw,(0,p.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Rw.isMDXComponent=!0;const Sw={toc:[]},Pw="wrapper";function Ew(t){let{components:e,...n}=t;return(0,s.kt)(Pw,(0,p.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ew.isMDXComponent=!0;const Ow={toc:[]},Gw="wrapper";function Fw(t){let{components:e,...n}=t;return(0,s.kt)(Gw,(0,p.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fw.isMDXComponent=!0;const Bw={toc:[]},Uw="wrapper";function Vw(t){let{components:e,...n}=t;return(0,s.kt)(Uw,(0,p.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vw.isMDXComponent=!0;const qw={toc:[]},jw="wrapper";function Yw(t){let{components:e,...n}=t;return(0,s.kt)(jw,(0,p.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Yw.isMDXComponent=!0;const Hw={toc:[]},Qw="wrapper";function $w(t){let{components:e,...n}=t;return(0,s.kt)(Qw,(0,p.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$w.isMDXComponent=!0;const Jw={toc:[]},Kw="wrapper";function tT(t){let{components:e,...n}=t;return(0,s.kt)(Kw,(0,p.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}tT.isMDXComponent=!0;const eT={toc:[]},nT="wrapper";function oT(t){let{components:e,...n}=t;return(0,s.kt)(nT,(0,p.Z)({},eT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(t){let{components:e,...n}=t;return(0,s.kt)(rT,(0,p.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sT.isMDXComponent=!0;const cT={toc:[]},iT="wrapper";function aT(t){let{components:e,...n}=t;return(0,s.kt)(iT,(0,p.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}aT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(t){let{components:e,...n}=t;return(0,s.kt)(uT,(0,p.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}mT.isMDXComponent=!0;const dT={toc:[]},hT="wrapper";function fT(t){let{components:e,...n}=t;return(0,s.kt)(hT,(0,p.Z)({},dT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}fT.isMDXComponent=!0;const kT={toc:[]},yT="wrapper";function DT(t){let{components:e,...n}=t;return(0,s.kt)(yT,(0,p.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(t){let{components:e,...n}=t;return(0,s.kt)(XT,(0,p.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function gT(t){let{components:e,...n}=t;return(0,s.kt)(TT,(0,p.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}gT.isMDXComponent=!0;const CT={toc:[]},xT="wrapper";function vT(t){let{components:e,...n}=t;return(0,s.kt)(xT,(0,p.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}vT.isMDXComponent=!0;const LT={toc:[]},ZT="wrapper";function bT(t){let{components:e,...n}=t;return(0,s.kt)(ZT,(0,p.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}bT.isMDXComponent=!0;const NT={toc:[]},AT="wrapper";function zT(t){let{components:e,...n}=t;return(0,s.kt)(AT,(0,p.Z)({},NT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zT.isMDXComponent=!0;const WT={toc:[]},IT="wrapper";function RT(t){let{components:e,...n}=t;return(0,s.kt)(IT,(0,p.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}RT.isMDXComponent=!0;const ST={toc:[]},PT="wrapper";function ET(t){let{components:e,...n}=t;return(0,s.kt)(PT,(0,p.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ET.isMDXComponent=!0;const OT={toc:[]},GT="wrapper";function FT(t){let{components:e,...n}=t;return(0,s.kt)(GT,(0,p.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}FT.isMDXComponent=!0;const BT={toc:[]},UT="wrapper";function VT(t){let{components:e,...n}=t;return(0,s.kt)(UT,(0,p.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}VT.isMDXComponent=!0;const qT={toc:[]},jT="wrapper";function YT(t){let{components:e,...n}=t;return(0,s.kt)(jT,(0,p.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}YT.isMDXComponent=!0;const HT={toc:[]},QT="wrapper";function $T(t){let{components:e,...n}=t;return(0,s.kt)(QT,(0,p.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}$T.isMDXComponent=!0;const JT={toc:[]},KT="wrapper";function tg(t){let{components:e,...n}=t;return(0,s.kt)(KT,(0,p.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}tg.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function og(t){let{components:e,...n}=t;return(0,s.kt)(ng,(0,p.Z)({},eg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}og.isMDXComponent=!0;const pg={toc:[]},rg="wrapper";function sg(t){let{components:e,...n}=t;return(0,s.kt)(rg,(0,p.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}sg.isMDXComponent=!0;const cg={toc:[]},ig="wrapper";function ag(t){let{components:e,...n}=t;return(0,s.kt)(ig,(0,p.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}ag.isMDXComponent=!0;const lg={toc:[]},ug="wrapper";function mg(t){let{components:e,...n}=t;return(0,s.kt)(ug,(0,p.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mg.isMDXComponent=!0;const dg={toc:[]},hg="wrapper";function fg(t){let{components:e,...n}=t;return(0,s.kt)(hg,(0,p.Z)({},dg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}fg.isMDXComponent=!0;const kg={toc:[]},yg="wrapper";function Dg(t){let{components:e,...n}=t;return(0,s.kt)(yg,(0,p.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Dg.isMDXComponent=!0;const Mg={toc:[]},Xg="wrapper";function _g(t){let{components:e,...n}=t;return(0,s.kt)(Xg,(0,p.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}_g.isMDXComponent=!0;const wg={toc:[]},Tg="wrapper";function gg(t){let{components:e,...n}=t;return(0,s.kt)(Tg,(0,p.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}gg.isMDXComponent=!0;const Cg={toc:[]},xg="wrapper";function vg(t){let{components:e,...n}=t;return(0,s.kt)(xg,(0,p.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}vg.isMDXComponent=!0;const Lg={toc:[]},Zg="wrapper";function bg(t){let{components:e,...n}=t;return(0,s.kt)(Zg,(0,p.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}bg.isMDXComponent=!0;const Ng={toc:[]},Ag="wrapper";function zg(t){let{components:e,...n}=t;return(0,s.kt)(Ag,(0,p.Z)({},Ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}zg.isMDXComponent=!0;const Wg={toc:[]},Ig="wrapper";function Rg(t){let{components:e,...n}=t;return(0,s.kt)(Ig,(0,p.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Rg.isMDXComponent=!0;const Sg={toc:[]},Pg="wrapper";function Eg(t){let{components:e,...n}=t;return(0,s.kt)(Pg,(0,p.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}Eg.isMDXComponent=!0;const Og={toc:[]},Gg="wrapper";function Fg(t){let{components:e,...n}=t;return(0,s.kt)(Gg,(0,p.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}Fg.isMDXComponent=!0;const Bg={toc:[]},Ug="wrapper";function Vg(t){let{components:e,...n}=t;return(0,s.kt)(Ug,(0,p.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Yg(t){let{components:e,...n}=t;return(0,s.kt)(jg,(0,p.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.kt)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.kt)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}Yg.isMDXComponent=!0;const Hg={toc:[]},Qg="wrapper";function $g(t){let{components:e,...n}=t;return(0,s.kt)(Qg,(0,p.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unique name of the plugin."))}$g.isMDXComponent=!0;const Jg={toc:[]},Kg="wrapper";function tC(t){let{components:e,...n}=t;return(0,s.kt)(Kg,(0,p.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}tC.isMDXComponent=!0;const eC={toc:[]},nC="wrapper";function oC(t){let{components:e,...n}=t;return(0,s.kt)(nC,(0,p.Z)({},eC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(t){let{components:e,...n}=t;return(0,s.kt)(rC,(0,p.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}sC.isMDXComponent=!0;const cC={toc:[]},iC="wrapper";function aC(t){let{components:e,...n}=t;return(0,s.kt)(iC,(0,p.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}aC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(t){let{components:e,...n}=t;return(0,s.kt)(uC,(0,p.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}mC.isMDXComponent=!0;const dC={toc:[]},hC="wrapper";function fC(t){let{components:e,...n}=t;return(0,s.kt)(hC,(0,p.Z)({},dC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}fC.isMDXComponent=!0;const kC={toc:[]},yC="wrapper";function DC(t){let{components:e,...n}=t;return(0,s.kt)(yC,(0,p.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(t){let{components:e,...n}=t;return(0,s.kt)(XC,(0,p.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function gC(t){let{components:e,...n}=t;return(0,s.kt)(TC,(0,p.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gC.isMDXComponent=!0;const CC={toc:[]},xC="wrapper";function vC(t){let{components:e,...n}=t;return(0,s.kt)(xC,(0,p.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}vC.isMDXComponent=!0;const LC={toc:[]},ZC="wrapper";function bC(t){let{components:e,...n}=t;return(0,s.kt)(ZC,(0,p.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}bC.isMDXComponent=!0;const NC={toc:[]},AC="wrapper";function zC(t){let{components:e,...n}=t;return(0,s.kt)(AC,(0,p.Z)({},NC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}zC.isMDXComponent=!0;const WC={toc:[]},IC="wrapper";function RC(t){let{components:e,...n}=t;return(0,s.kt)(IC,(0,p.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}RC.isMDXComponent=!0;const SC={toc:[]},PC="wrapper";function EC(t){let{components:e,...n}=t;return(0,s.kt)(PC,(0,p.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}EC.isMDXComponent=!0;const OC={toc:[]},GC="wrapper";function FC(t){let{components:e,...n}=t;return(0,s.kt)(GC,(0,p.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}FC.isMDXComponent=!0;const BC={toc:[]},UC="wrapper";function VC(t){let{components:e,...n}=t;return(0,s.kt)(UC,(0,p.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}VC.isMDXComponent=!0;const qC={toc:[]},jC="wrapper";function YC(t){let{components:e,...n}=t;return(0,s.kt)(jC,(0,p.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}YC.isMDXComponent=!0;const HC={toc:[]},QC="wrapper";function $C(t){let{components:e,...n}=t;return(0,s.kt)(QC,(0,p.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}$C.isMDXComponent=!0;const JC={toc:[]},KC="wrapper";function tx(t){let{components:e,...n}=t;return(0,s.kt)(KC,(0,p.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}tx.isMDXComponent=!0;const ex={toc:[]},nx="wrapper";function ox(t){let{components:e,...n}=t;return(0,s.kt)(nx,(0,p.Z)({},ex,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(t){let{components:e,...n}=t;return(0,s.kt)(rx,(0,p.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}sx.isMDXComponent=!0;const cx={toc:[]},ix="wrapper";function ax(t){let{components:e,...n}=t;return(0,s.kt)(ix,(0,p.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}ax.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(t){let{components:e,...n}=t;return(0,s.kt)(ux,(0,p.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}mx.isMDXComponent=!0;const dx={toc:[]},hx="wrapper";function fx(t){let{components:e,...n}=t;return(0,s.kt)(hx,(0,p.Z)({},dx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}fx.isMDXComponent=!0;const kx={toc:[]},yx="wrapper";function Dx(t){let{components:e,...n}=t;return(0,s.kt)(yx,(0,p.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(t){let{components:e,...n}=t;return(0,s.kt)(Xx,(0,p.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function gx(t){let{components:e,...n}=t;return(0,s.kt)(Tx,(0,p.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}gx.isMDXComponent=!0;const Cx={toc:[]},xx="wrapper";function vx(t){let{components:e,...n}=t;return(0,s.kt)(xx,(0,p.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}vx.isMDXComponent=!0;const Lx={toc:[]},Zx="wrapper";function bx(t){let{components:e,...n}=t;return(0,s.kt)(Zx,(0,p.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}bx.isMDXComponent=!0;const Nx={toc:[]},Ax="wrapper";function zx(t){let{components:e,...n}=t;return(0,s.kt)(Ax,(0,p.Z)({},Nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}zx.isMDXComponent=!0;const Wx={toc:[]},Ix="wrapper";function Rx(t){let{components:e,...n}=t;return(0,s.kt)(Ix,(0,p.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}Rx.isMDXComponent=!0;const Sx={toc:[]},Px="wrapper";function Ex(t){let{components:e,...n}=t;return(0,s.kt)(Px,(0,p.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}Ex.isMDXComponent=!0;const Ox={toc:[]},Gx="wrapper";function Fx(t){let{components:e,...n}=t;return(0,s.kt)(Gx,(0,p.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Fx.isMDXComponent=!0;const Bx={toc:[]},Ux="wrapper";function Vx(t){let{components:e,...n}=t;return(0,s.kt)(Ux,(0,p.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Vx.isMDXComponent=!0;const qx={toc:[]},jx="wrapper";function Yx(t){let{components:e,...n}=t;return(0,s.kt)(jx,(0,p.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Yx.isMDXComponent=!0;const Hx={toc:[]},Qx="wrapper";function $x(t){let{components:e,...n}=t;return(0,s.kt)(Qx,(0,p.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}$x.isMDXComponent=!0;const Jx={toc:[]},Kx="wrapper";function tv(t){let{components:e,...n}=t;return(0,s.kt)(Kx,(0,p.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}tv.isMDXComponent=!0;const ev={toc:[]},nv="wrapper";function ov(t){let{components:e,...n}=t;return(0,s.kt)(nv,(0,p.Z)({},ev,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(t){let{components:e,...n}=t;return(0,s.kt)(rv,(0,p.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}sv.isMDXComponent=!0;const cv={toc:[]},iv="wrapper";function av(t){let{components:e,...n}=t;return(0,s.kt)(iv,(0,p.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}av.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(t){let{components:e,...n}=t;return(0,s.kt)(uv,(0,p.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}mv.isMDXComponent=!0;const dv={toc:[]},hv="wrapper";function fv(t){let{components:e,...n}=t;return(0,s.kt)(hv,(0,p.Z)({},dv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}fv.isMDXComponent=!0;const kv={toc:[]},yv="wrapper";function Dv(t){let{components:e,...n}=t;return(0,s.kt)(yv,(0,p.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(t){let{components:e,...n}=t;return(0,s.kt)(Xv,(0,p.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function gv(t){let{components:e,...n}=t;return(0,s.kt)(Tv,(0,p.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}gv.isMDXComponent=!0;const Cv={toc:[]},xv="wrapper";function vv(t){let{components:e,...n}=t;return(0,s.kt)(xv,(0,p.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}vv.isMDXComponent=!0;const Lv={toc:[]},Zv="wrapper";function bv(t){let{components:e,...n}=t;return(0,s.kt)(Zv,(0,p.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}bv.isMDXComponent=!0;const Nv={toc:[]},Av="wrapper";function zv(t){let{components:e,...n}=t;return(0,s.kt)(Av,(0,p.Z)({},Nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}zv.isMDXComponent=!0;const Wv={toc:[]},Iv="wrapper";function Rv(t){let{components:e,...n}=t;return(0,s.kt)(Iv,(0,p.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}Rv.isMDXComponent=!0;const Sv={toc:[]},Pv="wrapper";function Ev(t){let{components:e,...n}=t;return(0,s.kt)(Pv,(0,p.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Ev.isMDXComponent=!0;const Ov={toc:[]},Gv="wrapper";function Fv(t){let{components:e,...n}=t;return(0,s.kt)(Gv,(0,p.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}Fv.isMDXComponent=!0;const Bv={toc:[]},Uv="wrapper";function Vv(t){let{components:e,...n}=t;return(0,s.kt)(Uv,(0,p.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Vv.isMDXComponent=!0;const qv={toc:[]},jv="wrapper";function Yv(t){let{components:e,...n}=t;return(0,s.kt)(jv,(0,p.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}Yv.isMDXComponent=!0;const Hv={toc:[]},Qv="wrapper";function $v(t){let{components:e,...n}=t;return(0,s.kt)(Qv,(0,p.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}$v.isMDXComponent=!0;const Jv={toc:[]},Kv="wrapper";function tL(t){let{components:e,...n}=t;return(0,s.kt)(Kv,(0,p.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}tL.isMDXComponent=!0;const eL={toc:[]},nL="wrapper";function oL(t){let{components:e,...n}=t;return(0,s.kt)(nL,(0,p.Z)({},eL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(t){let{components:e,...n}=t;return(0,s.kt)(rL,(0,p.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}sL.isMDXComponent=!0;const cL={toc:[]},iL="wrapper";function aL(t){let{components:e,...n}=t;return(0,s.kt)(iL,(0,p.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}aL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(t){let{components:e,...n}=t;return(0,s.kt)(uL,(0,p.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}mL.isMDXComponent=!0;const dL={toc:[]},hL="wrapper";function fL(t){let{components:e,...n}=t;return(0,s.kt)(hL,(0,p.Z)({},dL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}fL.isMDXComponent=!0;const kL={toc:[]},yL="wrapper";function DL(t){let{components:e,...n}=t;return(0,s.kt)(yL,(0,p.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(t){let{components:e,...n}=t;return(0,s.kt)(XL,(0,p.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function gL(t){let{components:e,...n}=t;return(0,s.kt)(TL,(0,p.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}gL.isMDXComponent=!0;const CL={toc:[]},xL="wrapper";function vL(t){let{components:e,...n}=t;return(0,s.kt)(xL,(0,p.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}vL.isMDXComponent=!0;const LL={toc:[]},ZL="wrapper";function bL(t){let{components:e,...n}=t;return(0,s.kt)(ZL,(0,p.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}bL.isMDXComponent=!0;const NL={toc:[]},AL="wrapper";function zL(t){let{components:e,...n}=t;return(0,s.kt)(AL,(0,p.Z)({},NL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}zL.isMDXComponent=!0;const WL={toc:[]},IL="wrapper";function RL(t){let{components:e,...n}=t;return(0,s.kt)(IL,(0,p.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}RL.isMDXComponent=!0;const SL={toc:[]},PL="wrapper";function EL(t){let{components:e,...n}=t;return(0,s.kt)(PL,(0,p.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}EL.isMDXComponent=!0;const OL={toc:[]},GL="wrapper";function FL(t){let{components:e,...n}=t;return(0,s.kt)(GL,(0,p.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}FL.isMDXComponent=!0;const BL={toc:[]},UL="wrapper";function VL(t){let{components:e,...n}=t;return(0,s.kt)(UL,(0,p.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}VL.isMDXComponent=!0;const qL={toc:[]},jL="wrapper";function YL(t){let{components:e,...n}=t;return(0,s.kt)(jL,(0,p.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}YL.isMDXComponent=!0;const HL={toc:[]},QL="wrapper";function $L(t){let{components:e,...n}=t;return(0,s.kt)(QL,(0,p.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}$L.isMDXComponent=!0;const JL={toc:[]},KL="wrapper";function tZ(t){let{components:e,...n}=t;return(0,s.kt)(KL,(0,p.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}tZ.isMDXComponent=!0;const eZ={toc:[]},nZ="wrapper";function oZ(t){let{components:e,...n}=t;return(0,s.kt)(nZ,(0,p.Z)({},eZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(t){let{components:e,...n}=t;return(0,s.kt)(rZ,(0,p.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}sZ.isMDXComponent=!0;const cZ={toc:[]},iZ="wrapper";function aZ(t){let{components:e,...n}=t;return(0,s.kt)(iZ,(0,p.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}aZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(t){let{components:e,...n}=t;return(0,s.kt)(uZ,(0,p.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}mZ.isMDXComponent=!0;const dZ={toc:[]},hZ="wrapper";function fZ(t){let{components:e,...n}=t;return(0,s.kt)(hZ,(0,p.Z)({},dZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}fZ.isMDXComponent=!0;const kZ={toc:[]},yZ="wrapper";function DZ(t){let{components:e,...n}=t;return(0,s.kt)(yZ,(0,p.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(t){let{components:e,...n}=t;return(0,s.kt)(XZ,(0,p.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function gZ(t){let{components:e,...n}=t;return(0,s.kt)(TZ,(0,p.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}gZ.isMDXComponent=!0;const CZ={toc:[]},xZ="wrapper";function vZ(t){let{components:e,...n}=t;return(0,s.kt)(xZ,(0,p.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}vZ.isMDXComponent=!0;const LZ={toc:[]},ZZ="wrapper";function bZ(t){let{components:e,...n}=t;return(0,s.kt)(ZZ,(0,p.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}bZ.isMDXComponent=!0;const NZ={toc:[]},AZ="wrapper";function zZ(t){let{components:e,...n}=t;return(0,s.kt)(AZ,(0,p.Z)({},NZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}zZ.isMDXComponent=!0;const WZ={toc:[]},IZ="wrapper";function RZ(t){let{components:e,...n}=t;return(0,s.kt)(IZ,(0,p.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}RZ.isMDXComponent=!0;const SZ={toc:[]},PZ="wrapper";function EZ(t){let{components:e,...n}=t;return(0,s.kt)(PZ,(0,p.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}EZ.isMDXComponent=!0;const OZ={toc:[]},GZ="wrapper";function FZ(t){let{components:e,...n}=t;return(0,s.kt)(GZ,(0,p.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}FZ.isMDXComponent=!0;const BZ={toc:[]},UZ="wrapper";function VZ(t){let{components:e,...n}=t;return(0,s.kt)(UZ,(0,p.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}VZ.isMDXComponent=!0;const qZ={toc:[]},jZ="wrapper";function YZ(t){let{components:e,...n}=t;return(0,s.kt)(jZ,(0,p.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YZ.isMDXComponent=!0;const HZ={toc:[]},QZ="wrapper";function $Z(t){let{components:e,...n}=t;return(0,s.kt)(QZ,(0,p.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}$Z.isMDXComponent=!0;const JZ={toc:[]},KZ="wrapper";function tb(t){let{components:e,...n}=t;return(0,s.kt)(KZ,(0,p.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}tb.isMDXComponent=!0;const eb={toc:[]},nb="wrapper";function ob(t){let{components:e,...n}=t;return(0,s.kt)(nb,(0,p.Z)({},eb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(t){let{components:e,...n}=t;return(0,s.kt)(rb,(0,p.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}sb.isMDXComponent=!0;const cb={toc:[]},ib="wrapper";function ab(t){let{components:e,...n}=t;return(0,s.kt)(ib,(0,p.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}ab.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(t){let{components:e,...n}=t;return(0,s.kt)(ub,(0,p.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}mb.isMDXComponent=!0;const db={toc:[]},hb="wrapper";function fb(t){let{components:e,...n}=t;return(0,s.kt)(hb,(0,p.Z)({},db,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}fb.isMDXComponent=!0;const kb={toc:[]},yb="wrapper";function Db(t){let{components:e,...n}=t;return(0,s.kt)(yb,(0,p.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(t){let{components:e,...n}=t;return(0,s.kt)(Xb,(0,p.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function gb(t){let{components:e,...n}=t;return(0,s.kt)(Tb,(0,p.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}gb.isMDXComponent=!0;const Cb={toc:[]},xb="wrapper";function vb(t){let{components:e,...n}=t;return(0,s.kt)(xb,(0,p.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}vb.isMDXComponent=!0;const Lb={toc:[]},Zb="wrapper";function bb(t){let{components:e,...n}=t;return(0,s.kt)(Zb,(0,p.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}bb.isMDXComponent=!0;const Nb={toc:[]},Ab="wrapper";function zb(t){let{components:e,...n}=t;return(0,s.kt)(Ab,(0,p.Z)({},Nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}zb.isMDXComponent=!0;const Wb={toc:[]},Ib="wrapper";function Rb(t){let{components:e,...n}=t;return(0,s.kt)(Ib,(0,p.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Rb.isMDXComponent=!0;const Sb={toc:[]},Pb="wrapper";function Eb(t){let{components:e,...n}=t;return(0,s.kt)(Pb,(0,p.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Eb.isMDXComponent=!0;const Ob={toc:[]},Gb="wrapper";function Fb(t){let{components:e,...n}=t;return(0,s.kt)(Gb,(0,p.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Fb.isMDXComponent=!0;const Bb={toc:[]},Ub="wrapper";function Vb(t){let{components:e,...n}=t;return(0,s.kt)(Ub,(0,p.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Vb.isMDXComponent=!0;const qb={toc:[]},jb="wrapper";function Yb(t){let{components:e,...n}=t;return(0,s.kt)(jb,(0,p.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}Yb.isMDXComponent=!0;const Hb={toc:[]},Qb="wrapper";function $b(t){let{components:e,...n}=t;return(0,s.kt)(Qb,(0,p.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}$b.isMDXComponent=!0;const Jb={toc:[]},Kb="wrapper";function tN(t){let{components:e,...n}=t;return(0,s.kt)(Kb,(0,p.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tN.isMDXComponent=!0;const eN={toc:[]},nN="wrapper";function oN(t){let{components:e,...n}=t;return(0,s.kt)(nN,(0,p.Z)({},eN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(t){let{components:e,...n}=t;return(0,s.kt)(rN,(0,p.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}sN.isMDXComponent=!0;const cN={toc:[]},iN="wrapper";function aN(t){let{components:e,...n}=t;return(0,s.kt)(iN,(0,p.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}aN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(t){let{components:e,...n}=t;return(0,s.kt)(uN,(0,p.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}mN.isMDXComponent=!0;const dN={toc:[]},hN="wrapper";function fN(t){let{components:e,...n}=t;return(0,s.kt)(hN,(0,p.Z)({},dN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}fN.isMDXComponent=!0;const kN={toc:[]},yN="wrapper";function DN(t){let{components:e,...n}=t;return(0,s.kt)(yN,(0,p.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(t){let{components:e,...n}=t;return(0,s.kt)(XN,(0,p.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function gN(t){let{components:e,...n}=t;return(0,s.kt)(TN,(0,p.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}gN.isMDXComponent=!0;const CN={toc:[]},xN="wrapper";function vN(t){let{components:e,...n}=t;return(0,s.kt)(xN,(0,p.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}vN.isMDXComponent=!0;const LN={toc:[]},ZN="wrapper";function bN(t){let{components:e,...n}=t;return(0,s.kt)(ZN,(0,p.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}bN.isMDXComponent=!0;const NN={toc:[]},AN="wrapper";function zN(t){let{components:e,...n}=t;return(0,s.kt)(AN,(0,p.Z)({},NN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}zN.isMDXComponent=!0;const WN={toc:[]},IN="wrapper";function RN(t){let{components:e,...n}=t;return(0,s.kt)(IN,(0,p.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}RN.isMDXComponent=!0;const SN={toc:[]},PN="wrapper";function EN(t){let{components:e,...n}=t;return(0,s.kt)(PN,(0,p.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}EN.isMDXComponent=!0;const ON={toc:[]},GN="wrapper";function FN(t){let{components:e,...n}=t;return(0,s.kt)(GN,(0,p.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}FN.isMDXComponent=!0;const BN={toc:[]},UN="wrapper";function VN(t){let{components:e,...n}=t;return(0,s.kt)(UN,(0,p.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}VN.isMDXComponent=!0;const qN={toc:[]},jN="wrapper";function YN(t){let{components:e,...n}=t;return(0,s.kt)(jN,(0,p.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}YN.isMDXComponent=!0;const HN={toc:[]},QN="wrapper";function $N(t){let{components:e,...n}=t;return(0,s.kt)(QN,(0,p.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}$N.isMDXComponent=!0;const JN={toc:[]},KN="wrapper";function tA(t){let{components:e,...n}=t;return(0,s.kt)(KN,(0,p.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}tA.isMDXComponent=!0;const eA={toc:[]},nA="wrapper";function oA(t){let{components:e,...n}=t;return(0,s.kt)(nA,(0,p.Z)({},eA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(t){let{components:e,...n}=t;return(0,s.kt)(rA,(0,p.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}sA.isMDXComponent=!0;const cA={toc:[]},iA="wrapper";function aA(t){let{components:e,...n}=t;return(0,s.kt)(iA,(0,p.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}aA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(t){let{components:e,...n}=t;return(0,s.kt)(uA,(0,p.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether experimental features are enabled."))}mA.isMDXComponent=!0;const dA={toc:[]},hA="wrapper";function fA(t){let{components:e,...n}=t;return(0,s.kt)(hA,(0,p.Z)({},dA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}fA.isMDXComponent=!0;const kA={toc:[]},yA="wrapper";function DA(t){let{components:e,...n}=t;return(0,s.kt)(yA,(0,p.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(t){let{components:e,...n}=t;return(0,s.kt)(XA,(0,p.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function gA(t){let{components:e,...n}=t;return(0,s.kt)(TA,(0,p.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}gA.isMDXComponent=!0;const CA={toc:[]},xA="wrapper";function vA(t){let{components:e,...n}=t;return(0,s.kt)(xA,(0,p.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}vA.isMDXComponent=!0;const LA={toc:[]},ZA="wrapper";function bA(t){let{components:e,...n}=t;return(0,s.kt)(ZA,(0,p.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}bA.isMDXComponent=!0;const NA={toc:[]},AA="wrapper";function zA(t){let{components:e,...n}=t;return(0,s.kt)(AA,(0,p.Z)({},NA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}zA.isMDXComponent=!0;const WA={toc:[]},IA="wrapper";function RA(t){let{components:e,...n}=t;return(0,s.kt)(IA,(0,p.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}RA.isMDXComponent=!0;const SA={toc:[]},PA="wrapper";function EA(t){let{components:e,...n}=t;return(0,s.kt)(PA,(0,p.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}EA.isMDXComponent=!0;const OA={toc:[]},GA="wrapper";function FA(t){let{components:e,...n}=t;return(0,s.kt)(GA,(0,p.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}FA.isMDXComponent=!0;const BA={toc:[]},UA="wrapper";function VA(t){let{components:e,...n}=t;return(0,s.kt)(UA,(0,p.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}VA.isMDXComponent=!0;const qA={toc:[]},jA="wrapper";function YA(t){let{components:e,...n}=t;return(0,s.kt)(jA,(0,p.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}YA.isMDXComponent=!0;const HA={toc:[]},QA="wrapper";function $A(t){let{components:e,...n}=t;return(0,s.kt)(QA,(0,p.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}$A.isMDXComponent=!0;const JA={toc:[]},KA="wrapper";function tz(t){let{components:e,...n}=t;return(0,s.kt)(KA,(0,p.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}tz.isMDXComponent=!0;const ez={toc:[]},nz="wrapper";function oz(t){let{components:e,...n}=t;return(0,s.kt)(nz,(0,p.Z)({},ez,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(t){let{components:e,...n}=t;return(0,s.kt)(rz,(0,p.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}sz.isMDXComponent=!0;const cz={toc:[]},iz="wrapper";function az(t){let{components:e,...n}=t;return(0,s.kt)(iz,(0,p.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}az.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(t){let{components:e,...n}=t;return(0,s.kt)(uz,(0,p.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}mz.isMDXComponent=!0;const dz={toc:[]},hz="wrapper";function fz(t){let{components:e,...n}=t;return(0,s.kt)(hz,(0,p.Z)({},dz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}fz.isMDXComponent=!0;const kz={toc:[]},yz="wrapper";function Dz(t){let{components:e,...n}=t;return(0,s.kt)(yz,(0,p.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(t){let{components:e,...n}=t;return(0,s.kt)(Xz,(0,p.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function gz(t){let{components:e,...n}=t;return(0,s.kt)(Tz,(0,p.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}gz.isMDXComponent=!0;const Cz={toc:[]},xz="wrapper";function vz(t){let{components:e,...n}=t;return(0,s.kt)(xz,(0,p.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}vz.isMDXComponent=!0;const Lz={toc:[]},Zz="wrapper";function bz(t){let{components:e,...n}=t;return(0,s.kt)(Zz,(0,p.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}bz.isMDXComponent=!0;const Nz={toc:[]},Az="wrapper";function zz(t){let{components:e,...n}=t;return(0,s.kt)(Az,(0,p.Z)({},Nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}zz.isMDXComponent=!0;const Wz={toc:[]},Iz="wrapper";function Rz(t){let{components:e,...n}=t;return(0,s.kt)(Iz,(0,p.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}Rz.isMDXComponent=!0;const Sz={toc:[]},Pz="wrapper";function Ez(t){let{components:e,...n}=t;return(0,s.kt)(Pz,(0,p.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Ez.isMDXComponent=!0;const Oz={toc:[]},Gz="wrapper";function Fz(t){let{components:e,...n}=t;return(0,s.kt)(Gz,(0,p.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Fz.isMDXComponent=!0;const Bz={toc:[]},Uz="wrapper";function Vz(t){let{components:e,...n}=t;return(0,s.kt)(Uz,(0,p.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Vz.isMDXComponent=!0;const qz={toc:[]},jz="wrapper";function Yz(t){let{components:e,...n}=t;return(0,s.kt)(jz,(0,p.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Yz.isMDXComponent=!0;const Hz={toc:[]},Qz="wrapper";function $z(t){let{components:e,...n}=t;return(0,s.kt)(Qz,(0,p.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}$z.isMDXComponent=!0;const Jz={toc:[]},Kz="wrapper";function tW(t){let{components:e,...n}=t;return(0,s.kt)(Kz,(0,p.Z)({},Jz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}tW.isMDXComponent=!0;const eW={toc:[]},nW="wrapper";function oW(t){let{components:e,...n}=t;return(0,s.kt)(nW,(0,p.Z)({},eW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(t){let{components:e,...n}=t;return(0,s.kt)(rW,(0,p.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}sW.isMDXComponent=!0;const cW={toc:[]},iW="wrapper";function aW(t){let{components:e,...n}=t;return(0,s.kt)(iW,(0,p.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}aW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(t){let{components:e,...n}=t;return(0,s.kt)(uW,(0,p.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}mW.isMDXComponent=!0;const dW={toc:[]},hW="wrapper";function fW(t){let{components:e,...n}=t;return(0,s.kt)(hW,(0,p.Z)({},dW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}fW.isMDXComponent=!0;const kW={toc:[]},yW="wrapper";function DW(t){let{components:e,...n}=t;return(0,s.kt)(yW,(0,p.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(t){let{components:e,...n}=t;return(0,s.kt)(XW,(0,p.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function gW(t){let{components:e,...n}=t;return(0,s.kt)(TW,(0,p.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}gW.isMDXComponent=!0;const CW={toc:[]},xW="wrapper";function vW(t){let{components:e,...n}=t;return(0,s.kt)(xW,(0,p.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}vW.isMDXComponent=!0;const LW={toc:[]},ZW="wrapper";function bW(t){let{components:e,...n}=t;return(0,s.kt)(ZW,(0,p.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}bW.isMDXComponent=!0;const NW={toc:[]},AW="wrapper";function zW(t){let{components:e,...n}=t;return(0,s.kt)(AW,(0,p.Z)({},NW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}zW.isMDXComponent=!0;const WW={toc:[]},IW="wrapper";function RW(t){let{components:e,...n}=t;return(0,s.kt)(IW,(0,p.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}RW.isMDXComponent=!0;const SW={toc:[]},PW="wrapper";function EW(t){let{components:e,...n}=t;return(0,s.kt)(PW,(0,p.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}EW.isMDXComponent=!0;const OW={toc:[]},GW="wrapper";function FW(t){let{components:e,...n}=t;return(0,s.kt)(GW,(0,p.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}FW.isMDXComponent=!0;const BW={toc:[]},UW="wrapper";function VW(t){let{components:e,...n}=t;return(0,s.kt)(UW,(0,p.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}VW.isMDXComponent=!0;const qW={toc:[]},jW="wrapper";function YW(t){let{components:e,...n}=t;return(0,s.kt)(jW,(0,p.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}YW.isMDXComponent=!0;const HW={toc:[]},QW="wrapper";function $W(t){let{components:e,...n}=t;return(0,s.kt)(QW,(0,p.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}$W.isMDXComponent=!0;const JW={toc:[]},KW="wrapper";function tI(t){let{components:e,...n}=t;return(0,s.kt)(KW,(0,p.Z)({},JW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}tI.isMDXComponent=!0;const eI={toc:[]},nI="wrapper";function oI(t){let{components:e,...n}=t;return(0,s.kt)(nI,(0,p.Z)({},eI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(t){let{components:e,...n}=t;return(0,s.kt)(rI,(0,p.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}sI.isMDXComponent=!0;const cI={toc:[]},iI="wrapper";function aI(t){let{components:e,...n}=t;return(0,s.kt)(iI,(0,p.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}aI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(t){let{components:e,...n}=t;return(0,s.kt)(uI,(0,p.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}mI.isMDXComponent=!0;const dI={toc:[]},hI="wrapper";function fI(t){let{components:e,...n}=t;return(0,s.kt)(hI,(0,p.Z)({},dI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}fI.isMDXComponent=!0;const kI={toc:[]},yI="wrapper";function DI(t){let{components:e,...n}=t;return(0,s.kt)(yI,(0,p.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(t){let{components:e,...n}=t;return(0,s.kt)(XI,(0,p.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function gI(t){let{components:e,...n}=t;return(0,s.kt)(TI,(0,p.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}gI.isMDXComponent=!0;const CI={toc:[]},xI="wrapper";function vI(t){let{components:e,...n}=t;return(0,s.kt)(xI,(0,p.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}vI.isMDXComponent=!0;const LI={toc:[]},ZI="wrapper";function bI(t){let{components:e,...n}=t;return(0,s.kt)(ZI,(0,p.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}bI.isMDXComponent=!0;const NI={toc:[]},AI="wrapper";function zI(t){let{components:e,...n}=t;return(0,s.kt)(AI,(0,p.Z)({},NI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}zI.isMDXComponent=!0;const WI={toc:[]},II="wrapper";function RI(t){let{components:e,...n}=t;return(0,s.kt)(II,(0,p.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}RI.isMDXComponent=!0;const SI={toc:[]},PI="wrapper";function EI(t){let{components:e,...n}=t;return(0,s.kt)(PI,(0,p.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}EI.isMDXComponent=!0;const OI={toc:[]},GI="wrapper";function FI(t){let{components:e,...n}=t;return(0,s.kt)(GI,(0,p.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}FI.isMDXComponent=!0;const BI={toc:[]},UI="wrapper";function VI(t){let{components:e,...n}=t;return(0,s.kt)(UI,(0,p.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}VI.isMDXComponent=!0;const qI={toc:[]},jI="wrapper";function YI(t){let{components:e,...n}=t;return(0,s.kt)(jI,(0,p.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}YI.isMDXComponent=!0;const HI={toc:[]},QI="wrapper";function $I(t){let{components:e,...n}=t;return(0,s.kt)(QI,(0,p.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}$I.isMDXComponent=!0;const JI={toc:[]},KI="wrapper";function tR(t){let{components:e,...n}=t;return(0,s.kt)(KI,(0,p.Z)({},JI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}tR.isMDXComponent=!0;const eR={toc:[]},nR="wrapper";function oR(t){let{components:e,...n}=t;return(0,s.kt)(nR,(0,p.Z)({},eR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(t){let{components:e,...n}=t;return(0,s.kt)(rR,(0,p.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}sR.isMDXComponent=!0;const cR={toc:[]},iR="wrapper";function aR(t){let{components:e,...n}=t;return(0,s.kt)(iR,(0,p.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}aR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(t){let{components:e,...n}=t;return(0,s.kt)(uR,(0,p.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mR.isMDXComponent=!0;const dR={toc:[]},hR="wrapper";function fR(t){let{components:e,...n}=t;return(0,s.kt)(hR,(0,p.Z)({},dR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}fR.isMDXComponent=!0;const kR={toc:[]},yR="wrapper";function DR(t){let{components:e,...n}=t;return(0,s.kt)(yR,(0,p.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(t){let{components:e,...n}=t;return(0,s.kt)(XR,(0,p.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function gR(t){let{components:e,...n}=t;return(0,s.kt)(TR,(0,p.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}gR.isMDXComponent=!0;const CR={toc:[]},xR="wrapper";function vR(t){let{components:e,...n}=t;return(0,s.kt)(xR,(0,p.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}vR.isMDXComponent=!0;const LR={toc:[]},ZR="wrapper";function bR(t){let{components:e,...n}=t;return(0,s.kt)(ZR,(0,p.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}bR.isMDXComponent=!0;const NR={toc:[]},AR="wrapper";function zR(t){let{components:e,...n}=t;return(0,s.kt)(AR,(0,p.Z)({},NR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}zR.isMDXComponent=!0;const WR={toc:[]},IR="wrapper";function RR(t){let{components:e,...n}=t;return(0,s.kt)(IR,(0,p.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}RR.isMDXComponent=!0;const SR={toc:[]},PR="wrapper";function ER(t){let{components:e,...n}=t;return(0,s.kt)(PR,(0,p.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}ER.isMDXComponent=!0;const OR={toc:[]},GR="wrapper";function FR(t){let{components:e,...n}=t;return(0,s.kt)(GR,(0,p.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}FR.isMDXComponent=!0;const BR={toc:[]},UR="wrapper";function VR(t){let{components:e,...n}=t;return(0,s.kt)(UR,(0,p.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}VR.isMDXComponent=!0;const qR={toc:[]},jR="wrapper";function YR(t){let{components:e,...n}=t;return(0,s.kt)(jR,(0,p.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}YR.isMDXComponent=!0;const HR={toc:[]},QR="wrapper";function $R(t){let{components:e,...n}=t;return(0,s.kt)(QR,(0,p.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}$R.isMDXComponent=!0;const JR={toc:[]},KR="wrapper";function tS(t){let{components:e,...n}=t;return(0,s.kt)(KR,(0,p.Z)({},JR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}tS.isMDXComponent=!0;const eS={toc:[]},nS="wrapper";function oS(t){let{components:e,...n}=t;return(0,s.kt)(nS,(0,p.Z)({},eS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(t){let{components:e,...n}=t;return(0,s.kt)(rS,(0,p.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}sS.isMDXComponent=!0;const cS={toc:[]},iS="wrapper";function aS(t){let{components:e,...n}=t;return(0,s.kt)(iS,(0,p.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}aS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(t){let{components:e,...n}=t;return(0,s.kt)(uS,(0,p.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}mS.isMDXComponent=!0;const dS={toc:[]},hS="wrapper";function fS(t){let{components:e,...n}=t;return(0,s.kt)(hS,(0,p.Z)({},dS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}fS.isMDXComponent=!0;const kS={toc:[]},yS="wrapper";function DS(t){let{components:e,...n}=t;return(0,s.kt)(yS,(0,p.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(t){let{components:e,...n}=t;return(0,s.kt)(XS,(0,p.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function gS(t){let{components:e,...n}=t;return(0,s.kt)(TS,(0,p.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}gS.isMDXComponent=!0;const CS={toc:[]},xS="wrapper";function vS(t){let{components:e,...n}=t;return(0,s.kt)(xS,(0,p.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}vS.isMDXComponent=!0;const LS={toc:[]},ZS="wrapper";function bS(t){let{components:e,...n}=t;return(0,s.kt)(ZS,(0,p.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}bS.isMDXComponent=!0;const NS={toc:[]},AS="wrapper";function zS(t){let{components:e,...n}=t;return(0,s.kt)(AS,(0,p.Z)({},NS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}zS.isMDXComponent=!0;const WS={toc:[]},IS="wrapper";function RS(t){let{components:e,...n}=t;return(0,s.kt)(IS,(0,p.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}RS.isMDXComponent=!0;const SS={toc:[]},PS="wrapper";function ES(t){let{components:e,...n}=t;return(0,s.kt)(PS,(0,p.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}ES.isMDXComponent=!0;const OS={toc:[]},GS="wrapper";function FS(t){let{components:e,...n}=t;return(0,s.kt)(GS,(0,p.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}FS.isMDXComponent=!0;const BS={toc:[]},US="wrapper";function VS(t){let{components:e,...n}=t;return(0,s.kt)(US,(0,p.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}VS.isMDXComponent=!0;const qS={toc:[]},jS="wrapper";function YS(t){let{components:e,...n}=t;return(0,s.kt)(jS,(0,p.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}YS.isMDXComponent=!0;const HS={toc:[]},QS="wrapper";function $S(t){let{components:e,...n}=t;return(0,s.kt)(QS,(0,p.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}$S.isMDXComponent=!0;const JS={toc:[]},KS="wrapper";function tP(t){let{components:e,...n}=t;return(0,s.kt)(KS,(0,p.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}tP.isMDXComponent=!0;const eP={toc:[]},nP="wrapper";function oP(t){let{components:e,...n}=t;return(0,s.kt)(nP,(0,p.Z)({},eP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(t){let{components:e,...n}=t;return(0,s.kt)(rP,(0,p.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}sP.isMDXComponent=!0;const cP={toc:[]},iP="wrapper";function aP(t){let{components:e,...n}=t;return(0,s.kt)(iP,(0,p.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}aP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(t){let{components:e,...n}=t;return(0,s.kt)(uP,(0,p.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}mP.isMDXComponent=!0;const dP={toc:[]},hP="wrapper";function fP(t){let{components:e,...n}=t;return(0,s.kt)(hP,(0,p.Z)({},dP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}fP.isMDXComponent=!0;const kP={toc:[]},yP="wrapper";function DP(t){let{components:e,...n}=t;return(0,s.kt)(yP,(0,p.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(t){let{components:e,...n}=t;return(0,s.kt)(XP,(0,p.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function gP(t){let{components:e,...n}=t;return(0,s.kt)(TP,(0,p.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}gP.isMDXComponent=!0;const CP={toc:[]},xP="wrapper";function vP(t){let{components:e,...n}=t;return(0,s.kt)(xP,(0,p.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vP.isMDXComponent=!0;const LP={toc:[]},ZP="wrapper";function bP(t){let{components:e,...n}=t;return(0,s.kt)(ZP,(0,p.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}bP.isMDXComponent=!0;const NP={toc:[]},AP="wrapper";function zP(t){let{components:e,...n}=t;return(0,s.kt)(AP,(0,p.Z)({},NP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}zP.isMDXComponent=!0;const WP={toc:[]},IP="wrapper";function RP(t){let{components:e,...n}=t;return(0,s.kt)(IP,(0,p.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}RP.isMDXComponent=!0;const SP={toc:[]},PP="wrapper";function EP(t){let{components:e,...n}=t;return(0,s.kt)(PP,(0,p.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}EP.isMDXComponent=!0;const OP={toc:[]},GP="wrapper";function FP(t){let{components:e,...n}=t;return(0,s.kt)(GP,(0,p.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}FP.isMDXComponent=!0;const BP={toc:[]},UP="wrapper";function VP(t){let{components:e,...n}=t;return(0,s.kt)(UP,(0,p.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}VP.isMDXComponent=!0;const qP={toc:[]},jP="wrapper";function YP(t){let{components:e,...n}=t;return(0,s.kt)(jP,(0,p.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}YP.isMDXComponent=!0;const HP={toc:[]},QP="wrapper";function $P(t){let{components:e,...n}=t;return(0,s.kt)(QP,(0,p.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}$P.isMDXComponent=!0;const JP={toc:[]},KP="wrapper";function tE(t){let{components:e,...n}=t;return(0,s.kt)(KP,(0,p.Z)({},JP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}tE.isMDXComponent=!0;const eE={toc:[]},nE="wrapper";function oE(t){let{components:e,...n}=t;return(0,s.kt)(nE,(0,p.Z)({},eE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(t){let{components:e,...n}=t;return(0,s.kt)(rE,(0,p.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}sE.isMDXComponent=!0;const cE={toc:[]},iE="wrapper";function aE(t){let{components:e,...n}=t;return(0,s.kt)(iE,(0,p.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}aE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(t){let{components:e,...n}=t;return(0,s.kt)(uE,(0,p.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}mE.isMDXComponent=!0;const dE={toc:[]},hE="wrapper";function fE(t){let{components:e,...n}=t;return(0,s.kt)(hE,(0,p.Z)({},dE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}fE.isMDXComponent=!0;const kE={toc:[]},yE="wrapper";function DE(t){let{components:e,...n}=t;return(0,s.kt)(yE,(0,p.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(t){let{components:e,...n}=t;return(0,s.kt)(XE,(0,p.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function gE(t){let{components:e,...n}=t;return(0,s.kt)(TE,(0,p.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in the given direction."))}gE.isMDXComponent=!0;const CE={toc:[]},xE="wrapper";function vE(t){let{components:e,...n}=t;return(0,s.kt)(xE,(0,p.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}vE.isMDXComponent=!0;const LE={toc:[]},ZE="wrapper";function bE(t){let{components:e,...n}=t;return(0,s.kt)(ZE,(0,p.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bE.isMDXComponent=!0;const NE={toc:[]},AE="wrapper";function zE(t){let{components:e,...n}=t;return(0,s.kt)(AE,(0,p.Z)({},NE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene towards the given origin."))}zE.isMDXComponent=!0;const WE={toc:[]},IE="wrapper";function RE(t){let{components:e,...n}=t;return(0,s.kt)(IE,(0,p.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin towards which to slide."))}RE.isMDXComponent=!0;const SE={toc:[]},PE="wrapper";function EE(t){let{components:e,...n}=t;return(0,s.kt)(PE,(0,p.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}EE.isMDXComponent=!0;const OE={toc:[]},GE="wrapper";function FE(t){let{components:e,...n}=t;return(0,s.kt)(GE,(0,p.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}FE.isMDXComponent=!0;const BE={toc:[]},UE="wrapper";function VE(t){let{components:e,...n}=t;return(0,s.kt)(UE,(0,p.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}VE.isMDXComponent=!0;const qE={toc:[]},jE="wrapper";function YE(t){let{components:e,...n}=t;return(0,s.kt)(jE,(0,p.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}YE.isMDXComponent=!0;const HE={toc:[]},QE="wrapper";function $E(t){let{components:e,...n}=t;return(0,s.kt)(QE,(0,p.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the previous scene should be rendered on top."))}$E.isMDXComponent=!0;const JE={toc:[]},KE="wrapper";function tO(t){let{components:e,...n}=t;return(0,s.kt)(KE,(0,p.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}tO.isMDXComponent=!0;const eO={toc:[]},nO="wrapper";function oO(t){let{components:e,...n}=t;return(0,s.kt)(nO,(0,p.Z)({},eO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(t){let{components:e,...n}=t;return(0,s.kt)(rO,(0,p.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}sO.isMDXComponent=!0;const cO={toc:[]},iO="wrapper";function aO(t){let{components:e,...n}=t;return(0,s.kt)(iO,(0,p.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}aO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(t){let{components:e,...n}=t;return(0,s.kt)(uO,(0,p.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}mO.isMDXComponent=!0;const dO={toc:[]},hO="wrapper";function fO(t){let{components:e,...n}=t;return(0,s.kt)(hO,(0,p.Z)({},dO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}fO.isMDXComponent=!0;const kO={toc:[]},yO="wrapper";function DO(t){let{components:e,...n}=t;return(0,s.kt)(yO,(0,p.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(t){let{components:e,...n}=t;return(0,s.kt)(XO,(0,p.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function gO(t){let{components:e,...n}=t;return(0,s.kt)(TO,(0,p.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}gO.isMDXComponent=!0;const CO={toc:[]},xO="wrapper";function vO(t){let{components:e,...n}=t;return(0,s.kt)(xO,(0,p.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}vO.isMDXComponent=!0;const LO={toc:[]},ZO="wrapper";function bO(t){let{components:e,...n}=t;return(0,s.kt)(ZO,(0,p.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}bO.isMDXComponent=!0;const NO={toc:[]},AO="wrapper";function zO(t){let{components:e,...n}=t;return(0,s.kt)(AO,(0,p.Z)({},NO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}zO.isMDXComponent=!0;const WO={toc:[]},IO="wrapper";function RO(t){let{components:e,...n}=t;return(0,s.kt)(IO,(0,p.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}RO.isMDXComponent=!0;const SO={toc:[]},PO="wrapper";function EO(t){let{components:e,...n}=t;return(0,s.kt)(PO,(0,p.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}EO.isMDXComponent=!0;const OO={toc:[]},GO="wrapper";function FO(t){let{components:e,...n}=t;return(0,s.kt)(GO,(0,p.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}FO.isMDXComponent=!0;const BO={toc:[]},UO="wrapper";function VO(t){let{components:e,...n}=t;return(0,s.kt)(UO,(0,p.Z)({},BO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}VO.isMDXComponent=!0;const qO={toc:[]},jO="wrapper";function YO(t){let{components:e,...n}=t;return(0,s.kt)(jO,(0,p.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}YO.isMDXComponent=!0;const HO={toc:[]},QO="wrapper";function $O(t){let{components:e,...n}=t;return(0,s.kt)(QO,(0,p.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}$O.isMDXComponent=!0;const JO={toc:[]},KO="wrapper";function tG(t){let{components:e,...n}=t;return(0,s.kt)(KO,(0,p.Z)({},JO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}tG.isMDXComponent=!0;const eG={toc:[]},nG="wrapper";function oG(t){let{components:e,...n}=t;return(0,s.kt)(nG,(0,p.Z)({},eG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(t){let{components:e,...n}=t;return(0,s.kt)(rG,(0,p.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}sG.isMDXComponent=!0;const cG={toc:[]},iG="wrapper";function aG(t){let{components:e,...n}=t;return(0,s.kt)(iG,(0,p.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}aG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(t){let{components:e,...n}=t;return(0,s.kt)(uG,(0,p.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}mG.isMDXComponent=!0;const dG={toc:[]},hG="wrapper";function fG(t){let{components:e,...n}=t;return(0,s.kt)(hG,(0,p.Z)({},dG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}fG.isMDXComponent=!0;const kG={toc:[]},yG="wrapper";function DG(t){let{components:e,...n}=t;return(0,s.kt)(yG,(0,p.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(t){let{components:e,...n}=t;return(0,s.kt)(XG,(0,p.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function gG(t){let{components:e,...n}=t;return(0,s.kt)(TG,(0,p.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}gG.isMDXComponent=!0;const CG={toc:[]},xG="wrapper";function vG(t){let{components:e,...n}=t;return(0,s.kt)(xG,(0,p.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}vG.isMDXComponent=!0;const LG={toc:[]},ZG="wrapper";function bG(t){let{components:e,...n}=t;return(0,s.kt)(ZG,(0,p.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}bG.isMDXComponent=!0;const NG={toc:[]},AG="wrapper";function zG(t){let{components:e,...n}=t;return(0,s.kt)(AG,(0,p.Z)({},NG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}zG.isMDXComponent=!0;const WG={toc:[]},IG="wrapper";function RG(t){let{components:e,...n}=t;return(0,s.kt)(IG,(0,p.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}RG.isMDXComponent=!0;const SG={toc:[]},PG="wrapper";function EG(t){let{components:e,...n}=t;return(0,s.kt)(PG,(0,p.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}EG.isMDXComponent=!0;const OG={toc:[]},GG="wrapper";function FG(t){let{components:e,...n}=t;return(0,s.kt)(GG,(0,p.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}FG.isMDXComponent=!0;const BG={toc:[]},UG="wrapper";function VG(t){let{components:e,...n}=t;return(0,s.kt)(UG,(0,p.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}VG.isMDXComponent=!0;const qG={toc:[]},jG="wrapper";function YG(t){let{components:e,...n}=t;return(0,s.kt)(jG,(0,p.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}YG.isMDXComponent=!0;const HG={toc:[]},QG="wrapper";function $G(t){let{components:e,...n}=t;return(0,s.kt)(QG,(0,p.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}$G.isMDXComponent=!0;const JG={toc:[]},KG="wrapper";function tF(t){let{components:e,...n}=t;return(0,s.kt)(KG,(0,p.Z)({},JG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}tF.isMDXComponent=!0;const eF={toc:[]},nF="wrapper";function oF(t){let{components:e,...n}=t;return(0,s.kt)(nF,(0,p.Z)({},eF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(t){let{components:e,...n}=t;return(0,s.kt)(rF,(0,p.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sF.isMDXComponent=!0;const cF={toc:[]},iF="wrapper";function aF(t){let{components:e,...n}=t;return(0,s.kt)(iF,(0,p.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}aF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(t){let{components:e,...n}=t;return(0,s.kt)(uF,(0,p.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}mF.isMDXComponent=!0;const dF={toc:[]},hF="wrapper";function fF(t){let{components:e,...n}=t;return(0,s.kt)(hF,(0,p.Z)({},dF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}fF.isMDXComponent=!0;const kF={toc:[]},yF="wrapper";function DF(t){let{components:e,...n}=t;return(0,s.kt)(yF,(0,p.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(t){let{components:e,...n}=t;return(0,s.kt)(XF,(0,p.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function gF(t){let{components:e,...n}=t;return(0,s.kt)(TF,(0,p.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}gF.isMDXComponent=!0;const CF={toc:[]},xF="wrapper";function vF(t){let{components:e,...n}=t;return(0,s.kt)(xF,(0,p.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}vF.isMDXComponent=!0;const LF={toc:[]},ZF="wrapper";function bF(t){let{components:e,...n}=t;return(0,s.kt)(ZF,(0,p.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}bF.isMDXComponent=!0;const NF={toc:[]},AF="wrapper";function zF(t){let{components:e,...n}=t;return(0,s.kt)(AF,(0,p.Z)({},NF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}zF.isMDXComponent=!0;const WF={toc:[]},IF="wrapper";function RF(t){let{components:e,...n}=t;return(0,s.kt)(IF,(0,p.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}RF.isMDXComponent=!0;const SF={toc:[]},PF="wrapper";function EF(t){let{components:e,...n}=t;return(0,s.kt)(PF,(0,p.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}EF.isMDXComponent=!0;const OF={toc:[]},GF="wrapper";function FF(t){let{components:e,...n}=t;return(0,s.kt)(GF,(0,p.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}FF.isMDXComponent=!0;const BF={toc:[]},UF="wrapper";function VF(t){let{components:e,...n}=t;return(0,s.kt)(UF,(0,p.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}VF.isMDXComponent=!0;const qF={toc:[]},jF="wrapper";function YF(t){let{components:e,...n}=t;return(0,s.kt)(jF,(0,p.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}YF.isMDXComponent=!0;const HF={toc:[]},QF="wrapper";function $F(t){let{components:e,...n}=t;return(0,s.kt)(QF,(0,p.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}$F.isMDXComponent=!0;const JF={toc:[]},KF="wrapper";function tB(t){let{components:e,...n}=t;return(0,s.kt)(KF,(0,p.Z)({},JF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}tB.isMDXComponent=!0;const eB={toc:[]},nB="wrapper";function oB(t){let{components:e,...n}=t;return(0,s.kt)(nB,(0,p.Z)({},eB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(t){let{components:e,...n}=t;return(0,s.kt)(rB,(0,p.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}sB.isMDXComponent=!0;const cB={toc:[]},iB="wrapper";function aB(t){let{components:e,...n}=t;return(0,s.kt)(iB,(0,p.Z)({},cB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}aB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(t){let{components:e,...n}=t;return(0,s.kt)(uB,(0,p.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}mB.isMDXComponent=!0;const dB={toc:[]},hB="wrapper";function fB(t){let{components:e,...n}=t;return(0,s.kt)(hB,(0,p.Z)({},dB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}fB.isMDXComponent=!0;const kB={toc:[]},yB="wrapper";function DB(t){let{components:e,...n}=t;return(0,s.kt)(yB,(0,p.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(t){let{components:e,...n}=t;return(0,s.kt)(XB,(0,p.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function gB(t){let{components:e,...n}=t;return(0,s.kt)(TB,(0,p.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}gB.isMDXComponent=!0;const CB={toc:[]},xB="wrapper";function vB(t){let{components:e,...n}=t;return(0,s.kt)(xB,(0,p.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}vB.isMDXComponent=!0;const LB={toc:[]},ZB="wrapper";function bB(t){let{components:e,...n}=t;return(0,s.kt)(ZB,(0,p.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}bB.isMDXComponent=!0;const NB={toc:[]},AB="wrapper";function zB(t){let{components:e,...n}=t;return(0,s.kt)(AB,(0,p.Z)({},NB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}zB.isMDXComponent=!0;const WB={toc:[]},IB="wrapper";function RB(t){let{components:e,...n}=t;return(0,s.kt)(IB,(0,p.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}RB.isMDXComponent=!0;const SB={toc:[]},PB="wrapper";function EB(t){let{components:e,...n}=t;return(0,s.kt)(PB,(0,p.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}EB.isMDXComponent=!0;const OB={toc:[]},GB="wrapper";function FB(t){let{components:e,...n}=t;return(0,s.kt)(GB,(0,p.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}FB.isMDXComponent=!0;const BB={toc:[]},UB="wrapper";function VB(t){let{components:e,...n}=t;return(0,s.kt)(UB,(0,p.Z)({},BB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}VB.isMDXComponent=!0;const qB={toc:[]},jB="wrapper";function YB(t){let{components:e,...n}=t;return(0,s.kt)(jB,(0,p.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}YB.isMDXComponent=!0;const HB={toc:[]},QB="wrapper";function $B(t){let{components:e,...n}=t;return(0,s.kt)(QB,(0,p.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}$B.isMDXComponent=!0;const JB={toc:[]},KB="wrapper";function tU(t){let{components:e,...n}=t;return(0,s.kt)(KB,(0,p.Z)({},JB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}tU.isMDXComponent=!0;const eU={toc:[]},nU="wrapper";function oU(t){let{components:e,...n}=t;return(0,s.kt)(nU,(0,p.Z)({},eU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(t){let{components:e,...n}=t;return(0,s.kt)(rU,(0,p.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}sU.isMDXComponent=!0;const cU={toc:[]},iU="wrapper";function aU(t){let{components:e,...n}=t;return(0,s.kt)(iU,(0,p.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}aU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(t){let{components:e,...n}=t;return(0,s.kt)(uU,(0,p.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}mU.isMDXComponent=!0;const dU={toc:[]},hU="wrapper";function fU(t){let{components:e,...n}=t;return(0,s.kt)(hU,(0,p.Z)({},dU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}fU.isMDXComponent=!0;const kU={toc:[]},yU="wrapper";function DU(t){let{components:e,...n}=t;return(0,s.kt)(yU,(0,p.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(t){let{components:e,...n}=t;return(0,s.kt)(XU,(0,p.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function gU(t){let{components:e,...n}=t;return(0,s.kt)(TU,(0,p.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}gU.isMDXComponent=!0;const CU={toc:[]},xU="wrapper";function vU(t){let{components:e,...n}=t;return(0,s.kt)(xU,(0,p.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}vU.isMDXComponent=!0;const LU={toc:[]},ZU="wrapper";function bU(t){let{components:e,...n}=t;return(0,s.kt)(ZU,(0,p.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}bU.isMDXComponent=!0;const NU={toc:[]},AU="wrapper";function zU(t){let{components:e,...n}=t;return(0,s.kt)(AU,(0,p.Z)({},NU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}zU.isMDXComponent=!0;const WU={toc:[]},IU="wrapper";function RU(t){let{components:e,...n}=t;return(0,s.kt)(IU,(0,p.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}RU.isMDXComponent=!0;const SU={toc:[]},PU="wrapper";function EU(t){let{components:e,...n}=t;return(0,s.kt)(PU,(0,p.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}EU.isMDXComponent=!0;const OU={toc:[]},GU="wrapper";function FU(t){let{components:e,...n}=t;return(0,s.kt)(GU,(0,p.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}FU.isMDXComponent=!0;const BU={toc:[]},UU="wrapper";function VU(t){let{components:e,...n}=t;return(0,s.kt)(UU,(0,p.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}VU.isMDXComponent=!0;const qU={toc:[]},jU="wrapper";function YU(t){let{components:e,...n}=t;return(0,s.kt)(jU,(0,p.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}YU.isMDXComponent=!0;const HU={toc:[]},QU="wrapper";function $U(t){let{components:e,...n}=t;return(0,s.kt)(QU,(0,p.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}$U.isMDXComponent=!0;const JU={toc:[]},KU="wrapper";function tV(t){let{components:e,...n}=t;return(0,s.kt)(KU,(0,p.Z)({},JU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}tV.isMDXComponent=!0;const eV={toc:[]},nV="wrapper";function oV(t){let{components:e,...n}=t;return(0,s.kt)(nV,(0,p.Z)({},eV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(t){let{components:e,...n}=t;return(0,s.kt)(rV,(0,p.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}sV.isMDXComponent=!0;const cV={toc:[]},iV="wrapper";function aV(t){let{components:e,...n}=t;return(0,s.kt)(iV,(0,p.Z)({},cV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}aV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(t){let{components:e,...n}=t;return(0,s.kt)(uV,(0,p.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}mV.isMDXComponent=!0;const dV={toc:[]},hV="wrapper";function fV(t){let{components:e,...n}=t;return(0,s.kt)(hV,(0,p.Z)({},dV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}fV.isMDXComponent=!0;const kV={toc:[]},yV="wrapper";function DV(t){let{components:e,...n}=t;return(0,s.kt)(yV,(0,p.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(t){let{components:e,...n}=t;return(0,s.kt)(XV,(0,p.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function gV(t){let{components:e,...n}=t;return(0,s.kt)(TV,(0,p.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}gV.isMDXComponent=!0;const CV={toc:[]},xV="wrapper";function vV(t){let{components:e,...n}=t;return(0,s.kt)(xV,(0,p.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}vV.isMDXComponent=!0;const LV={toc:[]},ZV="wrapper";function bV(t){let{components:e,...n}=t;return(0,s.kt)(ZV,(0,p.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}bV.isMDXComponent=!0;const NV={toc:[]},AV="wrapper";function zV(t){let{components:e,...n}=t;return(0,s.kt)(AV,(0,p.Z)({},NV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}zV.isMDXComponent=!0;const WV={toc:[]},IV="wrapper";function RV(t){let{components:e,...n}=t;return(0,s.kt)(IV,(0,p.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}RV.isMDXComponent=!0;const SV={toc:[]},PV="wrapper";function EV(t){let{components:e,...n}=t;return(0,s.kt)(PV,(0,p.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}EV.isMDXComponent=!0;const OV={toc:[]},GV="wrapper";function FV(t){let{components:e,...n}=t;return(0,s.kt)(GV,(0,p.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}FV.isMDXComponent=!0;const BV={toc:[]},UV="wrapper";function VV(t){let{components:e,...n}=t;return(0,s.kt)(UV,(0,p.Z)({},BV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}VV.isMDXComponent=!0;const qV={toc:[]},jV="wrapper";function YV(t){let{components:e,...n}=t;return(0,s.kt)(jV,(0,p.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}YV.isMDXComponent=!0;const HV={toc:[]},QV="wrapper";function $V(t){let{components:e,...n}=t;return(0,s.kt)(QV,(0,p.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}$V.isMDXComponent=!0;const JV={toc:[]},KV="wrapper";function tq(t){let{components:e,...n}=t;return(0,s.kt)(KV,(0,p.Z)({},JV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}tq.isMDXComponent=!0;const eq={toc:[]},nq="wrapper";function oq(t){let{components:e,...n}=t;return(0,s.kt)(nq,(0,p.Z)({},eq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(t){let{components:e,...n}=t;return(0,s.kt)(rq,(0,p.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}sq.isMDXComponent=!0;const cq={toc:[]},iq="wrapper";function aq(t){let{components:e,...n}=t;return(0,s.kt)(iq,(0,p.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}aq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(t){let{components:e,...n}=t;return(0,s.kt)(uq,(0,p.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}mq.isMDXComponent=!0;const dq={toc:[]},hq="wrapper";function fq(t){let{components:e,...n}=t;return(0,s.kt)(hq,(0,p.Z)({},dq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}fq.isMDXComponent=!0;const kq={toc:[]},yq="wrapper";function Dq(t){let{components:e,...n}=t;return(0,s.kt)(yq,(0,p.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(t){let{components:e,...n}=t;return(0,s.kt)(Xq,(0,p.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function gq(t){let{components:e,...n}=t;return(0,s.kt)(Tq,(0,p.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}gq.isMDXComponent=!0;const Cq={toc:[]},xq="wrapper";function vq(t){let{components:e,...n}=t;return(0,s.kt)(xq,(0,p.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}vq.isMDXComponent=!0;const Lq={toc:[]},Zq="wrapper";function bq(t){let{components:e,...n}=t;return(0,s.kt)(Zq,(0,p.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}bq.isMDXComponent=!0;const Nq={toc:[]},Aq="wrapper";function zq(t){let{components:e,...n}=t;return(0,s.kt)(Aq,(0,p.Z)({},Nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}zq.isMDXComponent=!0;const Wq={toc:[]},Iq="wrapper";function Rq(t){let{components:e,...n}=t;return(0,s.kt)(Iq,(0,p.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Rq.isMDXComponent=!0;const Sq={toc:[]},Pq="wrapper";function Eq(t){let{components:e,...n}=t;return(0,s.kt)(Pq,(0,p.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Eq.isMDXComponent=!0;const Oq={toc:[]},Gq="wrapper";function Fq(t){let{components:e,...n}=t;return(0,s.kt)(Gq,(0,p.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}Fq.isMDXComponent=!0;const Bq={toc:[]},Uq="wrapper";function Vq(t){let{components:e,...n}=t;return(0,s.kt)(Uq,(0,p.Z)({},Bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Vq.isMDXComponent=!0;const qq={toc:[]},jq="wrapper";function Yq(t){let{components:e,...n}=t;return(0,s.kt)(jq,(0,p.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Yq.isMDXComponent=!0;const Hq={toc:[]},Qq="wrapper";function $q(t){let{components:e,...n}=t;return(0,s.kt)(Qq,(0,p.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}$q.isMDXComponent=!0;const Jq={toc:[]},Kq="wrapper";function tj(t){let{components:e,...n}=t;return(0,s.kt)(Kq,(0,p.Z)({},Jq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}tj.isMDXComponent=!0;const ej={toc:[]},nj="wrapper";function oj(t){let{components:e,...n}=t;return(0,s.kt)(nj,(0,p.Z)({},ej,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(t){let{components:e,...n}=t;return(0,s.kt)(rj,(0,p.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}sj.isMDXComponent=!0;const cj={toc:[]},ij="wrapper";function aj(t){let{components:e,...n}=t;return(0,s.kt)(ij,(0,p.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}aj.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(t){let{components:e,...n}=t;return(0,s.kt)(uj,(0,p.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}mj.isMDXComponent=!0;const dj={toc:[]},hj="wrapper";function fj(t){let{components:e,...n}=t;return(0,s.kt)(hj,(0,p.Z)({},dj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}fj.isMDXComponent=!0;const kj={toc:[]},yj="wrapper";function Dj(t){let{components:e,...n}=t;return(0,s.kt)(yj,(0,p.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(t){let{components:e,...n}=t;return(0,s.kt)(Xj,(0,p.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function gj(t){let{components:e,...n}=t;return(0,s.kt)(Tj,(0,p.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}gj.isMDXComponent=!0;const Cj={toc:[]},xj="wrapper";function vj(t){let{components:e,...n}=t;return(0,s.kt)(xj,(0,p.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}vj.isMDXComponent=!0;const Lj={toc:[]},Zj="wrapper";function bj(t){let{components:e,...n}=t;return(0,s.kt)(Zj,(0,p.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}bj.isMDXComponent=!0;const Nj={toc:[]},Aj="wrapper";function zj(t){let{components:e,...n}=t;return(0,s.kt)(Aj,(0,p.Z)({},Nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}zj.isMDXComponent=!0;const Wj={toc:[]},Ij="wrapper";function Rj(t){let{components:e,...n}=t;return(0,s.kt)(Ij,(0,p.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}Rj.isMDXComponent=!0;const Sj={toc:[]},Pj="wrapper";function Ej(t){let{components:e,...n}=t;return(0,s.kt)(Pj,(0,p.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Ej.isMDXComponent=!0;const Oj={toc:[]},Gj="wrapper";function Fj(t){let{components:e,...n}=t;return(0,s.kt)(Gj,(0,p.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Fj.isMDXComponent=!0;const Bj={toc:[]},Uj="wrapper";function Vj(t){let{components:e,...n}=t;return(0,s.kt)(Uj,(0,p.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Vj.isMDXComponent=!0;const qj={toc:[]},jj="wrapper";function Yj(t){let{components:e,...n}=t;return(0,s.kt)(jj,(0,p.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Yj.isMDXComponent=!0;const Hj={toc:[]},Qj="wrapper";function $j(t){let{components:e,...n}=t;return(0,s.kt)(Qj,(0,p.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}$j.isMDXComponent=!0;const Jj={toc:[]},Kj="wrapper";function tY(t){let{components:e,...n}=t;return(0,s.kt)(Kj,(0,p.Z)({},Jj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}tY.isMDXComponent=!0;const eY={toc:[]},nY="wrapper";function oY(t){let{components:e,...n}=t;return(0,s.kt)(nY,(0,p.Z)({},eY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(t){let{components:e,...n}=t;return(0,s.kt)(rY,(0,p.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}sY.isMDXComponent=!0;const cY={toc:[]},iY="wrapper";function aY(t){let{components:e,...n}=t;return(0,s.kt)(iY,(0,p.Z)({},cY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}aY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(t){let{components:e,...n}=t;return(0,s.kt)(uY,(0,p.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}mY.isMDXComponent=!0;const dY={toc:[]},hY="wrapper";function fY(t){let{components:e,...n}=t;return(0,s.kt)(hY,(0,p.Z)({},dY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}fY.isMDXComponent=!0;const kY={toc:[]},yY="wrapper";function DY(t){let{components:e,...n}=t;return(0,s.kt)(yY,(0,p.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(t){let{components:e,...n}=t;return(0,s.kt)(XY,(0,p.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function gY(t){let{components:e,...n}=t;return(0,s.kt)(TY,(0,p.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}gY.isMDXComponent=!0;const CY={toc:[]},xY="wrapper";function vY(t){let{components:e,...n}=t;return(0,s.kt)(xY,(0,p.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}vY.isMDXComponent=!0;const LY={toc:[]},ZY="wrapper";function bY(t){let{components:e,...n}=t;return(0,s.kt)(ZY,(0,p.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}bY.isMDXComponent=!0;const NY={toc:[]},AY="wrapper";function zY(t){let{components:e,...n}=t;return(0,s.kt)(AY,(0,p.Z)({},NY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}zY.isMDXComponent=!0;const WY={toc:[]},IY="wrapper";function RY(t){let{components:e,...n}=t;return(0,s.kt)(IY,(0,p.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}RY.isMDXComponent=!0;const SY={toc:[]},PY="wrapper";function EY(t){let{components:e,...n}=t;return(0,s.kt)(PY,(0,p.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}EY.isMDXComponent=!0;const OY={toc:[]},GY="wrapper";function FY(t){let{components:e,...n}=t;return(0,s.kt)(GY,(0,p.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}FY.isMDXComponent=!0;const BY={toc:[]},UY="wrapper";function VY(t){let{components:e,...n}=t;return(0,s.kt)(UY,(0,p.Z)({},BY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}VY.isMDXComponent=!0;const qY={toc:[]},jY="wrapper";function YY(t){let{components:e,...n}=t;return(0,s.kt)(jY,(0,p.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YY.isMDXComponent=!0;const HY={toc:[]},QY="wrapper";function $Y(t){let{components:e,...n}=t;return(0,s.kt)(QY,(0,p.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}$Y.isMDXComponent=!0;const JY={toc:[]},KY="wrapper";function tH(t){let{components:e,...n}=t;return(0,s.kt)(KY,(0,p.Z)({},JY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}tH.isMDXComponent=!0;const eH={toc:[]},nH="wrapper";function oH(t){let{components:e,...n}=t;return(0,s.kt)(nH,(0,p.Z)({},eH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(t){let{components:e,...n}=t;return(0,s.kt)(rH,(0,p.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}sH.isMDXComponent=!0;const cH={toc:[]},iH="wrapper";function aH(t){let{components:e,...n}=t;return(0,s.kt)(iH,(0,p.Z)({},cH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}aH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(t){let{components:e,...n}=t;return(0,s.kt)(uH,(0,p.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}mH.isMDXComponent=!0;const dH={toc:[]},hH="wrapper";function fH(t){let{components:e,...n}=t;return(0,s.kt)(hH,(0,p.Z)({},dH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}fH.isMDXComponent=!0;const kH={toc:[]},yH="wrapper";function DH(t){let{components:e,...n}=t;return(0,s.kt)(yH,(0,p.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(t){let{components:e,...n}=t;return(0,s.kt)(XH,(0,p.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function gH(t){let{components:e,...n}=t;return(0,s.kt)(TH,(0,p.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}gH.isMDXComponent=!0;const CH={toc:[]},xH="wrapper";function vH(t){let{components:e,...n}=t;return(0,s.kt)(xH,(0,p.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}vH.isMDXComponent=!0;const LH={toc:[]},ZH="wrapper";function bH(t){let{components:e,...n}=t;return(0,s.kt)(ZH,(0,p.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}bH.isMDXComponent=!0;const NH={toc:[]},AH="wrapper";function zH(t){let{components:e,...n}=t;return(0,s.kt)(AH,(0,p.Z)({},NH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}zH.isMDXComponent=!0;const WH={toc:[]},IH="wrapper";function RH(t){let{components:e,...n}=t;return(0,s.kt)(IH,(0,p.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}RH.isMDXComponent=!0;const SH={toc:[]},PH="wrapper";function EH(t){let{components:e,...n}=t;return(0,s.kt)(PH,(0,p.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}EH.isMDXComponent=!0;const OH={toc:[]},GH="wrapper";function FH(t){let{components:e,...n}=t;return(0,s.kt)(GH,(0,p.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}FH.isMDXComponent=!0;const BH={toc:[]},UH="wrapper";function VH(t){let{components:e,...n}=t;return(0,s.kt)(UH,(0,p.Z)({},BH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}VH.isMDXComponent=!0;const qH={toc:[]},jH="wrapper";function YH(t){let{components:e,...n}=t;return(0,s.kt)(jH,(0,p.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}YH.isMDXComponent=!0;const HH={toc:[]},QH="wrapper";function $H(t){let{components:e,...n}=t;return(0,s.kt)(QH,(0,p.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}$H.isMDXComponent=!0;const JH={toc:[]},KH="wrapper";function tQ(t){let{components:e,...n}=t;return(0,s.kt)(KH,(0,p.Z)({},JH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}tQ.isMDXComponent=!0;const eQ={toc:[]},nQ="wrapper";function oQ(t){let{components:e,...n}=t;return(0,s.kt)(nQ,(0,p.Z)({},eQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(t){let{components:e,...n}=t;return(0,s.kt)(rQ,(0,p.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}sQ.isMDXComponent=!0;const cQ={toc:[]},iQ="wrapper";function aQ(t){let{components:e,...n}=t;return(0,s.kt)(iQ,(0,p.Z)({},cQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}aQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(t){let{components:e,...n}=t;return(0,s.kt)(uQ,(0,p.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mQ.isMDXComponent=!0;const dQ={toc:[]},hQ="wrapper";function fQ(t){let{components:e,...n}=t;return(0,s.kt)(hQ,(0,p.Z)({},dQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fQ.isMDXComponent=!0;const kQ={toc:[]},yQ="wrapper";function DQ(t){let{components:e,...n}=t;return(0,s.kt)(yQ,(0,p.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(t){let{components:e,...n}=t;return(0,s.kt)(XQ,(0,p.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function gQ(t){let{components:e,...n}=t;return(0,s.kt)(TQ,(0,p.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gQ.isMDXComponent=!0;const CQ={toc:[]},xQ="wrapper";function vQ(t){let{components:e,...n}=t;return(0,s.kt)(xQ,(0,p.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}vQ.isMDXComponent=!0;const LQ={toc:[]},ZQ="wrapper";function bQ(t){let{components:e,...n}=t;return(0,s.kt)(ZQ,(0,p.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}bQ.isMDXComponent=!0;const NQ={toc:[]},AQ="wrapper";function zQ(t){let{components:e,...n}=t;return(0,s.kt)(AQ,(0,p.Z)({},NQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}zQ.isMDXComponent=!0;const WQ={toc:[]},IQ="wrapper";function RQ(t){let{components:e,...n}=t;return(0,s.kt)(IQ,(0,p.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}RQ.isMDXComponent=!0;const SQ={toc:[]},PQ="wrapper";function EQ(t){let{components:e,...n}=t;return(0,s.kt)(PQ,(0,p.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}EQ.isMDXComponent=!0;const OQ={toc:[]},GQ="wrapper";function FQ(t){let{components:e,...n}=t;return(0,s.kt)(GQ,(0,p.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}FQ.isMDXComponent=!0;const BQ={toc:[]},UQ="wrapper";function VQ(t){let{components:e,...n}=t;return(0,s.kt)(UQ,(0,p.Z)({},BQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VQ.isMDXComponent=!0;const qQ={toc:[]},jQ="wrapper";function YQ(t){let{components:e,...n}=t;return(0,s.kt)(jQ,(0,p.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}YQ.isMDXComponent=!0;const HQ={toc:[]},QQ="wrapper";function $Q(t){let{components:e,...n}=t;return(0,s.kt)(QQ,(0,p.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$Q.isMDXComponent=!0;const JQ={toc:[]},KQ="wrapper";function t$(t){let{components:e,...n}=t;return(0,s.kt)(KQ,(0,p.Z)({},JQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}t$.isMDXComponent=!0;const e$={toc:[]},n$="wrapper";function o$(t){let{components:e,...n}=t;return(0,s.kt)(n$,(0,p.Z)({},e$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(t){let{components:e,...n}=t;return(0,s.kt)(r$,(0,p.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}s$.isMDXComponent=!0;const c$={toc:[]},i$="wrapper";function a$(t){let{components:e,...n}=t;return(0,s.kt)(i$,(0,p.Z)({},c$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}a$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(t){let{components:e,...n}=t;return(0,s.kt)(u$,(0,p.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m$.isMDXComponent=!0;const d$={toc:[]},h$="wrapper";function f$(t){let{components:e,...n}=t;return(0,s.kt)(h$,(0,p.Z)({},d$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}f$.isMDXComponent=!0;const k$={toc:[]},y$="wrapper";function D$(t){let{components:e,...n}=t;return(0,s.kt)(y$,(0,p.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(t){let{components:e,...n}=t;return(0,s.kt)(X$,(0,p.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function g$(t){let{components:e,...n}=t;return(0,s.kt)(T$,(0,p.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}g$.isMDXComponent=!0;const C$={toc:[]},x$="wrapper";function v$(t){let{components:e,...n}=t;return(0,s.kt)(x$,(0,p.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}v$.isMDXComponent=!0;const L$={toc:[]},Z$="wrapper";function b$(t){let{components:e,...n}=t;return(0,s.kt)(Z$,(0,p.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}b$.isMDXComponent=!0;const N$={toc:[]},A$="wrapper";function z$(t){let{components:e,...n}=t;return(0,s.kt)(A$,(0,p.Z)({},N$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}z$.isMDXComponent=!0;const W$={toc:[]},I$="wrapper";function R$(t){let{components:e,...n}=t;return(0,s.kt)(I$,(0,p.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}R$.isMDXComponent=!0;const S$={toc:[]},P$="wrapper";function E$(t){let{components:e,...n}=t;return(0,s.kt)(P$,(0,p.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}E$.isMDXComponent=!0;const O$={toc:[]},G$="wrapper";function F$(t){let{components:e,...n}=t;return(0,s.kt)(G$,(0,p.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}F$.isMDXComponent=!0;const B$={toc:[]},U$="wrapper";function V$(t){let{components:e,...n}=t;return(0,s.kt)(U$,(0,p.Z)({},B$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}V$.isMDXComponent=!0;const q$={toc:[]},j$="wrapper";function Y$(t){let{components:e,...n}=t;return(0,s.kt)(j$,(0,p.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y$.isMDXComponent=!0;const H$={toc:[]},Q$="wrapper";function $$(t){let{components:e,...n}=t;return(0,s.kt)(Q$,(0,p.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}$$.isMDXComponent=!0;const J$={toc:[]},K$="wrapper";function tJ(t){let{components:e,...n}=t;return(0,s.kt)(K$,(0,p.Z)({},J$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}tJ.isMDXComponent=!0;const eJ={toc:[]},nJ="wrapper";function oJ(t){let{components:e,...n}=t;return(0,s.kt)(nJ,(0,p.Z)({},eJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(t){let{components:e,...n}=t;return(0,s.kt)(rJ,(0,p.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sJ.isMDXComponent=!0;const cJ={toc:[]},iJ="wrapper";function aJ(t){let{components:e,...n}=t;return(0,s.kt)(iJ,(0,p.Z)({},cJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}aJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(t){let{components:e,...n}=t;return(0,s.kt)(uJ,(0,p.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mJ.isMDXComponent=!0;const dJ={toc:[]},hJ="wrapper";function fJ(t){let{components:e,...n}=t;return(0,s.kt)(hJ,(0,p.Z)({},dJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}fJ.isMDXComponent=!0;const kJ={toc:[]},yJ="wrapper";function DJ(t){let{components:e,...n}=t;return(0,s.kt)(yJ,(0,p.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(t){let{components:e,...n}=t;return(0,s.kt)(XJ,(0,p.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function gJ(t){let{components:e,...n}=t;return(0,s.kt)(TJ,(0,p.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}gJ.isMDXComponent=!0;const CJ={toc:[]},xJ="wrapper";function vJ(t){let{components:e,...n}=t;return(0,s.kt)(xJ,(0,p.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}vJ.isMDXComponent=!0;const LJ={toc:[]},ZJ="wrapper";function bJ(t){let{components:e,...n}=t;return(0,s.kt)(ZJ,(0,p.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}bJ.isMDXComponent=!0;const NJ={toc:[]},AJ="wrapper";function zJ(t){let{components:e,...n}=t;return(0,s.kt)(AJ,(0,p.Z)({},NJ,n,{components:e,mdxType:"MDXLayout"}))}zJ.isMDXComponent=!0;const WJ={toc:[]},IJ="wrapper";function RJ(t){let{components:e,...n}=t;return(0,s.kt)(IJ,(0,p.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RJ.isMDXComponent=!0;const SJ={toc:[]},PJ="wrapper";function EJ(t){let{components:e,...n}=t;return(0,s.kt)(PJ,(0,p.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}EJ.isMDXComponent=!0;const OJ={toc:[]},GJ="wrapper";function FJ(t){let{components:e,...n}=t;return(0,s.kt)(GJ,(0,p.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FJ.isMDXComponent=!0;const BJ={toc:[]},UJ="wrapper";function VJ(t){let{components:e,...n}=t;return(0,s.kt)(UJ,(0,p.Z)({},BJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}VJ.isMDXComponent=!0;const qJ={toc:[]},jJ="wrapper";function YJ(t){let{components:e,...n}=t;return(0,s.kt)(jJ,(0,p.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YJ.isMDXComponent=!0;const HJ={toc:[]},QJ="wrapper";function $J(t){let{components:e,...n}=t;return(0,s.kt)(QJ,(0,p.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$J.isMDXComponent=!0;const JJ={toc:[]},KJ="wrapper";function tK(t){let{components:e,...n}=t;return(0,s.kt)(KJ,(0,p.Z)({},JJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tK.isMDXComponent=!0;const eK={toc:[]},nK="wrapper";function oK(t){let{components:e,...n}=t;return(0,s.kt)(nK,(0,p.Z)({},eK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(t){let{components:e,...n}=t;return(0,s.kt)(rK,(0,p.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sK.isMDXComponent=!0;const cK={toc:[]},iK="wrapper";function aK(t){let{components:e,...n}=t;return(0,s.kt)(iK,(0,p.Z)({},cK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}aK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(t){let{components:e,...n}=t;return(0,s.kt)(uK,(0,p.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}mK.isMDXComponent=!0;const dK={toc:[]},hK="wrapper";function fK(t){let{components:e,...n}=t;return(0,s.kt)(hK,(0,p.Z)({},dK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}fK.isMDXComponent=!0;const kK={toc:[]},yK="wrapper";function DK(t){let{components:e,...n}=t;return(0,s.kt)(yK,(0,p.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(t){let{components:e,...n}=t;return(0,s.kt)(XK,(0,p.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function gK(t){let{components:e,...n}=t;return(0,s.kt)(TK,(0,p.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}gK.isMDXComponent=!0;const CK={toc:[]},xK="wrapper";function vK(t){let{components:e,...n}=t;return(0,s.kt)(xK,(0,p.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}vK.isMDXComponent=!0;const LK={toc:[]},ZK="wrapper";function bK(t){let{components:e,...n}=t;return(0,s.kt)(ZK,(0,p.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bK.isMDXComponent=!0;const NK={toc:[]},AK="wrapper";function zK(t){let{components:e,...n}=t;return(0,s.kt)(AK,(0,p.Z)({},NK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zK.isMDXComponent=!0;const WK={toc:[]},IK="wrapper";function RK(t){let{components:e,...n}=t;return(0,s.kt)(IK,(0,p.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}RK.isMDXComponent=!0;const SK={toc:[]},PK="wrapper";function EK(t){let{components:e,...n}=t;return(0,s.kt)(PK,(0,p.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}EK.isMDXComponent=!0;const OK={toc:[]},GK="wrapper";function FK(t){let{components:e,...n}=t;return(0,s.kt)(GK,(0,p.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FK.isMDXComponent=!0;const BK={toc:[]},UK="wrapper";function VK(t){let{components:e,...n}=t;return(0,s.kt)(UK,(0,p.Z)({},BK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}VK.isMDXComponent=!0;const qK={toc:[]},jK="wrapper";function YK(t){let{components:e,...n}=t;return(0,s.kt)(jK,(0,p.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}YK.isMDXComponent=!0;const HK={toc:[]},QK="wrapper";function $K(t){let{components:e,...n}=t;return(0,s.kt)(QK,(0,p.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}$K.isMDXComponent=!0;const JK={toc:[]},KK="wrapper";function t0(t){let{components:e,...n}=t;return(0,s.kt)(KK,(0,p.Z)({},JK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}t0.isMDXComponent=!0;const e0={toc:[]},n0="wrapper";function o0(t){let{components:e,...n}=t;return(0,s.kt)(n0,(0,p.Z)({},e0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(t){let{components:e,...n}=t;return(0,s.kt)(r0,(0,p.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}s0.isMDXComponent=!0;const c0={toc:[]},i0="wrapper";function a0(t){let{components:e,...n}=t;return(0,s.kt)(i0,(0,p.Z)({},c0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}a0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(t){let{components:e,...n}=t;return(0,s.kt)(u0,(0,p.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}m0.isMDXComponent=!0;const d0={toc:[]},h0="wrapper";function f0(t){let{components:e,...n}=t;return(0,s.kt)(h0,(0,p.Z)({},d0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}f0.isMDXComponent=!0;const k0={toc:[]},y0="wrapper";function D0(t){let{components:e,...n}=t;return(0,s.kt)(y0,(0,p.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(t){let{components:e,...n}=t;return(0,s.kt)(X0,(0,p.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function g0(t){let{components:e,...n}=t;return(0,s.kt)(T0,(0,p.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}g0.isMDXComponent=!0;const C0={toc:[]},x0="wrapper";function v0(t){let{components:e,...n}=t;return(0,s.kt)(x0,(0,p.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}v0.isMDXComponent=!0;const L0={toc:[]},Z0="wrapper";function b0(t){let{components:e,...n}=t;return(0,s.kt)(Z0,(0,p.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}b0.isMDXComponent=!0;const N0={toc:[]},A0="wrapper";function z0(t){let{components:e,...n}=t;return(0,s.kt)(A0,(0,p.Z)({},N0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}z0.isMDXComponent=!0;const W0={toc:[]},I0="wrapper";function R0(t){let{components:e,...n}=t;return(0,s.kt)(I0,(0,p.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}R0.isMDXComponent=!0;const S0={toc:[]},P0="wrapper";function E0(t){let{components:e,...n}=t;return(0,s.kt)(P0,(0,p.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}E0.isMDXComponent=!0;const O0={toc:[]},G0="wrapper";function F0(t){let{components:e,...n}=t;return(0,s.kt)(G0,(0,p.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}F0.isMDXComponent=!0;const B0={toc:[]},U0="wrapper";function V0(t){let{components:e,...n}=t;return(0,s.kt)(U0,(0,p.Z)({},B0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}V0.isMDXComponent=!0;const q0={toc:[]},j0="wrapper";function Y0(t){let{components:e,...n}=t;return(0,s.kt)(j0,(0,p.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Y0.isMDXComponent=!0;const H0={toc:[]},Q0="wrapper";function $0(t){let{components:e,...n}=t;return(0,s.kt)(Q0,(0,p.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$0.isMDXComponent=!0;const J0={toc:[]},K0="wrapper";function t2(t){let{components:e,...n}=t;return(0,s.kt)(K0,(0,p.Z)({},J0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}t2.isMDXComponent=!0;const e2={toc:[]},n2="wrapper";function o2(t){let{components:e,...n}=t;return(0,s.kt)(n2,(0,p.Z)({},e2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(t){let{components:e,...n}=t;return(0,s.kt)(r2,(0,p.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}s2.isMDXComponent=!0;const c2={toc:[]},i2="wrapper";function a2(t){let{components:e,...n}=t;return(0,s.kt)(i2,(0,p.Z)({},c2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}a2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(t){let{components:e,...n}=t;return(0,s.kt)(u2,(0,p.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}m2.isMDXComponent=!0;const d2={toc:[]},h2="wrapper";function f2(t){let{components:e,...n}=t;return(0,s.kt)(h2,(0,p.Z)({},d2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}f2.isMDXComponent=!0;const k2={toc:[]},y2="wrapper";function D2(t){let{components:e,...n}=t;return(0,s.kt)(y2,(0,p.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(t){let{components:e,...n}=t;return(0,s.kt)(X2,(0,p.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function g2(t){let{components:e,...n}=t;return(0,s.kt)(T2,(0,p.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}g2.isMDXComponent=!0;const C2={toc:[]},x2="wrapper";function v2(t){let{components:e,...n}=t;return(0,s.kt)(x2,(0,p.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}v2.isMDXComponent=!0;const L2={toc:[]},Z2="wrapper";function b2(t){let{components:e,...n}=t;return(0,s.kt)(Z2,(0,p.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}b2.isMDXComponent=!0;const N2={toc:[]},A2="wrapper";function z2(t){let{components:e,...n}=t;return(0,s.kt)(A2,(0,p.Z)({},N2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}z2.isMDXComponent=!0;const W2={toc:[]},I2="wrapper";function R2(t){let{components:e,...n}=t;return(0,s.kt)(I2,(0,p.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}R2.isMDXComponent=!0;const S2={toc:[]},P2="wrapper";function E2(t){let{components:e,...n}=t;return(0,s.kt)(P2,(0,p.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}E2.isMDXComponent=!0;const O2={toc:[]},G2="wrapper";function F2(t){let{components:e,...n}=t;return(0,s.kt)(G2,(0,p.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}F2.isMDXComponent=!0;const B2={toc:[]},U2="wrapper";function V2(t){let{components:e,...n}=t;return(0,s.kt)(U2,(0,p.Z)({},B2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}V2.isMDXComponent=!0;const q2={toc:[]},j2="wrapper";function Y2(t){let{components:e,...n}=t;return(0,s.kt)(j2,(0,p.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Y2.isMDXComponent=!0;const H2={toc:[]},Q2="wrapper";function $2(t){let{components:e,...n}=t;return(0,s.kt)(Q2,(0,p.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$2.isMDXComponent=!0;const J2={toc:[]},K2="wrapper";function t6(t){let{components:e,...n}=t;return(0,s.kt)(K2,(0,p.Z)({},J2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}t6.isMDXComponent=!0;const e6={toc:[]},n6="wrapper";function o6(t){let{components:e,...n}=t;return(0,s.kt)(n6,(0,p.Z)({},e6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(t){let{components:e,...n}=t;return(0,s.kt)(r6,(0,p.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}s6.isMDXComponent=!0;const c6={toc:[]},i6="wrapper";function a6(t){let{components:e,...n}=t;return(0,s.kt)(i6,(0,p.Z)({},c6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}a6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(t){let{components:e,...n}=t;return(0,s.kt)(u6,(0,p.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}m6.isMDXComponent=!0;const d6={toc:[]},h6="wrapper";function f6(t){let{components:e,...n}=t;return(0,s.kt)(h6,(0,p.Z)({},d6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}f6.isMDXComponent=!0;const k6={toc:[]},y6="wrapper";function D6(t){let{components:e,...n}=t;return(0,s.kt)(y6,(0,p.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(t){let{components:e,...n}=t;return(0,s.kt)(X6,(0,p.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function g6(t){let{components:e,...n}=t;return(0,s.kt)(T6,(0,p.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}g6.isMDXComponent=!0;const C6={toc:[]},x6="wrapper";function v6(t){let{components:e,...n}=t;return(0,s.kt)(x6,(0,p.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v6.isMDXComponent=!0;const L6={toc:[]},Z6="wrapper";function b6(t){let{components:e,...n}=t;return(0,s.kt)(Z6,(0,p.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}b6.isMDXComponent=!0;const N6={toc:[]},A6="wrapper";function z6(t){let{components:e,...n}=t;return(0,s.kt)(A6,(0,p.Z)({},N6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}z6.isMDXComponent=!0;const W6={toc:[]},I6="wrapper";function R6(t){let{components:e,...n}=t;return(0,s.kt)(I6,(0,p.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}R6.isMDXComponent=!0;const S6={toc:[]},P6="wrapper";function E6(t){let{components:e,...n}=t;return(0,s.kt)(P6,(0,p.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}E6.isMDXComponent=!0;const O6={toc:[]},G6="wrapper";function F6(t){let{components:e,...n}=t;return(0,s.kt)(G6,(0,p.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}F6.isMDXComponent=!0;const B6={toc:[]},U6="wrapper";function V6(t){let{components:e,...n}=t;return(0,s.kt)(U6,(0,p.Z)({},B6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}V6.isMDXComponent=!0;const q6={toc:[]},j6="wrapper";function Y6(t){let{components:e,...n}=t;return(0,s.kt)(j6,(0,p.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Y6.isMDXComponent=!0;const H6={toc:[]},Q6="wrapper";function $6(t){let{components:e,...n}=t;return(0,s.kt)(Q6,(0,p.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$6.isMDXComponent=!0;const J6={toc:[]},K6="wrapper";function t3(t){let{components:e,...n}=t;return(0,s.kt)(K6,(0,p.Z)({},J6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}t3.isMDXComponent=!0;const e3={toc:[]},n3="wrapper";function o3(t){let{components:e,...n}=t;return(0,s.kt)(n3,(0,p.Z)({},e3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(t){let{components:e,...n}=t;return(0,s.kt)(r3,(0,p.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}s3.isMDXComponent=!0;const c3={toc:[]},i3="wrapper";function a3(t){let{components:e,...n}=t;return(0,s.kt)(i3,(0,p.Z)({},c3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}a3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(t){let{components:e,...n}=t;return(0,s.kt)(u3,(0,p.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}m3.isMDXComponent=!0;const d3={toc:[]},h3="wrapper";function f3(t){let{components:e,...n}=t;return(0,s.kt)(h3,(0,p.Z)({},d3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}f3.isMDXComponent=!0;const k3={toc:[]},y3="wrapper";function D3(t){let{components:e,...n}=t;return(0,s.kt)(y3,(0,p.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(t){let{components:e,...n}=t;return(0,s.kt)(X3,(0,p.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function g3(t){let{components:e,...n}=t;return(0,s.kt)(T3,(0,p.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g3.isMDXComponent=!0;const C3={toc:[]},x3="wrapper";function v3(t){let{components:e,...n}=t;return(0,s.kt)(x3,(0,p.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}v3.isMDXComponent=!0;const L3={toc:[]},Z3="wrapper";function b3(t){let{components:e,...n}=t;return(0,s.kt)(Z3,(0,p.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}b3.isMDXComponent=!0;const N3={toc:[]},A3="wrapper";function z3(t){let{components:e,...n}=t;return(0,s.kt)(A3,(0,p.Z)({},N3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}z3.isMDXComponent=!0;const W3={toc:[]},I3="wrapper";function R3(t){let{components:e,...n}=t;return(0,s.kt)(I3,(0,p.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}R3.isMDXComponent=!0;const S3={toc:[]},P3="wrapper";function E3(t){let{components:e,...n}=t;return(0,s.kt)(P3,(0,p.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}E3.isMDXComponent=!0;const O3={toc:[]},G3="wrapper";function F3(t){let{components:e,...n}=t;return(0,s.kt)(G3,(0,p.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}F3.isMDXComponent=!0;const B3={toc:[]},U3="wrapper";function V3(t){let{components:e,...n}=t;return(0,s.kt)(U3,(0,p.Z)({},B3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}V3.isMDXComponent=!0;const q3={toc:[]},j3="wrapper";function Y3(t){let{components:e,...n}=t;return(0,s.kt)(j3,(0,p.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Y3.isMDXComponent=!0;const H3={toc:[]},Q3="wrapper";function $3(t){let{components:e,...n}=t;return(0,s.kt)(Q3,(0,p.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$3.isMDXComponent=!0;const J3={toc:[]},K3="wrapper";function t5(t){let{components:e,...n}=t;return(0,s.kt)(K3,(0,p.Z)({},J3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t5.isMDXComponent=!0;const e5={toc:[]},n5="wrapper";function o5(t){let{components:e,...n}=t;return(0,s.kt)(n5,(0,p.Z)({},e5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(t){let{components:e,...n}=t;return(0,s.kt)(r5,(0,p.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}s5.isMDXComponent=!0;const c5={toc:[]},i5="wrapper";function a5(t){let{components:e,...n}=t;return(0,s.kt)(i5,(0,p.Z)({},c5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}a5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(t){let{components:e,...n}=t;return(0,s.kt)(u5,(0,p.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}m5.isMDXComponent=!0;const d5={toc:[]},h5="wrapper";function f5(t){let{components:e,...n}=t;return(0,s.kt)(h5,(0,p.Z)({},d5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}f5.isMDXComponent=!0;const k5={toc:[]},y5="wrapper";function D5(t){let{components:e,...n}=t;return(0,s.kt)(y5,(0,p.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(t){let{components:e,...n}=t;return(0,s.kt)(X5,(0,p.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function g5(t){let{components:e,...n}=t;return(0,s.kt)(T5,(0,p.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}g5.isMDXComponent=!0;const C5={toc:[]},x5="wrapper";function v5(t){let{components:e,...n}=t;return(0,s.kt)(x5,(0,p.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}v5.isMDXComponent=!0;const L5={toc:[]},Z5="wrapper";function b5(t){let{components:e,...n}=t;return(0,s.kt)(Z5,(0,p.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}b5.isMDXComponent=!0;const N5={toc:[]},A5="wrapper";function z5(t){let{components:e,...n}=t;return(0,s.kt)(A5,(0,p.Z)({},N5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}z5.isMDXComponent=!0;const W5={toc:[]},I5="wrapper";function R5(t){let{components:e,...n}=t;return(0,s.kt)(I5,(0,p.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}R5.isMDXComponent=!0;const S5={toc:[]},P5="wrapper";function E5(t){let{components:e,...n}=t;return(0,s.kt)(P5,(0,p.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}E5.isMDXComponent=!0;const O5={toc:[]},G5="wrapper";function F5(t){let{components:e,...n}=t;return(0,s.kt)(G5,(0,p.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}F5.isMDXComponent=!0;const B5={toc:[]},U5="wrapper";function V5(t){let{components:e,...n}=t;return(0,s.kt)(U5,(0,p.Z)({},B5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}V5.isMDXComponent=!0;const q5={toc:[]},j5="wrapper";function Y5(t){let{components:e,...n}=t;return(0,s.kt)(j5,(0,p.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Y5.isMDXComponent=!0;const H5={toc:[]},Q5="wrapper";function $5(t){let{components:e,...n}=t;return(0,s.kt)(Q5,(0,p.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$5.isMDXComponent=!0;const J5={toc:[]},K5="wrapper";function t1(t){let{components:e,...n}=t;return(0,s.kt)(K5,(0,p.Z)({},J5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}t1.isMDXComponent=!0;const e1={toc:[]},n1="wrapper";function o1(t){let{components:e,...n}=t;return(0,s.kt)(n1,(0,p.Z)({},e1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(t){let{components:e,...n}=t;return(0,s.kt)(r1,(0,p.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}s1.isMDXComponent=!0;const c1={toc:[]},i1="wrapper";function a1(t){let{components:e,...n}=t;return(0,s.kt)(i1,(0,p.Z)({},c1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}a1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(t){let{components:e,...n}=t;return(0,s.kt)(u1,(0,p.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}m1.isMDXComponent=!0;const d1={toc:[]},h1="wrapper";function f1(t){let{components:e,...n}=t;return(0,s.kt)(h1,(0,p.Z)({},d1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}f1.isMDXComponent=!0;const k1={toc:[]},y1="wrapper";function D1(t){let{components:e,...n}=t;return(0,s.kt)(y1,(0,p.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(t){let{components:e,...n}=t;return(0,s.kt)(X1,(0,p.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function g1(t){let{components:e,...n}=t;return(0,s.kt)(T1,(0,p.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}g1.isMDXComponent=!0;const C1={toc:[]},x1="wrapper";function v1(t){let{components:e,...n}=t;return(0,s.kt)(x1,(0,p.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}v1.isMDXComponent=!0;const L1={toc:[]},Z1="wrapper";function b1(t){let{components:e,...n}=t;return(0,s.kt)(Z1,(0,p.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}b1.isMDXComponent=!0;const N1={toc:[]},A1="wrapper";function z1(t){let{components:e,...n}=t;return(0,s.kt)(A1,(0,p.Z)({},N1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}z1.isMDXComponent=!0;const W1={toc:[]},I1="wrapper";function R1(t){let{components:e,...n}=t;return(0,s.kt)(I1,(0,p.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}R1.isMDXComponent=!0;const S1={toc:[]},P1="wrapper";function E1(t){let{components:e,...n}=t;return(0,s.kt)(P1,(0,p.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}E1.isMDXComponent=!0;const O1={toc:[]},G1="wrapper";function F1(t){let{components:e,...n}=t;return(0,s.kt)(G1,(0,p.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F1.isMDXComponent=!0;const B1={toc:[]},U1="wrapper";function V1(t){let{components:e,...n}=t;return(0,s.kt)(U1,(0,p.Z)({},B1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}V1.isMDXComponent=!0;const q1={toc:[]},j1="wrapper";function Y1(t){let{components:e,...n}=t;return(0,s.kt)(j1,(0,p.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y1.isMDXComponent=!0;const H1={toc:[]},Q1="wrapper";function $1(t){let{components:e,...n}=t;return(0,s.kt)(Q1,(0,p.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}$1.isMDXComponent=!0;const J1={toc:[]},K1="wrapper";function t4(t){let{components:e,...n}=t;return(0,s.kt)(K1,(0,p.Z)({},J1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}t4.isMDXComponent=!0;const e4={toc:[]},n4="wrapper";function o4(t){let{components:e,...n}=t;return(0,s.kt)(n4,(0,p.Z)({},e4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(t){let{components:e,...n}=t;return(0,s.kt)(r4,(0,p.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}s4.isMDXComponent=!0;const c4={toc:[]},i4="wrapper";function a4(t){let{components:e,...n}=t;return(0,s.kt)(i4,(0,p.Z)({},c4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}a4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(t){let{components:e,...n}=t;return(0,s.kt)(u4,(0,p.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}m4.isMDXComponent=!0;const d4={toc:[]},h4="wrapper";function f4(t){let{components:e,...n}=t;return(0,s.kt)(h4,(0,p.Z)({},d4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}f4.isMDXComponent=!0;const k4={toc:[]},y4="wrapper";function D4(t){let{components:e,...n}=t;return(0,s.kt)(y4,(0,p.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(t){let{components:e,...n}=t;return(0,s.kt)(X4,(0,p.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function g4(t){let{components:e,...n}=t;return(0,s.kt)(T4,(0,p.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}g4.isMDXComponent=!0;const C4={toc:[]},x4="wrapper";function v4(t){let{components:e,...n}=t;return(0,s.kt)(x4,(0,p.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}v4.isMDXComponent=!0;const L4={toc:[]},Z4="wrapper";function b4(t){let{components:e,...n}=t;return(0,s.kt)(Z4,(0,p.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}b4.isMDXComponent=!0;const N4={toc:[]},A4="wrapper";function z4(t){let{components:e,...n}=t;return(0,s.kt)(A4,(0,p.Z)({},N4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}z4.isMDXComponent=!0;const W4={toc:[]},I4="wrapper";function R4(t){let{components:e,...n}=t;return(0,s.kt)(I4,(0,p.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}R4.isMDXComponent=!0;const S4={toc:[]},P4="wrapper";function E4(t){let{components:e,...n}=t;return(0,s.kt)(P4,(0,p.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}E4.isMDXComponent=!0;const O4={toc:[]},G4="wrapper";function F4(t){let{components:e,...n}=t;return(0,s.kt)(G4,(0,p.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F4.isMDXComponent=!0;const B4={toc:[]},U4="wrapper";function V4(t){let{components:e,...n}=t;return(0,s.kt)(U4,(0,p.Z)({},B4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}V4.isMDXComponent=!0;const q4={toc:[]},j4="wrapper";function Y4(t){let{components:e,...n}=t;return(0,s.kt)(j4,(0,p.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Y4.isMDXComponent=!0;const H4={toc:[]},Q4="wrapper";function $4(t){let{components:e,...n}=t;return(0,s.kt)(Q4,(0,p.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}$4.isMDXComponent=!0;const J4={toc:[]},K4="wrapper";function t8(t){let{components:e,...n}=t;return(0,s.kt)(K4,(0,p.Z)({},J4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}t8.isMDXComponent=!0;const e8={toc:[]},n8="wrapper";function o8(t){let{components:e,...n}=t;return(0,s.kt)(n8,(0,p.Z)({},e8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(t){let{components:e,...n}=t;return(0,s.kt)(r8,(0,p.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}s8.isMDXComponent=!0;const c8={toc:[]},i8="wrapper";function a8(t){let{components:e,...n}=t;return(0,s.kt)(i8,(0,p.Z)({},c8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}a8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(t){let{components:e,...n}=t;return(0,s.kt)(u8,(0,p.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}m8.isMDXComponent=!0;const d8={toc:[]},h8="wrapper";function f8(t){let{components:e,...n}=t;return(0,s.kt)(h8,(0,p.Z)({},d8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}f8.isMDXComponent=!0;const k8={toc:[]},y8="wrapper";function D8(t){let{components:e,...n}=t;return(0,s.kt)(y8,(0,p.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(t){let{components:e,...n}=t;return(0,s.kt)(X8,(0,p.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function g8(t){let{components:e,...n}=t;return(0,s.kt)(T8,(0,p.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}g8.isMDXComponent=!0;const C8={toc:[]},x8="wrapper";function v8(t){let{components:e,...n}=t;return(0,s.kt)(x8,(0,p.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}v8.isMDXComponent=!0;const L8={toc:[]},Z8="wrapper";function b8(t){let{components:e,...n}=t;return(0,s.kt)(Z8,(0,p.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}b8.isMDXComponent=!0;const N8={toc:[]},A8="wrapper";function z8(t){let{components:e,...n}=t;return(0,s.kt)(A8,(0,p.Z)({},N8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}z8.isMDXComponent=!0;const W8={toc:[]},I8="wrapper";function R8(t){let{components:e,...n}=t;return(0,s.kt)(I8,(0,p.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}R8.isMDXComponent=!0;const S8={toc:[]},P8="wrapper";function E8(t){let{components:e,...n}=t;return(0,s.kt)(P8,(0,p.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}E8.isMDXComponent=!0;const O8={toc:[]},G8="wrapper";function F8(t){let{components:e,...n}=t;return(0,s.kt)(G8,(0,p.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F8.isMDXComponent=!0;const B8={toc:[]},U8="wrapper";function V8(t){let{components:e,...n}=t;return(0,s.kt)(U8,(0,p.Z)({},B8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}V8.isMDXComponent=!0;const q8={toc:[]},j8="wrapper";function Y8(t){let{components:e,...n}=t;return(0,s.kt)(j8,(0,p.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Y8.isMDXComponent=!0;const H8={toc:[]},Q8="wrapper";function $8(t){let{components:e,...n}=t;return(0,s.kt)(Q8,(0,p.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}$8.isMDXComponent=!0;const J8={toc:[]},K8="wrapper";function t7(t){let{components:e,...n}=t;return(0,s.kt)(K8,(0,p.Z)({},J8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}t7.isMDXComponent=!0;const e7={toc:[]},n7="wrapper";function o7(t){let{components:e,...n}=t;return(0,s.kt)(n7,(0,p.Z)({},e7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(t){let{components:e,...n}=t;return(0,s.kt)(r7,(0,p.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}s7.isMDXComponent=!0;const c7={toc:[]},i7="wrapper";function a7(t){let{components:e,...n}=t;return(0,s.kt)(i7,(0,p.Z)({},c7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}a7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(t){let{components:e,...n}=t;return(0,s.kt)(u7,(0,p.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}m7.isMDXComponent=!0;const d7={toc:[]},h7="wrapper";function f7(t){let{components:e,...n}=t;return(0,s.kt)(h7,(0,p.Z)({},d7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}f7.isMDXComponent=!0;const k7={toc:[]},y7="wrapper";function D7(t){let{components:e,...n}=t;return(0,s.kt)(y7,(0,p.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(t){let{components:e,...n}=t;return(0,s.kt)(X7,(0,p.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function g7(t){let{components:e,...n}=t;return(0,s.kt)(T7,(0,p.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}g7.isMDXComponent=!0;const C7={toc:[]},x7="wrapper";function v7(t){let{components:e,...n}=t;return(0,s.kt)(x7,(0,p.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}v7.isMDXComponent=!0;const L7={toc:[]},Z7="wrapper";function b7(t){let{components:e,...n}=t;return(0,s.kt)(Z7,(0,p.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}b7.isMDXComponent=!0;const N7={toc:[]},A7="wrapper";function z7(t){let{components:e,...n}=t;return(0,s.kt)(A7,(0,p.Z)({},N7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}z7.isMDXComponent=!0;const W7={toc:[]},I7="wrapper";function R7(t){let{components:e,...n}=t;return(0,s.kt)(I7,(0,p.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}R7.isMDXComponent=!0;const S7={toc:[]},P7="wrapper";function E7(t){let{components:e,...n}=t;return(0,s.kt)(P7,(0,p.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}E7.isMDXComponent=!0;const O7={toc:[]},G7="wrapper";function F7(t){let{components:e,...n}=t;return(0,s.kt)(G7,(0,p.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}F7.isMDXComponent=!0;const B7={toc:[]},U7="wrapper";function V7(t){let{components:e,...n}=t;return(0,s.kt)(U7,(0,p.Z)({},B7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}V7.isMDXComponent=!0;const q7={toc:[]},j7="wrapper";function Y7(t){let{components:e,...n}=t;return(0,s.kt)(j7,(0,p.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}Y7.isMDXComponent=!0;const H7={toc:[]},Q7="wrapper";function $7(t){let{components:e,...n}=t;return(0,s.kt)(Q7,(0,p.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}$7.isMDXComponent=!0;const J7={toc:[]},K7="wrapper";function t9(t){let{components:e,...n}=t;return(0,s.kt)(K7,(0,p.Z)({},J7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}t9.isMDXComponent=!0;const e9={toc:[]},n9="wrapper";function o9(t){let{components:e,...n}=t;return(0,s.kt)(n9,(0,p.Z)({},e9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(t){let{components:e,...n}=t;return(0,s.kt)(r9,(0,p.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}s9.isMDXComponent=!0;const c9={toc:[]},i9="wrapper";function a9(t){let{components:e,...n}=t;return(0,s.kt)(i9,(0,p.Z)({},c9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}a9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(t){let{components:e,...n}=t;return(0,s.kt)(u9,(0,p.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m9.isMDXComponent=!0;const d9={toc:[]},h9="wrapper";function f9(t){let{components:e,...n}=t;return(0,s.kt)(h9,(0,p.Z)({},d9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}f9.isMDXComponent=!0;const k9={toc:[]},y9="wrapper";function D9(t){let{components:e,...n}=t;return(0,s.kt)(y9,(0,p.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(t){let{components:e,...n}=t;return(0,s.kt)(X9,(0,p.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function g9(t){let{components:e,...n}=t;return(0,s.kt)(T9,(0,p.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}g9.isMDXComponent=!0;const C9={toc:[]},x9="wrapper";function v9(t){let{components:e,...n}=t;return(0,s.kt)(x9,(0,p.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}v9.isMDXComponent=!0;const L9={toc:[]},Z9="wrapper";function b9(t){let{components:e,...n}=t;return(0,s.kt)(Z9,(0,p.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}b9.isMDXComponent=!0;const N9={toc:[]},A9="wrapper";function z9(t){let{components:e,...n}=t;return(0,s.kt)(A9,(0,p.Z)({},N9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}z9.isMDXComponent=!0;const W9={toc:[]},I9="wrapper";function R9(t){let{components:e,...n}=t;return(0,s.kt)(I9,(0,p.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}R9.isMDXComponent=!0;const S9={toc:[]},P9="wrapper";function E9(t){let{components:e,...n}=t;return(0,s.kt)(P9,(0,p.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}E9.isMDXComponent=!0;const O9={toc:[]},G9="wrapper";function F9(t){let{components:e,...n}=t;return(0,s.kt)(G9,(0,p.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}F9.isMDXComponent=!0;const B9={toc:[]},U9="wrapper";function V9(t){let{components:e,...n}=t;return(0,s.kt)(U9,(0,p.Z)({},B9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}V9.isMDXComponent=!0;const q9={toc:[]},j9="wrapper";function Y9(t){let{components:e,...n}=t;return(0,s.kt)(j9,(0,p.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Y9.isMDXComponent=!0;const H9={toc:[]},Q9="wrapper";function $9(t){let{components:e,...n}=t;return(0,s.kt)(Q9,(0,p.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$9.isMDXComponent=!0;const J9={toc:[]},K9="wrapper";function ttt(t){let{components:e,...n}=t;return(0,s.kt)(K9,(0,p.Z)({},J9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}ttt.isMDXComponent=!0;const ett={toc:[]},ntt="wrapper";function ott(t){let{components:e,...n}=t;return(0,s.kt)(ntt,(0,p.Z)({},ett,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}ott.isMDXComponent=!0;const ptt={toc:[]},rtt="wrapper";function stt(t){let{components:e,...n}=t;return(0,s.kt)(rtt,(0,p.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}stt.isMDXComponent=!0;const ctt={toc:[]},itt="wrapper";function att(t){let{components:e,...n}=t;return(0,s.kt)(itt,(0,p.Z)({},ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}att.isMDXComponent=!0;const ltt={toc:[]},utt="wrapper";function mtt(t){let{components:e,...n}=t;return(0,s.kt)(utt,(0,p.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mtt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function ftt(t){let{components:e,...n}=t;return(0,s.kt)(htt,(0,p.Z)({},dtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ftt.isMDXComponent=!0;const ktt={toc:[]},ytt="wrapper";function Dtt(t){let{components:e,...n}=t;return(0,s.kt)(ytt,(0,p.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Dtt.isMDXComponent=!0;const Mtt={toc:[]},Xtt="wrapper";function _tt(t){let{components:e,...n}=t;return(0,s.kt)(Xtt,(0,p.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_tt.isMDXComponent=!0;const wtt={toc:[]},Ttt="wrapper";function gtt(t){let{components:e,...n}=t;return(0,s.kt)(Ttt,(0,p.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gtt.isMDXComponent=!0;const Ctt={toc:[]},xtt="wrapper";function vtt(t){let{components:e,...n}=t;return(0,s.kt)(xtt,(0,p.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vtt.isMDXComponent=!0;const Ltt={toc:[]},Ztt="wrapper";function btt(t){let{components:e,...n}=t;return(0,s.kt)(Ztt,(0,p.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}btt.isMDXComponent=!0;const Ntt={toc:[]},Att="wrapper";function ztt(t){let{components:e,...n}=t;return(0,s.kt)(Att,(0,p.Z)({},Ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ztt.isMDXComponent=!0;const Wtt={toc:[]},Itt="wrapper";function Rtt(t){let{components:e,...n}=t;return(0,s.kt)(Itt,(0,p.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Rtt.isMDXComponent=!0;const Stt={toc:[]},Ptt="wrapper";function Ett(t){let{components:e,...n}=t;return(0,s.kt)(Ptt,(0,p.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Ett.isMDXComponent=!0;const Ott={toc:[]},Gtt="wrapper";function Ftt(t){let{components:e,...n}=t;return(0,s.kt)(Gtt,(0,p.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Ftt.isMDXComponent=!0;const Btt={toc:[]},Utt="wrapper";function Vtt(t){let{components:e,...n}=t;return(0,s.kt)(Utt,(0,p.Z)({},Btt,n,{components:e,mdxType:"MDXLayout"}))}Vtt.isMDXComponent=!0;const qtt={toc:[]},jtt="wrapper";function Ytt(t){let{components:e,...n}=t;return(0,s.kt)(jtt,(0,p.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ytt.isMDXComponent=!0;const Htt={toc:[]},Qtt="wrapper";function $tt(t){let{components:e,...n}=t;return(0,s.kt)(Qtt,(0,p.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}$tt.isMDXComponent=!0;const Jtt={toc:[]},Ktt="wrapper";function tet(t){let{components:e,...n}=t;return(0,s.kt)(Ktt,(0,p.Z)({},Jtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}tet.isMDXComponent=!0;const eet={toc:[]},net="wrapper";function oet(t){let{components:e,...n}=t;return(0,s.kt)(net,(0,p.Z)({},eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(t){let{components:e,...n}=t;return(0,s.kt)(ret,(0,p.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}set.isMDXComponent=!0;const cet={toc:[]},iet="wrapper";function aet(t){let{components:e,...n}=t;return(0,s.kt)(iet,(0,p.Z)({},cet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}aet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function det(t){let{components:e,...n}=t;return(0,s.kt)(met,(0,p.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}det.isMDXComponent=!0;const het={toc:[]},fet="wrapper";function ket(t){let{components:e,...n}=t;return(0,s.kt)(fet,(0,p.Z)({},het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ket.isMDXComponent=!0;const yet={toc:[]},Det="wrapper";function Met(t){let{components:e,...n}=t;return(0,s.kt)(Det,(0,p.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(t){let{components:e,...n}=t;return(0,s.kt)(_et,(0,p.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wet.isMDXComponent=!0;const Tet={toc:[]},get="wrapper";function Cet(t){let{components:e,...n}=t;return(0,s.kt)(get,(0,p.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cet.isMDXComponent=!0;const xet={toc:[]},vet="wrapper";function Let(t){let{components:e,...n}=t;return(0,s.kt)(vet,(0,p.Z)({},xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Let.isMDXComponent=!0;const Zet={toc:[]},bet="wrapper";function Net(t){let{components:e,...n}=t;return(0,s.kt)(bet,(0,p.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Net.isMDXComponent=!0;const Aet={toc:[]},zet="wrapper";function Wet(t){let{components:e,...n}=t;return(0,s.kt)(zet,(0,p.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wet.isMDXComponent=!0;const Iet={toc:[]},Ret="wrapper";function Set(t){let{components:e,...n}=t;return(0,s.kt)(Ret,(0,p.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Set.isMDXComponent=!0;const Pet={toc:[]},Eet="wrapper";function Oet(t){let{components:e,...n}=t;return(0,s.kt)(Eet,(0,p.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Oet.isMDXComponent=!0;const Get={toc:[]},Fet="wrapper";function Bet(t){let{components:e,...n}=t;return(0,s.kt)(Fet,(0,p.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bet.isMDXComponent=!0;const Uet={toc:[]},Vet="wrapper";function qet(t){let{components:e,...n}=t;return(0,s.kt)(Vet,(0,p.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qet.isMDXComponent=!0;const jet={toc:[]},Yet="wrapper";function Het(t){let{components:e,...n}=t;return(0,s.kt)(Yet,(0,p.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Het.isMDXComponent=!0;const Qet={toc:[]},$et="wrapper";function Jet(t){let{components:e,...n}=t;return(0,s.kt)($et,(0,p.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jet.isMDXComponent=!0;const Ket={toc:[]},tnt="wrapper";function ent(t){let{components:e,...n}=t;return(0,s.kt)(tnt,(0,p.Z)({},Ket,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ent.isMDXComponent=!0;const nnt={toc:[]},ont="wrapper";function pnt(t){let{components:e,...n}=t;return(0,s.kt)(ont,(0,p.Z)({},nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(t){let{components:e,...n}=t;return(0,s.kt)(snt,(0,p.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cnt.isMDXComponent=!0;const int={toc:[]},ant="wrapper";function lnt(t){let{components:e,...n}=t;return(0,s.kt)(ant,(0,p.Z)({},int,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function dnt(t){let{components:e,...n}=t;return(0,s.kt)(mnt,(0,p.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dnt.isMDXComponent=!0;const hnt={toc:[]},fnt="wrapper";function knt(t){let{components:e,...n}=t;return(0,s.kt)(fnt,(0,p.Z)({},hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}knt.isMDXComponent=!0;const ynt={toc:[]},Dnt="wrapper";function Mnt(t){let{components:e,...n}=t;return(0,s.kt)(Dnt,(0,p.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(t){let{components:e,...n}=t;return(0,s.kt)(_nt,(0,p.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},gnt="wrapper";function Cnt(t){let{components:e,...n}=t;return(0,s.kt)(gnt,(0,p.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Cnt.isMDXComponent=!0;const xnt={toc:[]},vnt="wrapper";function Lnt(t){let{components:e,...n}=t;return(0,s.kt)(vnt,(0,p.Z)({},xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Lnt.isMDXComponent=!0;const Znt={toc:[]},bnt="wrapper";function Nnt(t){let{components:e,...n}=t;return(0,s.kt)(bnt,(0,p.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Nnt.isMDXComponent=!0;const Ant={toc:[]},znt="wrapper";function Wnt(t){let{components:e,...n}=t;return(0,s.kt)(znt,(0,p.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Wnt.isMDXComponent=!0;const Int={toc:[]},Rnt="wrapper";function Snt(t){let{components:e,...n}=t;return(0,s.kt)(Rnt,(0,p.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Snt.isMDXComponent=!0;const Pnt={toc:[]},Ent="wrapper";function Ont(t){let{components:e,...n}=t;return(0,s.kt)(Ent,(0,p.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Ont.isMDXComponent=!0;const Gnt={toc:[]},Fnt="wrapper";function Bnt(t){let{components:e,...n}=t;return(0,s.kt)(Fnt,(0,p.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Bnt.isMDXComponent=!0;const Unt={toc:[]},Vnt="wrapper";function qnt(t){let{components:e,...n}=t;return(0,s.kt)(Vnt,(0,p.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qnt.isMDXComponent=!0;const jnt={toc:[]},Ynt="wrapper";function Hnt(t){let{components:e,...n}=t;return(0,s.kt)(Ynt,(0,p.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Hnt.isMDXComponent=!0;const Qnt={toc:[]},$nt="wrapper";function Jnt(t){let{components:e,...n}=t;return(0,s.kt)($nt,(0,p.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Jnt.isMDXComponent=!0;const Knt={toc:[]},tot="wrapper";function eot(t){let{components:e,...n}=t;return(0,s.kt)(tot,(0,p.Z)({},Knt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}eot.isMDXComponent=!0;const not={toc:[]},oot="wrapper";function pot(t){let{components:e,...n}=t;return(0,s.kt)(oot,(0,p.Z)({},not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(t){let{components:e,...n}=t;return(0,s.kt)(sot,(0,p.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cot.isMDXComponent=!0;const iot={toc:[]},aot="wrapper";function lot(t){let{components:e,...n}=t;return(0,s.kt)(aot,(0,p.Z)({},iot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function dot(t){let{components:e,...n}=t;return(0,s.kt)(mot,(0,p.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}dot.isMDXComponent=!0;const hot={toc:[]},fot="wrapper";function kot(t){let{components:e,...n}=t;return(0,s.kt)(fot,(0,p.Z)({},hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kot.isMDXComponent=!0;const yot={toc:[]},Dot="wrapper";function Mot(t){let{components:e,...n}=t;return(0,s.kt)(Dot,(0,p.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(t){let{components:e,...n}=t;return(0,s.kt)(_ot,(0,p.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wot.isMDXComponent=!0;const Tot={toc:[]},got="wrapper";function Cot(t){let{components:e,...n}=t;return(0,s.kt)(got,(0,p.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Cot.isMDXComponent=!0;const xot={toc:[]},vot="wrapper";function Lot(t){let{components:e,...n}=t;return(0,s.kt)(vot,(0,p.Z)({},xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Lot.isMDXComponent=!0;const Zot={toc:[]},bot="wrapper";function Not(t){let{components:e,...n}=t;return(0,s.kt)(bot,(0,p.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Not.isMDXComponent=!0;const Aot={toc:[]},zot="wrapper";function Wot(t){let{components:e,...n}=t;return(0,s.kt)(zot,(0,p.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wot.isMDXComponent=!0;const Iot={toc:[]},Rot="wrapper";function Sot(t){let{components:e,...n}=t;return(0,s.kt)(Rot,(0,p.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Sot.isMDXComponent=!0;const Pot={toc:[]},Eot="wrapper";function Oot(t){let{components:e,...n}=t;return(0,s.kt)(Eot,(0,p.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Oot.isMDXComponent=!0;const Got={toc:[]},Fot="wrapper";function Bot(t){let{components:e,...n}=t;return(0,s.kt)(Fot,(0,p.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Bot.isMDXComponent=!0;const Uot={toc:[]},Vot="wrapper";function qot(t){let{components:e,...n}=t;return(0,s.kt)(Vot,(0,p.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qot.isMDXComponent=!0;const jot={toc:[]},Yot="wrapper";function Hot(t){let{components:e,...n}=t;return(0,s.kt)(Yot,(0,p.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Hot.isMDXComponent=!0;const Qot={toc:[]},$ot="wrapper";function Jot(t){let{components:e,...n}=t;return(0,s.kt)($ot,(0,p.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Jot.isMDXComponent=!0;const Kot={toc:[]},tpt="wrapper";function ept(t){let{components:e,...n}=t;return(0,s.kt)(tpt,(0,p.Z)({},Kot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ept.isMDXComponent=!0;const npt={toc:[]},opt="wrapper";function ppt(t){let{components:e,...n}=t;return(0,s.kt)(opt,(0,p.Z)({},npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(t){let{components:e,...n}=t;return(0,s.kt)(spt,(0,p.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cpt.isMDXComponent=!0;const ipt={toc:[]},apt="wrapper";function lpt(t){let{components:e,...n}=t;return(0,s.kt)(apt,(0,p.Z)({},ipt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function dpt(t){let{components:e,...n}=t;return(0,s.kt)(mpt,(0,p.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dpt.isMDXComponent=!0;const hpt={toc:[]},fpt="wrapper";function kpt(t){let{components:e,...n}=t;return(0,s.kt)(fpt,(0,p.Z)({},hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kpt.isMDXComponent=!0;const ypt={toc:[]},Dpt="wrapper";function Mpt(t){let{components:e,...n}=t;return(0,s.kt)(Dpt,(0,p.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(t){let{components:e,...n}=t;return(0,s.kt)(_pt,(0,p.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},gpt="wrapper";function Cpt(t){let{components:e,...n}=t;return(0,s.kt)(gpt,(0,p.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Cpt.isMDXComponent=!0;const xpt={toc:[]},vpt="wrapper";function Lpt(t){let{components:e,...n}=t;return(0,s.kt)(vpt,(0,p.Z)({},xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]},bpt="wrapper";function Npt(t){let{components:e,...n}=t;return(0,s.kt)(bpt,(0,p.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Npt.isMDXComponent=!0;const Apt={toc:[]},zpt="wrapper";function Wpt(t){let{components:e,...n}=t;return(0,s.kt)(zpt,(0,p.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wpt.isMDXComponent=!0;const Ipt={toc:[]},Rpt="wrapper";function Spt(t){let{components:e,...n}=t;return(0,s.kt)(Rpt,(0,p.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Spt.isMDXComponent=!0;const Ppt={toc:[]},Ept="wrapper";function Opt(t){let{components:e,...n}=t;return(0,s.kt)(Ept,(0,p.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Opt.isMDXComponent=!0;const Gpt={toc:[]},Fpt="wrapper";function Bpt(t){let{components:e,...n}=t;return(0,s.kt)(Fpt,(0,p.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bpt.isMDXComponent=!0;const Upt={toc:[]},Vpt="wrapper";function qpt(t){let{components:e,...n}=t;return(0,s.kt)(Vpt,(0,p.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qpt.isMDXComponent=!0;const jpt={toc:[]},Ypt="wrapper";function Hpt(t){let{components:e,...n}=t;return(0,s.kt)(Ypt,(0,p.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]},$pt="wrapper";function Jpt(t){let{components:e,...n}=t;return(0,s.kt)($pt,(0,p.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Jpt.isMDXComponent=!0;const Kpt={toc:[]},trt="wrapper";function ert(t){let{components:e,...n}=t;return(0,s.kt)(trt,(0,p.Z)({},Kpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ert.isMDXComponent=!0;const nrt={toc:[]},ort="wrapper";function prt(t){let{components:e,...n}=t;return(0,s.kt)(ort,(0,p.Z)({},nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(t){let{components:e,...n}=t;return(0,s.kt)(srt,(0,p.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}crt.isMDXComponent=!0;const irt={toc:[]},art="wrapper";function lrt(t){let{components:e,...n}=t;return(0,s.kt)(art,(0,p.Z)({},irt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function drt(t){let{components:e,...n}=t;return(0,s.kt)(mrt,(0,p.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}drt.isMDXComponent=!0;const hrt={toc:[]},frt="wrapper";function krt(t){let{components:e,...n}=t;return(0,s.kt)(frt,(0,p.Z)({},hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}krt.isMDXComponent=!0;const yrt={toc:[]},Drt="wrapper";function Mrt(t){let{components:e,...n}=t;return(0,s.kt)(Drt,(0,p.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(t){let{components:e,...n}=t;return(0,s.kt)(_rt,(0,p.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wrt.isMDXComponent=!0;const Trt={toc:[]},grt="wrapper";function Crt(t){let{components:e,...n}=t;return(0,s.kt)(grt,(0,p.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Crt.isMDXComponent=!0;const xrt={toc:[]},vrt="wrapper";function Lrt(t){let{components:e,...n}=t;return(0,s.kt)(vrt,(0,p.Z)({},xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]},brt="wrapper";function Nrt(t){let{components:e,...n}=t;return(0,s.kt)(brt,(0,p.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Nrt.isMDXComponent=!0;const Art={toc:[]},zrt="wrapper";function Wrt(t){let{components:e,...n}=t;return(0,s.kt)(zrt,(0,p.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wrt.isMDXComponent=!0;const Irt={toc:[]},Rrt="wrapper";function Srt(t){let{components:e,...n}=t;return(0,s.kt)(Rrt,(0,p.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Srt.isMDXComponent=!0;const Prt={toc:[]},Ert="wrapper";function Ort(t){let{components:e,...n}=t;return(0,s.kt)(Ert,(0,p.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Ort.isMDXComponent=!0;const Grt={toc:[]},Frt="wrapper";function Brt(t){let{components:e,...n}=t;return(0,s.kt)(Frt,(0,p.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Brt.isMDXComponent=!0;const Urt={toc:[]},Vrt="wrapper";function qrt(t){let{components:e,...n}=t;return(0,s.kt)(Vrt,(0,p.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qrt.isMDXComponent=!0;const jrt={toc:[]},Yrt="wrapper";function Hrt(t){let{components:e,...n}=t;return(0,s.kt)(Yrt,(0,p.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Hrt.isMDXComponent=!0;const Qrt={toc:[]},$rt="wrapper";function Jrt(t){let{components:e,...n}=t;return(0,s.kt)($rt,(0,p.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Jrt.isMDXComponent=!0;const Krt={toc:[]},tst="wrapper";function est(t){let{components:e,...n}=t;return(0,s.kt)(tst,(0,p.Z)({},Krt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}est.isMDXComponent=!0;const nst={toc:[]},ost="wrapper";function pst(t){let{components:e,...n}=t;return(0,s.kt)(ost,(0,p.Z)({},nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(t){let{components:e,...n}=t;return(0,s.kt)(sst,(0,p.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cst.isMDXComponent=!0;const ist={toc:[]},ast="wrapper";function lst(t){let{components:e,...n}=t;return(0,s.kt)(ast,(0,p.Z)({},ist,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function dst(t){let{components:e,...n}=t;return(0,s.kt)(mst,(0,p.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dst.isMDXComponent=!0;const hst={toc:[]},fst="wrapper";function kst(t){let{components:e,...n}=t;return(0,s.kt)(fst,(0,p.Z)({},hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kst.isMDXComponent=!0;const yst={toc:[]},Dst="wrapper";function Mst(t){let{components:e,...n}=t;return(0,s.kt)(Dst,(0,p.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(t){let{components:e,...n}=t;return(0,s.kt)(_st,(0,p.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wst.isMDXComponent=!0;const Tst={toc:[]},gst="wrapper";function Cst(t){let{components:e,...n}=t;return(0,s.kt)(gst,(0,p.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Cst.isMDXComponent=!0;const xst={toc:[]},vst="wrapper";function Lst(t){let{components:e,...n}=t;return(0,s.kt)(vst,(0,p.Z)({},xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lst.isMDXComponent=!0;const Zst={toc:[]},bst="wrapper";function Nst(t){let{components:e,...n}=t;return(0,s.kt)(bst,(0,p.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Nst.isMDXComponent=!0;const Ast={toc:[]},zst="wrapper";function Wst(t){let{components:e,...n}=t;return(0,s.kt)(zst,(0,p.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Wst.isMDXComponent=!0;const Ist={toc:[]},Rst="wrapper";function Sst(t){let{components:e,...n}=t;return(0,s.kt)(Rst,(0,p.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Sst.isMDXComponent=!0;const Pst={toc:[]},Est="wrapper";function Ost(t){let{components:e,...n}=t;return(0,s.kt)(Est,(0,p.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ost.isMDXComponent=!0;const Gst={toc:[]},Fst="wrapper";function Bst(t){let{components:e,...n}=t;return(0,s.kt)(Fst,(0,p.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Bst.isMDXComponent=!0;const Ust={toc:[]},Vst="wrapper";function qst(t){let{components:e,...n}=t;return(0,s.kt)(Vst,(0,p.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qst.isMDXComponent=!0;const jst={toc:[]},Yst="wrapper";function Hst(t){let{components:e,...n}=t;return(0,s.kt)(Yst,(0,p.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Hst.isMDXComponent=!0;const Qst={toc:[]},$st="wrapper";function Jst(t){let{components:e,...n}=t;return(0,s.kt)($st,(0,p.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Jst.isMDXComponent=!0;const Kst={toc:[]},tct="wrapper";function ect(t){let{components:e,...n}=t;return(0,s.kt)(tct,(0,p.Z)({},Kst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ect.isMDXComponent=!0;const nct={toc:[]},oct="wrapper";function pct(t){let{components:e,...n}=t;return(0,s.kt)(oct,(0,p.Z)({},nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(t){let{components:e,...n}=t;return(0,s.kt)(sct,(0,p.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cct.isMDXComponent=!0;const ict={toc:[]},act="wrapper";function lct(t){let{components:e,...n}=t;return(0,s.kt)(act,(0,p.Z)({},ict,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function dct(t){let{components:e,...n}=t;return(0,s.kt)(mct,(0,p.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dct.isMDXComponent=!0;const hct={toc:[]},fct="wrapper";function kct(t){let{components:e,...n}=t;return(0,s.kt)(fct,(0,p.Z)({},hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}kct.isMDXComponent=!0;const yct={toc:[]},Dct="wrapper";function Mct(t){let{components:e,...n}=t;return(0,s.kt)(Dct,(0,p.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(t){let{components:e,...n}=t;return(0,s.kt)(_ct,(0,p.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wct.isMDXComponent=!0;const Tct={toc:[]},gct="wrapper";function Cct(t){let{components:e,...n}=t;return(0,s.kt)(gct,(0,p.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Cct.isMDXComponent=!0;const xct={toc:[]},vct="wrapper";function Lct(t){let{components:e,...n}=t;return(0,s.kt)(vct,(0,p.Z)({},xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Lct.isMDXComponent=!0;const Zct={toc:[]},bct="wrapper";function Nct(t){let{components:e,...n}=t;return(0,s.kt)(bct,(0,p.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Nct.isMDXComponent=!0;const Act={toc:[]},zct="wrapper";function Wct(t){let{components:e,...n}=t;return(0,s.kt)(zct,(0,p.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wct.isMDXComponent=!0;const Ict={toc:[]},Rct="wrapper";function Sct(t){let{components:e,...n}=t;return(0,s.kt)(Rct,(0,p.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Sct.isMDXComponent=!0;const Pct={toc:[]},Ect="wrapper";function Oct(t){let{components:e,...n}=t;return(0,s.kt)(Ect,(0,p.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Oct.isMDXComponent=!0;const Gct={toc:[]},Fct="wrapper";function Bct(t){let{components:e,...n}=t;return(0,s.kt)(Fct,(0,p.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Bct.isMDXComponent=!0;const Uct={toc:[]},Vct="wrapper";function qct(t){let{components:e,...n}=t;return(0,s.kt)(Vct,(0,p.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}qct.isMDXComponent=!0;const jct={toc:[]},Yct="wrapper";function Hct(t){let{components:e,...n}=t;return(0,s.kt)(Yct,(0,p.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hct.isMDXComponent=!0;const Qct={toc:[]},$ct="wrapper";function Jct(t){let{components:e,...n}=t;return(0,s.kt)($ct,(0,p.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Jct.isMDXComponent=!0;const Kct={toc:[]},tit="wrapper";function eit(t){let{components:e,...n}=t;return(0,s.kt)(tit,(0,p.Z)({},Kct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}eit.isMDXComponent=!0;const nit={toc:[]},oit="wrapper";function pit(t){let{components:e,...n}=t;return(0,s.kt)(oit,(0,p.Z)({},nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(t){let{components:e,...n}=t;return(0,s.kt)(sit,(0,p.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}cit.isMDXComponent=!0;const iit={toc:[]},ait="wrapper";function lit(t){let{components:e,...n}=t;return(0,s.kt)(ait,(0,p.Z)({},iit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function dit(t){let{components:e,...n}=t;return(0,s.kt)(mit,(0,p.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dit.isMDXComponent=!0;const hit={toc:[]},fit="wrapper";function kit(t){let{components:e,...n}=t;return(0,s.kt)(fit,(0,p.Z)({},hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}kit.isMDXComponent=!0;const yit={toc:[]},Dit="wrapper";function Mit(t){let{components:e,...n}=t;return(0,s.kt)(Dit,(0,p.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(t){let{components:e,...n}=t;return(0,s.kt)(_it,(0,p.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wit.isMDXComponent=!0;const Tit={toc:[]},git="wrapper";function Cit(t){let{components:e,...n}=t;return(0,s.kt)(git,(0,p.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Cit.isMDXComponent=!0;const xit={toc:[]},vit="wrapper";function Lit(t){let{components:e,...n}=t;return(0,s.kt)(vit,(0,p.Z)({},xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Lit.isMDXComponent=!0;const Zit={toc:[]},bit="wrapper";function Nit(t){let{components:e,...n}=t;return(0,s.kt)(bit,(0,p.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Nit.isMDXComponent=!0;const Ait={toc:[]},zit="wrapper";function Wit(t){let{components:e,...n}=t;return(0,s.kt)(zit,(0,p.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Wit.isMDXComponent=!0;const Iit={toc:[]},Rit="wrapper";function Sit(t){let{components:e,...n}=t;return(0,s.kt)(Rit,(0,p.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Sit.isMDXComponent=!0;const Pit={toc:[]},Eit="wrapper";function Oit(t){let{components:e,...n}=t;return(0,s.kt)(Eit,(0,p.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Oit.isMDXComponent=!0;const Git={toc:[]},Fit="wrapper";function Bit(t){let{components:e,...n}=t;return(0,s.kt)(Fit,(0,p.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Bit.isMDXComponent=!0;const Uit={toc:[]},Vit="wrapper";function qit(t){let{components:e,...n}=t;return(0,s.kt)(Vit,(0,p.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qit.isMDXComponent=!0;const jit={toc:[]},Yit="wrapper";function Hit(t){let{components:e,...n}=t;return(0,s.kt)(Yit,(0,p.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Hit.isMDXComponent=!0;const Qit={toc:[]},$it="wrapper";function Jit(t){let{components:e,...n}=t;return(0,s.kt)($it,(0,p.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Jit.isMDXComponent=!0;const Kit={toc:[]},tat="wrapper";function eat(t){let{components:e,...n}=t;return(0,s.kt)(tat,(0,p.Z)({},Kit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eat.isMDXComponent=!0;const nat={toc:[]},oat="wrapper";function pat(t){let{components:e,...n}=t;return(0,s.kt)(oat,(0,p.Z)({},nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(t){let{components:e,...n}=t;return(0,s.kt)(sat,(0,p.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cat.isMDXComponent=!0;const iat={toc:[]},aat="wrapper";function lat(t){let{components:e,...n}=t;return(0,s.kt)(aat,(0,p.Z)({},iat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function dat(t){let{components:e,...n}=t;return(0,s.kt)(mat,(0,p.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}dat.isMDXComponent=!0;const hat={toc:[]},fat="wrapper";function kat(t){let{components:e,...n}=t;return(0,s.kt)(fat,(0,p.Z)({},hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}kat.isMDXComponent=!0;const yat={toc:[]},Dat="wrapper";function Mat(t){let{components:e,...n}=t;return(0,s.kt)(Dat,(0,p.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(t){let{components:e,...n}=t;return(0,s.kt)(_at,(0,p.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wat.isMDXComponent=!0;const Tat={toc:[]},gat="wrapper";function Cat(t){let{components:e,...n}=t;return(0,s.kt)(gat,(0,p.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Cat.isMDXComponent=!0;const xat={toc:[]},vat="wrapper";function Lat(t){let{components:e,...n}=t;return(0,s.kt)(vat,(0,p.Z)({},xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Lat.isMDXComponent=!0;const Zat={toc:[]},bat="wrapper";function Nat(t){let{components:e,...n}=t;return(0,s.kt)(bat,(0,p.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Nat.isMDXComponent=!0;const Aat={toc:[]},zat="wrapper";function Wat(t){let{components:e,...n}=t;return(0,s.kt)(zat,(0,p.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Wat.isMDXComponent=!0;const Iat={toc:[]},Rat="wrapper";function Sat(t){let{components:e,...n}=t;return(0,s.kt)(Rat,(0,p.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sat.isMDXComponent=!0;const Pat={toc:[]},Eat="wrapper";function Oat(t){let{components:e,...n}=t;return(0,s.kt)(Eat,(0,p.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Oat.isMDXComponent=!0;const Gat={toc:[]},Fat="wrapper";function Bat(t){let{components:e,...n}=t;return(0,s.kt)(Fat,(0,p.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Bat.isMDXComponent=!0;const Uat={toc:[]},Vat="wrapper";function qat(t){let{components:e,...n}=t;return(0,s.kt)(Vat,(0,p.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}qat.isMDXComponent=!0;const jat={toc:[]},Yat="wrapper";function Hat(t){let{components:e,...n}=t;return(0,s.kt)(Yat,(0,p.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Hat.isMDXComponent=!0;const Qat={toc:[]},$at="wrapper";function Jat(t){let{components:e,...n}=t;return(0,s.kt)($at,(0,p.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Jat.isMDXComponent=!0;const Kat={toc:[]},tlt="wrapper";function elt(t){let{components:e,...n}=t;return(0,s.kt)(tlt,(0,p.Z)({},Kat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}elt.isMDXComponent=!0;const nlt={toc:[]},olt="wrapper";function plt(t){let{components:e,...n}=t;return(0,s.kt)(olt,(0,p.Z)({},nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(t){let{components:e,...n}=t;return(0,s.kt)(slt,(0,p.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}clt.isMDXComponent=!0;const ilt={toc:[]},alt="wrapper";function llt(t){let{components:e,...n}=t;return(0,s.kt)(alt,(0,p.Z)({},ilt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function dlt(t){let{components:e,...n}=t;return(0,s.kt)(mlt,(0,p.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dlt.isMDXComponent=!0;const hlt={toc:[]},flt="wrapper";function klt(t){let{components:e,...n}=t;return(0,s.kt)(flt,(0,p.Z)({},hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}klt.isMDXComponent=!0;const ylt={toc:[]},Dlt="wrapper";function Mlt(t){let{components:e,...n}=t;return(0,s.kt)(Dlt,(0,p.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(t){let{components:e,...n}=t;return(0,s.kt)(_lt,(0,p.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},glt="wrapper";function Clt(t){let{components:e,...n}=t;return(0,s.kt)(glt,(0,p.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Clt.isMDXComponent=!0;const xlt={toc:[]},vlt="wrapper";function Llt(t){let{components:e,...n}=t;return(0,s.kt)(vlt,(0,p.Z)({},xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Llt.isMDXComponent=!0;const Zlt={toc:[]},blt="wrapper";function Nlt(t){let{components:e,...n}=t;return(0,s.kt)(blt,(0,p.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Nlt.isMDXComponent=!0;const Alt={toc:[]},zlt="wrapper";function Wlt(t){let{components:e,...n}=t;return(0,s.kt)(zlt,(0,p.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wlt.isMDXComponent=!0;const Ilt={toc:[]},Rlt="wrapper";function Slt(t){let{components:e,...n}=t;return(0,s.kt)(Rlt,(0,p.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Slt.isMDXComponent=!0;const Plt={toc:[]},Elt="wrapper";function Olt(t){let{components:e,...n}=t;return(0,s.kt)(Elt,(0,p.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Olt.isMDXComponent=!0;const Glt={toc:[]},Flt="wrapper";function Blt(t){let{components:e,...n}=t;return(0,s.kt)(Flt,(0,p.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Blt.isMDXComponent=!0;const Ult={toc:[]},Vlt="wrapper";function qlt(t){let{components:e,...n}=t;return(0,s.kt)(Vlt,(0,p.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qlt.isMDXComponent=!0;const jlt={toc:[]},Ylt="wrapper";function Hlt(t){let{components:e,...n}=t;return(0,s.kt)(Ylt,(0,p.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]},$lt="wrapper";function Jlt(t){let{components:e,...n}=t;return(0,s.kt)($lt,(0,p.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Jlt.isMDXComponent=!0;const Klt={toc:[]},tut="wrapper";function eut(t){let{components:e,...n}=t;return(0,s.kt)(tut,(0,p.Z)({},Klt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eut.isMDXComponent=!0;const nut={toc:[]},out="wrapper";function put(t){let{components:e,...n}=t;return(0,s.kt)(out,(0,p.Z)({},nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(t){let{components:e,...n}=t;return(0,s.kt)(sut,(0,p.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cut.isMDXComponent=!0;const iut={toc:[]},aut="wrapper";function lut(t){let{components:e,...n}=t;return(0,s.kt)(aut,(0,p.Z)({},iut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function dut(t){let{components:e,...n}=t;return(0,s.kt)(mut,(0,p.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}dut.isMDXComponent=!0;const hut={toc:[]},fut="wrapper";function kut(t){let{components:e,...n}=t;return(0,s.kt)(fut,(0,p.Z)({},hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kut.isMDXComponent=!0;const yut={toc:[]},Dut="wrapper";function Mut(t){let{components:e,...n}=t;return(0,s.kt)(Dut,(0,p.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(t){let{components:e,...n}=t;return(0,s.kt)(_ut,(0,p.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wut.isMDXComponent=!0;const Tut={toc:[]},gut="wrapper";function Cut(t){let{components:e,...n}=t;return(0,s.kt)(gut,(0,p.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cut.isMDXComponent=!0;const xut={toc:[]},vut="wrapper";function Lut(t){let{components:e,...n}=t;return(0,s.kt)(vut,(0,p.Z)({},xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Lut.isMDXComponent=!0;const Zut={toc:[]},but="wrapper";function Nut(t){let{components:e,...n}=t;return(0,s.kt)(but,(0,p.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Nut.isMDXComponent=!0;const Aut={toc:[]},zut="wrapper";function Wut(t){let{components:e,...n}=t;return(0,s.kt)(zut,(0,p.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Wut.isMDXComponent=!0;const Iut={toc:[]},Rut="wrapper";function Sut(t){let{components:e,...n}=t;return(0,s.kt)(Rut,(0,p.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Sut.isMDXComponent=!0;const Put={toc:[]},Eut="wrapper";function Out(t){let{components:e,...n}=t;return(0,s.kt)(Eut,(0,p.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Out.isMDXComponent=!0;const Gut={toc:[]},Fut="wrapper";function But(t){let{components:e,...n}=t;return(0,s.kt)(Fut,(0,p.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}But.isMDXComponent=!0;const Uut={toc:[]},Vut="wrapper";function qut(t){let{components:e,...n}=t;return(0,s.kt)(Vut,(0,p.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qut.isMDXComponent=!0;const jut={toc:[]},Yut="wrapper";function Hut(t){let{components:e,...n}=t;return(0,s.kt)(Yut,(0,p.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Hut.isMDXComponent=!0;const Qut={toc:[]},$ut="wrapper";function Jut(t){let{components:e,...n}=t;return(0,s.kt)($ut,(0,p.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Jut.isMDXComponent=!0;const Kut={toc:[]},tmt="wrapper";function emt(t){let{components:e,...n}=t;return(0,s.kt)(tmt,(0,p.Z)({},Kut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}emt.isMDXComponent=!0;const nmt={toc:[]},omt="wrapper";function pmt(t){let{components:e,...n}=t;return(0,s.kt)(omt,(0,p.Z)({},nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(t){let{components:e,...n}=t;return(0,s.kt)(smt,(0,p.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}cmt.isMDXComponent=!0;const imt={toc:[]},amt="wrapper";function lmt(t){let{components:e,...n}=t;return(0,s.kt)(amt,(0,p.Z)({},imt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function dmt(t){let{components:e,...n}=t;return(0,s.kt)(mmt,(0,p.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}dmt.isMDXComponent=!0;const hmt={toc:[]},fmt="wrapper";function kmt(t){let{components:e,...n}=t;return(0,s.kt)(fmt,(0,p.Z)({},hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kmt.isMDXComponent=!0;const ymt={toc:[]},Dmt="wrapper";function Mmt(t){let{components:e,...n}=t;return(0,s.kt)(Dmt,(0,p.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(t){let{components:e,...n}=t;return(0,s.kt)(_mt,(0,p.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},gmt="wrapper";function Cmt(t){let{components:e,...n}=t;return(0,s.kt)(gmt,(0,p.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Cmt.isMDXComponent=!0;const xmt={toc:[]},vmt="wrapper";function Lmt(t){let{components:e,...n}=t;return(0,s.kt)(vmt,(0,p.Z)({},xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]},bmt="wrapper";function Nmt(t){let{components:e,...n}=t;return(0,s.kt)(bmt,(0,p.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Nmt.isMDXComponent=!0;const Amt={toc:[]},zmt="wrapper";function Wmt(t){let{components:e,...n}=t;return(0,s.kt)(zmt,(0,p.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Wmt.isMDXComponent=!0;const Imt={toc:[]},Rmt="wrapper";function Smt(t){let{components:e,...n}=t;return(0,s.kt)(Rmt,(0,p.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Smt.isMDXComponent=!0;const Pmt={toc:[]},Emt="wrapper";function Omt(t){let{components:e,...n}=t;return(0,s.kt)(Emt,(0,p.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Omt.isMDXComponent=!0;const Gmt={toc:[]},Fmt="wrapper";function Bmt(t){let{components:e,...n}=t;return(0,s.kt)(Fmt,(0,p.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Bmt.isMDXComponent=!0;const Umt={toc:[]},Vmt="wrapper";function qmt(t){let{components:e,...n}=t;return(0,s.kt)(Vmt,(0,p.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qmt.isMDXComponent=!0;const jmt={toc:[]},Ymt="wrapper";function Hmt(t){let{components:e,...n}=t;return(0,s.kt)(Ymt,(0,p.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Hmt.isMDXComponent=!0;const Qmt={toc:[]},$mt="wrapper";function Jmt(t){let{components:e,...n}=t;return(0,s.kt)($mt,(0,p.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Jmt.isMDXComponent=!0;const Kmt={toc:[]},tdt="wrapper";function edt(t){let{components:e,...n}=t;return(0,s.kt)(tdt,(0,p.Z)({},Kmt,n,{components:e,mdxType:"MDXLayout"}))}edt.isMDXComponent=!0;const ndt={toc:[]},odt="wrapper";function pdt(t){let{components:e,...n}=t;return(0,s.kt)(odt,(0,p.Z)({},ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(t){let{components:e,...n}=t;return(0,s.kt)(sdt,(0,p.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cdt.isMDXComponent=!0;const idt={toc:[]},adt="wrapper";function ldt(t){let{components:e,...n}=t;return(0,s.kt)(adt,(0,p.Z)({},idt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ddt(t){let{components:e,...n}=t;return(0,s.kt)(mdt,(0,p.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ddt.isMDXComponent=!0;const hdt={toc:[]},fdt="wrapper";function kdt(t){let{components:e,...n}=t;return(0,s.kt)(fdt,(0,p.Z)({},hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kdt.isMDXComponent=!0;const ydt={toc:[]},Ddt="wrapper";function Mdt(t){let{components:e,...n}=t;return(0,s.kt)(Ddt,(0,p.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(t){let{components:e,...n}=t;return(0,s.kt)(_dt,(0,p.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},gdt="wrapper";function Cdt(t){let{components:e,...n}=t;return(0,s.kt)(gdt,(0,p.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cdt.isMDXComponent=!0;const xdt={toc:[]},vdt="wrapper";function Ldt(t){let{components:e,...n}=t;return(0,s.kt)(vdt,(0,p.Z)({},xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]},bdt="wrapper";function Ndt(t){let{components:e,...n}=t;return(0,s.kt)(bdt,(0,p.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ndt.isMDXComponent=!0;const Adt={toc:[]},zdt="wrapper";function Wdt(t){let{components:e,...n}=t;return(0,s.kt)(zdt,(0,p.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wdt.isMDXComponent=!0;const Idt={toc:[]},Rdt="wrapper";function Sdt(t){let{components:e,...n}=t;return(0,s.kt)(Rdt,(0,p.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sdt.isMDXComponent=!0;const Pdt={toc:[]},Edt="wrapper";function Odt(t){let{components:e,...n}=t;return(0,s.kt)(Edt,(0,p.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Odt.isMDXComponent=!0;const Gdt={toc:[]},Fdt="wrapper";function Bdt(t){let{components:e,...n}=t;return(0,s.kt)(Fdt,(0,p.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bdt.isMDXComponent=!0;const Udt={toc:[]},Vdt="wrapper";function qdt(t){let{components:e,...n}=t;return(0,s.kt)(Vdt,(0,p.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qdt.isMDXComponent=!0;const jdt={toc:[]},Ydt="wrapper";function Hdt(t){let{components:e,...n}=t;return(0,s.kt)(Ydt,(0,p.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]},$dt="wrapper";function Jdt(t){let{components:e,...n}=t;return(0,s.kt)($dt,(0,p.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jdt.isMDXComponent=!0;const Kdt={toc:[]},tht="wrapper";function eht(t){let{components:e,...n}=t;return(0,s.kt)(tht,(0,p.Z)({},Kdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eht.isMDXComponent=!0;const nht={toc:[]},oht="wrapper";function pht(t){let{components:e,...n}=t;return(0,s.kt)(oht,(0,p.Z)({},nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(t){let{components:e,...n}=t;return(0,s.kt)(sht,(0,p.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cht.isMDXComponent=!0;const iht={toc:[]},aht="wrapper";function lht(t){let{components:e,...n}=t;return(0,s.kt)(aht,(0,p.Z)({},iht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function dht(t){let{components:e,...n}=t;return(0,s.kt)(mht,(0,p.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dht.isMDXComponent=!0;const hht={toc:[]},fht="wrapper";function kht(t){let{components:e,...n}=t;return(0,s.kt)(fht,(0,p.Z)({},hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}kht.isMDXComponent=!0;const yht={toc:[]},Dht="wrapper";function Mht(t){let{components:e,...n}=t;return(0,s.kt)(Dht,(0,p.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(t){let{components:e,...n}=t;return(0,s.kt)(_ht,(0,p.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wht.isMDXComponent=!0;const Tht={toc:[]},ght="wrapper";function Cht(t){let{components:e,...n}=t;return(0,s.kt)(ght,(0,p.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Cht.isMDXComponent=!0;const xht={toc:[]},vht="wrapper";function Lht(t){let{components:e,...n}=t;return(0,s.kt)(vht,(0,p.Z)({},xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Lht.isMDXComponent=!0;const Zht={toc:[]},bht="wrapper";function Nht(t){let{components:e,...n}=t;return(0,s.kt)(bht,(0,p.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Nht.isMDXComponent=!0;const Aht={toc:[]},zht="wrapper";function Wht(t){let{components:e,...n}=t;return(0,s.kt)(zht,(0,p.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Wht.isMDXComponent=!0;const Iht={toc:[]},Rht="wrapper";function Sht(t){let{components:e,...n}=t;return(0,s.kt)(Rht,(0,p.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Sht.isMDXComponent=!0;const Pht={toc:[]},Eht="wrapper";function Oht(t){let{components:e,...n}=t;return(0,s.kt)(Eht,(0,p.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Oht.isMDXComponent=!0;const Ght={toc:[]},Fht="wrapper";function Bht(t){let{components:e,...n}=t;return(0,s.kt)(Fht,(0,p.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Bht.isMDXComponent=!0;const Uht={toc:[]},Vht="wrapper";function qht(t){let{components:e,...n}=t;return(0,s.kt)(Vht,(0,p.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qht.isMDXComponent=!0;const jht={toc:[]},Yht="wrapper";function Hht(t){let{components:e,...n}=t;return(0,s.kt)(Yht,(0,p.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Hht.isMDXComponent=!0;const Qht={toc:[]},$ht="wrapper";function Jht(t){let{components:e,...n}=t;return(0,s.kt)($ht,(0,p.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Jht.isMDXComponent=!0;const Kht={toc:[]},tft="wrapper";function eft(t){let{components:e,...n}=t;return(0,s.kt)(tft,(0,p.Z)({},Kht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}eft.isMDXComponent=!0;const nft={toc:[]},oft="wrapper";function pft(t){let{components:e,...n}=t;return(0,s.kt)(oft,(0,p.Z)({},nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(t){let{components:e,...n}=t;return(0,s.kt)(sft,(0,p.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cft.isMDXComponent=!0;const ift={toc:[]},aft="wrapper";function lft(t){let{components:e,...n}=t;return(0,s.kt)(aft,(0,p.Z)({},ift,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function dft(t){let{components:e,...n}=t;return(0,s.kt)(mft,(0,p.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}dft.isMDXComponent=!0;const hft={toc:[]},fft="wrapper";function kft(t){let{components:e,...n}=t;return(0,s.kt)(fft,(0,p.Z)({},hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kft.isMDXComponent=!0;const yft={toc:[]},Dft="wrapper";function Mft(t){let{components:e,...n}=t;return(0,s.kt)(Dft,(0,p.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(t){let{components:e,...n}=t;return(0,s.kt)(_ft,(0,p.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wft.isMDXComponent=!0;const Tft={toc:[]},gft="wrapper";function Cft(t){let{components:e,...n}=t;return(0,s.kt)(gft,(0,p.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Cft.isMDXComponent=!0;const xft={toc:[]},vft="wrapper";function Lft(t){let{components:e,...n}=t;return(0,s.kt)(vft,(0,p.Z)({},xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Lft.isMDXComponent=!0;const Zft={toc:[]},bft="wrapper";function Nft(t){let{components:e,...n}=t;return(0,s.kt)(bft,(0,p.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nft.isMDXComponent=!0;const Aft={toc:[]},zft="wrapper";function Wft(t){let{components:e,...n}=t;return(0,s.kt)(zft,(0,p.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wft.isMDXComponent=!0;const Ift={toc:[]},Rft="wrapper";function Sft(t){let{components:e,...n}=t;return(0,s.kt)(Rft,(0,p.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Sft.isMDXComponent=!0;const Pft={toc:[]},Eft="wrapper";function Oft(t){let{components:e,...n}=t;return(0,s.kt)(Eft,(0,p.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Oft.isMDXComponent=!0;const Gft={toc:[]},Fft="wrapper";function Bft(t){let{components:e,...n}=t;return(0,s.kt)(Fft,(0,p.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Bft.isMDXComponent=!0;const Uft={toc:[]},Vft="wrapper";function qft(t){let{components:e,...n}=t;return(0,s.kt)(Vft,(0,p.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qft.isMDXComponent=!0;const jft={toc:[]},Yft="wrapper";function Hft(t){let{components:e,...n}=t;return(0,s.kt)(Yft,(0,p.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Hft.isMDXComponent=!0;const Qft={toc:[]},$ft="wrapper";function Jft(t){let{components:e,...n}=t;return(0,s.kt)($ft,(0,p.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Jft.isMDXComponent=!0;const Kft={toc:[]},tkt="wrapper";function ekt(t){let{components:e,...n}=t;return(0,s.kt)(tkt,(0,p.Z)({},Kft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ekt.isMDXComponent=!0;const nkt={toc:[]},okt="wrapper";function pkt(t){let{components:e,...n}=t;return(0,s.kt)(okt,(0,p.Z)({},nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(t){let{components:e,...n}=t;return(0,s.kt)(skt,(0,p.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ckt.isMDXComponent=!0;const ikt={toc:[]},akt="wrapper";function lkt(t){let{components:e,...n}=t;return(0,s.kt)(akt,(0,p.Z)({},ikt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function dkt(t){let{components:e,...n}=t;return(0,s.kt)(mkt,(0,p.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dkt.isMDXComponent=!0;const hkt={toc:[]},fkt="wrapper";function kkt(t){let{components:e,...n}=t;return(0,s.kt)(fkt,(0,p.Z)({},hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kkt.isMDXComponent=!0;const ykt={toc:[]},Dkt="wrapper";function Mkt(t){let{components:e,...n}=t;return(0,s.kt)(Dkt,(0,p.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(t){let{components:e,...n}=t;return(0,s.kt)(_kt,(0,p.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},gkt="wrapper";function Ckt(t){let{components:e,...n}=t;return(0,s.kt)(gkt,(0,p.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ckt.isMDXComponent=!0;const xkt={toc:[]},vkt="wrapper";function Lkt(t){let{components:e,...n}=t;return(0,s.kt)(vkt,(0,p.Z)({},xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]},bkt="wrapper";function Nkt(t){let{components:e,...n}=t;return(0,s.kt)(bkt,(0,p.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nkt.isMDXComponent=!0;const Akt={toc:[]},zkt="wrapper";function Wkt(t){let{components:e,...n}=t;return(0,s.kt)(zkt,(0,p.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wkt.isMDXComponent=!0;const Ikt={toc:[]},Rkt="wrapper";function Skt(t){let{components:e,...n}=t;return(0,s.kt)(Rkt,(0,p.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Skt.isMDXComponent=!0;const Pkt={toc:[]},Ekt="wrapper";function Okt(t){let{components:e,...n}=t;return(0,s.kt)(Ekt,(0,p.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Okt.isMDXComponent=!0;const Gkt={toc:[]},Fkt="wrapper";function Bkt(t){let{components:e,...n}=t;return(0,s.kt)(Fkt,(0,p.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bkt.isMDXComponent=!0;const Ukt={toc:[]},Vkt="wrapper";function qkt(t){let{components:e,...n}=t;return(0,s.kt)(Vkt,(0,p.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qkt.isMDXComponent=!0;const jkt={toc:[]},Ykt="wrapper";function Hkt(t){let{components:e,...n}=t;return(0,s.kt)(Ykt,(0,p.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]},$kt="wrapper";function Jkt(t){let{components:e,...n}=t;return(0,s.kt)($kt,(0,p.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Jkt.isMDXComponent=!0;const Kkt={toc:[]},tyt="wrapper";function eyt(t){let{components:e,...n}=t;return(0,s.kt)(tyt,(0,p.Z)({},Kkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}eyt.isMDXComponent=!0;const nyt={toc:[]},oyt="wrapper";function pyt(t){let{components:e,...n}=t;return(0,s.kt)(oyt,(0,p.Z)({},nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(t){let{components:e,...n}=t;return(0,s.kt)(syt,(0,p.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}cyt.isMDXComponent=!0;const iyt={toc:[]},ayt="wrapper";function lyt(t){let{components:e,...n}=t;return(0,s.kt)(ayt,(0,p.Z)({},iyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function dyt(t){let{components:e,...n}=t;return(0,s.kt)(myt,(0,p.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}dyt.isMDXComponent=!0;const hyt={toc:[]},fyt="wrapper";function kyt(t){let{components:e,...n}=t;return(0,s.kt)(fyt,(0,p.Z)({},hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kyt.isMDXComponent=!0;const yyt={toc:[]},Dyt="wrapper";function Myt(t){let{components:e,...n}=t;return(0,s.kt)(Dyt,(0,p.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(t){let{components:e,...n}=t;return(0,s.kt)(_yt,(0,p.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},gyt="wrapper";function Cyt(t){let{components:e,...n}=t;return(0,s.kt)(gyt,(0,p.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Cyt.isMDXComponent=!0;const xyt={toc:[]},vyt="wrapper";function Lyt(t){let{components:e,...n}=t;return(0,s.kt)(vyt,(0,p.Z)({},xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]},byt="wrapper";function Nyt(t){let{components:e,...n}=t;return(0,s.kt)(byt,(0,p.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Nyt.isMDXComponent=!0;const Ayt={toc:[]},zyt="wrapper";function Wyt(t){let{components:e,...n}=t;return(0,s.kt)(zyt,(0,p.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wyt.isMDXComponent=!0;const Iyt={toc:[]},Ryt="wrapper";function Syt(t){let{components:e,...n}=t;return(0,s.kt)(Ryt,(0,p.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Syt.isMDXComponent=!0;const Pyt={toc:[]},Eyt="wrapper";function Oyt(t){let{components:e,...n}=t;return(0,s.kt)(Eyt,(0,p.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Oyt.isMDXComponent=!0;const Gyt={toc:[]},Fyt="wrapper";function Byt(t){let{components:e,...n}=t;return(0,s.kt)(Fyt,(0,p.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Byt.isMDXComponent=!0;const Uyt={toc:[]},Vyt="wrapper";function qyt(t){let{components:e,...n}=t;return(0,s.kt)(Vyt,(0,p.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qyt.isMDXComponent=!0;const jyt={toc:[]},Yyt="wrapper";function Hyt(t){let{components:e,...n}=t;return(0,s.kt)(Yyt,(0,p.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Hyt.isMDXComponent=!0;const Qyt={toc:[]},$yt="wrapper";function Jyt(t){let{components:e,...n}=t;return(0,s.kt)($yt,(0,p.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Jyt.isMDXComponent=!0;const Kyt={toc:[]},tDt="wrapper";function eDt(t){let{components:e,...n}=t;return(0,s.kt)(tDt,(0,p.Z)({},Kyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eDt.isMDXComponent=!0;const nDt={toc:[]},oDt="wrapper";function pDt(t){let{components:e,...n}=t;return(0,s.kt)(oDt,(0,p.Z)({},nDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(t){let{components:e,...n}=t;return(0,s.kt)(sDt,(0,p.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cDt.isMDXComponent=!0;const iDt={toc:[]},aDt="wrapper";function lDt(t){let{components:e,...n}=t;return(0,s.kt)(aDt,(0,p.Z)({},iDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function dDt(t){let{components:e,...n}=t;return(0,s.kt)(mDt,(0,p.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dDt.isMDXComponent=!0;const hDt={toc:[]},fDt="wrapper";function kDt(t){let{components:e,...n}=t;return(0,s.kt)(fDt,(0,p.Z)({},hDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kDt.isMDXComponent=!0;const yDt={toc:[]},DDt="wrapper";function MDt(t){let{components:e,...n}=t;return(0,s.kt)(DDt,(0,p.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(t){let{components:e,...n}=t;return(0,s.kt)(_Dt,(0,p.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wDt.isMDXComponent=!0;const TDt={toc:[]},gDt="wrapper";function CDt(t){let{components:e,...n}=t;return(0,s.kt)(gDt,(0,p.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}CDt.isMDXComponent=!0;const xDt={toc:[]},vDt="wrapper";function LDt(t){let{components:e,...n}=t;return(0,s.kt)(vDt,(0,p.Z)({},xDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LDt.isMDXComponent=!0;const ZDt={toc:[]},bDt="wrapper";function NDt(t){let{components:e,...n}=t;return(0,s.kt)(bDt,(0,p.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NDt.isMDXComponent=!0;const ADt={toc:[]},zDt="wrapper";function WDt(t){let{components:e,...n}=t;return(0,s.kt)(zDt,(0,p.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WDt.isMDXComponent=!0;const IDt={toc:[]},RDt="wrapper";function SDt(t){let{components:e,...n}=t;return(0,s.kt)(RDt,(0,p.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}SDt.isMDXComponent=!0;const PDt={toc:[]},EDt="wrapper";function ODt(t){let{components:e,...n}=t;return(0,s.kt)(EDt,(0,p.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ODt.isMDXComponent=!0;const GDt={toc:[]},FDt="wrapper";function BDt(t){let{components:e,...n}=t;return(0,s.kt)(FDt,(0,p.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}BDt.isMDXComponent=!0;const UDt={toc:[]},VDt="wrapper";function qDt(t){let{components:e,...n}=t;return(0,s.kt)(VDt,(0,p.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qDt.isMDXComponent=!0;const jDt={toc:[]},YDt="wrapper";function HDt(t){let{components:e,...n}=t;return(0,s.kt)(YDt,(0,p.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}HDt.isMDXComponent=!0;const QDt={toc:[]},$Dt="wrapper";function JDt(t){let{components:e,...n}=t;return(0,s.kt)($Dt,(0,p.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}JDt.isMDXComponent=!0;const KDt={toc:[]},tMt="wrapper";function eMt(t){let{components:e,...n}=t;return(0,s.kt)(tMt,(0,p.Z)({},KDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}eMt.isMDXComponent=!0;const nMt={toc:[]},oMt="wrapper";function pMt(t){let{components:e,...n}=t;return(0,s.kt)(oMt,(0,p.Z)({},nMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(t){let{components:e,...n}=t;return(0,s.kt)(sMt,(0,p.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cMt.isMDXComponent=!0;const iMt={toc:[]},aMt="wrapper";function lMt(t){let{components:e,...n}=t;return(0,s.kt)(aMt,(0,p.Z)({},iMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function dMt(t){let{components:e,...n}=t;return(0,s.kt)(mMt,(0,p.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dMt.isMDXComponent=!0;const hMt={toc:[]},fMt="wrapper";function kMt(t){let{components:e,...n}=t;return(0,s.kt)(fMt,(0,p.Z)({},hMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}kMt.isMDXComponent=!0;const yMt={toc:[]},DMt="wrapper";function MMt(t){let{components:e,...n}=t;return(0,s.kt)(DMt,(0,p.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(t){let{components:e,...n}=t;return(0,s.kt)(_Mt,(0,p.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wMt.isMDXComponent=!0;const TMt={toc:[]},gMt="wrapper";function CMt(t){let{components:e,...n}=t;return(0,s.kt)(gMt,(0,p.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}CMt.isMDXComponent=!0;const xMt={toc:[]},vMt="wrapper";function LMt(t){let{components:e,...n}=t;return(0,s.kt)(vMt,(0,p.Z)({},xMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}LMt.isMDXComponent=!0;const ZMt={toc:[]},bMt="wrapper";function NMt(t){let{components:e,...n}=t;return(0,s.kt)(bMt,(0,p.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}NMt.isMDXComponent=!0;const AMt={toc:[]},zMt="wrapper";function WMt(t){let{components:e,...n}=t;return(0,s.kt)(zMt,(0,p.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WMt.isMDXComponent=!0;const IMt={toc:[]},RMt="wrapper";function SMt(t){let{components:e,...n}=t;return(0,s.kt)(RMt,(0,p.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}SMt.isMDXComponent=!0;const PMt={toc:[]},EMt="wrapper";function OMt(t){let{components:e,...n}=t;return(0,s.kt)(EMt,(0,p.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}OMt.isMDXComponent=!0;const GMt={toc:[]},FMt="wrapper";function BMt(t){let{components:e,...n}=t;return(0,s.kt)(FMt,(0,p.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}BMt.isMDXComponent=!0;const UMt={toc:[]},VMt="wrapper";function qMt(t){let{components:e,...n}=t;return(0,s.kt)(VMt,(0,p.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}qMt.isMDXComponent=!0;const jMt={toc:[]},YMt="wrapper";function HMt(t){let{components:e,...n}=t;return(0,s.kt)(YMt,(0,p.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HMt.isMDXComponent=!0;const QMt={toc:[]},$Mt="wrapper";function JMt(t){let{components:e,...n}=t;return(0,s.kt)($Mt,(0,p.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}JMt.isMDXComponent=!0;const KMt={toc:[]},tXt="wrapper";function eXt(t){let{components:e,...n}=t;return(0,s.kt)(tXt,(0,p.Z)({},KMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}eXt.isMDXComponent=!0;const nXt={toc:[]},oXt="wrapper";function pXt(t){let{components:e,...n}=t;return(0,s.kt)(oXt,(0,p.Z)({},nXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(t){let{components:e,...n}=t;return(0,s.kt)(sXt,(0,p.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}cXt.isMDXComponent=!0;const iXt={toc:[]},aXt="wrapper";function lXt(t){let{components:e,...n}=t;return(0,s.kt)(aXt,(0,p.Z)({},iXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function dXt(t){let{components:e,...n}=t;return(0,s.kt)(mXt,(0,p.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dXt.isMDXComponent=!0;const hXt={toc:[]},fXt="wrapper";function kXt(t){let{components:e,...n}=t;return(0,s.kt)(fXt,(0,p.Z)({},hXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}kXt.isMDXComponent=!0;const yXt={toc:[]},DXt="wrapper";function MXt(t){let{components:e,...n}=t;return(0,s.kt)(DXt,(0,p.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(t){let{components:e,...n}=t;return(0,s.kt)(_Xt,(0,p.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wXt.isMDXComponent=!0;const TXt={toc:[]},gXt="wrapper";function CXt(t){let{components:e,...n}=t;return(0,s.kt)(gXt,(0,p.Z)({},TXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}CXt.isMDXComponent=!0;const xXt={toc:[]},vXt="wrapper";function LXt(t){let{components:e,...n}=t;return(0,s.kt)(vXt,(0,p.Z)({},xXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}LXt.isMDXComponent=!0;const ZXt={toc:[]},bXt="wrapper";function NXt(t){let{components:e,...n}=t;return(0,s.kt)(bXt,(0,p.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}NXt.isMDXComponent=!0;const AXt={toc:[]},zXt="wrapper";function WXt(t){let{components:e,...n}=t;return(0,s.kt)(zXt,(0,p.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}WXt.isMDXComponent=!0;const IXt={toc:[]},RXt="wrapper";function SXt(t){let{components:e,...n}=t;return(0,s.kt)(RXt,(0,p.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SXt.isMDXComponent=!0;const PXt={toc:[]},EXt="wrapper";function OXt(t){let{components:e,...n}=t;return(0,s.kt)(EXt,(0,p.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}OXt.isMDXComponent=!0;const GXt={toc:[]},FXt="wrapper";function BXt(t){let{components:e,...n}=t;return(0,s.kt)(FXt,(0,p.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}BXt.isMDXComponent=!0;const UXt={toc:[]},VXt="wrapper";function qXt(t){let{components:e,...n}=t;return(0,s.kt)(VXt,(0,p.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qXt.isMDXComponent=!0;const jXt={toc:[]},YXt="wrapper";function HXt(t){let{components:e,...n}=t;return(0,s.kt)(YXt,(0,p.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}HXt.isMDXComponent=!0;const QXt={toc:[]},$Xt="wrapper";function JXt(t){let{components:e,...n}=t;return(0,s.kt)($Xt,(0,p.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}JXt.isMDXComponent=!0;const KXt={toc:[]},t_t="wrapper";function e_t(t){let{components:e,...n}=t;return(0,s.kt)(t_t,(0,p.Z)({},KXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}e_t.isMDXComponent=!0;const n_t={toc:[]},o_t="wrapper";function p_t(t){let{components:e,...n}=t;return(0,s.kt)(o_t,(0,p.Z)({},n_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(t){let{components:e,...n}=t;return(0,s.kt)(s_t,(0,p.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}c_t.isMDXComponent=!0;const i_t={toc:[]},a_t="wrapper";function l_t(t){let{components:e,...n}=t;return(0,s.kt)(a_t,(0,p.Z)({},i_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function d_t(t){let{components:e,...n}=t;return(0,s.kt)(m_t,(0,p.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}d_t.isMDXComponent=!0;const h_t={toc:[]},f_t="wrapper";function k_t(t){let{components:e,...n}=t;return(0,s.kt)(f_t,(0,p.Z)({},h_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}k_t.isMDXComponent=!0;const y_t={toc:[]},D_t="wrapper";function M_t(t){let{components:e,...n}=t;return(0,s.kt)(D_t,(0,p.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(t){let{components:e,...n}=t;return(0,s.kt)(__t,(0,p.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w_t.isMDXComponent=!0;const T_t={toc:[]},g_t="wrapper";function C_t(t){let{components:e,...n}=t;return(0,s.kt)(g_t,(0,p.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}C_t.isMDXComponent=!0;const x_t={toc:[]},v_t="wrapper";function L_t(t){let{components:e,...n}=t;return(0,s.kt)(v_t,(0,p.Z)({},x_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L_t.isMDXComponent=!0;const Z_t={toc:[]},b_t="wrapper";function N_t(t){let{components:e,...n}=t;return(0,s.kt)(b_t,(0,p.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}N_t.isMDXComponent=!0;const A_t={toc:[]},z_t="wrapper";function W_t(t){let{components:e,...n}=t;return(0,s.kt)(z_t,(0,p.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}W_t.isMDXComponent=!0;const I_t={toc:[]},R_t="wrapper";function S_t(t){let{components:e,...n}=t;return(0,s.kt)(R_t,(0,p.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}S_t.isMDXComponent=!0;const P_t={toc:[]},E_t="wrapper";function O_t(t){let{components:e,...n}=t;return(0,s.kt)(E_t,(0,p.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}O_t.isMDXComponent=!0;const G_t={toc:[]},F_t="wrapper";function B_t(t){let{components:e,...n}=t;return(0,s.kt)(F_t,(0,p.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}B_t.isMDXComponent=!0;const U_t={toc:[]},V_t="wrapper";function q_t(t){let{components:e,...n}=t;return(0,s.kt)(V_t,(0,p.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}q_t.isMDXComponent=!0;const j_t={toc:[]},Y_t="wrapper";function H_t(t){let{components:e,...n}=t;return(0,s.kt)(Y_t,(0,p.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}H_t.isMDXComponent=!0;const Q_t={toc:[]},$_t="wrapper";function J_t(t){let{components:e,...n}=t;return(0,s.kt)($_t,(0,p.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}J_t.isMDXComponent=!0;const K_t={toc:[]},twt="wrapper";function ewt(t){let{components:e,...n}=t;return(0,s.kt)(twt,(0,p.Z)({},K_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ewt.isMDXComponent=!0;const nwt={toc:[]},owt="wrapper";function pwt(t){let{components:e,...n}=t;return(0,s.kt)(owt,(0,p.Z)({},nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(t){let{components:e,...n}=t;return(0,s.kt)(swt,(0,p.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cwt.isMDXComponent=!0;const iwt={toc:[]},awt="wrapper";function lwt(t){let{components:e,...n}=t;return(0,s.kt)(awt,(0,p.Z)({},iwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function dwt(t){let{components:e,...n}=t;return(0,s.kt)(mwt,(0,p.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dwt.isMDXComponent=!0;const hwt={toc:[]},fwt="wrapper";function kwt(t){let{components:e,...n}=t;return(0,s.kt)(fwt,(0,p.Z)({},hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kwt.isMDXComponent=!0;const ywt={toc:[]},Dwt="wrapper";function Mwt(t){let{components:e,...n}=t;return(0,s.kt)(Dwt,(0,p.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(t){let{components:e,...n}=t;return(0,s.kt)(_wt,(0,p.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wwt.isMDXComponent=!0;const Twt={toc:[]},gwt="wrapper";function Cwt(t){let{components:e,...n}=t;return(0,s.kt)(gwt,(0,p.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Cwt.isMDXComponent=!0;const xwt={toc:[]},vwt="wrapper";function Lwt(t){let{components:e,...n}=t;return(0,s.kt)(vwt,(0,p.Z)({},xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]},bwt="wrapper";function Nwt(t){let{components:e,...n}=t;return(0,s.kt)(bwt,(0,p.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Nwt.isMDXComponent=!0;const Awt={toc:[]},zwt="wrapper";function Wwt(t){let{components:e,...n}=t;return(0,s.kt)(zwt,(0,p.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wwt.isMDXComponent=!0;const Iwt={toc:[]},Rwt="wrapper";function Swt(t){let{components:e,...n}=t;return(0,s.kt)(Rwt,(0,p.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Swt.isMDXComponent=!0;const Pwt={toc:[]},Ewt="wrapper";function Owt(t){let{components:e,...n}=t;return(0,s.kt)(Ewt,(0,p.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Owt.isMDXComponent=!0;const Gwt={toc:[]},Fwt="wrapper";function Bwt(t){let{components:e,...n}=t;return(0,s.kt)(Fwt,(0,p.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bwt.isMDXComponent=!0;const Uwt={toc:[]},Vwt="wrapper";function qwt(t){let{components:e,...n}=t;return(0,s.kt)(Vwt,(0,p.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qwt.isMDXComponent=!0;const jwt={toc:[]},Ywt="wrapper";function Hwt(t){let{components:e,...n}=t;return(0,s.kt)(Ywt,(0,p.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]},$wt="wrapper";function Jwt(t){let{components:e,...n}=t;return(0,s.kt)($wt,(0,p.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Jwt.isMDXComponent=!0;const Kwt={toc:[]},tTt="wrapper";function eTt(t){let{components:e,...n}=t;return(0,s.kt)(tTt,(0,p.Z)({},Kwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eTt.isMDXComponent=!0;const nTt={toc:[]},oTt="wrapper";function pTt(t){let{components:e,...n}=t;return(0,s.kt)(oTt,(0,p.Z)({},nTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(t){let{components:e,...n}=t;return(0,s.kt)(sTt,(0,p.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}cTt.isMDXComponent=!0;const iTt={toc:[]},aTt="wrapper";function lTt(t){let{components:e,...n}=t;return(0,s.kt)(aTt,(0,p.Z)({},iTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function dTt(t){let{components:e,...n}=t;return(0,s.kt)(mTt,(0,p.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dTt.isMDXComponent=!0;const hTt={toc:[]},fTt="wrapper";function kTt(t){let{components:e,...n}=t;return(0,s.kt)(fTt,(0,p.Z)({},hTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kTt.isMDXComponent=!0;const yTt={toc:[]},DTt="wrapper";function MTt(t){let{components:e,...n}=t;return(0,s.kt)(DTt,(0,p.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(t){let{components:e,...n}=t;return(0,s.kt)(_Tt,(0,p.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wTt.isMDXComponent=!0;const TTt={toc:[]},gTt="wrapper";function CTt(t){let{components:e,...n}=t;return(0,s.kt)(gTt,(0,p.Z)({},TTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}CTt.isMDXComponent=!0;const xTt={toc:[]},vTt="wrapper";function LTt(t){let{components:e,...n}=t;return(0,s.kt)(vTt,(0,p.Z)({},xTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}LTt.isMDXComponent=!0;const ZTt={toc:[]},bTt="wrapper";function NTt(t){let{components:e,...n}=t;return(0,s.kt)(bTt,(0,p.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}NTt.isMDXComponent=!0;const ATt={toc:[]},zTt="wrapper";function WTt(t){let{components:e,...n}=t;return(0,s.kt)(zTt,(0,p.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}WTt.isMDXComponent=!0;const ITt={toc:[]},RTt="wrapper";function STt(t){let{components:e,...n}=t;return(0,s.kt)(RTt,(0,p.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}STt.isMDXComponent=!0;const PTt={toc:[]},ETt="wrapper";function OTt(t){let{components:e,...n}=t;return(0,s.kt)(ETt,(0,p.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}OTt.isMDXComponent=!0;const GTt={toc:[]},FTt="wrapper";function BTt(t){let{components:e,...n}=t;return(0,s.kt)(FTt,(0,p.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}BTt.isMDXComponent=!0;const UTt={toc:[]},VTt="wrapper";function qTt(t){let{components:e,...n}=t;return(0,s.kt)(VTt,(0,p.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}qTt.isMDXComponent=!0;const jTt={toc:[]},YTt="wrapper";function HTt(t){let{components:e,...n}=t;return(0,s.kt)(YTt,(0,p.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}HTt.isMDXComponent=!0;const QTt={toc:[]},$Tt="wrapper";function JTt(t){let{components:e,...n}=t;return(0,s.kt)($Tt,(0,p.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JTt.isMDXComponent=!0;const KTt={toc:[]},tgt="wrapper";function egt(t){let{components:e,...n}=t;return(0,s.kt)(tgt,(0,p.Z)({},KTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}egt.isMDXComponent=!0;const ngt={toc:[]},ogt="wrapper";function pgt(t){let{components:e,...n}=t;return(0,s.kt)(ogt,(0,p.Z)({},ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(t){let{components:e,...n}=t;return(0,s.kt)(sgt,(0,p.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}cgt.isMDXComponent=!0;const igt={toc:[]},agt="wrapper";function lgt(t){let{components:e,...n}=t;return(0,s.kt)(agt,(0,p.Z)({},igt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function dgt(t){let{components:e,...n}=t;return(0,s.kt)(mgt,(0,p.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}dgt.isMDXComponent=!0;const hgt={toc:[]},fgt="wrapper";function kgt(t){let{components:e,...n}=t;return(0,s.kt)(fgt,(0,p.Z)({},hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kgt.isMDXComponent=!0;const ygt={toc:[]},Dgt="wrapper";function Mgt(t){let{components:e,...n}=t;return(0,s.kt)(Dgt,(0,p.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(t){let{components:e,...n}=t;return(0,s.kt)(_gt,(0,p.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wgt.isMDXComponent=!0;const Tgt={toc:[]},ggt="wrapper";function Cgt(t){let{components:e,...n}=t;return(0,s.kt)(ggt,(0,p.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Cgt.isMDXComponent=!0;const xgt={toc:[]},vgt="wrapper";function Lgt(t){let{components:e,...n}=t;return(0,s.kt)(vgt,(0,p.Z)({},xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Lgt.isMDXComponent=!0;const Zgt={toc:[]},bgt="wrapper";function Ngt(t){let{components:e,...n}=t;return(0,s.kt)(bgt,(0,p.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Ngt.isMDXComponent=!0;const Agt={toc:[]},zgt="wrapper";function Wgt(t){let{components:e,...n}=t;return(0,s.kt)(zgt,(0,p.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Wgt.isMDXComponent=!0;const Igt={toc:[]},Rgt="wrapper";function Sgt(t){let{components:e,...n}=t;return(0,s.kt)(Rgt,(0,p.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}))}Sgt.isMDXComponent=!0;const Pgt={toc:[]},Egt="wrapper";function Ogt(t){let{components:e,...n}=t;return(0,s.kt)(Egt,(0,p.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ogt.isMDXComponent=!0;const Ggt={toc:[]},Fgt="wrapper";function Bgt(t){let{components:e,...n}=t;return(0,s.kt)(Fgt,(0,p.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bgt.isMDXComponent=!0;const Ugt={toc:[]},Vgt="wrapper";function qgt(t){let{components:e,...n}=t;return(0,s.kt)(Vgt,(0,p.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qgt.isMDXComponent=!0;const jgt={toc:[]},Ygt="wrapper";function Hgt(t){let{components:e,...n}=t;return(0,s.kt)(Ygt,(0,p.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]},$gt="wrapper";function Jgt(t){let{components:e,...n}=t;return(0,s.kt)($gt,(0,p.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Jgt.isMDXComponent=!0;const Kgt={toc:[]},tCt="wrapper";function eCt(t){let{components:e,...n}=t;return(0,s.kt)(tCt,(0,p.Z)({},Kgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}eCt.isMDXComponent=!0;const nCt={toc:[]},oCt="wrapper";function pCt(t){let{components:e,...n}=t;return(0,s.kt)(oCt,(0,p.Z)({},nCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(t){let{components:e,...n}=t;return(0,s.kt)(sCt,(0,p.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cCt.isMDXComponent=!0;const iCt={toc:[]},aCt="wrapper";function lCt(t){let{components:e,...n}=t;return(0,s.kt)(aCt,(0,p.Z)({},iCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function dCt(t){let{components:e,...n}=t;return(0,s.kt)(mCt,(0,p.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dCt.isMDXComponent=!0;const hCt={toc:[]},fCt="wrapper";function kCt(t){let{components:e,...n}=t;return(0,s.kt)(fCt,(0,p.Z)({},hCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kCt.isMDXComponent=!0;const yCt={toc:[]},DCt="wrapper";function MCt(t){let{components:e,...n}=t;return(0,s.kt)(DCt,(0,p.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(t){let{components:e,...n}=t;return(0,s.kt)(_Ct,(0,p.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wCt.isMDXComponent=!0;const TCt={toc:[]},gCt="wrapper";function CCt(t){let{components:e,...n}=t;return(0,s.kt)(gCt,(0,p.Z)({},TCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}CCt.isMDXComponent=!0;const xCt={toc:[]},vCt="wrapper";function LCt(t){let{components:e,...n}=t;return(0,s.kt)(vCt,(0,p.Z)({},xCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}LCt.isMDXComponent=!0;const ZCt={toc:[]},bCt="wrapper";function NCt(t){let{components:e,...n}=t;return(0,s.kt)(bCt,(0,p.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}NCt.isMDXComponent=!0;const ACt={toc:[]},zCt="wrapper";function WCt(t){let{components:e,...n}=t;return(0,s.kt)(zCt,(0,p.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WCt.isMDXComponent=!0;const ICt={toc:[]},RCt="wrapper";function SCt(t){let{components:e,...n}=t;return(0,s.kt)(RCt,(0,p.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}SCt.isMDXComponent=!0;const PCt={toc:[]},ECt="wrapper";function OCt(t){let{components:e,...n}=t;return(0,s.kt)(ECt,(0,p.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}OCt.isMDXComponent=!0;const GCt={toc:[]},FCt="wrapper";function BCt(t){let{components:e,...n}=t;return(0,s.kt)(FCt,(0,p.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}BCt.isMDXComponent=!0;const UCt={toc:[]},VCt="wrapper";function qCt(t){let{components:e,...n}=t;return(0,s.kt)(VCt,(0,p.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qCt.isMDXComponent=!0;const jCt={toc:[]},YCt="wrapper";function HCt(t){let{components:e,...n}=t;return(0,s.kt)(YCt,(0,p.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}HCt.isMDXComponent=!0;const QCt={toc:[]},$Ct="wrapper";function JCt(t){let{components:e,...n}=t;return(0,s.kt)($Ct,(0,p.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}JCt.isMDXComponent=!0;const KCt={toc:[]},txt="wrapper";function ext(t){let{components:e,...n}=t;return(0,s.kt)(txt,(0,p.Z)({},KCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}ext.isMDXComponent=!0;const nxt={toc:[]},oxt="wrapper";function pxt(t){let{components:e,...n}=t;return(0,s.kt)(oxt,(0,p.Z)({},nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(t){let{components:e,...n}=t;return(0,s.kt)(sxt,(0,p.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}cxt.isMDXComponent=!0;const ixt={toc:[]},axt="wrapper";function lxt(t){let{components:e,...n}=t;return(0,s.kt)(axt,(0,p.Z)({},ixt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function dxt(t){let{components:e,...n}=t;return(0,s.kt)(mxt,(0,p.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dxt.isMDXComponent=!0;const hxt={toc:[]},fxt="wrapper";function kxt(t){let{components:e,...n}=t;return(0,s.kt)(fxt,(0,p.Z)({},hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}kxt.isMDXComponent=!0;const yxt={toc:[]},Dxt="wrapper";function Mxt(t){let{components:e,...n}=t;return(0,s.kt)(Dxt,(0,p.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(t){let{components:e,...n}=t;return(0,s.kt)(_xt,(0,p.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}wxt.isMDXComponent=!0;const Txt={toc:[]},gxt="wrapper";function Cxt(t){let{components:e,...n}=t;return(0,s.kt)(gxt,(0,p.Z)({},Txt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Cxt.isMDXComponent=!0;const xxt={toc:[]},vxt="wrapper";function Lxt(t){let{components:e,...n}=t;return(0,s.kt)(vxt,(0,p.Z)({},xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]},bxt="wrapper";function Nxt(t){let{components:e,...n}=t;return(0,s.kt)(bxt,(0,p.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Nxt.isMDXComponent=!0;const Axt={toc:[]},zxt="wrapper";function Wxt(t){let{components:e,...n}=t;return(0,s.kt)(zxt,(0,p.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Wxt.isMDXComponent=!0;const Ixt={toc:[]},Rxt="wrapper";function Sxt(t){let{components:e,...n}=t;return(0,s.kt)(Rxt,(0,p.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Sxt.isMDXComponent=!0;const Pxt={toc:[]},Ext="wrapper";function Oxt(t){let{components:e,...n}=t;return(0,s.kt)(Ext,(0,p.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Oxt.isMDXComponent=!0;const Gxt={toc:[]},Fxt="wrapper";function Bxt(t){let{components:e,...n}=t;return(0,s.kt)(Fxt,(0,p.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Bxt.isMDXComponent=!0;const Uxt={toc:[]},Vxt="wrapper";function qxt(t){let{components:e,...n}=t;return(0,s.kt)(Vxt,(0,p.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qxt.isMDXComponent=!0;const jxt={toc:[]},Yxt="wrapper";function Hxt(t){let{components:e,...n}=t;return(0,s.kt)(Yxt,(0,p.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]},$xt="wrapper";function Jxt(t){let{components:e,...n}=t;return(0,s.kt)($xt,(0,p.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jxt.isMDXComponent=!0;const Kxt={toc:[]},tvt="wrapper";function evt(t){let{components:e,...n}=t;return(0,s.kt)(tvt,(0,p.Z)({},Kxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}evt.isMDXComponent=!0;const nvt={toc:[]},ovt="wrapper";function pvt(t){let{components:e,...n}=t;return(0,s.kt)(ovt,(0,p.Z)({},nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(t){let{components:e,...n}=t;return(0,s.kt)(svt,(0,p.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}cvt.isMDXComponent=!0;const ivt={toc:[]},avt="wrapper";function lvt(t){let{components:e,...n}=t;return(0,s.kt)(avt,(0,p.Z)({},ivt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function dvt(t){let{components:e,...n}=t;return(0,s.kt)(mvt,(0,p.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dvt.isMDXComponent=!0;const hvt={toc:[]},fvt="wrapper";function kvt(t){let{components:e,...n}=t;return(0,s.kt)(fvt,(0,p.Z)({},hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}kvt.isMDXComponent=!0;const yvt={toc:[]},Dvt="wrapper";function Mvt(t){let{components:e,...n}=t;return(0,s.kt)(Dvt,(0,p.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(t){let{components:e,...n}=t;return(0,s.kt)(_vt,(0,p.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},gvt="wrapper";function Cvt(t){let{components:e,...n}=t;return(0,s.kt)(gvt,(0,p.Z)({},Tvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Cvt.isMDXComponent=!0;const xvt={toc:[]},vvt="wrapper";function Lvt(t){let{components:e,...n}=t;return(0,s.kt)(vvt,(0,p.Z)({},xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]},bvt="wrapper";function Nvt(t){let{components:e,...n}=t;return(0,s.kt)(bvt,(0,p.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Nvt.isMDXComponent=!0;const Avt={toc:[]},zvt="wrapper";function Wvt(t){let{components:e,...n}=t;return(0,s.kt)(zvt,(0,p.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Wvt.isMDXComponent=!0;const Ivt={toc:[]},Rvt="wrapper";function Svt(t){let{components:e,...n}=t;return(0,s.kt)(Rvt,(0,p.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Svt.isMDXComponent=!0;const Pvt={toc:[]},Evt="wrapper";function Ovt(t){let{components:e,...n}=t;return(0,s.kt)(Evt,(0,p.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Ovt.isMDXComponent=!0;const Gvt={toc:[]},Fvt="wrapper";function Bvt(t){let{components:e,...n}=t;return(0,s.kt)(Fvt,(0,p.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bvt.isMDXComponent=!0;const Uvt={toc:[]},Vvt="wrapper";function qvt(t){let{components:e,...n}=t;return(0,s.kt)(Vvt,(0,p.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qvt.isMDXComponent=!0;const jvt={toc:[]},Yvt="wrapper";function Hvt(t){let{components:e,...n}=t;return(0,s.kt)(Yvt,(0,p.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]},$vt="wrapper";function Jvt(t){let{components:e,...n}=t;return(0,s.kt)($vt,(0,p.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Jvt.isMDXComponent=!0;const Kvt={toc:[]},tLt="wrapper";function eLt(t){let{components:e,...n}=t;return(0,s.kt)(tLt,(0,p.Z)({},Kvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eLt.isMDXComponent=!0;const nLt={toc:[]},oLt="wrapper";function pLt(t){let{components:e,...n}=t;return(0,s.kt)(oLt,(0,p.Z)({},nLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(t){let{components:e,...n}=t;return(0,s.kt)(sLt,(0,p.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cLt.isMDXComponent=!0;const iLt={toc:[]},aLt="wrapper";function lLt(t){let{components:e,...n}=t;return(0,s.kt)(aLt,(0,p.Z)({},iLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function dLt(t){let{components:e,...n}=t;return(0,s.kt)(mLt,(0,p.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dLt.isMDXComponent=!0;const hLt={toc:[]},fLt="wrapper";function kLt(t){let{components:e,...n}=t;return(0,s.kt)(fLt,(0,p.Z)({},hLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}kLt.isMDXComponent=!0;const yLt={toc:[]},DLt="wrapper";function MLt(t){let{components:e,...n}=t;return(0,s.kt)(DLt,(0,p.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(t){let{components:e,...n}=t;return(0,s.kt)(_Lt,(0,p.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}wLt.isMDXComponent=!0;const TLt={toc:[]},gLt="wrapper";function CLt(t){let{components:e,...n}=t;return(0,s.kt)(gLt,(0,p.Z)({},TLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CLt.isMDXComponent=!0;const xLt={toc:[]},vLt="wrapper";function LLt(t){let{components:e,...n}=t;return(0,s.kt)(vLt,(0,p.Z)({},xLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LLt.isMDXComponent=!0;const ZLt={toc:[]},bLt="wrapper";function NLt(t){let{components:e,...n}=t;return(0,s.kt)(bLt,(0,p.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}NLt.isMDXComponent=!0;const ALt={toc:[]},zLt="wrapper";function WLt(t){let{components:e,...n}=t;return(0,s.kt)(zLt,(0,p.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}WLt.isMDXComponent=!0;const ILt={toc:[]},RLt="wrapper";function SLt(t){let{components:e,...n}=t;return(0,s.kt)(RLt,(0,p.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}SLt.isMDXComponent=!0;const PLt={toc:[]},ELt="wrapper";function OLt(t){let{components:e,...n}=t;return(0,s.kt)(ELt,(0,p.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}OLt.isMDXComponent=!0;const GLt={toc:[]},FLt="wrapper";function BLt(t){let{components:e,...n}=t;return(0,s.kt)(FLt,(0,p.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}BLt.isMDXComponent=!0;const ULt={toc:[]},VLt="wrapper";function qLt(t){let{components:e,...n}=t;return(0,s.kt)(VLt,(0,p.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qLt.isMDXComponent=!0;const jLt={toc:[]},YLt="wrapper";function HLt(t){let{components:e,...n}=t;return(0,s.kt)(YLt,(0,p.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}HLt.isMDXComponent=!0;const QLt={toc:[]},$Lt="wrapper";function JLt(t){let{components:e,...n}=t;return(0,s.kt)($Lt,(0,p.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}JLt.isMDXComponent=!0;const KLt={toc:[]},tZt="wrapper";function eZt(t){let{components:e,...n}=t;return(0,s.kt)(tZt,(0,p.Z)({},KLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}eZt.isMDXComponent=!0;const nZt={toc:[]},oZt="wrapper";function pZt(t){let{components:e,...n}=t;return(0,s.kt)(oZt,(0,p.Z)({},nZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(t){let{components:e,...n}=t;return(0,s.kt)(sZt,(0,p.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}cZt.isMDXComponent=!0;const iZt={toc:[]},aZt="wrapper";function lZt(t){let{components:e,...n}=t;return(0,s.kt)(aZt,(0,p.Z)({},iZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function dZt(t){let{components:e,...n}=t;return(0,s.kt)(mZt,(0,p.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}dZt.isMDXComponent=!0;const hZt={toc:[]},fZt="wrapper";function kZt(t){let{components:e,...n}=t;return(0,s.kt)(fZt,(0,p.Z)({},hZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kZt.isMDXComponent=!0;const yZt={toc:[]},DZt="wrapper";function MZt(t){let{components:e,...n}=t;return(0,s.kt)(DZt,(0,p.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(t){let{components:e,...n}=t;return(0,s.kt)(_Zt,(0,p.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wZt.isMDXComponent=!0;const TZt={toc:[]},gZt="wrapper";function CZt(t){let{components:e,...n}=t;return(0,s.kt)(gZt,(0,p.Z)({},TZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}CZt.isMDXComponent=!0;const xZt={toc:[]},vZt="wrapper";function LZt(t){let{components:e,...n}=t;return(0,s.kt)(vZt,(0,p.Z)({},xZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LZt.isMDXComponent=!0;const ZZt={toc:[]},bZt="wrapper";function NZt(t){let{components:e,...n}=t;return(0,s.kt)(bZt,(0,p.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NZt.isMDXComponent=!0;const AZt={toc:[]},zZt="wrapper";function WZt(t){let{components:e,...n}=t;return(0,s.kt)(zZt,(0,p.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}WZt.isMDXComponent=!0;const IZt={toc:[]},RZt="wrapper";function SZt(t){let{components:e,...n}=t;return(0,s.kt)(RZt,(0,p.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}SZt.isMDXComponent=!0;const PZt={toc:[]},EZt="wrapper";function OZt(t){let{components:e,...n}=t;return(0,s.kt)(EZt,(0,p.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}OZt.isMDXComponent=!0;const GZt={toc:[]},FZt="wrapper";function BZt(t){let{components:e,...n}=t;return(0,s.kt)(FZt,(0,p.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}BZt.isMDXComponent=!0;const UZt={toc:[]},VZt="wrapper";function qZt(t){let{components:e,...n}=t;return(0,s.kt)(VZt,(0,p.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qZt.isMDXComponent=!0;const jZt={toc:[]},YZt="wrapper";function HZt(t){let{components:e,...n}=t;return(0,s.kt)(YZt,(0,p.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}HZt.isMDXComponent=!0;const QZt={toc:[]},$Zt="wrapper";function JZt(t){let{components:e,...n}=t;return(0,s.kt)($Zt,(0,p.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}JZt.isMDXComponent=!0;const KZt={toc:[]},tbt="wrapper";function ebt(t){let{components:e,...n}=t;return(0,s.kt)(tbt,(0,p.Z)({},KZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ebt.isMDXComponent=!0;const nbt={toc:[]},obt="wrapper";function pbt(t){let{components:e,...n}=t;return(0,s.kt)(obt,(0,p.Z)({},nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(t){let{components:e,...n}=t;return(0,s.kt)(sbt,(0,p.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}cbt.isMDXComponent=!0;const ibt={toc:[]},abt="wrapper";function lbt(t){let{components:e,...n}=t;return(0,s.kt)(abt,(0,p.Z)({},ibt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function dbt(t){let{components:e,...n}=t;return(0,s.kt)(mbt,(0,p.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}dbt.isMDXComponent=!0;const hbt={toc:[]},fbt="wrapper";function kbt(t){let{components:e,...n}=t;return(0,s.kt)(fbt,(0,p.Z)({},hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kbt.isMDXComponent=!0;const ybt={toc:[]},Dbt="wrapper";function Mbt(t){let{components:e,...n}=t;return(0,s.kt)(Dbt,(0,p.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(t){let{components:e,...n}=t;return(0,s.kt)(_bt,(0,p.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},gbt="wrapper";function Cbt(t){let{components:e,...n}=t;return(0,s.kt)(gbt,(0,p.Z)({},Tbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Cbt.isMDXComponent=!0;const xbt={toc:[]},vbt="wrapper";function Lbt(t){let{components:e,...n}=t;return(0,s.kt)(vbt,(0,p.Z)({},xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]},bbt="wrapper";function Nbt(t){let{components:e,...n}=t;return(0,s.kt)(bbt,(0,p.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Nbt.isMDXComponent=!0;const Abt={toc:[]},zbt="wrapper";function Wbt(t){let{components:e,...n}=t;return(0,s.kt)(zbt,(0,p.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wbt.isMDXComponent=!0;const Ibt={toc:[]},Rbt="wrapper";function Sbt(t){let{components:e,...n}=t;return(0,s.kt)(Rbt,(0,p.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Sbt.isMDXComponent=!0;const Pbt={toc:[]},Ebt="wrapper";function Obt(t){let{components:e,...n}=t;return(0,s.kt)(Ebt,(0,p.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Obt.isMDXComponent=!0;const Gbt={toc:[]},Fbt="wrapper";function Bbt(t){let{components:e,...n}=t;return(0,s.kt)(Fbt,(0,p.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bbt.isMDXComponent=!0;const Ubt={toc:[]},Vbt="wrapper";function qbt(t){let{components:e,...n}=t;return(0,s.kt)(Vbt,(0,p.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qbt.isMDXComponent=!0;const jbt={toc:[]},Ybt="wrapper";function Hbt(t){let{components:e,...n}=t;return(0,s.kt)(Ybt,(0,p.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]},$bt="wrapper";function Jbt(t){let{components:e,...n}=t;return(0,s.kt)($bt,(0,p.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Jbt.isMDXComponent=!0;const Kbt={toc:[]},tNt="wrapper";function eNt(t){let{components:e,...n}=t;return(0,s.kt)(tNt,(0,p.Z)({},Kbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}eNt.isMDXComponent=!0;const nNt={toc:[]},oNt="wrapper";function pNt(t){let{components:e,...n}=t;return(0,s.kt)(oNt,(0,p.Z)({},nNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(t){let{components:e,...n}=t;return(0,s.kt)(sNt,(0,p.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}cNt.isMDXComponent=!0;const iNt={toc:[]},aNt="wrapper";function lNt(t){let{components:e,...n}=t;return(0,s.kt)(aNt,(0,p.Z)({},iNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function dNt(t){let{components:e,...n}=t;return(0,s.kt)(mNt,(0,p.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}dNt.isMDXComponent=!0;const hNt={toc:[]},fNt="wrapper";function kNt(t){let{components:e,...n}=t;return(0,s.kt)(fNt,(0,p.Z)({},hNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kNt.isMDXComponent=!0;const yNt={toc:[]},DNt="wrapper";function MNt(t){let{components:e,...n}=t;return(0,s.kt)(DNt,(0,p.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(t){let{components:e,...n}=t;return(0,s.kt)(_Nt,(0,p.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}wNt.isMDXComponent=!0;const TNt={toc:[]},gNt="wrapper";function CNt(t){let{components:e,...n}=t;return(0,s.kt)(gNt,(0,p.Z)({},TNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CNt.isMDXComponent=!0;const xNt={toc:[]},vNt="wrapper";function LNt(t){let{components:e,...n}=t;return(0,s.kt)(vNt,(0,p.Z)({},xNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LNt.isMDXComponent=!0;const ZNt={toc:[]},bNt="wrapper";function NNt(t){let{components:e,...n}=t;return(0,s.kt)(bNt,(0,p.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}NNt.isMDXComponent=!0;const ANt={toc:[]},zNt="wrapper";function WNt(t){let{components:e,...n}=t;return(0,s.kt)(zNt,(0,p.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}WNt.isMDXComponent=!0;const INt={toc:[]},RNt="wrapper";function SNt(t){let{components:e,...n}=t;return(0,s.kt)(RNt,(0,p.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}SNt.isMDXComponent=!0;const PNt={toc:[]},ENt="wrapper";function ONt(t){let{components:e,...n}=t;return(0,s.kt)(ENt,(0,p.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ONt.isMDXComponent=!0;const GNt={toc:[]},FNt="wrapper";function BNt(t){let{components:e,...n}=t;return(0,s.kt)(FNt,(0,p.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}BNt.isMDXComponent=!0;const UNt={toc:[]},VNt="wrapper";function qNt(t){let{components:e,...n}=t;return(0,s.kt)(VNt,(0,p.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qNt.isMDXComponent=!0;const jNt={toc:[]},YNt="wrapper";function HNt(t){let{components:e,...n}=t;return(0,s.kt)(YNt,(0,p.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}HNt.isMDXComponent=!0;const QNt={toc:[]},$Nt="wrapper";function JNt(t){let{components:e,...n}=t;return(0,s.kt)($Nt,(0,p.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JNt.isMDXComponent=!0;const KNt={toc:[]},tAt="wrapper";function eAt(t){let{components:e,...n}=t;return(0,s.kt)(tAt,(0,p.Z)({},KNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}eAt.isMDXComponent=!0;const nAt={toc:[]},oAt="wrapper";function pAt(t){let{components:e,...n}=t;return(0,s.kt)(oAt,(0,p.Z)({},nAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(t){let{components:e,...n}=t;return(0,s.kt)(sAt,(0,p.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}cAt.isMDXComponent=!0;const iAt={toc:[]},aAt="wrapper";function lAt(t){let{components:e,...n}=t;return(0,s.kt)(aAt,(0,p.Z)({},iAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function dAt(t){let{components:e,...n}=t;return(0,s.kt)(mAt,(0,p.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}dAt.isMDXComponent=!0;const hAt={toc:[]},fAt="wrapper";function kAt(t){let{components:e,...n}=t;return(0,s.kt)(fAt,(0,p.Z)({},hAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}kAt.isMDXComponent=!0;const yAt={toc:[]},DAt="wrapper";function MAt(t){let{components:e,...n}=t;return(0,s.kt)(DAt,(0,p.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(t){let{components:e,...n}=t;return(0,s.kt)(_At,(0,p.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wAt.isMDXComponent=!0;const TAt={toc:[]},gAt="wrapper";function CAt(t){let{components:e,...n}=t;return(0,s.kt)(gAt,(0,p.Z)({},TAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}CAt.isMDXComponent=!0;const xAt={toc:[]},vAt="wrapper";function LAt(t){let{components:e,...n}=t;return(0,s.kt)(vAt,(0,p.Z)({},xAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LAt.isMDXComponent=!0;const ZAt={toc:[]},bAt="wrapper";function NAt(t){let{components:e,...n}=t;return(0,s.kt)(bAt,(0,p.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NAt.isMDXComponent=!0;const AAt={toc:[]},zAt="wrapper";function WAt(t){let{components:e,...n}=t;return(0,s.kt)(zAt,(0,p.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}WAt.isMDXComponent=!0;const IAt={toc:[]},RAt="wrapper";function SAt(t){let{components:e,...n}=t;return(0,s.kt)(RAt,(0,p.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}SAt.isMDXComponent=!0;const PAt={toc:[]},EAt="wrapper";function OAt(t){let{components:e,...n}=t;return(0,s.kt)(EAt,(0,p.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}OAt.isMDXComponent=!0;const GAt={toc:[]},FAt="wrapper";function BAt(t){let{components:e,...n}=t;return(0,s.kt)(FAt,(0,p.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}BAt.isMDXComponent=!0;const UAt={toc:[]},VAt="wrapper";function qAt(t){let{components:e,...n}=t;return(0,s.kt)(VAt,(0,p.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qAt.isMDXComponent=!0;const jAt={toc:[]},YAt="wrapper";function HAt(t){let{components:e,...n}=t;return(0,s.kt)(YAt,(0,p.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}HAt.isMDXComponent=!0;const QAt={toc:[]},$At="wrapper";function JAt(t){let{components:e,...n}=t;return(0,s.kt)($At,(0,p.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}JAt.isMDXComponent=!0;const KAt={toc:[]},tzt="wrapper";function ezt(t){let{components:e,...n}=t;return(0,s.kt)(tzt,(0,p.Z)({},KAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}ezt.isMDXComponent=!0;const nzt={toc:[]},ozt="wrapper";function pzt(t){let{components:e,...n}=t;return(0,s.kt)(ozt,(0,p.Z)({},nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(t){let{components:e,...n}=t;return(0,s.kt)(szt,(0,p.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}czt.isMDXComponent=!0;const izt={toc:[]},azt="wrapper";function lzt(t){let{components:e,...n}=t;return(0,s.kt)(azt,(0,p.Z)({},izt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function dzt(t){let{components:e,...n}=t;return(0,s.kt)(mzt,(0,p.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dzt.isMDXComponent=!0;const hzt={toc:[]},fzt="wrapper";function kzt(t){let{components:e,...n}=t;return(0,s.kt)(fzt,(0,p.Z)({},hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kzt.isMDXComponent=!0;const yzt={toc:[]},Dzt="wrapper";function Mzt(t){let{components:e,...n}=t;return(0,s.kt)(Dzt,(0,p.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(t){let{components:e,...n}=t;return(0,s.kt)(_zt,(0,p.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},gzt="wrapper";function Czt(t){let{components:e,...n}=t;return(0,s.kt)(gzt,(0,p.Z)({},Tzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Czt.isMDXComponent=!0;const xzt={toc:[]},vzt="wrapper";function Lzt(t){let{components:e,...n}=t;return(0,s.kt)(vzt,(0,p.Z)({},xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]},bzt="wrapper";function Nzt(t){let{components:e,...n}=t;return(0,s.kt)(bzt,(0,p.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Nzt.isMDXComponent=!0;const Azt={toc:[]},zzt="wrapper";function Wzt(t){let{components:e,...n}=t;return(0,s.kt)(zzt,(0,p.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Wzt.isMDXComponent=!0;const Izt={toc:[]},Rzt="wrapper";function Szt(t){let{components:e,...n}=t;return(0,s.kt)(Rzt,(0,p.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Szt.isMDXComponent=!0;const Pzt={toc:[]},Ezt="wrapper";function Ozt(t){let{components:e,...n}=t;return(0,s.kt)(Ezt,(0,p.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ozt.isMDXComponent=!0;const Gzt={toc:[]},Fzt="wrapper";function Bzt(t){let{components:e,...n}=t;return(0,s.kt)(Fzt,(0,p.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Bzt.isMDXComponent=!0;const Uzt={toc:[]},Vzt="wrapper";function qzt(t){let{components:e,...n}=t;return(0,s.kt)(Vzt,(0,p.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qzt.isMDXComponent=!0;const jzt={toc:[]},Yzt="wrapper";function Hzt(t){let{components:e,...n}=t;return(0,s.kt)(Yzt,(0,p.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]},$zt="wrapper";function Jzt(t){let{components:e,...n}=t;return(0,s.kt)($zt,(0,p.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}Jzt.isMDXComponent=!0;const Kzt={toc:[]},tWt="wrapper";function eWt(t){let{components:e,...n}=t;return(0,s.kt)(tWt,(0,p.Z)({},Kzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}eWt.isMDXComponent=!0;const nWt={toc:[]},oWt="wrapper";function pWt(t){let{components:e,...n}=t;return(0,s.kt)(oWt,(0,p.Z)({},nWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(t){let{components:e,...n}=t;return(0,s.kt)(sWt,(0,p.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}cWt.isMDXComponent=!0;const iWt={toc:[]},aWt="wrapper";function lWt(t){let{components:e,...n}=t;return(0,s.kt)(aWt,(0,p.Z)({},iWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function dWt(t){let{components:e,...n}=t;return(0,s.kt)(mWt,(0,p.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dWt.isMDXComponent=!0;const hWt={toc:[]},fWt="wrapper";function kWt(t){let{components:e,...n}=t;return(0,s.kt)(fWt,(0,p.Z)({},hWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kWt.isMDXComponent=!0;const yWt={toc:[]},DWt="wrapper";function MWt(t){let{components:e,...n}=t;return(0,s.kt)(DWt,(0,p.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(t){let{components:e,...n}=t;return(0,s.kt)(_Wt,(0,p.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}wWt.isMDXComponent=!0;const TWt={toc:[]},gWt="wrapper";function CWt(t){let{components:e,...n}=t;return(0,s.kt)(gWt,(0,p.Z)({},TWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}CWt.isMDXComponent=!0;const xWt={toc:[]},vWt="wrapper";function LWt(t){let{components:e,...n}=t;return(0,s.kt)(vWt,(0,p.Z)({},xWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}LWt.isMDXComponent=!0;const ZWt={toc:[]},bWt="wrapper";function NWt(t){let{components:e,...n}=t;return(0,s.kt)(bWt,(0,p.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}NWt.isMDXComponent=!0;const AWt={toc:[]},zWt="wrapper";function WWt(t){let{components:e,...n}=t;return(0,s.kt)(zWt,(0,p.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}WWt.isMDXComponent=!0;const IWt={toc:[]},RWt="wrapper";function SWt(t){let{components:e,...n}=t;return(0,s.kt)(RWt,(0,p.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}SWt.isMDXComponent=!0;const PWt={toc:[]},EWt="wrapper";function OWt(t){let{components:e,...n}=t;return(0,s.kt)(EWt,(0,p.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}OWt.isMDXComponent=!0;const GWt={toc:[]},FWt="wrapper";function BWt(t){let{components:e,...n}=t;return(0,s.kt)(FWt,(0,p.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}BWt.isMDXComponent=!0;const UWt={toc:[]},VWt="wrapper";function qWt(t){let{components:e,...n}=t;return(0,s.kt)(VWt,(0,p.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qWt.isMDXComponent=!0;const jWt={toc:[]},YWt="wrapper";function HWt(t){let{components:e,...n}=t;return(0,s.kt)(YWt,(0,p.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HWt.isMDXComponent=!0;const QWt={toc:[]},$Wt="wrapper";function JWt(t){let{components:e,...n}=t;return(0,s.kt)($Wt,(0,p.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}JWt.isMDXComponent=!0;const KWt={toc:[]},tIt="wrapper";function eIt(t){let{components:e,...n}=t;return(0,s.kt)(tIt,(0,p.Z)({},KWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}eIt.isMDXComponent=!0;const nIt={toc:[]},oIt="wrapper";function pIt(t){let{components:e,...n}=t;return(0,s.kt)(oIt,(0,p.Z)({},nIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(t){let{components:e,...n}=t;return(0,s.kt)(sIt,(0,p.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}cIt.isMDXComponent=!0;const iIt={toc:[]},aIt="wrapper";function lIt(t){let{components:e,...n}=t;return(0,s.kt)(aIt,(0,p.Z)({},iIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function dIt(t){let{components:e,...n}=t;return(0,s.kt)(mIt,(0,p.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}dIt.isMDXComponent=!0;const hIt={toc:[]},fIt="wrapper";function kIt(t){let{components:e,...n}=t;return(0,s.kt)(fIt,(0,p.Z)({},hIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kIt.isMDXComponent=!0;const yIt={toc:[]},DIt="wrapper";function MIt(t){let{components:e,...n}=t;return(0,s.kt)(DIt,(0,p.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(t){let{components:e,...n}=t;return(0,s.kt)(_It,(0,p.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wIt.isMDXComponent=!0;const TIt={toc:[]},gIt="wrapper";function CIt(t){let{components:e,...n}=t;return(0,s.kt)(gIt,(0,p.Z)({},TIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}CIt.isMDXComponent=!0;const xIt={toc:[]},vIt="wrapper";function LIt(t){let{components:e,...n}=t;return(0,s.kt)(vIt,(0,p.Z)({},xIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LIt.isMDXComponent=!0;const ZIt={toc:[]},bIt="wrapper";function NIt(t){let{components:e,...n}=t;return(0,s.kt)(bIt,(0,p.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NIt.isMDXComponent=!0;const AIt={toc:[]},zIt="wrapper";function WIt(t){let{components:e,...n}=t;return(0,s.kt)(zIt,(0,p.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WIt.isMDXComponent=!0;const IIt={toc:[]},RIt="wrapper";function SIt(t){let{components:e,...n}=t;return(0,s.kt)(RIt,(0,p.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SIt.isMDXComponent=!0;const PIt={toc:[]},EIt="wrapper";function OIt(t){let{components:e,...n}=t;return(0,s.kt)(EIt,(0,p.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OIt.isMDXComponent=!0;const GIt={toc:[]},FIt="wrapper";function BIt(t){let{components:e,...n}=t;return(0,s.kt)(FIt,(0,p.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BIt.isMDXComponent=!0;const UIt={toc:[]},VIt="wrapper";function qIt(t){let{components:e,...n}=t;return(0,s.kt)(VIt,(0,p.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qIt.isMDXComponent=!0;const jIt={toc:[]},YIt="wrapper";function HIt(t){let{components:e,...n}=t;return(0,s.kt)(YIt,(0,p.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}HIt.isMDXComponent=!0;const QIt={toc:[]},$It="wrapper";function JIt(t){let{components:e,...n}=t;return(0,s.kt)($It,(0,p.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}JIt.isMDXComponent=!0;const KIt={toc:[]},tRt="wrapper";function eRt(t){let{components:e,...n}=t;return(0,s.kt)(tRt,(0,p.Z)({},KIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}eRt.isMDXComponent=!0;const nRt={toc:[]},oRt="wrapper";function pRt(t){let{components:e,...n}=t;return(0,s.kt)(oRt,(0,p.Z)({},nRt,n,{components:e,mdxType:"MDXLayout"}))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(t){let{components:e,...n}=t;return(0,s.kt)(sRt,(0,p.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}cRt.isMDXComponent=!0;const iRt={toc:[]},aRt="wrapper";function lRt(t){let{components:e,...n}=t;return(0,s.kt)(aRt,(0,p.Z)({},iRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function dRt(t){let{components:e,...n}=t;return(0,s.kt)(mRt,(0,p.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dRt.isMDXComponent=!0;const hRt={toc:[]},fRt="wrapper";function kRt(t){let{components:e,...n}=t;return(0,s.kt)(fRt,(0,p.Z)({},hRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kRt.isMDXComponent=!0;const yRt={toc:[]},DRt="wrapper";function MRt(t){let{components:e,...n}=t;return(0,s.kt)(DRt,(0,p.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(t){let{components:e,...n}=t;return(0,s.kt)(_Rt,(0,p.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wRt.isMDXComponent=!0;const TRt={toc:[]},gRt="wrapper";function CRt(t){let{components:e,...n}=t;return(0,s.kt)(gRt,(0,p.Z)({},TRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}CRt.isMDXComponent=!0;const xRt={toc:[]},vRt="wrapper";function LRt(t){let{components:e,...n}=t;return(0,s.kt)(vRt,(0,p.Z)({},xRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LRt.isMDXComponent=!0;const ZRt={toc:[]},bRt="wrapper";function NRt(t){let{components:e,...n}=t;return(0,s.kt)(bRt,(0,p.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}NRt.isMDXComponent=!0;const ARt={toc:[]},zRt="wrapper";function WRt(t){let{components:e,...n}=t;return(0,s.kt)(zRt,(0,p.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WRt.isMDXComponent=!0;const IRt={toc:[]},RRt="wrapper";function SRt(t){let{components:e,...n}=t;return(0,s.kt)(RRt,(0,p.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}SRt.isMDXComponent=!0;const PRt={toc:[]},ERt="wrapper";function ORt(t){let{components:e,...n}=t;return(0,s.kt)(ERt,(0,p.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}ORt.isMDXComponent=!0;const GRt={toc:[]},FRt="wrapper";function BRt(t){let{components:e,...n}=t;return(0,s.kt)(FRt,(0,p.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BRt.isMDXComponent=!0;const URt={toc:[]},VRt="wrapper";function qRt(t){let{components:e,...n}=t;return(0,s.kt)(VRt,(0,p.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}qRt.isMDXComponent=!0;const jRt={toc:[]},YRt="wrapper";function HRt(t){let{components:e,...n}=t;return(0,s.kt)(YRt,(0,p.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}HRt.isMDXComponent=!0;const QRt={toc:[]},$Rt="wrapper";function JRt(t){let{components:e,...n}=t;return(0,s.kt)($Rt,(0,p.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}JRt.isMDXComponent=!0;const KRt={toc:[]},tSt="wrapper";function eSt(t){let{components:e,...n}=t;return(0,s.kt)(tSt,(0,p.Z)({},KRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eSt.isMDXComponent=!0;const nSt={toc:[]},oSt="wrapper";function pSt(t){let{components:e,...n}=t;return(0,s.kt)(oSt,(0,p.Z)({},nSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(t){let{components:e,...n}=t;return(0,s.kt)(sSt,(0,p.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cSt.isMDXComponent=!0;const iSt={toc:[]},aSt="wrapper";function lSt(t){let{components:e,...n}=t;return(0,s.kt)(aSt,(0,p.Z)({},iSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function dSt(t){let{components:e,...n}=t;return(0,s.kt)(mSt,(0,p.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}dSt.isMDXComponent=!0;const hSt={toc:[]},fSt="wrapper";function kSt(t){let{components:e,...n}=t;return(0,s.kt)(fSt,(0,p.Z)({},hSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}kSt.isMDXComponent=!0;const ySt={toc:[]},DSt="wrapper";function MSt(t){let{components:e,...n}=t;return(0,s.kt)(DSt,(0,p.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(t){let{components:e,...n}=t;return(0,s.kt)(_St,(0,p.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wSt.isMDXComponent=!0;const TSt={toc:[]},gSt="wrapper";function CSt(t){let{components:e,...n}=t;return(0,s.kt)(gSt,(0,p.Z)({},TSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}CSt.isMDXComponent=!0;const xSt={toc:[]},vSt="wrapper";function LSt(t){let{components:e,...n}=t;return(0,s.kt)(vSt,(0,p.Z)({},xSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}LSt.isMDXComponent=!0;const ZSt={toc:[]},bSt="wrapper";function NSt(t){let{components:e,...n}=t;return(0,s.kt)(bSt,(0,p.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NSt.isMDXComponent=!0;const ASt={toc:[]},zSt="wrapper";function WSt(t){let{components:e,...n}=t;return(0,s.kt)(zSt,(0,p.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}WSt.isMDXComponent=!0;const ISt={toc:[]},RSt="wrapper";function SSt(t){let{components:e,...n}=t;return(0,s.kt)(RSt,(0,p.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}SSt.isMDXComponent=!0;const PSt={toc:[]},ESt="wrapper";function OSt(t){let{components:e,...n}=t;return(0,s.kt)(ESt,(0,p.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}OSt.isMDXComponent=!0;const GSt={toc:[]},FSt="wrapper";function BSt(t){let{components:e,...n}=t;return(0,s.kt)(FSt,(0,p.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}BSt.isMDXComponent=!0;const USt={toc:[]},VSt="wrapper";function qSt(t){let{components:e,...n}=t;return(0,s.kt)(VSt,(0,p.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qSt.isMDXComponent=!0;const jSt={toc:[]},YSt="wrapper";function HSt(t){let{components:e,...n}=t;return(0,s.kt)(YSt,(0,p.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}HSt.isMDXComponent=!0;const QSt={toc:[]},$St="wrapper";function JSt(t){let{components:e,...n}=t;return(0,s.kt)($St,(0,p.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}JSt.isMDXComponent=!0;const KSt={toc:[]},tPt="wrapper";function ePt(t){let{components:e,...n}=t;return(0,s.kt)(tPt,(0,p.Z)({},KSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ePt.isMDXComponent=!0;const nPt={toc:[]},oPt="wrapper";function pPt(t){let{components:e,...n}=t;return(0,s.kt)(oPt,(0,p.Z)({},nPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(t){let{components:e,...n}=t;return(0,s.kt)(sPt,(0,p.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}cPt.isMDXComponent=!0;const iPt={toc:[]},aPt="wrapper";function lPt(t){let{components:e,...n}=t;return(0,s.kt)(aPt,(0,p.Z)({},iPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function dPt(t){let{components:e,...n}=t;return(0,s.kt)(mPt,(0,p.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}dPt.isMDXComponent=!0;const hPt={toc:[]},fPt="wrapper";function kPt(t){let{components:e,...n}=t;return(0,s.kt)(fPt,(0,p.Z)({},hPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kPt.isMDXComponent=!0;const yPt={toc:[]},DPt="wrapper";function MPt(t){let{components:e,...n}=t;return(0,s.kt)(DPt,(0,p.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(t){let{components:e,...n}=t;return(0,s.kt)(_Pt,(0,p.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}wPt.isMDXComponent=!0;const TPt={toc:[]},gPt="wrapper";function CPt(t){let{components:e,...n}=t;return(0,s.kt)(gPt,(0,p.Z)({},TPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CPt.isMDXComponent=!0;const xPt={toc:[]},vPt="wrapper";function LPt(t){let{components:e,...n}=t;return(0,s.kt)(vPt,(0,p.Z)({},xPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LPt.isMDXComponent=!0;const ZPt={toc:[]},bPt="wrapper";function NPt(t){let{components:e,...n}=t;return(0,s.kt)(bPt,(0,p.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NPt.isMDXComponent=!0;const APt={toc:[]},zPt="wrapper";function WPt(t){let{components:e,...n}=t;return(0,s.kt)(zPt,(0,p.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WPt.isMDXComponent=!0;const IPt={toc:[]},RPt="wrapper";function SPt(t){let{components:e,...n}=t;return(0,s.kt)(RPt,(0,p.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}SPt.isMDXComponent=!0;const PPt={toc:[]},EPt="wrapper";function OPt(t){let{components:e,...n}=t;return(0,s.kt)(EPt,(0,p.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}OPt.isMDXComponent=!0;const GPt={toc:[]},FPt="wrapper";function BPt(t){let{components:e,...n}=t;return(0,s.kt)(FPt,(0,p.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BPt.isMDXComponent=!0;const UPt={toc:[]},VPt="wrapper";function qPt(t){let{components:e,...n}=t;return(0,s.kt)(VPt,(0,p.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qPt.isMDXComponent=!0;const jPt={toc:[]},YPt="wrapper";function HPt(t){let{components:e,...n}=t;return(0,s.kt)(YPt,(0,p.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}HPt.isMDXComponent=!0;const QPt={toc:[]},$Pt="wrapper";function JPt(t){let{components:e,...n}=t;return(0,s.kt)($Pt,(0,p.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}JPt.isMDXComponent=!0;const KPt={toc:[]},tEt="wrapper";function eEt(t){let{components:e,...n}=t;return(0,s.kt)(tEt,(0,p.Z)({},KPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eEt.isMDXComponent=!0;const nEt={toc:[]},oEt="wrapper";function pEt(t){let{components:e,...n}=t;return(0,s.kt)(oEt,(0,p.Z)({},nEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(t){let{components:e,...n}=t;return(0,s.kt)(sEt,(0,p.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cEt.isMDXComponent=!0;const iEt={toc:[]},aEt="wrapper";function lEt(t){let{components:e,...n}=t;return(0,s.kt)(aEt,(0,p.Z)({},iEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function dEt(t){let{components:e,...n}=t;return(0,s.kt)(mEt,(0,p.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dEt.isMDXComponent=!0;const hEt={toc:[]},fEt="wrapper";function kEt(t){let{components:e,...n}=t;return(0,s.kt)(fEt,(0,p.Z)({},hEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kEt.isMDXComponent=!0;const yEt={toc:[]},DEt="wrapper";function MEt(t){let{components:e,...n}=t;return(0,s.kt)(DEt,(0,p.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(t){let{components:e,...n}=t;return(0,s.kt)(_Et,(0,p.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wEt.isMDXComponent=!0;const TEt={toc:[]},gEt="wrapper";function CEt(t){let{components:e,...n}=t;return(0,s.kt)(gEt,(0,p.Z)({},TEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}CEt.isMDXComponent=!0;const xEt={toc:[]},vEt="wrapper";function LEt(t){let{components:e,...n}=t;return(0,s.kt)(vEt,(0,p.Z)({},xEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}LEt.isMDXComponent=!0;const ZEt={toc:[]},bEt="wrapper";function NEt(t){let{components:e,...n}=t;return(0,s.kt)(bEt,(0,p.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}NEt.isMDXComponent=!0;const AEt={toc:[]},zEt="wrapper";function WEt(t){let{components:e,...n}=t;return(0,s.kt)(zEt,(0,p.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}WEt.isMDXComponent=!0;const IEt={toc:[]},REt="wrapper";function SEt(t){let{components:e,...n}=t;return(0,s.kt)(REt,(0,p.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SEt.isMDXComponent=!0;const PEt={toc:[]},EEt="wrapper";function OEt(t){let{components:e,...n}=t;return(0,s.kt)(EEt,(0,p.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}OEt.isMDXComponent=!0;const GEt={toc:[]},FEt="wrapper";function BEt(t){let{components:e,...n}=t;return(0,s.kt)(FEt,(0,p.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}BEt.isMDXComponent=!0;const UEt={toc:[]},VEt="wrapper";function qEt(t){let{components:e,...n}=t;return(0,s.kt)(VEt,(0,p.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qEt.isMDXComponent=!0;const jEt={toc:[]},YEt="wrapper";function HEt(t){let{components:e,...n}=t;return(0,s.kt)(YEt,(0,p.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}HEt.isMDXComponent=!0;const QEt={toc:[]},$Et="wrapper";function JEt(t){let{components:e,...n}=t;return(0,s.kt)($Et,(0,p.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JEt.isMDXComponent=!0;const KEt={toc:[]},tOt="wrapper";function eOt(t){let{components:e,...n}=t;return(0,s.kt)(tOt,(0,p.Z)({},KEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}eOt.isMDXComponent=!0;const nOt={toc:[]},oOt="wrapper";function pOt(t){let{components:e,...n}=t;return(0,s.kt)(oOt,(0,p.Z)({},nOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(t){let{components:e,...n}=t;return(0,s.kt)(sOt,(0,p.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}cOt.isMDXComponent=!0;const iOt={toc:[]},aOt="wrapper";function lOt(t){let{components:e,...n}=t;return(0,s.kt)(aOt,(0,p.Z)({},iOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function dOt(t){let{components:e,...n}=t;return(0,s.kt)(mOt,(0,p.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}dOt.isMDXComponent=!0;const hOt={toc:[]},fOt="wrapper";function kOt(t){let{components:e,...n}=t;return(0,s.kt)(fOt,(0,p.Z)({},hOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}kOt.isMDXComponent=!0;const yOt={toc:[]},DOt="wrapper";function MOt(t){let{components:e,...n}=t;return(0,s.kt)(DOt,(0,p.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(t){let{components:e,...n}=t;return(0,s.kt)(_Ot,(0,p.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}wOt.isMDXComponent=!0;const TOt={toc:[]},gOt="wrapper";function COt(t){let{components:e,...n}=t;return(0,s.kt)(gOt,(0,p.Z)({},TOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}COt.isMDXComponent=!0;const xOt={toc:[]},vOt="wrapper";function LOt(t){let{components:e,...n}=t;return(0,s.kt)(vOt,(0,p.Z)({},xOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}LOt.isMDXComponent=!0;const ZOt={toc:[]},bOt="wrapper";function NOt(t){let{components:e,...n}=t;return(0,s.kt)(bOt,(0,p.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}NOt.isMDXComponent=!0;const AOt={toc:[]},zOt="wrapper";function WOt(t){let{components:e,...n}=t;return(0,s.kt)(zOt,(0,p.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}WOt.isMDXComponent=!0;const IOt={toc:[]},ROt="wrapper";function SOt(t){let{components:e,...n}=t;return(0,s.kt)(ROt,(0,p.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SOt.isMDXComponent=!0;const POt={toc:[]},EOt="wrapper";function OOt(t){let{components:e,...n}=t;return(0,s.kt)(EOt,(0,p.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}OOt.isMDXComponent=!0;const GOt={toc:[]},FOt="wrapper";function BOt(t){let{components:e,...n}=t;return(0,s.kt)(FOt,(0,p.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}BOt.isMDXComponent=!0;const UOt={toc:[]},VOt="wrapper";function qOt(t){let{components:e,...n}=t;return(0,s.kt)(VOt,(0,p.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qOt.isMDXComponent=!0;const jOt={toc:[]},YOt="wrapper";function HOt(t){let{components:e,...n}=t;return(0,s.kt)(YOt,(0,p.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}HOt.isMDXComponent=!0;const QOt={toc:[]},$Ot="wrapper";function JOt(t){let{components:e,...n}=t;return(0,s.kt)($Ot,(0,p.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}JOt.isMDXComponent=!0;const KOt={toc:[]},tGt="wrapper";function eGt(t){let{components:e,...n}=t;return(0,s.kt)(tGt,(0,p.Z)({},KOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}eGt.isMDXComponent=!0;const nGt={toc:[]},oGt="wrapper";function pGt(t){let{components:e,...n}=t;return(0,s.kt)(oGt,(0,p.Z)({},nGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(t){let{components:e,...n}=t;return(0,s.kt)(sGt,(0,p.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}cGt.isMDXComponent=!0;const iGt={toc:[]},aGt="wrapper";function lGt(t){let{components:e,...n}=t;return(0,s.kt)(aGt,(0,p.Z)({},iGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function dGt(t){let{components:e,...n}=t;return(0,s.kt)(mGt,(0,p.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dGt.isMDXComponent=!0;const hGt={toc:[]},fGt="wrapper";function kGt(t){let{components:e,...n}=t;return(0,s.kt)(fGt,(0,p.Z)({},hGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}kGt.isMDXComponent=!0;const yGt={toc:[]},DGt="wrapper";function MGt(t){let{components:e,...n}=t;return(0,s.kt)(DGt,(0,p.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(t){let{components:e,...n}=t;return(0,s.kt)(_Gt,(0,p.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wGt.isMDXComponent=!0;const TGt={toc:[]},gGt="wrapper";function CGt(t){let{components:e,...n}=t;return(0,s.kt)(gGt,(0,p.Z)({},TGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}CGt.isMDXComponent=!0;const xGt={toc:[]},vGt="wrapper";function LGt(t){let{components:e,...n}=t;return(0,s.kt)(vGt,(0,p.Z)({},xGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}LGt.isMDXComponent=!0;const ZGt={toc:[]},bGt="wrapper";function NGt(t){let{components:e,...n}=t;return(0,s.kt)(bGt,(0,p.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NGt.isMDXComponent=!0;const AGt={toc:[]},zGt="wrapper";function WGt(t){let{components:e,...n}=t;return(0,s.kt)(zGt,(0,p.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WGt.isMDXComponent=!0;const IGt={toc:[]},RGt="wrapper";function SGt(t){let{components:e,...n}=t;return(0,s.kt)(RGt,(0,p.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}SGt.isMDXComponent=!0;const PGt={toc:[]},EGt="wrapper";function OGt(t){let{components:e,...n}=t;return(0,s.kt)(EGt,(0,p.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}OGt.isMDXComponent=!0;const GGt={toc:[]},FGt="wrapper";function BGt(t){let{components:e,...n}=t;return(0,s.kt)(FGt,(0,p.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BGt.isMDXComponent=!0;const UGt={toc:[]},VGt="wrapper";function qGt(t){let{components:e,...n}=t;return(0,s.kt)(VGt,(0,p.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qGt.isMDXComponent=!0;const jGt={toc:[]},YGt="wrapper";function HGt(t){let{components:e,...n}=t;return(0,s.kt)(YGt,(0,p.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}HGt.isMDXComponent=!0;const QGt={toc:[]},$Gt="wrapper";function JGt(t){let{components:e,...n}=t;return(0,s.kt)($Gt,(0,p.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JGt.isMDXComponent=!0;const KGt={toc:[]},tFt="wrapper";function eFt(t){let{components:e,...n}=t;return(0,s.kt)(tFt,(0,p.Z)({},KGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}eFt.isMDXComponent=!0;const nFt={toc:[]},oFt="wrapper";function pFt(t){let{components:e,...n}=t;return(0,s.kt)(oFt,(0,p.Z)({},nFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(t){let{components:e,...n}=t;return(0,s.kt)(sFt,(0,p.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cFt.isMDXComponent=!0;const iFt={toc:[]},aFt="wrapper";function lFt(t){let{components:e,...n}=t;return(0,s.kt)(aFt,(0,p.Z)({},iFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function dFt(t){let{components:e,...n}=t;return(0,s.kt)(mFt,(0,p.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dFt.isMDXComponent=!0;const hFt={toc:[]},fFt="wrapper";function kFt(t){let{components:e,...n}=t;return(0,s.kt)(fFt,(0,p.Z)({},hFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kFt.isMDXComponent=!0;const yFt={toc:[]},DFt="wrapper";function MFt(t){let{components:e,...n}=t;return(0,s.kt)(DFt,(0,p.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(t){let{components:e,...n}=t;return(0,s.kt)(_Ft,(0,p.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wFt.isMDXComponent=!0;const TFt={toc:[]},gFt="wrapper";function CFt(t){let{components:e,...n}=t;return(0,s.kt)(gFt,(0,p.Z)({},TFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CFt.isMDXComponent=!0;const xFt={toc:[]},vFt="wrapper";function LFt(t){let{components:e,...n}=t;return(0,s.kt)(vFt,(0,p.Z)({},xFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LFt.isMDXComponent=!0;const ZFt={toc:[]},bFt="wrapper";function NFt(t){let{components:e,...n}=t;return(0,s.kt)(bFt,(0,p.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}NFt.isMDXComponent=!0;const AFt={toc:[]},zFt="wrapper";function WFt(t){let{components:e,...n}=t;return(0,s.kt)(zFt,(0,p.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WFt.isMDXComponent=!0;const IFt={toc:[]},RFt="wrapper";function SFt(t){let{components:e,...n}=t;return(0,s.kt)(RFt,(0,p.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}SFt.isMDXComponent=!0;const PFt={toc:[]},EFt="wrapper";function OFt(t){let{components:e,...n}=t;return(0,s.kt)(EFt,(0,p.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}OFt.isMDXComponent=!0;const GFt={toc:[]},FFt="wrapper";function BFt(t){let{components:e,...n}=t;return(0,s.kt)(FFt,(0,p.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BFt.isMDXComponent=!0;const UFt={toc:[]},VFt="wrapper";function qFt(t){let{components:e,...n}=t;return(0,s.kt)(VFt,(0,p.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qFt.isMDXComponent=!0;const jFt={toc:[]},YFt="wrapper";function HFt(t){let{components:e,...n}=t;return(0,s.kt)(YFt,(0,p.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}HFt.isMDXComponent=!0;const QFt={toc:[]},$Ft="wrapper";function JFt(t){let{components:e,...n}=t;return(0,s.kt)($Ft,(0,p.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}JFt.isMDXComponent=!0;const KFt={toc:[]},tBt="wrapper";function eBt(t){let{components:e,...n}=t;return(0,s.kt)(tBt,(0,p.Z)({},KFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eBt.isMDXComponent=!0;const nBt={toc:[]},oBt="wrapper";function pBt(t){let{components:e,...n}=t;return(0,s.kt)(oBt,(0,p.Z)({},nBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(t){let{components:e,...n}=t;return(0,s.kt)(sBt,(0,p.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cBt.isMDXComponent=!0;const iBt={toc:[]},aBt="wrapper";function lBt(t){let{components:e,...n}=t;return(0,s.kt)(aBt,(0,p.Z)({},iBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function dBt(t){let{components:e,...n}=t;return(0,s.kt)(mBt,(0,p.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dBt.isMDXComponent=!0;const hBt={toc:[]},fBt="wrapper";function kBt(t){let{components:e,...n}=t;return(0,s.kt)(fBt,(0,p.Z)({},hBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kBt.isMDXComponent=!0;const yBt={toc:[]},DBt="wrapper";function MBt(t){let{components:e,...n}=t;return(0,s.kt)(DBt,(0,p.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(t){let{components:e,...n}=t;return(0,s.kt)(_Bt,(0,p.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wBt.isMDXComponent=!0;const TBt={toc:[]},gBt="wrapper";function CBt(t){let{components:e,...n}=t;return(0,s.kt)(gBt,(0,p.Z)({},TBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}CBt.isMDXComponent=!0;const xBt={toc:[]},vBt="wrapper";function LBt(t){let{components:e,...n}=t;return(0,s.kt)(vBt,(0,p.Z)({},xBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LBt.isMDXComponent=!0;const ZBt={toc:[]},bBt="wrapper";function NBt(t){let{components:e,...n}=t;return(0,s.kt)(bBt,(0,p.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NBt.isMDXComponent=!0;const ABt={toc:[]},zBt="wrapper";function WBt(t){let{components:e,...n}=t;return(0,s.kt)(zBt,(0,p.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WBt.isMDXComponent=!0;const IBt={toc:[]},RBt="wrapper";function SBt(t){let{components:e,...n}=t;return(0,s.kt)(RBt,(0,p.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SBt.isMDXComponent=!0;const PBt={toc:[]},EBt="wrapper";function OBt(t){let{components:e,...n}=t;return(0,s.kt)(EBt,(0,p.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OBt.isMDXComponent=!0;const GBt={toc:[]},FBt="wrapper";function BBt(t){let{components:e,...n}=t;return(0,s.kt)(FBt,(0,p.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}BBt.isMDXComponent=!0;const UBt={toc:[]},VBt="wrapper";function qBt(t){let{components:e,...n}=t;return(0,s.kt)(VBt,(0,p.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qBt.isMDXComponent=!0;const jBt={toc:[]},YBt="wrapper";function HBt(t){let{components:e,...n}=t;return(0,s.kt)(YBt,(0,p.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}HBt.isMDXComponent=!0;const QBt={toc:[]},$Bt="wrapper";function JBt(t){let{components:e,...n}=t;return(0,s.kt)($Bt,(0,p.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JBt.isMDXComponent=!0;const KBt={toc:[]},tUt="wrapper";function eUt(t){let{components:e,...n}=t;return(0,s.kt)(tUt,(0,p.Z)({},KBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eUt.isMDXComponent=!0;const nUt={toc:[]},oUt="wrapper";function pUt(t){let{components:e,...n}=t;return(0,s.kt)(oUt,(0,p.Z)({},nUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(t){let{components:e,...n}=t;return(0,s.kt)(sUt,(0,p.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cUt.isMDXComponent=!0;const iUt={toc:[]},aUt="wrapper";function lUt(t){let{components:e,...n}=t;return(0,s.kt)(aUt,(0,p.Z)({},iUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function dUt(t){let{components:e,...n}=t;return(0,s.kt)(mUt,(0,p.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}dUt.isMDXComponent=!0;const hUt={toc:[]},fUt="wrapper";function kUt(t){let{components:e,...n}=t;return(0,s.kt)(fUt,(0,p.Z)({},hUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kUt.isMDXComponent=!0;const yUt={toc:[]},DUt="wrapper";function MUt(t){let{components:e,...n}=t;return(0,s.kt)(DUt,(0,p.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(t){let{components:e,...n}=t;return(0,s.kt)(_Ut,(0,p.Z)({},XUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wUt.isMDXComponent=!0;const TUt={toc:[]},gUt="wrapper";function CUt(t){let{components:e,...n}=t;return(0,s.kt)(gUt,(0,p.Z)({},TUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}CUt.isMDXComponent=!0;const xUt={toc:[]},vUt="wrapper";function LUt(t){let{components:e,...n}=t;return(0,s.kt)(vUt,(0,p.Z)({},xUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LUt.isMDXComponent=!0;const ZUt={toc:[]},bUt="wrapper";function NUt(t){let{components:e,...n}=t;return(0,s.kt)(bUt,(0,p.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}NUt.isMDXComponent=!0;const AUt={toc:[]},zUt="wrapper";function WUt(t){let{components:e,...n}=t;return(0,s.kt)(zUt,(0,p.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}WUt.isMDXComponent=!0;const IUt={toc:[]},RUt="wrapper";function SUt(t){let{components:e,...n}=t;return(0,s.kt)(RUt,(0,p.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}SUt.isMDXComponent=!0;const PUt={toc:[]},EUt="wrapper";function OUt(t){let{components:e,...n}=t;return(0,s.kt)(EUt,(0,p.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}OUt.isMDXComponent=!0;const GUt={toc:[]},FUt="wrapper";function BUt(t){let{components:e,...n}=t;return(0,s.kt)(FUt,(0,p.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}BUt.isMDXComponent=!0;const UUt={toc:[]},VUt="wrapper";function qUt(t){let{components:e,...n}=t;return(0,s.kt)(VUt,(0,p.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qUt.isMDXComponent=!0;const jUt={toc:[]},YUt="wrapper";function HUt(t){let{components:e,...n}=t;return(0,s.kt)(YUt,(0,p.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HUt.isMDXComponent=!0;const QUt={toc:[]},$Ut="wrapper";function JUt(t){let{components:e,...n}=t;return(0,s.kt)($Ut,(0,p.Z)({},QUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}JUt.isMDXComponent=!0;const KUt={toc:[]},tVt="wrapper";function eVt(t){let{components:e,...n}=t;return(0,s.kt)(tVt,(0,p.Z)({},KUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eVt.isMDXComponent=!0;const nVt={toc:[]},oVt="wrapper";function pVt(t){let{components:e,...n}=t;return(0,s.kt)(oVt,(0,p.Z)({},nVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(t){let{components:e,...n}=t;return(0,s.kt)(sVt,(0,p.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cVt.isMDXComponent=!0;const iVt={toc:[]},aVt="wrapper";function lVt(t){let{components:e,...n}=t;return(0,s.kt)(aVt,(0,p.Z)({},iVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function dVt(t){let{components:e,...n}=t;return(0,s.kt)(mVt,(0,p.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}dVt.isMDXComponent=!0;const hVt={toc:[]},fVt="wrapper";function kVt(t){let{components:e,...n}=t;return(0,s.kt)(fVt,(0,p.Z)({},hVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}kVt.isMDXComponent=!0;const yVt={toc:[]},DVt="wrapper";function MVt(t){let{components:e,...n}=t;return(0,s.kt)(DVt,(0,p.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(t){let{components:e,...n}=t;return(0,s.kt)(_Vt,(0,p.Z)({},XVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}wVt.isMDXComponent=!0;const TVt={toc:[]},gVt="wrapper";function CVt(t){let{components:e,...n}=t;return(0,s.kt)(gVt,(0,p.Z)({},TVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}CVt.isMDXComponent=!0;const xVt={toc:[]},vVt="wrapper";function LVt(t){let{components:e,...n}=t;return(0,s.kt)(vVt,(0,p.Z)({},xVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}LVt.isMDXComponent=!0;const ZVt={toc:[]},bVt="wrapper";function NVt(t){let{components:e,...n}=t;return(0,s.kt)(bVt,(0,p.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}NVt.isMDXComponent=!0;const AVt={toc:[]},zVt="wrapper";function WVt(t){let{components:e,...n}=t;return(0,s.kt)(zVt,(0,p.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WVt.isMDXComponent=!0;const IVt={toc:[]},RVt="wrapper";function SVt(t){let{components:e,...n}=t;return(0,s.kt)(RVt,(0,p.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}SVt.isMDXComponent=!0;const PVt={toc:[]},EVt="wrapper";function OVt(t){let{components:e,...n}=t;return(0,s.kt)(EVt,(0,p.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}OVt.isMDXComponent=!0;const GVt={toc:[]},FVt="wrapper";function BVt(t){let{components:e,...n}=t;return(0,s.kt)(FVt,(0,p.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}BVt.isMDXComponent=!0;const UVt={toc:[]},VVt="wrapper";function qVt(t){let{components:e,...n}=t;return(0,s.kt)(VVt,(0,p.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qVt.isMDXComponent=!0;const jVt={toc:[]},YVt="wrapper";function HVt(t){let{components:e,...n}=t;return(0,s.kt)(YVt,(0,p.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}HVt.isMDXComponent=!0;const QVt={toc:[]},$Vt="wrapper";function JVt(t){let{components:e,...n}=t;return(0,s.kt)($Vt,(0,p.Z)({},QVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}JVt.isMDXComponent=!0;const KVt={toc:[]},tqt="wrapper";function eqt(t){let{components:e,...n}=t;return(0,s.kt)(tqt,(0,p.Z)({},KVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}eqt.isMDXComponent=!0;const nqt={toc:[]},oqt="wrapper";function pqt(t){let{components:e,...n}=t;return(0,s.kt)(oqt,(0,p.Z)({},nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(t){let{components:e,...n}=t;return(0,s.kt)(sqt,(0,p.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cqt.isMDXComponent=!0;const iqt={toc:[]},aqt="wrapper";function lqt(t){let{components:e,...n}=t;return(0,s.kt)(aqt,(0,p.Z)({},iqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function dqt(t){let{components:e,...n}=t;return(0,s.kt)(mqt,(0,p.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dqt.isMDXComponent=!0;const hqt={toc:[]},fqt="wrapper";function kqt(t){let{components:e,...n}=t;return(0,s.kt)(fqt,(0,p.Z)({},hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kqt.isMDXComponent=!0;const yqt={toc:[]},Dqt="wrapper";function Mqt(t){let{components:e,...n}=t;return(0,s.kt)(Dqt,(0,p.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(t){let{components:e,...n}=t;return(0,s.kt)(_qt,(0,p.Z)({},Xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},gqt="wrapper";function Cqt(t){let{components:e,...n}=t;return(0,s.kt)(gqt,(0,p.Z)({},Tqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Cqt.isMDXComponent=!0;const xqt={toc:[]},vqt="wrapper";function Lqt(t){let{components:e,...n}=t;return(0,s.kt)(vqt,(0,p.Z)({},xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Lqt.isMDXComponent=!0;const Zqt={toc:[]},bqt="wrapper";function Nqt(t){let{components:e,...n}=t;return(0,s.kt)(bqt,(0,p.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Nqt.isMDXComponent=!0;const Aqt={toc:[]},zqt="wrapper";function Wqt(t){let{components:e,...n}=t;return(0,s.kt)(zqt,(0,p.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wqt.isMDXComponent=!0;const Iqt={toc:[]},Rqt="wrapper";function Sqt(t){let{components:e,...n}=t;return(0,s.kt)(Rqt,(0,p.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Sqt.isMDXComponent=!0;const Pqt={toc:[]},Eqt="wrapper";function Oqt(t){let{components:e,...n}=t;return(0,s.kt)(Eqt,(0,p.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Oqt.isMDXComponent=!0;const Gqt={toc:[]},Fqt="wrapper";function Bqt(t){let{components:e,...n}=t;return(0,s.kt)(Fqt,(0,p.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bqt.isMDXComponent=!0;const Uqt={toc:[]},Vqt="wrapper";function qqt(t){let{components:e,...n}=t;return(0,s.kt)(Vqt,(0,p.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qqt.isMDXComponent=!0;const jqt={toc:[]},Yqt="wrapper";function Hqt(t){let{components:e,...n}=t;return(0,s.kt)(Yqt,(0,p.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]},$qt="wrapper";function Jqt(t){let{components:e,...n}=t;return(0,s.kt)($qt,(0,p.Z)({},Qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jqt.isMDXComponent=!0;const Kqt={toc:[]},tjt="wrapper";function ejt(t){let{components:e,...n}=t;return(0,s.kt)(tjt,(0,p.Z)({},Kqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ejt.isMDXComponent=!0;const njt={toc:[]},ojt="wrapper";function pjt(t){let{components:e,...n}=t;return(0,s.kt)(ojt,(0,p.Z)({},njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(t){let{components:e,...n}=t;return(0,s.kt)(sjt,(0,p.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cjt.isMDXComponent=!0;const ijt={toc:[]},ajt="wrapper";function ljt(t){let{components:e,...n}=t;return(0,s.kt)(ajt,(0,p.Z)({},ijt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function djt(t){let{components:e,...n}=t;return(0,s.kt)(mjt,(0,p.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}djt.isMDXComponent=!0;const hjt={toc:[]},fjt="wrapper";function kjt(t){let{components:e,...n}=t;return(0,s.kt)(fjt,(0,p.Z)({},hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kjt.isMDXComponent=!0;const yjt={toc:[]},Djt="wrapper";function Mjt(t){let{components:e,...n}=t;return(0,s.kt)(Djt,(0,p.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(t){let{components:e,...n}=t;return(0,s.kt)(_jt,(0,p.Z)({},Xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},gjt="wrapper";function Cjt(t){let{components:e,...n}=t;return(0,s.kt)(gjt,(0,p.Z)({},Tjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Cjt.isMDXComponent=!0;const xjt={toc:[]},vjt="wrapper";function Ljt(t){let{components:e,...n}=t;return(0,s.kt)(vjt,(0,p.Z)({},xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]},bjt="wrapper";function Njt(t){let{components:e,...n}=t;return(0,s.kt)(bjt,(0,p.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Njt.isMDXComponent=!0;const Ajt={toc:[]},zjt="wrapper";function Wjt(t){let{components:e,...n}=t;return(0,s.kt)(zjt,(0,p.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Wjt.isMDXComponent=!0;const Ijt={toc:[]},Rjt="wrapper";function Sjt(t){let{components:e,...n}=t;return(0,s.kt)(Rjt,(0,p.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Sjt.isMDXComponent=!0;const Pjt={toc:[]},Ejt="wrapper";function Ojt(t){let{components:e,...n}=t;return(0,s.kt)(Ejt,(0,p.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Ojt.isMDXComponent=!0;const Gjt={toc:[]},Fjt="wrapper";function Bjt(t){let{components:e,...n}=t;return(0,s.kt)(Fjt,(0,p.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}))}Bjt.isMDXComponent=!0;const Ujt={toc:[]},Vjt="wrapper";function qjt(t){let{components:e,...n}=t;return(0,s.kt)(Vjt,(0,p.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qjt.isMDXComponent=!0;const jjt={toc:[]},Yjt="wrapper";function Hjt(t){let{components:e,...n}=t;return(0,s.kt)(Yjt,(0,p.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]},$jt="wrapper";function Jjt(t){let{components:e,...n}=t;return(0,s.kt)($jt,(0,p.Z)({},Qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jjt.isMDXComponent=!0;const Kjt={toc:[]},tYt="wrapper";function eYt(t){let{components:e,...n}=t;return(0,s.kt)(tYt,(0,p.Z)({},Kjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}eYt.isMDXComponent=!0;const nYt={toc:[]},oYt="wrapper";function pYt(t){let{components:e,...n}=t;return(0,s.kt)(oYt,(0,p.Z)({},nYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(t){let{components:e,...n}=t;return(0,s.kt)(sYt,(0,p.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cYt.isMDXComponent=!0;const iYt={toc:[]},aYt="wrapper";function lYt(t){let{components:e,...n}=t;return(0,s.kt)(aYt,(0,p.Z)({},iYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function dYt(t){let{components:e,...n}=t;return(0,s.kt)(mYt,(0,p.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dYt.isMDXComponent=!0;const hYt={toc:[]},fYt="wrapper";function kYt(t){let{components:e,...n}=t;return(0,s.kt)(fYt,(0,p.Z)({},hYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kYt.isMDXComponent=!0;const yYt={toc:[]},DYt="wrapper";function MYt(t){let{components:e,...n}=t;return(0,s.kt)(DYt,(0,p.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(t){let{components:e,...n}=t;return(0,s.kt)(_Yt,(0,p.Z)({},XYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wYt.isMDXComponent=!0;const TYt={toc:[]},gYt="wrapper";function CYt(t){let{components:e,...n}=t;return(0,s.kt)(gYt,(0,p.Z)({},TYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}CYt.isMDXComponent=!0;const xYt={toc:[]},vYt="wrapper";function LYt(t){let{components:e,...n}=t;return(0,s.kt)(vYt,(0,p.Z)({},xYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LYt.isMDXComponent=!0;const ZYt={toc:[]},bYt="wrapper";function NYt(t){let{components:e,...n}=t;return(0,s.kt)(bYt,(0,p.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NYt.isMDXComponent=!0;const AYt={toc:[]},zYt="wrapper";function WYt(t){let{components:e,...n}=t;return(0,s.kt)(zYt,(0,p.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}WYt.isMDXComponent=!0;const IYt={toc:[]},RYt="wrapper";function SYt(t){let{components:e,...n}=t;return(0,s.kt)(RYt,(0,p.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}SYt.isMDXComponent=!0;const PYt={toc:[]},EYt="wrapper";function OYt(t){let{components:e,...n}=t;return(0,s.kt)(EYt,(0,p.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}OYt.isMDXComponent=!0;const GYt={toc:[]},FYt="wrapper";function BYt(t){let{components:e,...n}=t;return(0,s.kt)(FYt,(0,p.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}BYt.isMDXComponent=!0;const UYt={toc:[]},VYt="wrapper";function qYt(t){let{components:e,...n}=t;return(0,s.kt)(VYt,(0,p.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qYt.isMDXComponent=!0;const jYt={toc:[]},YYt="wrapper";function HYt(t){let{components:e,...n}=t;return(0,s.kt)(YYt,(0,p.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}HYt.isMDXComponent=!0;const QYt={toc:[]},$Yt="wrapper";function JYt(t){let{components:e,...n}=t;return(0,s.kt)($Yt,(0,p.Z)({},QYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}JYt.isMDXComponent=!0;const KYt={toc:[]},tHt="wrapper";function eHt(t){let{components:e,...n}=t;return(0,s.kt)(tHt,(0,p.Z)({},KYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eHt.isMDXComponent=!0;const nHt={toc:[]},oHt="wrapper";function pHt(t){let{components:e,...n}=t;return(0,s.kt)(oHt,(0,p.Z)({},nHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(t){let{components:e,...n}=t;return(0,s.kt)(sHt,(0,p.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cHt.isMDXComponent=!0;const iHt={toc:[]},aHt="wrapper";function lHt(t){let{components:e,...n}=t;return(0,s.kt)(aHt,(0,p.Z)({},iHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function dHt(t){let{components:e,...n}=t;return(0,s.kt)(mHt,(0,p.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dHt.isMDXComponent=!0;const hHt={toc:[]},fHt="wrapper";function kHt(t){let{components:e,...n}=t;return(0,s.kt)(fHt,(0,p.Z)({},hHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kHt.isMDXComponent=!0;const yHt={toc:[]},DHt="wrapper";function MHt(t){let{components:e,...n}=t;return(0,s.kt)(DHt,(0,p.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(t){let{components:e,...n}=t;return(0,s.kt)(_Ht,(0,p.Z)({},XHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wHt.isMDXComponent=!0;const THt={toc:[]},gHt="wrapper";function CHt(t){let{components:e,...n}=t;return(0,s.kt)(gHt,(0,p.Z)({},THt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CHt.isMDXComponent=!0;const xHt={toc:[]},vHt="wrapper";function LHt(t){let{components:e,...n}=t;return(0,s.kt)(vHt,(0,p.Z)({},xHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}LHt.isMDXComponent=!0;const ZHt={toc:[]},bHt="wrapper";function NHt(t){let{components:e,...n}=t;return(0,s.kt)(bHt,(0,p.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}NHt.isMDXComponent=!0;const AHt={toc:[]},zHt="wrapper";function WHt(t){let{components:e,...n}=t;return(0,s.kt)(zHt,(0,p.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}WHt.isMDXComponent=!0;const IHt={toc:[]},RHt="wrapper";function SHt(t){let{components:e,...n}=t;return(0,s.kt)(RHt,(0,p.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}SHt.isMDXComponent=!0;const PHt={toc:[]},EHt="wrapper";function OHt(t){let{components:e,...n}=t;return(0,s.kt)(EHt,(0,p.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}OHt.isMDXComponent=!0;const GHt={toc:[]},FHt="wrapper";function BHt(t){let{components:e,...n}=t;return(0,s.kt)(FHt,(0,p.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}BHt.isMDXComponent=!0;const UHt={toc:[]},VHt="wrapper";function qHt(t){let{components:e,...n}=t;return(0,s.kt)(VHt,(0,p.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qHt.isMDXComponent=!0;const jHt={toc:[]},YHt="wrapper";function HHt(t){let{components:e,...n}=t;return(0,s.kt)(YHt,(0,p.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}HHt.isMDXComponent=!0;const QHt={toc:[]},$Ht="wrapper";function JHt(t){let{components:e,...n}=t;return(0,s.kt)($Ht,(0,p.Z)({},QHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}JHt.isMDXComponent=!0;const KHt={toc:[]},tQt="wrapper";function eQt(t){let{components:e,...n}=t;return(0,s.kt)(tQt,(0,p.Z)({},KHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}eQt.isMDXComponent=!0;const nQt={toc:[]},oQt="wrapper";function pQt(t){let{components:e,...n}=t;return(0,s.kt)(oQt,(0,p.Z)({},nQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(t){let{components:e,...n}=t;return(0,s.kt)(sQt,(0,p.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}cQt.isMDXComponent=!0;const iQt={toc:[]},aQt="wrapper";function lQt(t){let{components:e,...n}=t;return(0,s.kt)(aQt,(0,p.Z)({},iQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function dQt(t){let{components:e,...n}=t;return(0,s.kt)(mQt,(0,p.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}dQt.isMDXComponent=!0;const hQt={toc:[]},fQt="wrapper";function kQt(t){let{components:e,...n}=t;return(0,s.kt)(fQt,(0,p.Z)({},hQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kQt.isMDXComponent=!0;const yQt={toc:[]},DQt="wrapper";function MQt(t){let{components:e,...n}=t;return(0,s.kt)(DQt,(0,p.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(t){let{components:e,...n}=t;return(0,s.kt)(_Qt,(0,p.Z)({},XQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}wQt.isMDXComponent=!0;const TQt={toc:[]},gQt="wrapper";function CQt(t){let{components:e,...n}=t;return(0,s.kt)(gQt,(0,p.Z)({},TQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}CQt.isMDXComponent=!0;const xQt={toc:[]},vQt="wrapper";function LQt(t){let{components:e,...n}=t;return(0,s.kt)(vQt,(0,p.Z)({},xQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}LQt.isMDXComponent=!0;const ZQt={toc:[]},bQt="wrapper";function NQt(t){let{components:e,...n}=t;return(0,s.kt)(bQt,(0,p.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NQt.isMDXComponent=!0;const AQt={toc:[]},zQt="wrapper";function WQt(t){let{components:e,...n}=t;return(0,s.kt)(zQt,(0,p.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WQt.isMDXComponent=!0;const IQt={toc:[]},RQt="wrapper";function SQt(t){let{components:e,...n}=t;return(0,s.kt)(RQt,(0,p.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}SQt.isMDXComponent=!0;const PQt={toc:[]},EQt="wrapper";function OQt(t){let{components:e,...n}=t;return(0,s.kt)(EQt,(0,p.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}OQt.isMDXComponent=!0;const GQt={toc:[]},FQt="wrapper";function BQt(t){let{components:e,...n}=t;return(0,s.kt)(FQt,(0,p.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}BQt.isMDXComponent=!0;const UQt={toc:[]},VQt="wrapper";function qQt(t){let{components:e,...n}=t;return(0,s.kt)(VQt,(0,p.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}qQt.isMDXComponent=!0;const jQt={toc:[]},YQt="wrapper";function HQt(t){let{components:e,...n}=t;return(0,s.kt)(YQt,(0,p.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}HQt.isMDXComponent=!0;const QQt={toc:[]},$Qt="wrapper";function JQt(t){let{components:e,...n}=t;return(0,s.kt)($Qt,(0,p.Z)({},QQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}JQt.isMDXComponent=!0;const KQt={toc:[]},t$t="wrapper";function e$t(t){let{components:e,...n}=t;return(0,s.kt)(t$t,(0,p.Z)({},KQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e$t.isMDXComponent=!0;const n$t={toc:[]},o$t="wrapper";function p$t(t){let{components:e,...n}=t;return(0,s.kt)(o$t,(0,p.Z)({},n$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(t){let{components:e,...n}=t;return(0,s.kt)(s$t,(0,p.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c$t.isMDXComponent=!0;const i$t={toc:[]},a$t="wrapper";function l$t(t){let{components:e,...n}=t;return(0,s.kt)(a$t,(0,p.Z)({},i$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function d$t(t){let{components:e,...n}=t;return(0,s.kt)(m$t,(0,p.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d$t.isMDXComponent=!0;const h$t={toc:[]},f$t="wrapper";function k$t(t){let{components:e,...n}=t;return(0,s.kt)(f$t,(0,p.Z)({},h$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}k$t.isMDXComponent=!0;const y$t={toc:[]},D$t="wrapper";function M$t(t){let{components:e,...n}=t;return(0,s.kt)(D$t,(0,p.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(t){let{components:e,...n}=t;return(0,s.kt)(_$t,(0,p.Z)({},X$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}w$t.isMDXComponent=!0;const T$t={toc:[]},g$t="wrapper";function C$t(t){let{components:e,...n}=t;return(0,s.kt)(g$t,(0,p.Z)({},T$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}C$t.isMDXComponent=!0;const x$t={toc:[]},v$t="wrapper";function L$t(t){let{components:e,...n}=t;return(0,s.kt)(v$t,(0,p.Z)({},x$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}L$t.isMDXComponent=!0;const Z$t={toc:[]},b$t="wrapper";function N$t(t){let{components:e,...n}=t;return(0,s.kt)(b$t,(0,p.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N$t.isMDXComponent=!0;const A$t={toc:[]},z$t="wrapper";function W$t(t){let{components:e,...n}=t;return(0,s.kt)(z$t,(0,p.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}W$t.isMDXComponent=!0;const I$t={toc:[]},R$t="wrapper";function S$t(t){let{components:e,...n}=t;return(0,s.kt)(R$t,(0,p.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}S$t.isMDXComponent=!0;const P$t={toc:[]},E$t="wrapper";function O$t(t){let{components:e,...n}=t;return(0,s.kt)(E$t,(0,p.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}O$t.isMDXComponent=!0;const G$t={toc:[]},F$t="wrapper";function B$t(t){let{components:e,...n}=t;return(0,s.kt)(F$t,(0,p.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B$t.isMDXComponent=!0;const U$t={toc:[]},V$t="wrapper";function q$t(t){let{components:e,...n}=t;return(0,s.kt)(V$t,(0,p.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}q$t.isMDXComponent=!0;const j$t={toc:[]},Y$t="wrapper";function H$t(t){let{components:e,...n}=t;return(0,s.kt)(Y$t,(0,p.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}H$t.isMDXComponent=!0;const Q$t={toc:[]},$$t="wrapper";function J$t(t){let{components:e,...n}=t;return(0,s.kt)($$t,(0,p.Z)({},Q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}J$t.isMDXComponent=!0;const K$t={toc:[]},tJt="wrapper";function eJt(t){let{components:e,...n}=t;return(0,s.kt)(tJt,(0,p.Z)({},K$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}eJt.isMDXComponent=!0;const nJt={toc:[]},oJt="wrapper";function pJt(t){let{components:e,...n}=t;return(0,s.kt)(oJt,(0,p.Z)({},nJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(t){let{components:e,...n}=t;return(0,s.kt)(sJt,(0,p.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}cJt.isMDXComponent=!0;const iJt={toc:[]},aJt="wrapper";function lJt(t){let{components:e,...n}=t;return(0,s.kt)(aJt,(0,p.Z)({},iJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function dJt(t){let{components:e,...n}=t;return(0,s.kt)(mJt,(0,p.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}dJt.isMDXComponent=!0;const hJt={toc:[]},fJt="wrapper";function kJt(t){let{components:e,...n}=t;return(0,s.kt)(fJt,(0,p.Z)({},hJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kJt.isMDXComponent=!0;const yJt={toc:[]},DJt="wrapper";function MJt(t){let{components:e,...n}=t;return(0,s.kt)(DJt,(0,p.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(t){let{components:e,...n}=t;return(0,s.kt)(_Jt,(0,p.Z)({},XJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wJt.isMDXComponent=!0;const TJt={toc:[]},gJt="wrapper";function CJt(t){let{components:e,...n}=t;return(0,s.kt)(gJt,(0,p.Z)({},TJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}CJt.isMDXComponent=!0;const xJt={toc:[]},vJt="wrapper";function LJt(t){let{components:e,...n}=t;return(0,s.kt)(vJt,(0,p.Z)({},xJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}LJt.isMDXComponent=!0;const ZJt={toc:[]},bJt="wrapper";function NJt(t){let{components:e,...n}=t;return(0,s.kt)(bJt,(0,p.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}NJt.isMDXComponent=!0;const AJt={toc:[]},zJt="wrapper";function WJt(t){let{components:e,...n}=t;return(0,s.kt)(zJt,(0,p.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}WJt.isMDXComponent=!0;const IJt={toc:[]},RJt="wrapper";function SJt(t){let{components:e,...n}=t;return(0,s.kt)(RJt,(0,p.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}SJt.isMDXComponent=!0;const PJt={toc:[]},EJt="wrapper";function OJt(t){let{components:e,...n}=t;return(0,s.kt)(EJt,(0,p.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}OJt.isMDXComponent=!0;const GJt={toc:[]},FJt="wrapper";function BJt(t){let{components:e,...n}=t;return(0,s.kt)(FJt,(0,p.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}BJt.isMDXComponent=!0;const UJt={toc:[]},VJt="wrapper";function qJt(t){let{components:e,...n}=t;return(0,s.kt)(VJt,(0,p.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qJt.isMDXComponent=!0;const jJt={toc:[]},YJt="wrapper";function HJt(t){let{components:e,...n}=t;return(0,s.kt)(YJt,(0,p.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}HJt.isMDXComponent=!0;const QJt={toc:[]},$Jt="wrapper";function JJt(t){let{components:e,...n}=t;return(0,s.kt)($Jt,(0,p.Z)({},QJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}JJt.isMDXComponent=!0;const KJt={toc:[]},tKt="wrapper";function eKt(t){let{components:e,...n}=t;return(0,s.kt)(tKt,(0,p.Z)({},KJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eKt.isMDXComponent=!0;const nKt={toc:[]},oKt="wrapper";function pKt(t){let{components:e,...n}=t;return(0,s.kt)(oKt,(0,p.Z)({},nKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(t){let{components:e,...n}=t;return(0,s.kt)(sKt,(0,p.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cKt.isMDXComponent=!0;const iKt={toc:[]},aKt="wrapper";function lKt(t){let{components:e,...n}=t;return(0,s.kt)(aKt,(0,p.Z)({},iKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function dKt(t){let{components:e,...n}=t;return(0,s.kt)(mKt,(0,p.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dKt.isMDXComponent=!0;const hKt={toc:[]},fKt="wrapper";function kKt(t){let{components:e,...n}=t;return(0,s.kt)(fKt,(0,p.Z)({},hKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kKt.isMDXComponent=!0;const yKt={toc:[]},DKt="wrapper";function MKt(t){let{components:e,...n}=t;return(0,s.kt)(DKt,(0,p.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(t){let{components:e,...n}=t;return(0,s.kt)(_Kt,(0,p.Z)({},XKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wKt.isMDXComponent=!0;const TKt={toc:[]},gKt="wrapper";function CKt(t){let{components:e,...n}=t;return(0,s.kt)(gKt,(0,p.Z)({},TKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CKt.isMDXComponent=!0;const xKt={toc:[]},vKt="wrapper";function LKt(t){let{components:e,...n}=t;return(0,s.kt)(vKt,(0,p.Z)({},xKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LKt.isMDXComponent=!0;const ZKt={toc:[]},bKt="wrapper";function NKt(t){let{components:e,...n}=t;return(0,s.kt)(bKt,(0,p.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NKt.isMDXComponent=!0;const AKt={toc:[]},zKt="wrapper";function WKt(t){let{components:e,...n}=t;return(0,s.kt)(zKt,(0,p.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WKt.isMDXComponent=!0;const IKt={toc:[]},RKt="wrapper";function SKt(t){let{components:e,...n}=t;return(0,s.kt)(RKt,(0,p.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SKt.isMDXComponent=!0;const PKt={toc:[]},EKt="wrapper";function OKt(t){let{components:e,...n}=t;return(0,s.kt)(EKt,(0,p.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}OKt.isMDXComponent=!0;const GKt={toc:[]},FKt="wrapper";function BKt(t){let{components:e,...n}=t;return(0,s.kt)(FKt,(0,p.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BKt.isMDXComponent=!0;const UKt={toc:[]},VKt="wrapper";function qKt(t){let{components:e,...n}=t;return(0,s.kt)(VKt,(0,p.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qKt.isMDXComponent=!0;const jKt={toc:[]},YKt="wrapper";function HKt(t){let{components:e,...n}=t;return(0,s.kt)(YKt,(0,p.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HKt.isMDXComponent=!0;const QKt={toc:[]},$Kt="wrapper";function JKt(t){let{components:e,...n}=t;return(0,s.kt)($Kt,(0,p.Z)({},QKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}JKt.isMDXComponent=!0;const KKt={toc:[]},t0t="wrapper";function e0t(t){let{components:e,...n}=t;return(0,s.kt)(t0t,(0,p.Z)({},KKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e0t.isMDXComponent=!0;const n0t={toc:[]},o0t="wrapper";function p0t(t){let{components:e,...n}=t;return(0,s.kt)(o0t,(0,p.Z)({},n0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(t){let{components:e,...n}=t;return(0,s.kt)(s0t,(0,p.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}c0t.isMDXComponent=!0;const i0t={toc:[]},a0t="wrapper";function l0t(t){let{components:e,...n}=t;return(0,s.kt)(a0t,(0,p.Z)({},i0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function d0t(t){let{components:e,...n}=t;return(0,s.kt)(m0t,(0,p.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}d0t.isMDXComponent=!0;const h0t={toc:[]},f0t="wrapper";function k0t(t){let{components:e,...n}=t;return(0,s.kt)(f0t,(0,p.Z)({},h0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}k0t.isMDXComponent=!0;const y0t={toc:[]},D0t="wrapper";function M0t(t){let{components:e,...n}=t;return(0,s.kt)(D0t,(0,p.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(t){let{components:e,...n}=t;return(0,s.kt)(_0t,(0,p.Z)({},X0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w0t.isMDXComponent=!0;const T0t={toc:[]},g0t="wrapper";function C0t(t){let{components:e,...n}=t;return(0,s.kt)(g0t,(0,p.Z)({},T0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}C0t.isMDXComponent=!0;const x0t={toc:[]},v0t="wrapper";function L0t(t){let{components:e,...n}=t;return(0,s.kt)(v0t,(0,p.Z)({},x0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}L0t.isMDXComponent=!0;const Z0t={toc:[]},b0t="wrapper";function N0t(t){let{components:e,...n}=t;return(0,s.kt)(b0t,(0,p.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}N0t.isMDXComponent=!0;const A0t={toc:[]},z0t="wrapper";function W0t(t){let{components:e,...n}=t;return(0,s.kt)(z0t,(0,p.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}W0t.isMDXComponent=!0;const I0t={toc:[]},R0t="wrapper";function S0t(t){let{components:e,...n}=t;return(0,s.kt)(R0t,(0,p.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}S0t.isMDXComponent=!0;const P0t={toc:[]},E0t="wrapper";function O0t(t){let{components:e,...n}=t;return(0,s.kt)(E0t,(0,p.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}O0t.isMDXComponent=!0;const G0t={toc:[]},F0t="wrapper";function B0t(t){let{components:e,...n}=t;return(0,s.kt)(F0t,(0,p.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}B0t.isMDXComponent=!0;const U0t={toc:[]},V0t="wrapper";function q0t(t){let{components:e,...n}=t;return(0,s.kt)(V0t,(0,p.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}q0t.isMDXComponent=!0;const j0t={toc:[]},Y0t="wrapper";function H0t(t){let{components:e,...n}=t;return(0,s.kt)(Y0t,(0,p.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}H0t.isMDXComponent=!0;const Q0t={toc:[]},$0t="wrapper";function J0t(t){let{components:e,...n}=t;return(0,s.kt)($0t,(0,p.Z)({},Q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}J0t.isMDXComponent=!0;const K0t={toc:[]},t2t="wrapper";function e2t(t){let{components:e,...n}=t;return(0,s.kt)(t2t,(0,p.Z)({},K0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}e2t.isMDXComponent=!0;const n2t={toc:[]},o2t="wrapper";function p2t(t){let{components:e,...n}=t;return(0,s.kt)(o2t,(0,p.Z)({},n2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(t){let{components:e,...n}=t;return(0,s.kt)(s2t,(0,p.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}c2t.isMDXComponent=!0;const i2t={toc:[]},a2t="wrapper";function l2t(t){let{components:e,...n}=t;return(0,s.kt)(a2t,(0,p.Z)({},i2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function d2t(t){let{components:e,...n}=t;return(0,s.kt)(m2t,(0,p.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}d2t.isMDXComponent=!0;const h2t={toc:[]},f2t="wrapper";function k2t(t){let{components:e,...n}=t;return(0,s.kt)(f2t,(0,p.Z)({},h2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}k2t.isMDXComponent=!0;const y2t={toc:[]},D2t="wrapper";function M2t(t){let{components:e,...n}=t;return(0,s.kt)(D2t,(0,p.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(t){let{components:e,...n}=t;return(0,s.kt)(_2t,(0,p.Z)({},X2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}w2t.isMDXComponent=!0;const T2t={toc:[]},g2t="wrapper";function C2t(t){let{components:e,...n}=t;return(0,s.kt)(g2t,(0,p.Z)({},T2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}C2t.isMDXComponent=!0;const x2t={toc:[]},v2t="wrapper";function L2t(t){let{components:e,...n}=t;return(0,s.kt)(v2t,(0,p.Z)({},x2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}L2t.isMDXComponent=!0;const Z2t={toc:[]},b2t="wrapper";function N2t(t){let{components:e,...n}=t;return(0,s.kt)(b2t,(0,p.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}N2t.isMDXComponent=!0;const A2t={toc:[]},z2t="wrapper";function W2t(t){let{components:e,...n}=t;return(0,s.kt)(z2t,(0,p.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}W2t.isMDXComponent=!0;const I2t={toc:[]},R2t="wrapper";function S2t(t){let{components:e,...n}=t;return(0,s.kt)(R2t,(0,p.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}S2t.isMDXComponent=!0;const P2t={toc:[]},E2t="wrapper";function O2t(t){let{components:e,...n}=t;return(0,s.kt)(E2t,(0,p.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}O2t.isMDXComponent=!0;const G2t={toc:[]},F2t="wrapper";function B2t(t){let{components:e,...n}=t;return(0,s.kt)(F2t,(0,p.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}B2t.isMDXComponent=!0;const U2t={toc:[]},V2t="wrapper";function q2t(t){let{components:e,...n}=t;return(0,s.kt)(V2t,(0,p.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q2t.isMDXComponent=!0;const j2t={toc:[]},Y2t="wrapper";function H2t(t){let{components:e,...n}=t;return(0,s.kt)(Y2t,(0,p.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}H2t.isMDXComponent=!0;const Q2t={toc:[]},$2t="wrapper";function J2t(t){let{components:e,...n}=t;return(0,s.kt)($2t,(0,p.Z)({},Q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}J2t.isMDXComponent=!0;const K2t={toc:[]},t6t="wrapper";function e6t(t){let{components:e,...n}=t;return(0,s.kt)(t6t,(0,p.Z)({},K2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}e6t.isMDXComponent=!0;const n6t={toc:[]},o6t="wrapper";function p6t(t){let{components:e,...n}=t;return(0,s.kt)(o6t,(0,p.Z)({},n6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(t){let{components:e,...n}=t;return(0,s.kt)(s6t,(0,p.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c6t.isMDXComponent=!0;const i6t={toc:[]},a6t="wrapper";function l6t(t){let{components:e,...n}=t;return(0,s.kt)(a6t,(0,p.Z)({},i6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function d6t(t){let{components:e,...n}=t;return(0,s.kt)(m6t,(0,p.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}d6t.isMDXComponent=!0;const h6t={toc:[]},f6t="wrapper";function k6t(t){let{components:e,...n}=t;return(0,s.kt)(f6t,(0,p.Z)({},h6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}k6t.isMDXComponent=!0;const y6t={toc:[]},D6t="wrapper";function M6t(t){let{components:e,...n}=t;return(0,s.kt)(D6t,(0,p.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(t){let{components:e,...n}=t;return(0,s.kt)(_6t,(0,p.Z)({},X6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w6t.isMDXComponent=!0;const T6t={toc:[]},g6t="wrapper";function C6t(t){let{components:e,...n}=t;return(0,s.kt)(g6t,(0,p.Z)({},T6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}C6t.isMDXComponent=!0;const x6t={toc:[]},v6t="wrapper";function L6t(t){let{components:e,...n}=t;return(0,s.kt)(v6t,(0,p.Z)({},x6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L6t.isMDXComponent=!0;const Z6t={toc:[]},b6t="wrapper";function N6t(t){let{components:e,...n}=t;return(0,s.kt)(b6t,(0,p.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}N6t.isMDXComponent=!0;const A6t={toc:[]},z6t="wrapper";function W6t(t){let{components:e,...n}=t;return(0,s.kt)(z6t,(0,p.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}W6t.isMDXComponent=!0;const I6t={toc:[]},R6t="wrapper";function S6t(t){let{components:e,...n}=t;return(0,s.kt)(R6t,(0,p.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}S6t.isMDXComponent=!0;const P6t={toc:[]},E6t="wrapper";function O6t(t){let{components:e,...n}=t;return(0,s.kt)(E6t,(0,p.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}O6t.isMDXComponent=!0;const G6t={toc:[]},F6t="wrapper";function B6t(t){let{components:e,...n}=t;return(0,s.kt)(F6t,(0,p.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B6t.isMDXComponent=!0;const U6t={toc:[]},V6t="wrapper";function q6t(t){let{components:e,...n}=t;return(0,s.kt)(V6t,(0,p.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}q6t.isMDXComponent=!0;const j6t={toc:[]},Y6t="wrapper";function H6t(t){let{components:e,...n}=t;return(0,s.kt)(Y6t,(0,p.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}H6t.isMDXComponent=!0;const Q6t={toc:[]},$6t="wrapper";function J6t(t){let{components:e,...n}=t;return(0,s.kt)($6t,(0,p.Z)({},Q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}J6t.isMDXComponent=!0;const K6t={toc:[]},t3t="wrapper";function e3t(t){let{components:e,...n}=t;return(0,s.kt)(t3t,(0,p.Z)({},K6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e3t.isMDXComponent=!0;const n3t={toc:[]},o3t="wrapper";function p3t(t){let{components:e,...n}=t;return(0,s.kt)(o3t,(0,p.Z)({},n3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(t){let{components:e,...n}=t;return(0,s.kt)(s3t,(0,p.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}c3t.isMDXComponent=!0;const i3t={toc:[]},a3t="wrapper";function l3t(t){let{components:e,...n}=t;return(0,s.kt)(a3t,(0,p.Z)({},i3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function d3t(t){let{components:e,...n}=t;return(0,s.kt)(m3t,(0,p.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}d3t.isMDXComponent=!0;const h3t={toc:[]},f3t="wrapper";function k3t(t){let{components:e,...n}=t;return(0,s.kt)(f3t,(0,p.Z)({},h3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}k3t.isMDXComponent=!0;const y3t={toc:[]},D3t="wrapper";function M3t(t){let{components:e,...n}=t;return(0,s.kt)(D3t,(0,p.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(t){let{components:e,...n}=t;return(0,s.kt)(_3t,(0,p.Z)({},X3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}w3t.isMDXComponent=!0;const T3t={toc:[]},g3t="wrapper";function C3t(t){let{components:e,...n}=t;return(0,s.kt)(g3t,(0,p.Z)({},T3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}C3t.isMDXComponent=!0;const x3t={toc:[]},v3t="wrapper";function L3t(t){let{components:e,...n}=t;return(0,s.kt)(v3t,(0,p.Z)({},x3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}L3t.isMDXComponent=!0;const Z3t={toc:[]},b3t="wrapper";function N3t(t){let{components:e,...n}=t;return(0,s.kt)(b3t,(0,p.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}N3t.isMDXComponent=!0;const A3t={toc:[]},z3t="wrapper";function W3t(t){let{components:e,...n}=t;return(0,s.kt)(z3t,(0,p.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}W3t.isMDXComponent=!0;const I3t={toc:[]},R3t="wrapper";function S3t(t){let{components:e,...n}=t;return(0,s.kt)(R3t,(0,p.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}S3t.isMDXComponent=!0;const P3t={toc:[]},E3t="wrapper";function O3t(t){let{components:e,...n}=t;return(0,s.kt)(E3t,(0,p.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d';\nimport {all, waitFor} from '@motion-canvas/core';\nimport {createRef} from '@motion-canvas/core';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}O3t.isMDXComponent=!0;const G3t={toc:[]},F3t="wrapper";function B3t(t){let{components:e,...n}=t;return(0,s.kt)(F3t,(0,p.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}B3t.isMDXComponent=!0;const U3t={toc:[]},V3t="wrapper";function q3t(t){let{components:e,...n}=t;return(0,s.kt)(V3t,(0,p.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q3t.isMDXComponent=!0;const j3t={toc:[]},Y3t="wrapper";function H3t(t){let{components:e,...n}=t;return(0,s.kt)(Y3t,(0,p.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}H3t.isMDXComponent=!0;const Q3t={toc:[]},$3t="wrapper";function J3t(t){let{components:e,...n}=t;return(0,s.kt)($3t,(0,p.Z)({},Q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}J3t.isMDXComponent=!0;const K3t={toc:[]},t5t="wrapper";function e5t(t){let{components:e,...n}=t;return(0,s.kt)(t5t,(0,p.Z)({},K3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}e5t.isMDXComponent=!0;const n5t={toc:[]},o5t="wrapper";function p5t(t){let{components:e,...n}=t;return(0,s.kt)(o5t,(0,p.Z)({},n5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(t){let{components:e,...n}=t;return(0,s.kt)(s5t,(0,p.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}c5t.isMDXComponent=!0;const i5t={toc:[]},a5t="wrapper";function l5t(t){let{components:e,...n}=t;return(0,s.kt)(a5t,(0,p.Z)({},i5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function d5t(t){let{components:e,...n}=t;return(0,s.kt)(m5t,(0,p.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}d5t.isMDXComponent=!0;const h5t={toc:[]},f5t="wrapper";function k5t(t){let{components:e,...n}=t;return(0,s.kt)(f5t,(0,p.Z)({},h5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}k5t.isMDXComponent=!0;const y5t={toc:[]},D5t="wrapper";function M5t(t){let{components:e,...n}=t;return(0,s.kt)(D5t,(0,p.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(t){let{components:e,...n}=t;return(0,s.kt)(_5t,(0,p.Z)({},X5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}w5t.isMDXComponent=!0;const T5t={toc:[]},g5t="wrapper";function C5t(t){let{components:e,...n}=t;return(0,s.kt)(g5t,(0,p.Z)({},T5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}C5t.isMDXComponent=!0;const x5t={toc:[]},v5t="wrapper";function L5t(t){let{components:e,...n}=t;return(0,s.kt)(v5t,(0,p.Z)({},x5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}L5t.isMDXComponent=!0;const Z5t={toc:[]},b5t="wrapper";function N5t(t){let{components:e,...n}=t;return(0,s.kt)(b5t,(0,p.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}N5t.isMDXComponent=!0;const A5t={toc:[]},z5t="wrapper";function W5t(t){let{components:e,...n}=t;return(0,s.kt)(z5t,(0,p.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}W5t.isMDXComponent=!0;const I5t={toc:[]},R5t="wrapper";function S5t(t){let{components:e,...n}=t;return(0,s.kt)(R5t,(0,p.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}S5t.isMDXComponent=!0;const P5t={toc:[]},E5t="wrapper";function O5t(t){let{components:e,...n}=t;return(0,s.kt)(E5t,(0,p.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}O5t.isMDXComponent=!0;const G5t={toc:[]},F5t="wrapper";function B5t(t){let{components:e,...n}=t;return(0,s.kt)(F5t,(0,p.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}B5t.isMDXComponent=!0;const U5t={toc:[]},V5t="wrapper";function q5t(t){let{components:e,...n}=t;return(0,s.kt)(V5t,(0,p.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}q5t.isMDXComponent=!0;const j5t={toc:[]},Y5t="wrapper";function H5t(t){let{components:e,...n}=t;return(0,s.kt)(Y5t,(0,p.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}H5t.isMDXComponent=!0;const Q5t={toc:[]},$5t="wrapper";function J5t(t){let{components:e,...n}=t;return(0,s.kt)($5t,(0,p.Z)({},Q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}J5t.isMDXComponent=!0;const K5t={toc:[]},t1t="wrapper";function e1t(t){let{components:e,...n}=t;return(0,s.kt)(t1t,(0,p.Z)({},K5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}e1t.isMDXComponent=!0;const n1t={toc:[]},o1t="wrapper";function p1t(t){let{components:e,...n}=t;return(0,s.kt)(o1t,(0,p.Z)({},n1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(t){let{components:e,...n}=t;return(0,s.kt)(s1t,(0,p.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}c1t.isMDXComponent=!0;const i1t={toc:[]},a1t="wrapper";function l1t(t){let{components:e,...n}=t;return(0,s.kt)(a1t,(0,p.Z)({},i1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function d1t(t){let{components:e,...n}=t;return(0,s.kt)(m1t,(0,p.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}d1t.isMDXComponent=!0;const h1t={toc:[]},f1t="wrapper";function k1t(t){let{components:e,...n}=t;return(0,s.kt)(f1t,(0,p.Z)({},h1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}k1t.isMDXComponent=!0;const y1t={toc:[]},D1t="wrapper";function M1t(t){let{components:e,...n}=t;return(0,s.kt)(D1t,(0,p.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(t){let{components:e,...n}=t;return(0,s.kt)(_1t,(0,p.Z)({},X1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}w1t.isMDXComponent=!0;const T1t={toc:[]},g1t="wrapper";function C1t(t){let{components:e,...n}=t;return(0,s.kt)(g1t,(0,p.Z)({},T1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}C1t.isMDXComponent=!0;const x1t={toc:[]},v1t="wrapper";function L1t(t){let{components:e,...n}=t;return(0,s.kt)(v1t,(0,p.Z)({},x1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}L1t.isMDXComponent=!0;const Z1t={toc:[]},b1t="wrapper";function N1t(t){let{components:e,...n}=t;return(0,s.kt)(b1t,(0,p.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}N1t.isMDXComponent=!0;const A1t={toc:[]},z1t="wrapper";function W1t(t){let{components:e,...n}=t;return(0,s.kt)(z1t,(0,p.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}W1t.isMDXComponent=!0;const I1t={toc:[]},R1t="wrapper";function S1t(t){let{components:e,...n}=t;return(0,s.kt)(R1t,(0,p.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}S1t.isMDXComponent=!0;const P1t={toc:[]},E1t="wrapper";function O1t(t){let{components:e,...n}=t;return(0,s.kt)(E1t,(0,p.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}O1t.isMDXComponent=!0;const G1t={toc:[]},F1t="wrapper";function B1t(t){let{components:e,...n}=t;return(0,s.kt)(F1t,(0,p.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}B1t.isMDXComponent=!0;const U1t={toc:[]},V1t="wrapper";function q1t(t){let{components:e,...n}=t;return(0,s.kt)(V1t,(0,p.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}q1t.isMDXComponent=!0;const j1t={toc:[]},Y1t="wrapper";function H1t(t){let{components:e,...n}=t;return(0,s.kt)(Y1t,(0,p.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}H1t.isMDXComponent=!0;const Q1t={toc:[]},$1t="wrapper";function J1t(t){let{components:e,...n}=t;return(0,s.kt)($1t,(0,p.Z)({},Q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}J1t.isMDXComponent=!0;const K1t={toc:[]},t4t="wrapper";function e4t(t){let{components:e,...n}=t;return(0,s.kt)(t4t,(0,p.Z)({},K1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}e4t.isMDXComponent=!0;const n4t={toc:[]},o4t="wrapper";function p4t(t){let{components:e,...n}=t;return(0,s.kt)(o4t,(0,p.Z)({},n4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(t){let{components:e,...n}=t;return(0,s.kt)(s4t,(0,p.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}c4t.isMDXComponent=!0;const i4t={toc:[]},a4t="wrapper";function l4t(t){let{components:e,...n}=t;return(0,s.kt)(a4t,(0,p.Z)({},i4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function d4t(t){let{components:e,...n}=t;return(0,s.kt)(m4t,(0,p.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}d4t.isMDXComponent=!0;const h4t={toc:[]},f4t="wrapper";function k4t(t){let{components:e,...n}=t;return(0,s.kt)(f4t,(0,p.Z)({},h4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k4t.isMDXComponent=!0;const y4t={toc:[]},D4t="wrapper";function M4t(t){let{components:e,...n}=t;return(0,s.kt)(D4t,(0,p.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(t){let{components:e,...n}=t;return(0,s.kt)(_4t,(0,p.Z)({},X4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}w4t.isMDXComponent=!0;const T4t={toc:[]},g4t="wrapper";function C4t(t){let{components:e,...n}=t;return(0,s.kt)(g4t,(0,p.Z)({},T4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}C4t.isMDXComponent=!0;const x4t={toc:[]},v4t="wrapper";function L4t(t){let{components:e,...n}=t;return(0,s.kt)(v4t,(0,p.Z)({},x4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}L4t.isMDXComponent=!0;const Z4t={toc:[]},b4t="wrapper";function N4t(t){let{components:e,...n}=t;return(0,s.kt)(b4t,(0,p.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}N4t.isMDXComponent=!0;const A4t={toc:[]},z4t="wrapper";function W4t(t){let{components:e,...n}=t;return(0,s.kt)(z4t,(0,p.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}W4t.isMDXComponent=!0;const I4t={toc:[]},R4t="wrapper";function S4t(t){let{components:e,...n}=t;return(0,s.kt)(R4t,(0,p.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}S4t.isMDXComponent=!0;const P4t={toc:[]},E4t="wrapper";function O4t(t){let{components:e,...n}=t;return(0,s.kt)(E4t,(0,p.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}O4t.isMDXComponent=!0;const G4t={toc:[]},F4t="wrapper";function B4t(t){let{components:e,...n}=t;return(0,s.kt)(F4t,(0,p.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}B4t.isMDXComponent=!0;const U4t={toc:[]},V4t="wrapper";function q4t(t){let{components:e,...n}=t;return(0,s.kt)(V4t,(0,p.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}q4t.isMDXComponent=!0;const j4t={toc:[]},Y4t="wrapper";function H4t(t){let{components:e,...n}=t;return(0,s.kt)(Y4t,(0,p.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}H4t.isMDXComponent=!0;const Q4t={toc:[]},$4t="wrapper";function J4t(t){let{components:e,...n}=t;return(0,s.kt)($4t,(0,p.Z)({},Q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}J4t.isMDXComponent=!0;const K4t={toc:[]},t8t="wrapper";function e8t(t){let{components:e,...n}=t;return(0,s.kt)(t8t,(0,p.Z)({},K4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}e8t.isMDXComponent=!0;const n8t={toc:[]},o8t="wrapper";function p8t(t){let{components:e,...n}=t;return(0,s.kt)(o8t,(0,p.Z)({},n8t,n,{components:e,mdxType:"MDXLayout"}))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(t){let{components:e,...n}=t;return(0,s.kt)(s8t,(0,p.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}c8t.isMDXComponent=!0;const i8t={toc:[]},a8t="wrapper";function l8t(t){let{components:e,...n}=t;return(0,s.kt)(a8t,(0,p.Z)({},i8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function d8t(t){let{components:e,...n}=t;return(0,s.kt)(m8t,(0,p.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}d8t.isMDXComponent=!0;const h8t={toc:[]},f8t="wrapper";function k8t(t){let{components:e,...n}=t;return(0,s.kt)(f8t,(0,p.Z)({},h8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}k8t.isMDXComponent=!0;const y8t={toc:[]},D8t="wrapper";function M8t(t){let{components:e,...n}=t;return(0,s.kt)(D8t,(0,p.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(t){let{components:e,...n}=t;return(0,s.kt)(_8t,(0,p.Z)({},X8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}w8t.isMDXComponent=!0;const T8t={toc:[]},g8t="wrapper";function C8t(t){let{components:e,...n}=t;return(0,s.kt)(g8t,(0,p.Z)({},T8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}C8t.isMDXComponent=!0;const x8t={toc:[]},v8t="wrapper";function L8t(t){let{components:e,...n}=t;return(0,s.kt)(v8t,(0,p.Z)({},x8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}L8t.isMDXComponent=!0;const Z8t={toc:[]},b8t="wrapper";function N8t(t){let{components:e,...n}=t;return(0,s.kt)(b8t,(0,p.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N8t.isMDXComponent=!0;const A8t={toc:[]},z8t="wrapper";function W8t(t){let{components:e,...n}=t;return(0,s.kt)(z8t,(0,p.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}W8t.isMDXComponent=!0;const I8t={toc:[]},R8t="wrapper";function S8t(t){let{components:e,...n}=t;return(0,s.kt)(R8t,(0,p.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}S8t.isMDXComponent=!0;const P8t={toc:[]},E8t="wrapper";function O8t(t){let{components:e,...n}=t;return(0,s.kt)(E8t,(0,p.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}O8t.isMDXComponent=!0;const G8t={toc:[]},F8t="wrapper";function B8t(t){let{components:e,...n}=t;return(0,s.kt)(F8t,(0,p.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}B8t.isMDXComponent=!0;const U8t={toc:[]},V8t="wrapper";function q8t(t){let{components:e,...n}=t;return(0,s.kt)(V8t,(0,p.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}q8t.isMDXComponent=!0;const j8t={toc:[]},Y8t="wrapper";function H8t(t){let{components:e,...n}=t;return(0,s.kt)(Y8t,(0,p.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}H8t.isMDXComponent=!0;const Q8t={toc:[]},$8t="wrapper";function J8t(t){let{components:e,...n}=t;return(0,s.kt)($8t,(0,p.Z)({},Q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}J8t.isMDXComponent=!0;const K8t={toc:[]},t7t="wrapper";function e7t(t){let{components:e,...n}=t;return(0,s.kt)(t7t,(0,p.Z)({},K8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}e7t.isMDXComponent=!0;const n7t={toc:[]},o7t="wrapper";function p7t(t){let{components:e,...n}=t;return(0,s.kt)(o7t,(0,p.Z)({},n7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(t){let{components:e,...n}=t;return(0,s.kt)(s7t,(0,p.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c7t.isMDXComponent=!0;const i7t={toc:[]},a7t="wrapper";function l7t(t){let{components:e,...n}=t;return(0,s.kt)(a7t,(0,p.Z)({},i7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function d7t(t){let{components:e,...n}=t;return(0,s.kt)(m7t,(0,p.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}d7t.isMDXComponent=!0;const h7t={toc:[]},f7t="wrapper";function k7t(t){let{components:e,...n}=t;return(0,s.kt)(f7t,(0,p.Z)({},h7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}k7t.isMDXComponent=!0;const y7t={toc:[]},D7t="wrapper";function M7t(t){let{components:e,...n}=t;return(0,s.kt)(D7t,(0,p.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(t){let{components:e,...n}=t;return(0,s.kt)(_7t,(0,p.Z)({},X7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}w7t.isMDXComponent=!0;const T7t={toc:[]},g7t="wrapper";function C7t(t){let{components:e,...n}=t;return(0,s.kt)(g7t,(0,p.Z)({},T7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}C7t.isMDXComponent=!0;const x7t={toc:[]},v7t="wrapper";function L7t(t){let{components:e,...n}=t;return(0,s.kt)(v7t,(0,p.Z)({},x7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}L7t.isMDXComponent=!0;const Z7t={toc:[]},b7t="wrapper";function N7t(t){let{components:e,...n}=t;return(0,s.kt)(b7t,(0,p.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}N7t.isMDXComponent=!0;const A7t={toc:[]},z7t="wrapper";function W7t(t){let{components:e,...n}=t;return(0,s.kt)(z7t,(0,p.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}W7t.isMDXComponent=!0;const I7t={toc:[]},R7t="wrapper";function S7t(t){let{components:e,...n}=t;return(0,s.kt)(R7t,(0,p.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}S7t.isMDXComponent=!0;const P7t={toc:[]},E7t="wrapper";function O7t(t){let{components:e,...n}=t;return(0,s.kt)(E7t,(0,p.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}O7t.isMDXComponent=!0;const G7t={toc:[]},F7t="wrapper";function B7t(t){let{components:e,...n}=t;return(0,s.kt)(F7t,(0,p.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}B7t.isMDXComponent=!0;const U7t={toc:[]},V7t="wrapper";function q7t(t){let{components:e,...n}=t;return(0,s.kt)(V7t,(0,p.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}q7t.isMDXComponent=!0;const j7t={toc:[]},Y7t="wrapper";function H7t(t){let{components:e,...n}=t;return(0,s.kt)(Y7t,(0,p.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}H7t.isMDXComponent=!0;const Q7t={toc:[]},$7t="wrapper";function J7t(t){let{components:e,...n}=t;return(0,s.kt)($7t,(0,p.Z)({},Q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}J7t.isMDXComponent=!0;const K7t={toc:[]},t9t="wrapper";function e9t(t){let{components:e,...n}=t;return(0,s.kt)(t9t,(0,p.Z)({},K7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e9t.isMDXComponent=!0;const n9t={toc:[]},o9t="wrapper";function p9t(t){let{components:e,...n}=t;return(0,s.kt)(o9t,(0,p.Z)({},n9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(t){let{components:e,...n}=t;return(0,s.kt)(s9t,(0,p.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}c9t.isMDXComponent=!0;const i9t={toc:[]},a9t="wrapper";function l9t(t){let{components:e,...n}=t;return(0,s.kt)(a9t,(0,p.Z)({},i9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function d9t(t){let{components:e,...n}=t;return(0,s.kt)(m9t,(0,p.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}d9t.isMDXComponent=!0;const h9t={toc:[]},f9t="wrapper";function k9t(t){let{components:e,...n}=t;return(0,s.kt)(f9t,(0,p.Z)({},h9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}k9t.isMDXComponent=!0;const y9t={toc:[]},D9t="wrapper";function M9t(t){let{components:e,...n}=t;return(0,s.kt)(D9t,(0,p.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(t){let{components:e,...n}=t;return(0,s.kt)(_9t,(0,p.Z)({},X9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}w9t.isMDXComponent=!0;const T9t={toc:[]},g9t="wrapper";function C9t(t){let{components:e,...n}=t;return(0,s.kt)(g9t,(0,p.Z)({},T9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}C9t.isMDXComponent=!0;const x9t={toc:[]},v9t="wrapper";function L9t(t){let{components:e,...n}=t;return(0,s.kt)(v9t,(0,p.Z)({},x9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}L9t.isMDXComponent=!0;const Z9t={toc:[]},b9t="wrapper";function N9t(t){let{components:e,...n}=t;return(0,s.kt)(b9t,(0,p.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}N9t.isMDXComponent=!0;const A9t={toc:[]},z9t="wrapper";function W9t(t){let{components:e,...n}=t;return(0,s.kt)(z9t,(0,p.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}W9t.isMDXComponent=!0;const I9t={toc:[]},R9t="wrapper";function S9t(t){let{components:e,...n}=t;return(0,s.kt)(R9t,(0,p.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}S9t.isMDXComponent=!0;const P9t={toc:[]},E9t="wrapper";function O9t(t){let{components:e,...n}=t;return(0,s.kt)(E9t,(0,p.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}O9t.isMDXComponent=!0;const G9t={toc:[]},F9t="wrapper";function B9t(t){let{components:e,...n}=t;return(0,s.kt)(F9t,(0,p.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}B9t.isMDXComponent=!0;const U9t={toc:[]},V9t="wrapper";function q9t(t){let{components:e,...n}=t;return(0,s.kt)(V9t,(0,p.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}q9t.isMDXComponent=!0;const j9t={toc:[]},Y9t="wrapper";function H9t(t){let{components:e,...n}=t;return(0,s.kt)(Y9t,(0,p.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H9t.isMDXComponent=!0;const Q9t={toc:[]},$9t="wrapper";function J9t(t){let{components:e,...n}=t;return(0,s.kt)($9t,(0,p.Z)({},Q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}J9t.isMDXComponent=!0;const K9t={toc:[]},tte="wrapper";function ete(t){let{components:e,...n}=t;return(0,s.kt)(tte,(0,p.Z)({},K9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ete.isMDXComponent=!0;const nte={toc:[]},ote="wrapper";function pte(t){let{components:e,...n}=t;return(0,s.kt)(ote,(0,p.Z)({},nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pte.isMDXComponent=!0;const rte={toc:[]},ste="wrapper";function cte(t){let{components:e,...n}=t;return(0,s.kt)(ste,(0,p.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cte.isMDXComponent=!0;const ite={toc:[]},ate="wrapper";function lte(t){let{components:e,...n}=t;return(0,s.kt)(ate,(0,p.Z)({},ite,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lte.isMDXComponent=!0;const ute={toc:[]},mte="wrapper";function dte(t){let{components:e,...n}=t;return(0,s.kt)(mte,(0,p.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dte.isMDXComponent=!0;const hte={toc:[]},fte="wrapper";function kte(t){let{components:e,...n}=t;return(0,s.kt)(fte,(0,p.Z)({},hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kte.isMDXComponent=!0;const yte={toc:[]},Dte="wrapper";function Mte(t){let{components:e,...n}=t;return(0,s.kt)(Dte,(0,p.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mte.isMDXComponent=!0;const Xte={toc:[]},_te="wrapper";function wte(t){let{components:e,...n}=t;return(0,s.kt)(_te,(0,p.Z)({},Xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wte.isMDXComponent=!0;const Tte={toc:[]},gte="wrapper";function Cte(t){let{components:e,...n}=t;return(0,s.kt)(gte,(0,p.Z)({},Tte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Cte.isMDXComponent=!0;const xte={toc:[]},vte="wrapper";function Lte(t){let{components:e,...n}=t;return(0,s.kt)(vte,(0,p.Z)({},xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lte.isMDXComponent=!0;const Zte={toc:[]},bte="wrapper";function Nte(t){let{components:e,...n}=t;return(0,s.kt)(bte,(0,p.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nte.isMDXComponent=!0;const Ate={toc:[]},zte="wrapper";function Wte(t){let{components:e,...n}=t;return(0,s.kt)(zte,(0,p.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Ste(t){let{components:e,...n}=t;return(0,s.kt)(Rte,(0,p.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ste.isMDXComponent=!0;const Pte={toc:[]},Ete="wrapper";function Ote(t){let{components:e,...n}=t;return(0,s.kt)(Ete,(0,p.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ote.isMDXComponent=!0;const Gte={toc:[]},Fte="wrapper";function Bte(t){let{components:e,...n}=t;return(0,s.kt)(Fte,(0,p.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Bte.isMDXComponent=!0;const Ute={toc:[]},Vte="wrapper";function qte(t){let{components:e,...n}=t;return(0,s.kt)(Vte,(0,p.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qte.isMDXComponent=!0;const jte={toc:[]},Yte="wrapper";function Hte(t){let{components:e,...n}=t;return(0,s.kt)(Yte,(0,p.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Hte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Jte(t){let{components:e,...n}=t;return(0,s.kt)($te,(0,p.Z)({},Qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Jte.isMDXComponent=!0;const Kte={toc:[]},tee="wrapper";function eee(t){let{components:e,...n}=t;return(0,s.kt)(tee,(0,p.Z)({},Kte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eee.isMDXComponent=!0;const nee={toc:[]},oee="wrapper";function pee(t){let{components:e,...n}=t;return(0,s.kt)(oee,(0,p.Z)({},nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pee.isMDXComponent=!0;const ree={toc:[]},see="wrapper";function cee(t){let{components:e,...n}=t;return(0,s.kt)(see,(0,p.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cee.isMDXComponent=!0;const iee={toc:[]},aee="wrapper";function lee(t){let{components:e,...n}=t;return(0,s.kt)(aee,(0,p.Z)({},iee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lee.isMDXComponent=!0;const uee={toc:[]},mee="wrapper";function dee(t){let{components:e,...n}=t;return(0,s.kt)(mee,(0,p.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}dee.isMDXComponent=!0;const hee={toc:[]},fee="wrapper";function kee(t){let{components:e,...n}=t;return(0,s.kt)(fee,(0,p.Z)({},hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}kee.isMDXComponent=!0;const yee={toc:[]},Dee="wrapper";function Mee(t){let{components:e,...n}=t;return(0,s.kt)(Dee,(0,p.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Mee.isMDXComponent=!0;const Xee={toc:[]},_ee="wrapper";function wee(t){let{components:e,...n}=t;return(0,s.kt)(_ee,(0,p.Z)({},Xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}wee.isMDXComponent=!0;const Tee={toc:[]},gee="wrapper";function Cee(t){let{components:e,...n}=t;return(0,s.kt)(gee,(0,p.Z)({},Tee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Cee.isMDXComponent=!0;const xee={toc:[]},vee="wrapper";function Lee(t){let{components:e,...n}=t;return(0,s.kt)(vee,(0,p.Z)({},xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Lee.isMDXComponent=!0;const Zee={toc:[]},bee="wrapper";function Nee(t){let{components:e,...n}=t;return(0,s.kt)(bee,(0,p.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Nee.isMDXComponent=!0;const Aee={toc:[]},zee="wrapper";function Wee(t){let{components:e,...n}=t;return(0,s.kt)(zee,(0,p.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function See(t){let{components:e,...n}=t;return(0,s.kt)(Ree,(0,p.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}See.isMDXComponent=!0;const Pee={toc:[]},Eee="wrapper";function Oee(t){let{components:e,...n}=t;return(0,s.kt)(Eee,(0,p.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Oee.isMDXComponent=!0;const Gee={toc:[]},Fee="wrapper";function Bee(t){let{components:e,...n}=t;return(0,s.kt)(Fee,(0,p.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Bee.isMDXComponent=!0;const Uee={toc:[]},Vee="wrapper";function qee(t){let{components:e,...n}=t;return(0,s.kt)(Vee,(0,p.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qee.isMDXComponent=!0;const jee={toc:[]},Yee="wrapper";function Hee(t){let{components:e,...n}=t;return(0,s.kt)(Yee,(0,p.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Hee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Jee(t){let{components:e,...n}=t;return(0,s.kt)($ee,(0,p.Z)({},Qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Jee.isMDXComponent=!0;const Kee={toc:[]},tne="wrapper";function ene(t){let{components:e,...n}=t;return(0,s.kt)(tne,(0,p.Z)({},Kee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ene.isMDXComponent=!0;const nne={toc:[]},one="wrapper";function pne(t){let{components:e,...n}=t;return(0,s.kt)(one,(0,p.Z)({},nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pne.isMDXComponent=!0;const rne={toc:[]},sne="wrapper";function cne(t){let{components:e,...n}=t;return(0,s.kt)(sne,(0,p.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cne.isMDXComponent=!0;const ine={toc:[]},ane="wrapper";function lne(t){let{components:e,...n}=t;return(0,s.kt)(ane,(0,p.Z)({},ine,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lne.isMDXComponent=!0;const une={toc:[]},mne="wrapper";function dne(t){let{components:e,...n}=t;return(0,s.kt)(mne,(0,p.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dne.isMDXComponent=!0;const hne={toc:[]},fne="wrapper";function kne(t){let{components:e,...n}=t;return(0,s.kt)(fne,(0,p.Z)({},hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kne.isMDXComponent=!0;const yne={toc:[]},Dne="wrapper";function Mne(t){let{components:e,...n}=t;return(0,s.kt)(Dne,(0,p.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Mne.isMDXComponent=!0;const Xne={toc:[]},_ne="wrapper";function wne(t){let{components:e,...n}=t;return(0,s.kt)(_ne,(0,p.Z)({},Xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wne.isMDXComponent=!0;const Tne={toc:[]},gne="wrapper";function Cne(t){let{components:e,...n}=t;return(0,s.kt)(gne,(0,p.Z)({},Tne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Cne.isMDXComponent=!0;const xne={toc:[]},vne="wrapper";function Lne(t){let{components:e,...n}=t;return(0,s.kt)(vne,(0,p.Z)({},xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Lne.isMDXComponent=!0;const Zne={toc:[]},bne="wrapper";function Nne(t){let{components:e,...n}=t;return(0,s.kt)(bne,(0,p.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nne.isMDXComponent=!0;const Ane={toc:[]},zne="wrapper";function Wne(t){let{components:e,...n}=t;return(0,s.kt)(zne,(0,p.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Sne(t){let{components:e,...n}=t;return(0,s.kt)(Rne,(0,p.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Sne.isMDXComponent=!0;const Pne={toc:[]},Ene="wrapper";function One(t){let{components:e,...n}=t;return(0,s.kt)(Ene,(0,p.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}One.isMDXComponent=!0;const Gne={toc:[]},Fne="wrapper";function Bne(t){let{components:e,...n}=t;return(0,s.kt)(Fne,(0,p.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Bne.isMDXComponent=!0;const Une={toc:[]},Vne="wrapper";function qne(t){let{components:e,...n}=t;return(0,s.kt)(Vne,(0,p.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qne.isMDXComponent=!0;const jne={toc:[]},Yne="wrapper";function Hne(t){let{components:e,...n}=t;return(0,s.kt)(Yne,(0,p.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Hne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Jne(t){let{components:e,...n}=t;return(0,s.kt)($ne,(0,p.Z)({},Qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Jne.isMDXComponent=!0;const Kne={toc:[]},toe="wrapper";function eoe(t){let{components:e,...n}=t;return(0,s.kt)(toe,(0,p.Z)({},Kne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eoe.isMDXComponent=!0;const noe={toc:[]},ooe="wrapper";function poe(t){let{components:e,...n}=t;return(0,s.kt)(ooe,(0,p.Z)({},noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}poe.isMDXComponent=!0;const roe={toc:[]},soe="wrapper";function coe(t){let{components:e,...n}=t;return(0,s.kt)(soe,(0,p.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}coe.isMDXComponent=!0;const ioe={toc:[]},aoe="wrapper";function loe(t){let{components:e,...n}=t;return(0,s.kt)(aoe,(0,p.Z)({},ioe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}loe.isMDXComponent=!0;const uoe={toc:[]},moe="wrapper";function doe(t){let{components:e,...n}=t;return(0,s.kt)(moe,(0,p.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}doe.isMDXComponent=!0;const hoe={toc:[]},foe="wrapper";function koe(t){let{components:e,...n}=t;return(0,s.kt)(foe,(0,p.Z)({},hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}koe.isMDXComponent=!0;const yoe={toc:[]},Doe="wrapper";function Moe(t){let{components:e,...n}=t;return(0,s.kt)(Doe,(0,p.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Moe.isMDXComponent=!0;const Xoe={toc:[]},_oe="wrapper";function woe(t){let{components:e,...n}=t;return(0,s.kt)(_oe,(0,p.Z)({},Xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}woe.isMDXComponent=!0;const Toe={toc:[]},goe="wrapper";function Coe(t){let{components:e,...n}=t;return(0,s.kt)(goe,(0,p.Z)({},Toe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Coe.isMDXComponent=!0;const xoe={toc:[]},voe="wrapper";function Loe(t){let{components:e,...n}=t;return(0,s.kt)(voe,(0,p.Z)({},xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Loe.isMDXComponent=!0;const Zoe={toc:[]},boe="wrapper";function Noe(t){let{components:e,...n}=t;return(0,s.kt)(boe,(0,p.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Noe.isMDXComponent=!0;const Aoe={toc:[]},zoe="wrapper";function Woe(t){let{components:e,...n}=t;return(0,s.kt)(zoe,(0,p.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Woe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Soe(t){let{components:e,...n}=t;return(0,s.kt)(Roe,(0,p.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Soe.isMDXComponent=!0;const Poe={toc:[]},Eoe="wrapper";function Ooe(t){let{components:e,...n}=t;return(0,s.kt)(Eoe,(0,p.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Ooe.isMDXComponent=!0;const Goe={toc:[]},Foe="wrapper";function Boe(t){let{components:e,...n}=t;return(0,s.kt)(Foe,(0,p.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Boe.isMDXComponent=!0;const Uoe={toc:[]},Voe="wrapper";function qoe(t){let{components:e,...n}=t;return(0,s.kt)(Voe,(0,p.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qoe.isMDXComponent=!0;const joe={toc:[]},Yoe="wrapper";function Hoe(t){let{components:e,...n}=t;return(0,s.kt)(Yoe,(0,p.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Hoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Joe(t){let{components:e,...n}=t;return(0,s.kt)($oe,(0,p.Z)({},Qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Joe.isMDXComponent=!0;const Koe={toc:[]},tpe="wrapper";function epe(t){let{components:e,...n}=t;return(0,s.kt)(tpe,(0,p.Z)({},Koe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}epe.isMDXComponent=!0;const npe={toc:[]},ope="wrapper";function ppe(t){let{components:e,...n}=t;return(0,s.kt)(ope,(0,p.Z)({},npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}ppe.isMDXComponent=!0;const rpe={toc:[]},spe="wrapper";function cpe(t){let{components:e,...n}=t;return(0,s.kt)(spe,(0,p.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cpe.isMDXComponent=!0;const ipe={toc:[]},ape="wrapper";function lpe(t){let{components:e,...n}=t;return(0,s.kt)(ape,(0,p.Z)({},ipe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}lpe.isMDXComponent=!0;const upe={toc:[]},mpe="wrapper";function dpe(t){let{components:e,...n}=t;return(0,s.kt)(mpe,(0,p.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}dpe.isMDXComponent=!0;const hpe={toc:[]},fpe="wrapper";function kpe(t){let{components:e,...n}=t;return(0,s.kt)(fpe,(0,p.Z)({},hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kpe.isMDXComponent=!0;const ype={toc:[]},Dpe="wrapper";function Mpe(t){let{components:e,...n}=t;return(0,s.kt)(Dpe,(0,p.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Mpe.isMDXComponent=!0;const Xpe={toc:[]},_pe="wrapper";function wpe(t){let{components:e,...n}=t;return(0,s.kt)(_pe,(0,p.Z)({},Xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wpe.isMDXComponent=!0;const Tpe={toc:[]},gpe="wrapper";function Cpe(t){let{components:e,...n}=t;return(0,s.kt)(gpe,(0,p.Z)({},Tpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Cpe.isMDXComponent=!0;const xpe={toc:[]},vpe="wrapper";function Lpe(t){let{components:e,...n}=t;return(0,s.kt)(vpe,(0,p.Z)({},xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]},bpe="wrapper";function Npe(t){let{components:e,...n}=t;return(0,s.kt)(bpe,(0,p.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Npe.isMDXComponent=!0;const Ape={toc:[]},zpe="wrapper";function Wpe(t){let{components:e,...n}=t;return(0,s.kt)(zpe,(0,p.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Wpe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Spe(t){let{components:e,...n}=t;return(0,s.kt)(Rpe,(0,p.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Spe.isMDXComponent=!0;const Ppe={toc:[]},Epe="wrapper";function Ope(t){let{components:e,...n}=t;return(0,s.kt)(Epe,(0,p.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ope.isMDXComponent=!0;const Gpe={toc:[]},Fpe="wrapper";function Bpe(t){let{components:e,...n}=t;return(0,s.kt)(Fpe,(0,p.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Bpe.isMDXComponent=!0;const Upe={toc:[]},Vpe="wrapper";function qpe(t){let{components:e,...n}=t;return(0,s.kt)(Vpe,(0,p.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Ype="wrapper";function Hpe(t){let{components:e,...n}=t;return(0,s.kt)(Ype,(0,p.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Hpe.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Jpe(t){let{components:e,...n}=t;return(0,s.kt)($pe,(0,p.Z)({},Qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Jpe.isMDXComponent=!0;const Kpe={toc:[]},tre="wrapper";function ere(t){let{components:e,...n}=t;return(0,s.kt)(tre,(0,p.Z)({},Kpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ere.isMDXComponent=!0;const nre={toc:[]},ore="wrapper";function pre(t){let{components:e,...n}=t;return(0,s.kt)(ore,(0,p.Z)({},nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}pre.isMDXComponent=!0;const rre={toc:[]},sre="wrapper";function cre(t){let{components:e,...n}=t;return(0,s.kt)(sre,(0,p.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}cre.isMDXComponent=!0;const ire={toc:[]},are="wrapper";function lre(t){let{components:e,...n}=t;return(0,s.kt)(are,(0,p.Z)({},ire,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lre.isMDXComponent=!0;const ure={toc:[]},mre="wrapper";function dre(t){let{components:e,...n}=t;return(0,s.kt)(mre,(0,p.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}dre.isMDXComponent=!0;const hre={toc:[]},fre="wrapper";function kre(t){let{components:e,...n}=t;return(0,s.kt)(fre,(0,p.Z)({},hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}kre.isMDXComponent=!0;const yre={toc:[]},Dre="wrapper";function Mre(t){let{components:e,...n}=t;return(0,s.kt)(Dre,(0,p.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Mre.isMDXComponent=!0;const Xre={toc:[]},_re="wrapper";function wre(t){let{components:e,...n}=t;return(0,s.kt)(_re,(0,p.Z)({},Xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}wre.isMDXComponent=!0;const Tre={toc:[]},gre="wrapper";function Cre(t){let{components:e,...n}=t;return(0,s.kt)(gre,(0,p.Z)({},Tre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Cre.isMDXComponent=!0;const xre={toc:[]},vre="wrapper";function Lre(t){let{components:e,...n}=t;return(0,s.kt)(vre,(0,p.Z)({},xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Lre.isMDXComponent=!0;const Zre={toc:[]},bre="wrapper";function Nre(t){let{components:e,...n}=t;return(0,s.kt)(bre,(0,p.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Nre.isMDXComponent=!0;const Are={toc:[]},zre="wrapper";function Wre(t){let{components:e,...n}=t;return(0,s.kt)(zre,(0,p.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Sre(t){let{components:e,...n}=t;return(0,s.kt)(Rre,(0,p.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Sre.isMDXComponent=!0;const Pre={toc:[]},Ere="wrapper";function Ore(t){let{components:e,...n}=t;return(0,s.kt)(Ere,(0,p.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Ore.isMDXComponent=!0;const Gre={toc:[]},Fre="wrapper";function Bre(t){let{components:e,...n}=t;return(0,s.kt)(Fre,(0,p.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Bre.isMDXComponent=!0;const Ure={toc:[]},Vre="wrapper";function qre(t){let{components:e,...n}=t;return(0,s.kt)(Vre,(0,p.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}qre.isMDXComponent=!0;const jre={toc:[]},Yre="wrapper";function Hre(t){let{components:e,...n}=t;return(0,s.kt)(Yre,(0,p.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Hre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Jre(t){let{components:e,...n}=t;return(0,s.kt)($re,(0,p.Z)({},Qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Jre.isMDXComponent=!0;const Kre={toc:[]},tse="wrapper";function ese(t){let{components:e,...n}=t;return(0,s.kt)(tse,(0,p.Z)({},Kre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}ese.isMDXComponent=!0;const nse={toc:[]},ose="wrapper";function pse(t){let{components:e,...n}=t;return(0,s.kt)(ose,(0,p.Z)({},nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pse.isMDXComponent=!0;const rse={toc:[]},sse="wrapper";function cse(t){let{components:e,...n}=t;return(0,s.kt)(sse,(0,p.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cse.isMDXComponent=!0;const ise={toc:[]},ase="wrapper";function lse(t){let{components:e,...n}=t;return(0,s.kt)(ase,(0,p.Z)({},ise,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lse.isMDXComponent=!0;const use={toc:[]},mse="wrapper";function dse(t){let{components:e,...n}=t;return(0,s.kt)(mse,(0,p.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dse.isMDXComponent=!0;const hse={toc:[]},fse="wrapper";function kse(t){let{components:e,...n}=t;return(0,s.kt)(fse,(0,p.Z)({},hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kse.isMDXComponent=!0;const yse={toc:[]},Dse="wrapper";function Mse(t){let{components:e,...n}=t;return(0,s.kt)(Dse,(0,p.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Mse.isMDXComponent=!0;const Xse={toc:[]},_se="wrapper";function wse(t){let{components:e,...n}=t;return(0,s.kt)(_se,(0,p.Z)({},Xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}wse.isMDXComponent=!0;const Tse={toc:[]},gse="wrapper";function Cse(t){let{components:e,...n}=t;return(0,s.kt)(gse,(0,p.Z)({},Tse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Cse.isMDXComponent=!0;const xse={toc:[]},vse="wrapper";function Lse(t){let{components:e,...n}=t;return(0,s.kt)(vse,(0,p.Z)({},xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Lse.isMDXComponent=!0;const Zse={toc:[]},bse="wrapper";function Nse(t){let{components:e,...n}=t;return(0,s.kt)(bse,(0,p.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Nse.isMDXComponent=!0;const Ase={toc:[]},zse="wrapper";function Wse(t){let{components:e,...n}=t;return(0,s.kt)(zse,(0,p.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Wse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Sse(t){let{components:e,...n}=t;return(0,s.kt)(Rse,(0,p.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Sse.isMDXComponent=!0;const Pse={toc:[]},Ese="wrapper";function Ose(t){let{components:e,...n}=t;return(0,s.kt)(Ese,(0,p.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ose.isMDXComponent=!0;const Gse={toc:[]},Fse="wrapper";function Bse(t){let{components:e,...n}=t;return(0,s.kt)(Fse,(0,p.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}Bse.isMDXComponent=!0;const Use={toc:[]},Vse="wrapper";function qse(t){let{components:e,...n}=t;return(0,s.kt)(Vse,(0,p.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qse.isMDXComponent=!0;const jse={toc:[]},Yse="wrapper";function Hse(t){let{components:e,...n}=t;return(0,s.kt)(Yse,(0,p.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Hse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Jse(t){let{components:e,...n}=t;return(0,s.kt)($se,(0,p.Z)({},Qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Jse.isMDXComponent=!0;const Kse={toc:[]},tce="wrapper";function ece(t){let{components:e,...n}=t;return(0,s.kt)(tce,(0,p.Z)({},Kse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ece.isMDXComponent=!0;const nce={toc:[]},oce="wrapper";function pce(t){let{components:e,...n}=t;return(0,s.kt)(oce,(0,p.Z)({},nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pce.isMDXComponent=!0;const rce={toc:[]},sce="wrapper";function cce(t){let{components:e,...n}=t;return(0,s.kt)(sce,(0,p.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}cce.isMDXComponent=!0;const ice={toc:[]},ace="wrapper";function lce(t){let{components:e,...n}=t;return(0,s.kt)(ace,(0,p.Z)({},ice,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}lce.isMDXComponent=!0;const uce={toc:[]},mce="wrapper";function dce(t){let{components:e,...n}=t;return(0,s.kt)(mce,(0,p.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}dce.isMDXComponent=!0;const hce={toc:[]},fce="wrapper";function kce(t){let{components:e,...n}=t;return(0,s.kt)(fce,(0,p.Z)({},hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}kce.isMDXComponent=!0;const yce={toc:[]},Dce="wrapper";function Mce(t){let{components:e,...n}=t;return(0,s.kt)(Dce,(0,p.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Mce.isMDXComponent=!0;const Xce={toc:[]},_ce="wrapper";function wce(t){let{components:e,...n}=t;return(0,s.kt)(_ce,(0,p.Z)({},Xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}wce.isMDXComponent=!0;const Tce={toc:[]},gce="wrapper";function Cce(t){let{components:e,...n}=t;return(0,s.kt)(gce,(0,p.Z)({},Tce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Cce.isMDXComponent=!0;const xce={toc:[]},vce="wrapper";function Lce(t){let{components:e,...n}=t;return(0,s.kt)(vce,(0,p.Z)({},xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Lce.isMDXComponent=!0;const Zce={toc:[]},bce="wrapper";function Nce(t){let{components:e,...n}=t;return(0,s.kt)(bce,(0,p.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Nce.isMDXComponent=!0;const Ace={toc:[]},zce="wrapper";function Wce(t){let{components:e,...n}=t;return(0,s.kt)(zce,(0,p.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Sce(t){let{components:e,...n}=t;return(0,s.kt)(Rce,(0,p.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Sce.isMDXComponent=!0;const Pce={toc:[]},Ece="wrapper";function Oce(t){let{components:e,...n}=t;return(0,s.kt)(Ece,(0,p.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Oce.isMDXComponent=!0;const Gce={toc:[]},Fce="wrapper";function Bce(t){let{components:e,...n}=t;return(0,s.kt)(Fce,(0,p.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Bce.isMDXComponent=!0;const Uce={toc:[]},Vce="wrapper";function qce(t){let{components:e,...n}=t;return(0,s.kt)(Vce,(0,p.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qce.isMDXComponent=!0;const jce={toc:[]},Yce="wrapper";function Hce(t){let{components:e,...n}=t;return(0,s.kt)(Yce,(0,p.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Hce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Jce(t){let{components:e,...n}=t;return(0,s.kt)($ce,(0,p.Z)({},Qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Jce.isMDXComponent=!0;const Kce={toc:[]},tie="wrapper";function eie(t){let{components:e,...n}=t;return(0,s.kt)(tie,(0,p.Z)({},Kce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}eie.isMDXComponent=!0;const nie={toc:[]},oie="wrapper";function pie(t){let{components:e,...n}=t;return(0,s.kt)(oie,(0,p.Z)({},nie,n,{components:e,mdxType:"MDXLayout"}))}pie.isMDXComponent=!0;const rie={toc:[]},sie="wrapper";function cie(t){let{components:e,...n}=t;return(0,s.kt)(sie,(0,p.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}cie.isMDXComponent=!0;const iie={toc:[]},aie="wrapper";function lie(t){let{components:e,...n}=t;return(0,s.kt)(aie,(0,p.Z)({},iie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}lie.isMDXComponent=!0;const uie={toc:[]},mie="wrapper";function die(t){let{components:e,...n}=t;return(0,s.kt)(mie,(0,p.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}die.isMDXComponent=!0;const hie={toc:[]},fie="wrapper";function kie(t){let{components:e,...n}=t;return(0,s.kt)(fie,(0,p.Z)({},hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}kie.isMDXComponent=!0;const yie={toc:[]},Die="wrapper";function Mie(t){let{components:e,...n}=t;return(0,s.kt)(Die,(0,p.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mie.isMDXComponent=!0;const Xie={toc:[]},_ie="wrapper";function wie(t){let{components:e,...n}=t;return(0,s.kt)(_ie,(0,p.Z)({},Xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wie.isMDXComponent=!0;const Tie={toc:[]},gie="wrapper";function Cie(t){let{components:e,...n}=t;return(0,s.kt)(gie,(0,p.Z)({},Tie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Cie.isMDXComponent=!0;const xie={toc:[]},vie="wrapper";function Lie(t){let{components:e,...n}=t;return(0,s.kt)(vie,(0,p.Z)({},xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lie.isMDXComponent=!0;const Zie={toc:[]},bie="wrapper";function Nie(t){let{components:e,...n}=t;return(0,s.kt)(bie,(0,p.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Nie.isMDXComponent=!0;const Aie={toc:[]},zie="wrapper";function Wie(t){let{components:e,...n}=t;return(0,s.kt)(zie,(0,p.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Wie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Sie(t){let{components:e,...n}=t;return(0,s.kt)(Rie,(0,p.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Sie.isMDXComponent=!0;const Pie={toc:[]},Eie="wrapper";function Oie(t){let{components:e,...n}=t;return(0,s.kt)(Eie,(0,p.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Oie.isMDXComponent=!0;const Gie={toc:[]},Fie="wrapper";function Bie(t){let{components:e,...n}=t;return(0,s.kt)(Fie,(0,p.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Bie.isMDXComponent=!0;const Uie={toc:[]},Vie="wrapper";function qie(t){let{components:e,...n}=t;return(0,s.kt)(Vie,(0,p.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qie.isMDXComponent=!0;const jie={toc:[]},Yie="wrapper";function Hie(t){let{components:e,...n}=t;return(0,s.kt)(Yie,(0,p.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Jie(t){let{components:e,...n}=t;return(0,s.kt)($ie,(0,p.Z)({},Qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Jie.isMDXComponent=!0;const Kie={toc:[]},tae="wrapper";function eae(t){let{components:e,...n}=t;return(0,s.kt)(tae,(0,p.Z)({},Kie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}eae.isMDXComponent=!0;const nae={toc:[]},oae="wrapper";function pae(t){let{components:e,...n}=t;return(0,s.kt)(oae,(0,p.Z)({},nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}pae.isMDXComponent=!0;const rae={toc:[]},sae="wrapper";function cae(t){let{components:e,...n}=t;return(0,s.kt)(sae,(0,p.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cae.isMDXComponent=!0;const iae={toc:[]},aae="wrapper";function lae(t){let{components:e,...n}=t;return(0,s.kt)(aae,(0,p.Z)({},iae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lae.isMDXComponent=!0;const uae={toc:[]},mae="wrapper";function dae(t){let{components:e,...n}=t;return(0,s.kt)(mae,(0,p.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}dae.isMDXComponent=!0;const hae={toc:[]},fae="wrapper";function kae(t){let{components:e,...n}=t;return(0,s.kt)(fae,(0,p.Z)({},hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}kae.isMDXComponent=!0;const yae={toc:[]},Dae="wrapper";function Mae(t){let{components:e,...n}=t;return(0,s.kt)(Dae,(0,p.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Mae.isMDXComponent=!0;const Xae={toc:[]},_ae="wrapper";function wae(t){let{components:e,...n}=t;return(0,s.kt)(_ae,(0,p.Z)({},Xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wae.isMDXComponent=!0;const Tae={toc:[]},gae="wrapper";function Cae(t){let{components:e,...n}=t;return(0,s.kt)(gae,(0,p.Z)({},Tae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Cae.isMDXComponent=!0;const xae={toc:[]},vae="wrapper";function Lae(t){let{components:e,...n}=t;return(0,s.kt)(vae,(0,p.Z)({},xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lae.isMDXComponent=!0;const Zae={toc:[]},bae="wrapper";function Nae(t){let{components:e,...n}=t;return(0,s.kt)(bae,(0,p.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Nae.isMDXComponent=!0;const Aae={toc:[]},zae="wrapper";function Wae(t){let{components:e,...n}=t;return(0,s.kt)(zae,(0,p.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Sae(t){let{components:e,...n}=t;return(0,s.kt)(Rae,(0,p.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Sae.isMDXComponent=!0;const Pae={toc:[]},Eae="wrapper";function Oae(t){let{components:e,...n}=t;return(0,s.kt)(Eae,(0,p.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Oae.isMDXComponent=!0;const Gae={toc:[]},Fae="wrapper";function Bae(t){let{components:e,...n}=t;return(0,s.kt)(Fae,(0,p.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Bae.isMDXComponent=!0;const Uae={toc:[]},Vae="wrapper";function qae(t){let{components:e,...n}=t;return(0,s.kt)(Vae,(0,p.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}qae.isMDXComponent=!0;const jae={toc:[]},Yae="wrapper";function Hae(t){let{components:e,...n}=t;return(0,s.kt)(Yae,(0,p.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Hae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Jae(t){let{components:e,...n}=t;return(0,s.kt)($ae,(0,p.Z)({},Qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Jae.isMDXComponent=!0;const Kae={toc:[]},tle="wrapper";function ele(t){let{components:e,...n}=t;return(0,s.kt)(tle,(0,p.Z)({},Kae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ele.isMDXComponent=!0;const nle={toc:[]},ole="wrapper";function ple(t){let{components:e,...n}=t;return(0,s.kt)(ole,(0,p.Z)({},nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ple.isMDXComponent=!0;const rle={toc:[]},sle="wrapper";function cle(t){let{components:e,...n}=t;return(0,s.kt)(sle,(0,p.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cle.isMDXComponent=!0;const ile={toc:[]},ale="wrapper";function lle(t){let{components:e,...n}=t;return(0,s.kt)(ale,(0,p.Z)({},ile,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lle.isMDXComponent=!0;const ule={toc:[]},mle="wrapper";function dle(t){let{components:e,...n}=t;return(0,s.kt)(mle,(0,p.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dle.isMDXComponent=!0;const hle={toc:[]},fle="wrapper";function kle(t){let{components:e,...n}=t;return(0,s.kt)(fle,(0,p.Z)({},hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kle.isMDXComponent=!0;const yle={toc:[]},Dle="wrapper";function Mle(t){let{components:e,...n}=t;return(0,s.kt)(Dle,(0,p.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Mle.isMDXComponent=!0;const Xle={toc:[]},_le="wrapper";function wle(t){let{components:e,...n}=t;return(0,s.kt)(_le,(0,p.Z)({},Xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wle.isMDXComponent=!0;const Tle={toc:[]},gle="wrapper";function Cle(t){let{components:e,...n}=t;return(0,s.kt)(gle,(0,p.Z)({},Tle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Cle.isMDXComponent=!0;const xle={toc:[]},vle="wrapper";function Lle(t){let{components:e,...n}=t;return(0,s.kt)(vle,(0,p.Z)({},xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lle.isMDXComponent=!0;const Zle={toc:[]},ble="wrapper";function Nle(t){let{components:e,...n}=t;return(0,s.kt)(ble,(0,p.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Nle.isMDXComponent=!0;const Ale={toc:[]},zle="wrapper";function Wle(t){let{components:e,...n}=t;return(0,s.kt)(zle,(0,p.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wle.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Sle(t){let{components:e,...n}=t;return(0,s.kt)(Rle,(0,p.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Sle.isMDXComponent=!0;const Ple={toc:[]},Ele="wrapper";function Ole(t){let{components:e,...n}=t;return(0,s.kt)(Ele,(0,p.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ole.isMDXComponent=!0;const Gle={toc:[]},Fle="wrapper";function Ble(t){let{components:e,...n}=t;return(0,s.kt)(Fle,(0,p.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ble.isMDXComponent=!0;const Ule={toc:[]},Vle="wrapper";function qle(t){let{components:e,...n}=t;return(0,s.kt)(Vle,(0,p.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qle.isMDXComponent=!0;const jle={toc:[]},Yle="wrapper";function Hle(t){let{components:e,...n}=t;return(0,s.kt)(Yle,(0,p.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Hle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Jle(t){let{components:e,...n}=t;return(0,s.kt)($le,(0,p.Z)({},Qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Jle.isMDXComponent=!0;const Kle={toc:[]},tue="wrapper";function eue(t){let{components:e,...n}=t;return(0,s.kt)(tue,(0,p.Z)({},Kle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eue.isMDXComponent=!0;const nue={toc:[]},oue="wrapper";function pue(t){let{components:e,...n}=t;return(0,s.kt)(oue,(0,p.Z)({},nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pue.isMDXComponent=!0;const rue={toc:[]},sue="wrapper";function cue(t){let{components:e,...n}=t;return(0,s.kt)(sue,(0,p.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cue.isMDXComponent=!0;const iue={toc:[]},aue="wrapper";function lue(t){let{components:e,...n}=t;return(0,s.kt)(aue,(0,p.Z)({},iue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}lue.isMDXComponent=!0;const uue={toc:[]},mue="wrapper";function due(t){let{components:e,...n}=t;return(0,s.kt)(mue,(0,p.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}due.isMDXComponent=!0;const hue={toc:[]},fue="wrapper";function kue(t){let{components:e,...n}=t;return(0,s.kt)(fue,(0,p.Z)({},hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kue.isMDXComponent=!0;const yue={toc:[]},Due="wrapper";function Mue(t){let{components:e,...n}=t;return(0,s.kt)(Due,(0,p.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Mue.isMDXComponent=!0;const Xue={toc:[]},_ue="wrapper";function wue(t){let{components:e,...n}=t;return(0,s.kt)(_ue,(0,p.Z)({},Xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wue.isMDXComponent=!0;const Tue={toc:[]},gue="wrapper";function Cue(t){let{components:e,...n}=t;return(0,s.kt)(gue,(0,p.Z)({},Tue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Cue.isMDXComponent=!0;const xue={toc:[]},vue="wrapper";function Lue(t){let{components:e,...n}=t;return(0,s.kt)(vue,(0,p.Z)({},xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Lue.isMDXComponent=!0;const Zue={toc:[]},bue="wrapper";function Nue(t){let{components:e,...n}=t;return(0,s.kt)(bue,(0,p.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Nue.isMDXComponent=!0;const Aue={toc:[]},zue="wrapper";function Wue(t){let{components:e,...n}=t;return(0,s.kt)(zue,(0,p.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Wue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Sue(t){let{components:e,...n}=t;return(0,s.kt)(Rue,(0,p.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Sue.isMDXComponent=!0;const Pue={toc:[]},Eue="wrapper";function Oue(t){let{components:e,...n}=t;return(0,s.kt)(Eue,(0,p.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Oue.isMDXComponent=!0;const Gue={toc:[]},Fue="wrapper";function Bue(t){let{components:e,...n}=t;return(0,s.kt)(Fue,(0,p.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Bue.isMDXComponent=!0;const Uue={toc:[]},Vue="wrapper";function que(t){let{components:e,...n}=t;return(0,s.kt)(Vue,(0,p.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}que.isMDXComponent=!0;const jue={toc:[]},Yue="wrapper";function Hue(t){let{components:e,...n}=t;return(0,s.kt)(Yue,(0,p.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Hue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Jue(t){let{components:e,...n}=t;return(0,s.kt)($ue,(0,p.Z)({},Que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Jue.isMDXComponent=!0;const Kue={toc:[]},tme="wrapper";function eme(t){let{components:e,...n}=t;return(0,s.kt)(tme,(0,p.Z)({},Kue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eme.isMDXComponent=!0;const nme={toc:[]},ome="wrapper";function pme(t){let{components:e,...n}=t;return(0,s.kt)(ome,(0,p.Z)({},nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pme.isMDXComponent=!0;const rme={toc:[]},sme="wrapper";function cme(t){let{components:e,...n}=t;return(0,s.kt)(sme,(0,p.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cme.isMDXComponent=!0;const ime={toc:[]},ame="wrapper";function lme(t){let{components:e,...n}=t;return(0,s.kt)(ame,(0,p.Z)({},ime,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lme.isMDXComponent=!0;const ume={toc:[]},mme="wrapper";function dme(t){let{components:e,...n}=t;return(0,s.kt)(mme,(0,p.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dme.isMDXComponent=!0;const hme={toc:[]},fme="wrapper";function kme(t){let{components:e,...n}=t;return(0,s.kt)(fme,(0,p.Z)({},hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kme.isMDXComponent=!0;const yme={toc:[]},Dme="wrapper";function Mme(t){let{components:e,...n}=t;return(0,s.kt)(Dme,(0,p.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mme.isMDXComponent=!0;const Xme={toc:[]},_me="wrapper";function wme(t){let{components:e,...n}=t;return(0,s.kt)(_me,(0,p.Z)({},Xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wme.isMDXComponent=!0;const Tme={toc:[]},gme="wrapper";function Cme(t){let{components:e,...n}=t;return(0,s.kt)(gme,(0,p.Z)({},Tme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Cme.isMDXComponent=!0;const xme={toc:[]},vme="wrapper";function Lme(t){let{components:e,...n}=t;return(0,s.kt)(vme,(0,p.Z)({},xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Lme.isMDXComponent=!0;const Zme={toc:[]},bme="wrapper";function Nme(t){let{components:e,...n}=t;return(0,s.kt)(bme,(0,p.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Nme.isMDXComponent=!0;const Ame={toc:[]},zme="wrapper";function Wme(t){let{components:e,...n}=t;return(0,s.kt)(zme,(0,p.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Sme(t){let{components:e,...n}=t;return(0,s.kt)(Rme,(0,p.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Sme.isMDXComponent=!0;const Pme={toc:[]},Eme="wrapper";function Ome(t){let{components:e,...n}=t;return(0,s.kt)(Eme,(0,p.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ome.isMDXComponent=!0;const Gme={toc:[]},Fme="wrapper";function Bme(t){let{components:e,...n}=t;return(0,s.kt)(Fme,(0,p.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bme.isMDXComponent=!0;const Ume={toc:[]},Vme="wrapper";function qme(t){let{components:e,...n}=t;return(0,s.kt)(Vme,(0,p.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qme.isMDXComponent=!0;const jme={toc:[]},Yme="wrapper";function Hme(t){let{components:e,...n}=t;return(0,s.kt)(Yme,(0,p.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Hme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Jme(t){let{components:e,...n}=t;return(0,s.kt)($me,(0,p.Z)({},Qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Jme.isMDXComponent=!0;const Kme={toc:[]},tde="wrapper";function ede(t){let{components:e,...n}=t;return(0,s.kt)(tde,(0,p.Z)({},Kme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ede.isMDXComponent=!0;const nde={toc:[]},ode="wrapper";function pde(t){let{components:e,...n}=t;return(0,s.kt)(ode,(0,p.Z)({},nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}pde.isMDXComponent=!0;const rde={toc:[]},sde="wrapper";function cde(t){let{components:e,...n}=t;return(0,s.kt)(sde,(0,p.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cde.isMDXComponent=!0;const ide={toc:[]},ade="wrapper";function lde(t){let{components:e,...n}=t;return(0,s.kt)(ade,(0,p.Z)({},ide,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}lde.isMDXComponent=!0;const ude={toc:[]},mde="wrapper";function dde(t){let{components:e,...n}=t;return(0,s.kt)(mde,(0,p.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dde.isMDXComponent=!0;const hde={toc:[]},fde="wrapper";function kde(t){let{components:e,...n}=t;return(0,s.kt)(fde,(0,p.Z)({},hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kde.isMDXComponent=!0;const yde={toc:[]},Dde="wrapper";function Mde(t){let{components:e,...n}=t;return(0,s.kt)(Dde,(0,p.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mde.isMDXComponent=!0;const Xde={toc:[]},_de="wrapper";function wde(t){let{components:e,...n}=t;return(0,s.kt)(_de,(0,p.Z)({},Xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wde.isMDXComponent=!0;const Tde={toc:[]},gde="wrapper";function Cde(t){let{components:e,...n}=t;return(0,s.kt)(gde,(0,p.Z)({},Tde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Cde.isMDXComponent=!0;const xde={toc:[]},vde="wrapper";function Lde(t){let{components:e,...n}=t;return(0,s.kt)(vde,(0,p.Z)({},xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Lde.isMDXComponent=!0;const Zde={toc:[]},bde="wrapper";function Nde(t){let{components:e,...n}=t;return(0,s.kt)(bde,(0,p.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Nde.isMDXComponent=!0;const Ade={toc:[]},zde="wrapper";function Wde(t){let{components:e,...n}=t;return(0,s.kt)(zde,(0,p.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Sde(t){let{components:e,...n}=t;return(0,s.kt)(Rde,(0,p.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Sde.isMDXComponent=!0;const Pde={toc:[]},Ede="wrapper";function Ode(t){let{components:e,...n}=t;return(0,s.kt)(Ede,(0,p.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ode.isMDXComponent=!0;const Gde={toc:[]},Fde="wrapper";function Bde(t){let{components:e,...n}=t;return(0,s.kt)(Fde,(0,p.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Bde.isMDXComponent=!0;const Ude={toc:[]},Vde="wrapper";function qde(t){let{components:e,...n}=t;return(0,s.kt)(Vde,(0,p.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qde.isMDXComponent=!0;const jde={toc:[]},Yde="wrapper";function Hde(t){let{components:e,...n}=t;return(0,s.kt)(Yde,(0,p.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Hde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Jde(t){let{components:e,...n}=t;return(0,s.kt)($de,(0,p.Z)({},Qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Jde.isMDXComponent=!0;const Kde={toc:[]},the="wrapper";function ehe(t){let{components:e,...n}=t;return(0,s.kt)(the,(0,p.Z)({},Kde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ehe.isMDXComponent=!0;const nhe={toc:[]},ohe="wrapper";function phe(t){let{components:e,...n}=t;return(0,s.kt)(ohe,(0,p.Z)({},nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}phe.isMDXComponent=!0;const rhe={toc:[]},she="wrapper";function che(t){let{components:e,...n}=t;return(0,s.kt)(she,(0,p.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}che.isMDXComponent=!0;const ihe={toc:[]},ahe="wrapper";function lhe(t){let{components:e,...n}=t;return(0,s.kt)(ahe,(0,p.Z)({},ihe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lhe.isMDXComponent=!0;const uhe={toc:[]},mhe="wrapper";function dhe(t){let{components:e,...n}=t;return(0,s.kt)(mhe,(0,p.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dhe.isMDXComponent=!0;const hhe={toc:[]},fhe="wrapper";function khe(t){let{components:e,...n}=t;return(0,s.kt)(fhe,(0,p.Z)({},hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}khe.isMDXComponent=!0;const yhe={toc:[]},Dhe="wrapper";function Mhe(t){let{components:e,...n}=t;return(0,s.kt)(Dhe,(0,p.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mhe.isMDXComponent=!0;const Xhe={toc:[]},_he="wrapper";function whe(t){let{components:e,...n}=t;return(0,s.kt)(_he,(0,p.Z)({},Xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}whe.isMDXComponent=!0;const The={toc:[]},ghe="wrapper";function Che(t){let{components:e,...n}=t;return(0,s.kt)(ghe,(0,p.Z)({},The,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Che.isMDXComponent=!0;const xhe={toc:[]},vhe="wrapper";function Lhe(t){let{components:e,...n}=t;return(0,s.kt)(vhe,(0,p.Z)({},xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]},bhe="wrapper";function Nhe(t){let{components:e,...n}=t;return(0,s.kt)(bhe,(0,p.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nhe.isMDXComponent=!0;const Ahe={toc:[]},zhe="wrapper";function Whe(t){let{components:e,...n}=t;return(0,s.kt)(zhe,(0,p.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Whe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function She(t){let{components:e,...n}=t;return(0,s.kt)(Rhe,(0,p.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}She.isMDXComponent=!0;const Phe={toc:[]},Ehe="wrapper";function Ohe(t){let{components:e,...n}=t;return(0,s.kt)(Ehe,(0,p.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ohe.isMDXComponent=!0;const Ghe={toc:[]},Fhe="wrapper";function Bhe(t){let{components:e,...n}=t;return(0,s.kt)(Fhe,(0,p.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bhe.isMDXComponent=!0;const Uhe={toc:[]},Vhe="wrapper";function qhe(t){let{components:e,...n}=t;return(0,s.kt)(Vhe,(0,p.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Yhe="wrapper";function Hhe(t){let{components:e,...n}=t;return(0,s.kt)(Yhe,(0,p.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Jhe(t){let{components:e,...n}=t;return(0,s.kt)($he,(0,p.Z)({},Qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Jhe.isMDXComponent=!0;const Khe={toc:[]},tfe="wrapper";function efe(t){let{components:e,...n}=t;return(0,s.kt)(tfe,(0,p.Z)({},Khe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}efe.isMDXComponent=!0;const nfe={toc:[]},ofe="wrapper";function pfe(t){let{components:e,...n}=t;return(0,s.kt)(ofe,(0,p.Z)({},nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pfe.isMDXComponent=!0;const rfe={toc:[]},sfe="wrapper";function cfe(t){let{components:e,...n}=t;return(0,s.kt)(sfe,(0,p.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cfe.isMDXComponent=!0;const ife={toc:[]},afe="wrapper";function lfe(t){let{components:e,...n}=t;return(0,s.kt)(afe,(0,p.Z)({},ife,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lfe.isMDXComponent=!0;const ufe={toc:[]},mfe="wrapper";function dfe(t){let{components:e,...n}=t;return(0,s.kt)(mfe,(0,p.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dfe.isMDXComponent=!0;const hfe={toc:[]},ffe="wrapper";function kfe(t){let{components:e,...n}=t;return(0,s.kt)(ffe,(0,p.Z)({},hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}kfe.isMDXComponent=!0;const yfe={toc:[]},Dfe="wrapper";function Mfe(t){let{components:e,...n}=t;return(0,s.kt)(Dfe,(0,p.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Mfe.isMDXComponent=!0;const Xfe={toc:[]},_fe="wrapper";function wfe(t){let{components:e,...n}=t;return(0,s.kt)(_fe,(0,p.Z)({},Xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wfe.isMDXComponent=!0;const Tfe={toc:[]},gfe="wrapper";function Cfe(t){let{components:e,...n}=t;return(0,s.kt)(gfe,(0,p.Z)({},Tfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}Cfe.isMDXComponent=!0;const xfe={toc:[]},vfe="wrapper";function Lfe(t){let{components:e,...n}=t;return(0,s.kt)(vfe,(0,p.Z)({},xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]},bfe="wrapper";function Nfe(t){let{components:e,...n}=t;return(0,s.kt)(bfe,(0,p.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nfe.isMDXComponent=!0;const Afe={toc:[]},zfe="wrapper";function Wfe(t){let{components:e,...n}=t;return(0,s.kt)(zfe,(0,p.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Wfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Sfe(t){let{components:e,...n}=t;return(0,s.kt)(Rfe,(0,p.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Sfe.isMDXComponent=!0;const Pfe={toc:[]},Efe="wrapper";function Ofe(t){let{components:e,...n}=t;return(0,s.kt)(Efe,(0,p.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ofe.isMDXComponent=!0;const Gfe={toc:[]},Ffe="wrapper";function Bfe(t){let{components:e,...n}=t;return(0,s.kt)(Ffe,(0,p.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Bfe.isMDXComponent=!0;const Ufe={toc:[]},Vfe="wrapper";function qfe(t){let{components:e,...n}=t;return(0,s.kt)(Vfe,(0,p.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Yfe="wrapper";function Hfe(t){let{components:e,...n}=t;return(0,s.kt)(Yfe,(0,p.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Hfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Jfe(t){let{components:e,...n}=t;return(0,s.kt)($fe,(0,p.Z)({},Qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Jfe.isMDXComponent=!0;const Kfe={toc:[]},tke="wrapper";function eke(t){let{components:e,...n}=t;return(0,s.kt)(tke,(0,p.Z)({},Kfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}eke.isMDXComponent=!0;const nke={toc:[]},oke="wrapper";function pke(t){let{components:e,...n}=t;return(0,s.kt)(oke,(0,p.Z)({},nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}pke.isMDXComponent=!0;const rke={toc:[]},ske="wrapper";function cke(t){let{components:e,...n}=t;return(0,s.kt)(ske,(0,p.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}cke.isMDXComponent=!0;const ike={toc:[]},ake="wrapper";function lke(t){let{components:e,...n}=t;return(0,s.kt)(ake,(0,p.Z)({},ike,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lke.isMDXComponent=!0;const uke={toc:[]},mke="wrapper";function dke(t){let{components:e,...n}=t;return(0,s.kt)(mke,(0,p.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}dke.isMDXComponent=!0;const hke={toc:[]},fke="wrapper";function kke(t){let{components:e,...n}=t;return(0,s.kt)(fke,(0,p.Z)({},hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kke.isMDXComponent=!0;const yke={toc:[]},Dke="wrapper";function Mke(t){let{components:e,...n}=t;return(0,s.kt)(Dke,(0,p.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Mke.isMDXComponent=!0;const Xke={toc:[]},_ke="wrapper";function wke(t){let{components:e,...n}=t;return(0,s.kt)(_ke,(0,p.Z)({},Xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wke.isMDXComponent=!0;const Tke={toc:[]},gke="wrapper";function Cke(t){let{components:e,...n}=t;return(0,s.kt)(gke,(0,p.Z)({},Tke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Cke.isMDXComponent=!0;const xke={toc:[]},vke="wrapper";function Lke(t){let{components:e,...n}=t;return(0,s.kt)(vke,(0,p.Z)({},xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lke.isMDXComponent=!0;const Zke={toc:[]},bke="wrapper";function Nke(t){let{components:e,...n}=t;return(0,s.kt)(bke,(0,p.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Nke.isMDXComponent=!0;const Ake={toc:[]},zke="wrapper";function Wke(t){let{components:e,...n}=t;return(0,s.kt)(zke,(0,p.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Wke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Ske(t){let{components:e,...n}=t;return(0,s.kt)(Rke,(0,p.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ske.isMDXComponent=!0;const Pke={toc:[]},Eke="wrapper";function Oke(t){let{components:e,...n}=t;return(0,s.kt)(Eke,(0,p.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Oke.isMDXComponent=!0;const Gke={toc:[]},Fke="wrapper";function Bke(t){let{components:e,...n}=t;return(0,s.kt)(Fke,(0,p.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Bke.isMDXComponent=!0;const Uke={toc:[]},Vke="wrapper";function qke(t){let{components:e,...n}=t;return(0,s.kt)(Vke,(0,p.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qke.isMDXComponent=!0;const jke={toc:[]},Yke="wrapper";function Hke(t){let{components:e,...n}=t;return(0,s.kt)(Yke,(0,p.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Hke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Jke(t){let{components:e,...n}=t;return(0,s.kt)($ke,(0,p.Z)({},Qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Jke.isMDXComponent=!0;const Kke={toc:[]},tye="wrapper";function eye(t){let{components:e,...n}=t;return(0,s.kt)(tye,(0,p.Z)({},Kke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eye.isMDXComponent=!0;const nye={toc:[]},oye="wrapper";function pye(t){let{components:e,...n}=t;return(0,s.kt)(oye,(0,p.Z)({},nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pye.isMDXComponent=!0;const rye={toc:[]},sye="wrapper";function cye(t){let{components:e,...n}=t;return(0,s.kt)(sye,(0,p.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cye.isMDXComponent=!0;const iye={toc:[]},aye="wrapper";function lye(t){let{components:e,...n}=t;return(0,s.kt)(aye,(0,p.Z)({},iye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lye.isMDXComponent=!0;const uye={toc:[]},mye="wrapper";function dye(t){let{components:e,...n}=t;return(0,s.kt)(mye,(0,p.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dye.isMDXComponent=!0;const hye={toc:[]},fye="wrapper";function kye(t){let{components:e,...n}=t;return(0,s.kt)(fye,(0,p.Z)({},hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kye.isMDXComponent=!0;const yye={toc:[]},Dye="wrapper";function Mye(t){let{components:e,...n}=t;return(0,s.kt)(Dye,(0,p.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Mye.isMDXComponent=!0;const Xye={toc:[]},_ye="wrapper";function wye(t){let{components:e,...n}=t;return(0,s.kt)(_ye,(0,p.Z)({},Xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}wye.isMDXComponent=!0;const Tye={toc:[]},gye="wrapper";function Cye(t){let{components:e,...n}=t;return(0,s.kt)(gye,(0,p.Z)({},Tye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Cye.isMDXComponent=!0;const xye={toc:[]},vye="wrapper";function Lye(t){let{components:e,...n}=t;return(0,s.kt)(vye,(0,p.Z)({},xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Lye.isMDXComponent=!0;const Zye={toc:[]},bye="wrapper";function Nye(t){let{components:e,...n}=t;return(0,s.kt)(bye,(0,p.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Nye.isMDXComponent=!0;const Aye={toc:[]},zye="wrapper";function Wye(t){let{components:e,...n}=t;return(0,s.kt)(zye,(0,p.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Sye(t){let{components:e,...n}=t;return(0,s.kt)(Rye,(0,p.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Sye.isMDXComponent=!0;const Pye={toc:[]},Eye="wrapper";function Oye(t){let{components:e,...n}=t;return(0,s.kt)(Eye,(0,p.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Oye.isMDXComponent=!0;const Gye={toc:[]},Fye="wrapper";function Bye(t){let{components:e,...n}=t;return(0,s.kt)(Fye,(0,p.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bye.isMDXComponent=!0;const Uye={toc:[]},Vye="wrapper";function qye(t){let{components:e,...n}=t;return(0,s.kt)(Vye,(0,p.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qye.isMDXComponent=!0;const jye={toc:[]},Yye="wrapper";function Hye(t){let{components:e,...n}=t;return(0,s.kt)(Yye,(0,p.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Jye(t){let{components:e,...n}=t;return(0,s.kt)($ye,(0,p.Z)({},Qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jye.isMDXComponent=!0;const Kye={toc:[]},tDe="wrapper";function eDe(t){let{components:e,...n}=t;return(0,s.kt)(tDe,(0,p.Z)({},Kye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}eDe.isMDXComponent=!0;const nDe={toc:[]},oDe="wrapper";function pDe(t){let{components:e,...n}=t;return(0,s.kt)(oDe,(0,p.Z)({},nDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pDe.isMDXComponent=!0;const rDe={toc:[]},sDe="wrapper";function cDe(t){let{components:e,...n}=t;return(0,s.kt)(sDe,(0,p.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cDe.isMDXComponent=!0;const iDe={toc:[]},aDe="wrapper";function lDe(t){let{components:e,...n}=t;return(0,s.kt)(aDe,(0,p.Z)({},iDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lDe.isMDXComponent=!0;const uDe={toc:[]},mDe="wrapper";function dDe(t){let{components:e,...n}=t;return(0,s.kt)(mDe,(0,p.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dDe.isMDXComponent=!0;const hDe={toc:[]},fDe="wrapper";function kDe(t){let{components:e,...n}=t;return(0,s.kt)(fDe,(0,p.Z)({},hDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kDe.isMDXComponent=!0;const yDe={toc:[]},DDe="wrapper";function MDe(t){let{components:e,...n}=t;return(0,s.kt)(DDe,(0,p.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}MDe.isMDXComponent=!0;const XDe={toc:[]},_De="wrapper";function wDe(t){let{components:e,...n}=t;return(0,s.kt)(_De,(0,p.Z)({},XDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wDe.isMDXComponent=!0;const TDe={toc:[]},gDe="wrapper";function CDe(t){let{components:e,...n}=t;return(0,s.kt)(gDe,(0,p.Z)({},TDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}CDe.isMDXComponent=!0;const xDe={toc:[]},vDe="wrapper";function LDe(t){let{components:e,...n}=t;return(0,s.kt)(vDe,(0,p.Z)({},xDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}LDe.isMDXComponent=!0;const ZDe={toc:[]},bDe="wrapper";function NDe(t){let{components:e,...n}=t;return(0,s.kt)(bDe,(0,p.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}NDe.isMDXComponent=!0;const ADe={toc:[]},zDe="wrapper";function WDe(t){let{components:e,...n}=t;return(0,s.kt)(zDe,(0,p.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}WDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function SDe(t){let{components:e,...n}=t;return(0,s.kt)(RDe,(0,p.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}SDe.isMDXComponent=!0;const PDe={toc:[]},EDe="wrapper";function ODe(t){let{components:e,...n}=t;return(0,s.kt)(EDe,(0,p.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}ODe.isMDXComponent=!0;const GDe={toc:[]},FDe="wrapper";function BDe(t){let{components:e,...n}=t;return(0,s.kt)(FDe,(0,p.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}))}BDe.isMDXComponent=!0;const UDe={toc:[]},VDe="wrapper";function qDe(t){let{components:e,...n}=t;return(0,s.kt)(VDe,(0,p.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qDe.isMDXComponent=!0;const jDe={toc:[]},YDe="wrapper";function HDe(t){let{components:e,...n}=t;return(0,s.kt)(YDe,(0,p.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}HDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function JDe(t){let{components:e,...n}=t;return(0,s.kt)($De,(0,p.Z)({},QDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}JDe.isMDXComponent=!0;const KDe={toc:[]},tMe="wrapper";function eMe(t){let{components:e,...n}=t;return(0,s.kt)(tMe,(0,p.Z)({},KDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}eMe.isMDXComponent=!0;const nMe={toc:[]},oMe="wrapper";function pMe(t){let{components:e,...n}=t;return(0,s.kt)(oMe,(0,p.Z)({},nMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pMe.isMDXComponent=!0;const rMe={toc:[]},sMe="wrapper";function cMe(t){let{components:e,...n}=t;return(0,s.kt)(sMe,(0,p.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cMe.isMDXComponent=!0;const iMe={toc:[]},aMe="wrapper";function lMe(t){let{components:e,...n}=t;return(0,s.kt)(aMe,(0,p.Z)({},iMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lMe.isMDXComponent=!0;const uMe={toc:[]},mMe="wrapper";function dMe(t){let{components:e,...n}=t;return(0,s.kt)(mMe,(0,p.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dMe.isMDXComponent=!0;const hMe={toc:[]},fMe="wrapper";function kMe(t){let{components:e,...n}=t;return(0,s.kt)(fMe,(0,p.Z)({},hMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kMe.isMDXComponent=!0;const yMe={toc:[]},DMe="wrapper";function MMe(t){let{components:e,...n}=t;return(0,s.kt)(DMe,(0,p.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MMe.isMDXComponent=!0;const XMe={toc:[]},_Me="wrapper";function wMe(t){let{components:e,...n}=t;return(0,s.kt)(_Me,(0,p.Z)({},XMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wMe.isMDXComponent=!0;const TMe={toc:[]},gMe="wrapper";function CMe(t){let{components:e,...n}=t;return(0,s.kt)(gMe,(0,p.Z)({},TMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}CMe.isMDXComponent=!0;const xMe={toc:[]},vMe="wrapper";function LMe(t){let{components:e,...n}=t;return(0,s.kt)(vMe,(0,p.Z)({},xMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LMe.isMDXComponent=!0;const ZMe={toc:[]},bMe="wrapper";function NMe(t){let{components:e,...n}=t;return(0,s.kt)(bMe,(0,p.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NMe.isMDXComponent=!0;const AMe={toc:[]},zMe="wrapper";function WMe(t){let{components:e,...n}=t;return(0,s.kt)(zMe,(0,p.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}WMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function SMe(t){let{components:e,...n}=t;return(0,s.kt)(RMe,(0,p.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}SMe.isMDXComponent=!0;const PMe={toc:[]},EMe="wrapper";function OMe(t){let{components:e,...n}=t;return(0,s.kt)(EMe,(0,p.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}OMe.isMDXComponent=!0;const GMe={toc:[]},FMe="wrapper";function BMe(t){let{components:e,...n}=t;return(0,s.kt)(FMe,(0,p.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}BMe.isMDXComponent=!0;const UMe={toc:[]},VMe="wrapper";function qMe(t){let{components:e,...n}=t;return(0,s.kt)(VMe,(0,p.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qMe.isMDXComponent=!0;const jMe={toc:[]},YMe="wrapper";function HMe(t){let{components:e,...n}=t;return(0,s.kt)(YMe,(0,p.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}HMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function JMe(t){let{components:e,...n}=t;return(0,s.kt)($Me,(0,p.Z)({},QMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}JMe.isMDXComponent=!0;const KMe={toc:[]},tXe="wrapper";function eXe(t){let{components:e,...n}=t;return(0,s.kt)(tXe,(0,p.Z)({},KMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eXe.isMDXComponent=!0;const nXe={toc:[]},oXe="wrapper";function pXe(t){let{components:e,...n}=t;return(0,s.kt)(oXe,(0,p.Z)({},nXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pXe.isMDXComponent=!0;const rXe={toc:[]},sXe="wrapper";function cXe(t){let{components:e,...n}=t;return(0,s.kt)(sXe,(0,p.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cXe.isMDXComponent=!0;const iXe={toc:[]},aXe="wrapper";function lXe(t){let{components:e,...n}=t;return(0,s.kt)(aXe,(0,p.Z)({},iXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}lXe.isMDXComponent=!0;const uXe={toc:[]},mXe="wrapper";function dXe(t){let{components:e,...n}=t;return(0,s.kt)(mXe,(0,p.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dXe.isMDXComponent=!0;const hXe={toc:[]},fXe="wrapper";function kXe(t){let{components:e,...n}=t;return(0,s.kt)(fXe,(0,p.Z)({},hXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kXe.isMDXComponent=!0;const yXe={toc:[]},DXe="wrapper";function MXe(t){let{components:e,...n}=t;return(0,s.kt)(DXe,(0,p.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}MXe.isMDXComponent=!0;const XXe={toc:[]},_Xe="wrapper";function wXe(t){let{components:e,...n}=t;return(0,s.kt)(_Xe,(0,p.Z)({},XXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wXe.isMDXComponent=!0;const TXe={toc:[]},gXe="wrapper";function CXe(t){let{components:e,...n}=t;return(0,s.kt)(gXe,(0,p.Z)({},TXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CXe.isMDXComponent=!0;const xXe={toc:[]},vXe="wrapper";function LXe(t){let{components:e,...n}=t;return(0,s.kt)(vXe,(0,p.Z)({},xXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}LXe.isMDXComponent=!0;const ZXe={toc:[]},bXe="wrapper";function NXe(t){let{components:e,...n}=t;return(0,s.kt)(bXe,(0,p.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}NXe.isMDXComponent=!0;const AXe={toc:[]},zXe="wrapper";function WXe(t){let{components:e,...n}=t;return(0,s.kt)(zXe,(0,p.Z)({},AXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}WXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function SXe(t){let{components:e,...n}=t;return(0,s.kt)(RXe,(0,p.Z)({},IXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}SXe.isMDXComponent=!0;const PXe={toc:[]},EXe="wrapper";function OXe(t){let{components:e,...n}=t;return(0,s.kt)(EXe,(0,p.Z)({},PXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}OXe.isMDXComponent=!0;const GXe={toc:[]},FXe="wrapper";function BXe(t){let{components:e,...n}=t;return(0,s.kt)(FXe,(0,p.Z)({},GXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}BXe.isMDXComponent=!0;const UXe={toc:[]},VXe="wrapper";function qXe(t){let{components:e,...n}=t;return(0,s.kt)(VXe,(0,p.Z)({},UXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qXe.isMDXComponent=!0;const jXe={toc:[]},YXe="wrapper";function HXe(t){let{components:e,...n}=t;return(0,s.kt)(YXe,(0,p.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}HXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function JXe(t){let{components:e,...n}=t;return(0,s.kt)($Xe,(0,p.Z)({},QXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}JXe.isMDXComponent=!0;const KXe={toc:[]},t_e="wrapper";function e_e(t){let{components:e,...n}=t;return(0,s.kt)(t_e,(0,p.Z)({},KXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}e_e.isMDXComponent=!0;const n_e={toc:[]},o_e="wrapper";function p_e(t){let{components:e,...n}=t;return(0,s.kt)(o_e,(0,p.Z)({},n_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p_e.isMDXComponent=!0;const r_e={toc:[]},s_e="wrapper";function c_e(t){let{components:e,...n}=t;return(0,s.kt)(s_e,(0,p.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c_e.isMDXComponent=!0;const i_e={toc:[]},a_e="wrapper";function l_e(t){let{components:e,...n}=t;return(0,s.kt)(a_e,(0,p.Z)({},i_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l_e.isMDXComponent=!0;const u_e={toc:[]},m_e="wrapper";function d_e(t){let{components:e,...n}=t;return(0,s.kt)(m_e,(0,p.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}d_e.isMDXComponent=!0;const h_e={toc:[]},f_e="wrapper";function k_e(t){let{components:e,...n}=t;return(0,s.kt)(f_e,(0,p.Z)({},h_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}k_e.isMDXComponent=!0;const y_e={toc:[]},D_e="wrapper";function M_e(t){let{components:e,...n}=t;return(0,s.kt)(D_e,(0,p.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}M_e.isMDXComponent=!0;const X_e={toc:[]},__e="wrapper";function w_e(t){let{components:e,...n}=t;return(0,s.kt)(__e,(0,p.Z)({},X_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}w_e.isMDXComponent=!0;const T_e={toc:[]},g_e="wrapper";function C_e(t){let{components:e,...n}=t;return(0,s.kt)(g_e,(0,p.Z)({},T_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C_e.isMDXComponent=!0;const x_e={toc:[]},v_e="wrapper";function L_e(t){let{components:e,...n}=t;return(0,s.kt)(v_e,(0,p.Z)({},x_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L_e.isMDXComponent=!0;const Z_e={toc:[]},b_e="wrapper";function N_e(t){let{components:e,...n}=t;return(0,s.kt)(b_e,(0,p.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N_e.isMDXComponent=!0;const A_e={toc:[]},z_e="wrapper";function W_e(t){let{components:e,...n}=t;return(0,s.kt)(z_e,(0,p.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function S_e(t){let{components:e,...n}=t;return(0,s.kt)(R_e,(0,p.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}S_e.isMDXComponent=!0;const P_e={toc:[]},E_e="wrapper";function O_e(t){let{components:e,...n}=t;return(0,s.kt)(E_e,(0,p.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O_e.isMDXComponent=!0;const G_e={toc:[]},F_e="wrapper";function B_e(t){let{components:e,...n}=t;return(0,s.kt)(F_e,(0,p.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B_e.isMDXComponent=!0;const U_e={toc:[]},V_e="wrapper";function q_e(t){let{components:e,...n}=t;return(0,s.kt)(V_e,(0,p.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q_e.isMDXComponent=!0;const j_e={toc:[]},Y_e="wrapper";function H_e(t){let{components:e,...n}=t;return(0,s.kt)(Y_e,(0,p.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}H_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function J_e(t){let{components:e,...n}=t;return(0,s.kt)($_e,(0,p.Z)({},Q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}J_e.isMDXComponent=!0;const K_e={toc:[]},twe="wrapper";function ewe(t){let{components:e,...n}=t;return(0,s.kt)(twe,(0,p.Z)({},K_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ewe.isMDXComponent=!0;const nwe={toc:[]},owe="wrapper";function pwe(t){let{components:e,...n}=t;return(0,s.kt)(owe,(0,p.Z)({},nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pwe.isMDXComponent=!0;const rwe={toc:[]},swe="wrapper";function cwe(t){let{components:e,...n}=t;return(0,s.kt)(swe,(0,p.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cwe.isMDXComponent=!0;const iwe={toc:[]},awe="wrapper";function lwe(t){let{components:e,...n}=t;return(0,s.kt)(awe,(0,p.Z)({},iwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lwe.isMDXComponent=!0;const uwe={toc:[]},mwe="wrapper";function dwe(t){let{components:e,...n}=t;return(0,s.kt)(mwe,(0,p.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dwe.isMDXComponent=!0;const hwe={toc:[]},fwe="wrapper";function kwe(t){let{components:e,...n}=t;return(0,s.kt)(fwe,(0,p.Z)({},hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}kwe.isMDXComponent=!0;const ywe={toc:[]},Dwe="wrapper";function Mwe(t){let{components:e,...n}=t;return(0,s.kt)(Dwe,(0,p.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mwe.isMDXComponent=!0;const Xwe={toc:[]},_we="wrapper";function wwe(t){let{components:e,...n}=t;return(0,s.kt)(_we,(0,p.Z)({},Xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wwe.isMDXComponent=!0;const Twe={toc:[]},gwe="wrapper";function Cwe(t){let{components:e,...n}=t;return(0,s.kt)(gwe,(0,p.Z)({},Twe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Cwe.isMDXComponent=!0;const xwe={toc:[]},vwe="wrapper";function Lwe(t){let{components:e,...n}=t;return(0,s.kt)(vwe,(0,p.Z)({},xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]},bwe="wrapper";function Nwe(t){let{components:e,...n}=t;return(0,s.kt)(bwe,(0,p.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nwe.isMDXComponent=!0;const Awe={toc:[]},zwe="wrapper";function Wwe(t){let{components:e,...n}=t;return(0,s.kt)(zwe,(0,p.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Swe(t){let{components:e,...n}=t;return(0,s.kt)(Rwe,(0,p.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Swe.isMDXComponent=!0;const Pwe={toc:[]},Ewe="wrapper";function Owe(t){let{components:e,...n}=t;return(0,s.kt)(Ewe,(0,p.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Owe.isMDXComponent=!0;const Gwe={toc:[]},Fwe="wrapper";function Bwe(t){let{components:e,...n}=t;return(0,s.kt)(Fwe,(0,p.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bwe.isMDXComponent=!0;const Uwe={toc:[]},Vwe="wrapper";function qwe(t){let{components:e,...n}=t;return(0,s.kt)(Vwe,(0,p.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Ywe="wrapper";function Hwe(t){let{components:e,...n}=t;return(0,s.kt)(Ywe,(0,p.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Hwe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Jwe(t){let{components:e,...n}=t;return(0,s.kt)($we,(0,p.Z)({},Qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Jwe.isMDXComponent=!0;const Kwe={toc:[]},tTe="wrapper";function eTe(t){let{components:e,...n}=t;return(0,s.kt)(tTe,(0,p.Z)({},Kwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}eTe.isMDXComponent=!0;const nTe={toc:[]},oTe="wrapper";function pTe(t){let{components:e,...n}=t;return(0,s.kt)(oTe,(0,p.Z)({},nTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}pTe.isMDXComponent=!0;const rTe={toc:[]},sTe="wrapper";function cTe(t){let{components:e,...n}=t;return(0,s.kt)(sTe,(0,p.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}cTe.isMDXComponent=!0;const iTe={toc:[]},aTe="wrapper";function lTe(t){let{components:e,...n}=t;return(0,s.kt)(aTe,(0,p.Z)({},iTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lTe.isMDXComponent=!0;const uTe={toc:[]},mTe="wrapper";function dTe(t){let{components:e,...n}=t;return(0,s.kt)(mTe,(0,p.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}dTe.isMDXComponent=!0;const hTe={toc:[]},fTe="wrapper";function kTe(t){let{components:e,...n}=t;return(0,s.kt)(fTe,(0,p.Z)({},hTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}kTe.isMDXComponent=!0;const yTe={toc:[]},DTe="wrapper";function MTe(t){let{components:e,...n}=t;return(0,s.kt)(DTe,(0,p.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}MTe.isMDXComponent=!0;const XTe={toc:[]},_Te="wrapper";function wTe(t){let{components:e,...n}=t;return(0,s.kt)(_Te,(0,p.Z)({},XTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wTe.isMDXComponent=!0;const TTe={toc:[]},gTe="wrapper";function CTe(t){let{components:e,...n}=t;return(0,s.kt)(gTe,(0,p.Z)({},TTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}CTe.isMDXComponent=!0;const xTe={toc:[]},vTe="wrapper";function LTe(t){let{components:e,...n}=t;return(0,s.kt)(vTe,(0,p.Z)({},xTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LTe.isMDXComponent=!0;const ZTe={toc:[]},bTe="wrapper";function NTe(t){let{components:e,...n}=t;return(0,s.kt)(bTe,(0,p.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}NTe.isMDXComponent=!0;const ATe={toc:[]},zTe="wrapper";function WTe(t){let{components:e,...n}=t;return(0,s.kt)(zTe,(0,p.Z)({},ATe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}WTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function STe(t){let{components:e,...n}=t;return(0,s.kt)(RTe,(0,p.Z)({},ITe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}STe.isMDXComponent=!0;const PTe={toc:[]},ETe="wrapper";function OTe(t){let{components:e,...n}=t;return(0,s.kt)(ETe,(0,p.Z)({},PTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}OTe.isMDXComponent=!0;const GTe={toc:[]},FTe="wrapper";function BTe(t){let{components:e,...n}=t;return(0,s.kt)(FTe,(0,p.Z)({},GTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}BTe.isMDXComponent=!0;const UTe={toc:[]},VTe="wrapper";function qTe(t){let{components:e,...n}=t;return(0,s.kt)(VTe,(0,p.Z)({},UTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qTe.isMDXComponent=!0;const jTe={toc:[]},YTe="wrapper";function HTe(t){let{components:e,...n}=t;return(0,s.kt)(YTe,(0,p.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}HTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function JTe(t){let{components:e,...n}=t;return(0,s.kt)($Te,(0,p.Z)({},QTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JTe.isMDXComponent=!0;const KTe={toc:[]},tge="wrapper";function ege(t){let{components:e,...n}=t;return(0,s.kt)(tge,(0,p.Z)({},KTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ege.isMDXComponent=!0;const nge={toc:[]},oge="wrapper";function pge(t){let{components:e,...n}=t;return(0,s.kt)(oge,(0,p.Z)({},nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pge.isMDXComponent=!0;const rge={toc:[]},sge="wrapper";function cge(t){let{components:e,...n}=t;return(0,s.kt)(sge,(0,p.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cge.isMDXComponent=!0;const ige={toc:[]},age="wrapper";function lge(t){let{components:e,...n}=t;return(0,s.kt)(age,(0,p.Z)({},ige,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lge.isMDXComponent=!0;const uge={toc:[]},mge="wrapper";function dge(t){let{components:e,...n}=t;return(0,s.kt)(mge,(0,p.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dge.isMDXComponent=!0;const hge={toc:[]},fge="wrapper";function kge(t){let{components:e,...n}=t;return(0,s.kt)(fge,(0,p.Z)({},hge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kge.isMDXComponent=!0;const yge={toc:[]},Dge="wrapper";function Mge(t){let{components:e,...n}=t;return(0,s.kt)(Dge,(0,p.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Mge.isMDXComponent=!0;const Xge={toc:[]},_ge="wrapper";function wge(t){let{components:e,...n}=t;return(0,s.kt)(_ge,(0,p.Z)({},Xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wge.isMDXComponent=!0;const Tge={toc:[]},gge="wrapper";function Cge(t){let{components:e,...n}=t;return(0,s.kt)(gge,(0,p.Z)({},Tge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cge.isMDXComponent=!0;const xge={toc:[]},vge="wrapper";function Lge(t){let{components:e,...n}=t;return(0,s.kt)(vge,(0,p.Z)({},xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lge.isMDXComponent=!0;const Zge={toc:[]},bge="wrapper";function Nge(t){let{components:e,...n}=t;return(0,s.kt)(bge,(0,p.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Nge.isMDXComponent=!0;const Age={toc:[]},zge="wrapper";function Wge(t){let{components:e,...n}=t;return(0,s.kt)(zge,(0,p.Z)({},Age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Sge(t){let{components:e,...n}=t;return(0,s.kt)(Rge,(0,p.Z)({},Ige,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Sge.isMDXComponent=!0;const Pge={toc:[]},Ege="wrapper";function Oge(t){let{components:e,...n}=t;return(0,s.kt)(Ege,(0,p.Z)({},Pge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Oge.isMDXComponent=!0;const Gge={toc:[]},Fge="wrapper";function Bge(t){let{components:e,...n}=t;return(0,s.kt)(Fge,(0,p.Z)({},Gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Bge.isMDXComponent=!0;const Uge={toc:[]},Vge="wrapper";function qge(t){let{components:e,...n}=t;return(0,s.kt)(Vge,(0,p.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qge.isMDXComponent=!0;const jge={toc:[]},Yge="wrapper";function Hge(t){let{components:e,...n}=t;return(0,s.kt)(Yge,(0,p.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Hge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Jge(t){let{components:e,...n}=t;return(0,s.kt)($ge,(0,p.Z)({},Qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Jge.isMDXComponent=!0;const Kge={toc:[]},tCe="wrapper";function eCe(t){let{components:e,...n}=t;return(0,s.kt)(tCe,(0,p.Z)({},Kge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eCe.isMDXComponent=!0;const nCe={toc:[]},oCe="wrapper";function pCe(t){let{components:e,...n}=t;return(0,s.kt)(oCe,(0,p.Z)({},nCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pCe.isMDXComponent=!0;const rCe={toc:[]},sCe="wrapper";function cCe(t){let{components:e,...n}=t;return(0,s.kt)(sCe,(0,p.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cCe.isMDXComponent=!0;const iCe={toc:[]},aCe="wrapper";function lCe(t){let{components:e,...n}=t;return(0,s.kt)(aCe,(0,p.Z)({},iCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lCe.isMDXComponent=!0;const uCe={toc:[]},mCe="wrapper";function dCe(t){let{components:e,...n}=t;return(0,s.kt)(mCe,(0,p.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dCe.isMDXComponent=!0;const hCe={toc:[]},fCe="wrapper";function kCe(t){let{components:e,...n}=t;return(0,s.kt)(fCe,(0,p.Z)({},hCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}kCe.isMDXComponent=!0;const yCe={toc:[]},DCe="wrapper";function MCe(t){let{components:e,...n}=t;return(0,s.kt)(DCe,(0,p.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}MCe.isMDXComponent=!0;const XCe={toc:[]},_Ce="wrapper";function wCe(t){let{components:e,...n}=t;return(0,s.kt)(_Ce,(0,p.Z)({},XCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wCe.isMDXComponent=!0;const TCe={toc:[]},gCe="wrapper";function CCe(t){let{components:e,...n}=t;return(0,s.kt)(gCe,(0,p.Z)({},TCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}CCe.isMDXComponent=!0;const xCe={toc:[]},vCe="wrapper";function LCe(t){let{components:e,...n}=t;return(0,s.kt)(vCe,(0,p.Z)({},xCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}LCe.isMDXComponent=!0;const ZCe={toc:[]},bCe="wrapper";function NCe(t){let{components:e,...n}=t;return(0,s.kt)(bCe,(0,p.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NCe.isMDXComponent=!0;const ACe={toc:[]},zCe="wrapper";function WCe(t){let{components:e,...n}=t;return(0,s.kt)(zCe,(0,p.Z)({},ACe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}WCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function SCe(t){let{components:e,...n}=t;return(0,s.kt)(RCe,(0,p.Z)({},ICe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}SCe.isMDXComponent=!0;const PCe={toc:[]},ECe="wrapper";function OCe(t){let{components:e,...n}=t;return(0,s.kt)(ECe,(0,p.Z)({},PCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}OCe.isMDXComponent=!0;const GCe={toc:[]},FCe="wrapper";function BCe(t){let{components:e,...n}=t;return(0,s.kt)(FCe,(0,p.Z)({},GCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BCe.isMDXComponent=!0;const UCe={toc:[]},VCe="wrapper";function qCe(t){let{components:e,...n}=t;return(0,s.kt)(VCe,(0,p.Z)({},UCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qCe.isMDXComponent=!0;const jCe={toc:[]},YCe="wrapper";function HCe(t){let{components:e,...n}=t;return(0,s.kt)(YCe,(0,p.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}HCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function JCe(t){let{components:e,...n}=t;return(0,s.kt)($Ce,(0,p.Z)({},QCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}JCe.isMDXComponent=!0;const KCe={toc:[]},txe="wrapper";function exe(t){let{components:e,...n}=t;return(0,s.kt)(txe,(0,p.Z)({},KCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}exe.isMDXComponent=!0;const nxe={toc:[]},oxe="wrapper";function pxe(t){let{components:e,...n}=t;return(0,s.kt)(oxe,(0,p.Z)({},nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pxe.isMDXComponent=!0;const rxe={toc:[]},sxe="wrapper";function cxe(t){let{components:e,...n}=t;return(0,s.kt)(sxe,(0,p.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cxe.isMDXComponent=!0;const ixe={toc:[]},axe="wrapper";function lxe(t){let{components:e,...n}=t;return(0,s.kt)(axe,(0,p.Z)({},ixe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lxe.isMDXComponent=!0;const uxe={toc:[]},mxe="wrapper";function dxe(t){let{components:e,...n}=t;return(0,s.kt)(mxe,(0,p.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dxe.isMDXComponent=!0;const hxe={toc:[]},fxe="wrapper";function kxe(t){let{components:e,...n}=t;return(0,s.kt)(fxe,(0,p.Z)({},hxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kxe.isMDXComponent=!0;const yxe={toc:[]},Dxe="wrapper";function Mxe(t){let{components:e,...n}=t;return(0,s.kt)(Dxe,(0,p.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mxe.isMDXComponent=!0;const Xxe={toc:[]},_xe="wrapper";function wxe(t){let{components:e,...n}=t;return(0,s.kt)(_xe,(0,p.Z)({},Xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wxe.isMDXComponent=!0;const Txe={toc:[]},gxe="wrapper";function Cxe(t){let{components:e,...n}=t;return(0,s.kt)(gxe,(0,p.Z)({},Txe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cxe.isMDXComponent=!0;const xxe={toc:[]},vxe="wrapper";function Lxe(t){let{components:e,...n}=t;return(0,s.kt)(vxe,(0,p.Z)({},xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]},bxe="wrapper";function Nxe(t){let{components:e,...n}=t;return(0,s.kt)(bxe,(0,p.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nxe.isMDXComponent=!0;const Axe={toc:[]},zxe="wrapper";function Wxe(t){let{components:e,...n}=t;return(0,s.kt)(zxe,(0,p.Z)({},Axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Wxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Sxe(t){let{components:e,...n}=t;return(0,s.kt)(Rxe,(0,p.Z)({},Ixe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Sxe.isMDXComponent=!0;const Pxe={toc:[]},Exe="wrapper";function Oxe(t){let{components:e,...n}=t;return(0,s.kt)(Exe,(0,p.Z)({},Pxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Oxe.isMDXComponent=!0;const Gxe={toc:[]},Fxe="wrapper";function Bxe(t){let{components:e,...n}=t;return(0,s.kt)(Fxe,(0,p.Z)({},Gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Bxe.isMDXComponent=!0;const Uxe={toc:[]},Vxe="wrapper";function qxe(t){let{components:e,...n}=t;return(0,s.kt)(Vxe,(0,p.Z)({},Uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Yxe="wrapper";function Hxe(t){let{components:e,...n}=t;return(0,s.kt)(Yxe,(0,p.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Hxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Jxe(t){let{components:e,...n}=t;return(0,s.kt)($xe,(0,p.Z)({},Qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Jxe.isMDXComponent=!0;const Kxe={toc:[]},tve="wrapper";function eve(t){let{components:e,...n}=t;return(0,s.kt)(tve,(0,p.Z)({},Kxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}eve.isMDXComponent=!0;const nve={toc:[]},ove="wrapper";function pve(t){let{components:e,...n}=t;return(0,s.kt)(ove,(0,p.Z)({},nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pve.isMDXComponent=!0;const rve={toc:[]},sve="wrapper";function cve(t){let{components:e,...n}=t;return(0,s.kt)(sve,(0,p.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cve.isMDXComponent=!0;const ive={toc:[]},ave="wrapper";function lve(t){let{components:e,...n}=t;return(0,s.kt)(ave,(0,p.Z)({},ive,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lve.isMDXComponent=!0;const uve={toc:[]},mve="wrapper";function dve(t){let{components:e,...n}=t;return(0,s.kt)(mve,(0,p.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dve.isMDXComponent=!0;const hve={toc:[]},fve="wrapper";function kve(t){let{components:e,...n}=t;return(0,s.kt)(fve,(0,p.Z)({},hve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kve.isMDXComponent=!0;const yve={toc:[]},Dve="wrapper";function Mve(t){let{components:e,...n}=t;return(0,s.kt)(Dve,(0,p.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mve.isMDXComponent=!0;const Xve={toc:[]},_ve="wrapper";function wve(t){let{components:e,...n}=t;return(0,s.kt)(_ve,(0,p.Z)({},Xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wve.isMDXComponent=!0;const Tve={toc:[]},gve="wrapper";function Cve(t){let{components:e,...n}=t;return(0,s.kt)(gve,(0,p.Z)({},Tve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Cve.isMDXComponent=!0;const xve={toc:[]},vve="wrapper";function Lve(t){let{components:e,...n}=t;return(0,s.kt)(vve,(0,p.Z)({},xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lve.isMDXComponent=!0;const Zve={toc:[]},bve="wrapper";function Nve(t){let{components:e,...n}=t;return(0,s.kt)(bve,(0,p.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nve.isMDXComponent=!0;const Ave={toc:[]},zve="wrapper";function Wve(t){let{components:e,...n}=t;return(0,s.kt)(zve,(0,p.Z)({},Ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Sve(t){let{components:e,...n}=t;return(0,s.kt)(Rve,(0,p.Z)({},Ive,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Sve.isMDXComponent=!0;const Pve={toc:[]},Eve="wrapper";function Ove(t){let{components:e,...n}=t;return(0,s.kt)(Eve,(0,p.Z)({},Pve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ove.isMDXComponent=!0;const Gve={toc:[]},Fve="wrapper";function Bve(t){let{components:e,...n}=t;return(0,s.kt)(Fve,(0,p.Z)({},Gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bve.isMDXComponent=!0;const Uve={toc:[]},Vve="wrapper";function qve(t){let{components:e,...n}=t;return(0,s.kt)(Vve,(0,p.Z)({},Uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qve.isMDXComponent=!0;const jve={toc:[]},Yve="wrapper";function Hve(t){let{components:e,...n}=t;return(0,s.kt)(Yve,(0,p.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Jve(t){let{components:e,...n}=t;return(0,s.kt)($ve,(0,p.Z)({},Qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Jve.isMDXComponent=!0;const Kve={toc:[]},tLe="wrapper";function eLe(t){let{components:e,...n}=t;return(0,s.kt)(tLe,(0,p.Z)({},Kve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}eLe.isMDXComponent=!0;const nLe={toc:[]},oLe="wrapper";function pLe(t){let{components:e,...n}=t;return(0,s.kt)(oLe,(0,p.Z)({},nLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pLe.isMDXComponent=!0;const rLe={toc:[]},sLe="wrapper";function cLe(t){let{components:e,...n}=t;return(0,s.kt)(sLe,(0,p.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cLe.isMDXComponent=!0;const iLe={toc:[]},aLe="wrapper";function lLe(t){let{components:e,...n}=t;return(0,s.kt)(aLe,(0,p.Z)({},iLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lLe.isMDXComponent=!0;const uLe={toc:[]},mLe="wrapper";function dLe(t){let{components:e,...n}=t;return(0,s.kt)(mLe,(0,p.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dLe.isMDXComponent=!0;const hLe={toc:[]},fLe="wrapper";function kLe(t){let{components:e,...n}=t;return(0,s.kt)(fLe,(0,p.Z)({},hLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kLe.isMDXComponent=!0;const yLe={toc:[]},DLe="wrapper";function MLe(t){let{components:e,...n}=t;return(0,s.kt)(DLe,(0,p.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}MLe.isMDXComponent=!0;const XLe={toc:[]},_Le="wrapper";function wLe(t){let{components:e,...n}=t;return(0,s.kt)(_Le,(0,p.Z)({},XLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wLe.isMDXComponent=!0;const TLe={toc:[]},gLe="wrapper";function CLe(t){let{components:e,...n}=t;return(0,s.kt)(gLe,(0,p.Z)({},TLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}CLe.isMDXComponent=!0;const xLe={toc:[]},vLe="wrapper";function LLe(t){let{components:e,...n}=t;return(0,s.kt)(vLe,(0,p.Z)({},xLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LLe.isMDXComponent=!0;const ZLe={toc:[]},bLe="wrapper";function NLe(t){let{components:e,...n}=t;return(0,s.kt)(bLe,(0,p.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NLe.isMDXComponent=!0;const ALe={toc:[]},zLe="wrapper";function WLe(t){let{components:e,...n}=t;return(0,s.kt)(zLe,(0,p.Z)({},ALe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function SLe(t){let{components:e,...n}=t;return(0,s.kt)(RLe,(0,p.Z)({},ILe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}SLe.isMDXComponent=!0;const PLe={toc:[]},ELe="wrapper";function OLe(t){let{components:e,...n}=t;return(0,s.kt)(ELe,(0,p.Z)({},PLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}OLe.isMDXComponent=!0;const GLe={toc:[]},FLe="wrapper";function BLe(t){let{components:e,...n}=t;return(0,s.kt)(FLe,(0,p.Z)({},GLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BLe.isMDXComponent=!0;const ULe={toc:[]},VLe="wrapper";function qLe(t){let{components:e,...n}=t;return(0,s.kt)(VLe,(0,p.Z)({},ULe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qLe.isMDXComponent=!0;const jLe={toc:[]},YLe="wrapper";function HLe(t){let{components:e,...n}=t;return(0,s.kt)(YLe,(0,p.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function JLe(t){let{components:e,...n}=t;return(0,s.kt)($Le,(0,p.Z)({},QLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}JLe.isMDXComponent=!0;const KLe={toc:[]},tZe="wrapper";function eZe(t){let{components:e,...n}=t;return(0,s.kt)(tZe,(0,p.Z)({},KLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eZe.isMDXComponent=!0;const nZe={toc:[]},oZe="wrapper";function pZe(t){let{components:e,...n}=t;return(0,s.kt)(oZe,(0,p.Z)({},nZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pZe.isMDXComponent=!0;const rZe={toc:[]},sZe="wrapper";function cZe(t){let{components:e,...n}=t;return(0,s.kt)(sZe,(0,p.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cZe.isMDXComponent=!0;const iZe={toc:[]},aZe="wrapper";function lZe(t){let{components:e,...n}=t;return(0,s.kt)(aZe,(0,p.Z)({},iZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lZe.isMDXComponent=!0;const uZe={toc:[]},mZe="wrapper";function dZe(t){let{components:e,...n}=t;return(0,s.kt)(mZe,(0,p.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dZe.isMDXComponent=!0;const hZe={toc:[]},fZe="wrapper";function kZe(t){let{components:e,...n}=t;return(0,s.kt)(fZe,(0,p.Z)({},hZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}kZe.isMDXComponent=!0;const yZe={toc:[]},DZe="wrapper";function MZe(t){let{components:e,...n}=t;return(0,s.kt)(DZe,(0,p.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}MZe.isMDXComponent=!0;const XZe={toc:[]},_Ze="wrapper";function wZe(t){let{components:e,...n}=t;return(0,s.kt)(_Ze,(0,p.Z)({},XZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wZe.isMDXComponent=!0;const TZe={toc:[]},gZe="wrapper";function CZe(t){let{components:e,...n}=t;return(0,s.kt)(gZe,(0,p.Z)({},TZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}CZe.isMDXComponent=!0;const xZe={toc:[]},vZe="wrapper";function LZe(t){let{components:e,...n}=t;return(0,s.kt)(vZe,(0,p.Z)({},xZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}LZe.isMDXComponent=!0;const ZZe={toc:[]},bZe="wrapper";function NZe(t){let{components:e,...n}=t;return(0,s.kt)(bZe,(0,p.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}NZe.isMDXComponent=!0;const AZe={toc:[]},zZe="wrapper";function WZe(t){let{components:e,...n}=t;return(0,s.kt)(zZe,(0,p.Z)({},AZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}WZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function SZe(t){let{components:e,...n}=t;return(0,s.kt)(RZe,(0,p.Z)({},IZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}SZe.isMDXComponent=!0;const PZe={toc:[]},EZe="wrapper";function OZe(t){let{components:e,...n}=t;return(0,s.kt)(EZe,(0,p.Z)({},PZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}OZe.isMDXComponent=!0;const GZe={toc:[]},FZe="wrapper";function BZe(t){let{components:e,...n}=t;return(0,s.kt)(FZe,(0,p.Z)({},GZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BZe.isMDXComponent=!0;const UZe={toc:[]},VZe="wrapper";function qZe(t){let{components:e,...n}=t;return(0,s.kt)(VZe,(0,p.Z)({},UZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qZe.isMDXComponent=!0;const jZe={toc:[]},YZe="wrapper";function HZe(t){let{components:e,...n}=t;return(0,s.kt)(YZe,(0,p.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}HZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function JZe(t){let{components:e,...n}=t;return(0,s.kt)($Ze,(0,p.Z)({},QZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}JZe.isMDXComponent=!0;const KZe={toc:[]},tbe="wrapper";function ebe(t){let{components:e,...n}=t;return(0,s.kt)(tbe,(0,p.Z)({},KZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ebe.isMDXComponent=!0;const nbe={toc:[]},obe="wrapper";function pbe(t){let{components:e,...n}=t;return(0,s.kt)(obe,(0,p.Z)({},nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pbe.isMDXComponent=!0;const rbe={toc:[]},sbe="wrapper";function cbe(t){let{components:e,...n}=t;return(0,s.kt)(sbe,(0,p.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cbe.isMDXComponent=!0;const ibe={toc:[]},abe="wrapper";function lbe(t){let{components:e,...n}=t;return(0,s.kt)(abe,(0,p.Z)({},ibe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lbe.isMDXComponent=!0;const ube={toc:[]},mbe="wrapper";function dbe(t){let{components:e,...n}=t;return(0,s.kt)(mbe,(0,p.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}dbe.isMDXComponent=!0;const hbe={toc:[]},fbe="wrapper";function kbe(t){let{components:e,...n}=t;return(0,s.kt)(fbe,(0,p.Z)({},hbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}kbe.isMDXComponent=!0;const ybe={toc:[]},Dbe="wrapper";function Mbe(t){let{components:e,...n}=t;return(0,s.kt)(Dbe,(0,p.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}))}Mbe.isMDXComponent=!0;const Xbe={toc:[]},_be="wrapper";function wbe(t){let{components:e,...n}=t;return(0,s.kt)(_be,(0,p.Z)({},Xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wbe.isMDXComponent=!0;const Tbe={toc:[]},gbe="wrapper";function Cbe(t){let{components:e,...n}=t;return(0,s.kt)(gbe,(0,p.Z)({},Tbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cbe.isMDXComponent=!0;const xbe={toc:[]},vbe="wrapper";function Lbe(t){let{components:e,...n}=t;return(0,s.kt)(vbe,(0,p.Z)({},xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]},bbe="wrapper";function Nbe(t){let{components:e,...n}=t;return(0,s.kt)(bbe,(0,p.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nbe.isMDXComponent=!0;const Abe={toc:[]},zbe="wrapper";function Wbe(t){let{components:e,...n}=t;return(0,s.kt)(zbe,(0,p.Z)({},Abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Sbe(t){let{components:e,...n}=t;return(0,s.kt)(Rbe,(0,p.Z)({},Ibe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sbe.isMDXComponent=!0;const Pbe={toc:[]},Ebe="wrapper";function Obe(t){let{components:e,...n}=t;return(0,s.kt)(Ebe,(0,p.Z)({},Pbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Obe.isMDXComponent=!0;const Gbe={toc:[]},Fbe="wrapper";function Bbe(t){let{components:e,...n}=t;return(0,s.kt)(Fbe,(0,p.Z)({},Gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bbe.isMDXComponent=!0;const Ube={toc:[]},Vbe="wrapper";function qbe(t){let{components:e,...n}=t;return(0,s.kt)(Vbe,(0,p.Z)({},Ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Ybe="wrapper";function Hbe(t){let{components:e,...n}=t;return(0,s.kt)(Ybe,(0,p.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hbe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Jbe(t){let{components:e,...n}=t;return(0,s.kt)($be,(0,p.Z)({},Qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jbe.isMDXComponent=!0;const Kbe={toc:[]},tNe="wrapper";function eNe(t){let{components:e,...n}=t;return(0,s.kt)(tNe,(0,p.Z)({},Kbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eNe.isMDXComponent=!0;const nNe={toc:[]},oNe="wrapper";function pNe(t){let{components:e,...n}=t;return(0,s.kt)(oNe,(0,p.Z)({},nNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pNe.isMDXComponent=!0;const rNe={toc:[]},sNe="wrapper";function cNe(t){let{components:e,...n}=t;return(0,s.kt)(sNe,(0,p.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cNe.isMDXComponent=!0;const iNe={toc:[]},aNe="wrapper";function lNe(t){let{components:e,...n}=t;return(0,s.kt)(aNe,(0,p.Z)({},iNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lNe.isMDXComponent=!0;const uNe={toc:[]},mNe="wrapper";function dNe(t){let{components:e,...n}=t;return(0,s.kt)(mNe,(0,p.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dNe.isMDXComponent=!0;const hNe={toc:[]},fNe="wrapper";function kNe(t){let{components:e,...n}=t;return(0,s.kt)(fNe,(0,p.Z)({},hNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kNe.isMDXComponent=!0;const yNe={toc:[]},DNe="wrapper";function MNe(t){let{components:e,...n}=t;return(0,s.kt)(DNe,(0,p.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MNe.isMDXComponent=!0;const XNe={toc:[]},_Ne="wrapper";function wNe(t){let{components:e,...n}=t;return(0,s.kt)(_Ne,(0,p.Z)({},XNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wNe.isMDXComponent=!0;const TNe={toc:[]},gNe="wrapper";function CNe(t){let{components:e,...n}=t;return(0,s.kt)(gNe,(0,p.Z)({},TNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}CNe.isMDXComponent=!0;const xNe={toc:[]},vNe="wrapper";function LNe(t){let{components:e,...n}=t;return(0,s.kt)(vNe,(0,p.Z)({},xNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}LNe.isMDXComponent=!0;const ZNe={toc:[]},bNe="wrapper";function NNe(t){let{components:e,...n}=t;return(0,s.kt)(bNe,(0,p.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NNe.isMDXComponent=!0;const ANe={toc:[]},zNe="wrapper";function WNe(t){let{components:e,...n}=t;return(0,s.kt)(zNe,(0,p.Z)({},ANe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function SNe(t){let{components:e,...n}=t;return(0,s.kt)(RNe,(0,p.Z)({},INe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}SNe.isMDXComponent=!0;const PNe={toc:[]},ENe="wrapper";function ONe(t){let{components:e,...n}=t;return(0,s.kt)(ENe,(0,p.Z)({},PNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ONe.isMDXComponent=!0;const GNe={toc:[]},FNe="wrapper";function BNe(t){let{components:e,...n}=t;return(0,s.kt)(FNe,(0,p.Z)({},GNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}BNe.isMDXComponent=!0;const UNe={toc:[]},VNe="wrapper";function qNe(t){let{components:e,...n}=t;return(0,s.kt)(VNe,(0,p.Z)({},UNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qNe.isMDXComponent=!0;const jNe={toc:[]},YNe="wrapper";function HNe(t){let{components:e,...n}=t;return(0,s.kt)(YNe,(0,p.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}HNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function JNe(t){let{components:e,...n}=t;return(0,s.kt)($Ne,(0,p.Z)({},QNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}JNe.isMDXComponent=!0;const KNe={toc:[]},tAe="wrapper";function eAe(t){let{components:e,...n}=t;return(0,s.kt)(tAe,(0,p.Z)({},KNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eAe.isMDXComponent=!0;const nAe={toc:[]},oAe="wrapper";function pAe(t){let{components:e,...n}=t;return(0,s.kt)(oAe,(0,p.Z)({},nAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pAe.isMDXComponent=!0;const rAe={toc:[]},sAe="wrapper";function cAe(t){let{components:e,...n}=t;return(0,s.kt)(sAe,(0,p.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cAe.isMDXComponent=!0;const iAe={toc:[]},aAe="wrapper";function lAe(t){let{components:e,...n}=t;return(0,s.kt)(aAe,(0,p.Z)({},iAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lAe.isMDXComponent=!0;const uAe={toc:[]},mAe="wrapper";function dAe(t){let{components:e,...n}=t;return(0,s.kt)(mAe,(0,p.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dAe.isMDXComponent=!0;const hAe={toc:[]},fAe="wrapper";function kAe(t){let{components:e,...n}=t;return(0,s.kt)(fAe,(0,p.Z)({},hAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kAe.isMDXComponent=!0;const yAe={toc:[]},DAe="wrapper";function MAe(t){let{components:e,...n}=t;return(0,s.kt)(DAe,(0,p.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MAe.isMDXComponent=!0;const XAe={toc:[]},_Ae="wrapper";function wAe(t){let{components:e,...n}=t;return(0,s.kt)(_Ae,(0,p.Z)({},XAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wAe.isMDXComponent=!0;const TAe={toc:[]},gAe="wrapper";function CAe(t){let{components:e,...n}=t;return(0,s.kt)(gAe,(0,p.Z)({},TAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}CAe.isMDXComponent=!0;const xAe={toc:[]},vAe="wrapper";function LAe(t){let{components:e,...n}=t;return(0,s.kt)(vAe,(0,p.Z)({},xAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LAe.isMDXComponent=!0;const ZAe={toc:[]},bAe="wrapper";function NAe(t){let{components:e,...n}=t;return(0,s.kt)(bAe,(0,p.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}NAe.isMDXComponent=!0;const AAe={toc:[]},zAe="wrapper";function WAe(t){let{components:e,...n}=t;return(0,s.kt)(zAe,(0,p.Z)({},AAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}WAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function SAe(t){let{components:e,...n}=t;return(0,s.kt)(RAe,(0,p.Z)({},IAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}SAe.isMDXComponent=!0;const PAe={toc:[]},EAe="wrapper";function OAe(t){let{components:e,...n}=t;return(0,s.kt)(EAe,(0,p.Z)({},PAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}OAe.isMDXComponent=!0;const GAe={toc:[]},FAe="wrapper";function BAe(t){let{components:e,...n}=t;return(0,s.kt)(FAe,(0,p.Z)({},GAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}BAe.isMDXComponent=!0;const UAe={toc:[]},VAe="wrapper";function qAe(t){let{components:e,...n}=t;return(0,s.kt)(VAe,(0,p.Z)({},UAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qAe.isMDXComponent=!0;const jAe={toc:[]},YAe="wrapper";function HAe(t){let{components:e,...n}=t;return(0,s.kt)(YAe,(0,p.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}HAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function JAe(t){let{components:e,...n}=t;return(0,s.kt)($Ae,(0,p.Z)({},QAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}JAe.isMDXComponent=!0;const KAe={toc:[]},tze="wrapper";function eze(t){let{components:e,...n}=t;return(0,s.kt)(tze,(0,p.Z)({},KAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eze.isMDXComponent=!0;const nze={toc:[]},oze="wrapper";function pze(t){let{components:e,...n}=t;return(0,s.kt)(oze,(0,p.Z)({},nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pze.isMDXComponent=!0;const rze={toc:[]},sze="wrapper";function cze(t){let{components:e,...n}=t;return(0,s.kt)(sze,(0,p.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cze.isMDXComponent=!0;const ize={toc:[]},aze="wrapper";function lze(t){let{components:e,...n}=t;return(0,s.kt)(aze,(0,p.Z)({},ize,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lze.isMDXComponent=!0;const uze={toc:[]},mze="wrapper";function dze(t){let{components:e,...n}=t;return(0,s.kt)(mze,(0,p.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dze.isMDXComponent=!0;const hze={toc:[]},fze="wrapper";function kze(t){let{components:e,...n}=t;return(0,s.kt)(fze,(0,p.Z)({},hze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kze.isMDXComponent=!0;const yze={toc:[]},Dze="wrapper";function Mze(t){let{components:e,...n}=t;return(0,s.kt)(Dze,(0,p.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mze.isMDXComponent=!0;const Xze={toc:[]},_ze="wrapper";function wze(t){let{components:e,...n}=t;return(0,s.kt)(_ze,(0,p.Z)({},Xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wze.isMDXComponent=!0;const Tze={toc:[]},gze="wrapper";function Cze(t){let{components:e,...n}=t;return(0,s.kt)(gze,(0,p.Z)({},Tze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cze.isMDXComponent=!0;const xze={toc:[]},vze="wrapper";function Lze(t){let{components:e,...n}=t;return(0,s.kt)(vze,(0,p.Z)({},xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lze.isMDXComponent=!0;const Zze={toc:[]},bze="wrapper";function Nze(t){let{components:e,...n}=t;return(0,s.kt)(bze,(0,p.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nze.isMDXComponent=!0;const Aze={toc:[]},zze="wrapper";function Wze(t){let{components:e,...n}=t;return(0,s.kt)(zze,(0,p.Z)({},Aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Sze(t){let{components:e,...n}=t;return(0,s.kt)(Rze,(0,p.Z)({},Ize,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Sze.isMDXComponent=!0;const Pze={toc:[]},Eze="wrapper";function Oze(t){let{components:e,...n}=t;return(0,s.kt)(Eze,(0,p.Z)({},Pze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Oze.isMDXComponent=!0;const Gze={toc:[]},Fze="wrapper";function Bze(t){let{components:e,...n}=t;return(0,s.kt)(Fze,(0,p.Z)({},Gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bze.isMDXComponent=!0;const Uze={toc:[]},Vze="wrapper";function qze(t){let{components:e,...n}=t;return(0,s.kt)(Vze,(0,p.Z)({},Uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qze.isMDXComponent=!0;const jze={toc:[]},Yze="wrapper";function Hze(t){let{components:e,...n}=t;return(0,s.kt)(Yze,(0,p.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Hze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Jze(t){let{components:e,...n}=t;return(0,s.kt)($ze,(0,p.Z)({},Qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Jze.isMDXComponent=!0;const Kze={toc:[]},tWe="wrapper";function eWe(t){let{components:e,...n}=t;return(0,s.kt)(tWe,(0,p.Z)({},Kze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}eWe.isMDXComponent=!0;const nWe={toc:[]},oWe="wrapper";function pWe(t){let{components:e,...n}=t;return(0,s.kt)(oWe,(0,p.Z)({},nWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pWe.isMDXComponent=!0;const rWe={toc:[]},sWe="wrapper";function cWe(t){let{components:e,...n}=t;return(0,s.kt)(sWe,(0,p.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cWe.isMDXComponent=!0;const iWe={toc:[]},aWe="wrapper";function lWe(t){let{components:e,...n}=t;return(0,s.kt)(aWe,(0,p.Z)({},iWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lWe.isMDXComponent=!0;const uWe={toc:[]},mWe="wrapper";function dWe(t){let{components:e,...n}=t;return(0,s.kt)(mWe,(0,p.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dWe.isMDXComponent=!0;const hWe={toc:[]},fWe="wrapper";function kWe(t){let{components:e,...n}=t;return(0,s.kt)(fWe,(0,p.Z)({},hWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}kWe.isMDXComponent=!0;const yWe={toc:[]},DWe="wrapper";function MWe(t){let{components:e,...n}=t;return(0,s.kt)(DWe,(0,p.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MWe.isMDXComponent=!0;const XWe={toc:[]},_We="wrapper";function wWe(t){let{components:e,...n}=t;return(0,s.kt)(_We,(0,p.Z)({},XWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wWe.isMDXComponent=!0;const TWe={toc:[]},gWe="wrapper";function CWe(t){let{components:e,...n}=t;return(0,s.kt)(gWe,(0,p.Z)({},TWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}CWe.isMDXComponent=!0;const xWe={toc:[]},vWe="wrapper";function LWe(t){let{components:e,...n}=t;return(0,s.kt)(vWe,(0,p.Z)({},xWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LWe.isMDXComponent=!0;const ZWe={toc:[]},bWe="wrapper";function NWe(t){let{components:e,...n}=t;return(0,s.kt)(bWe,(0,p.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}NWe.isMDXComponent=!0;const AWe={toc:[]},zWe="wrapper";function WWe(t){let{components:e,...n}=t;return(0,s.kt)(zWe,(0,p.Z)({},AWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}WWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function SWe(t){let{components:e,...n}=t;return(0,s.kt)(RWe,(0,p.Z)({},IWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}SWe.isMDXComponent=!0;const PWe={toc:[]},EWe="wrapper";function OWe(t){let{components:e,...n}=t;return(0,s.kt)(EWe,(0,p.Z)({},PWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}OWe.isMDXComponent=!0;const GWe={toc:[]},FWe="wrapper";function BWe(t){let{components:e,...n}=t;return(0,s.kt)(FWe,(0,p.Z)({},GWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}BWe.isMDXComponent=!0;const UWe={toc:[]},VWe="wrapper";function qWe(t){let{components:e,...n}=t;return(0,s.kt)(VWe,(0,p.Z)({},UWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qWe.isMDXComponent=!0;const jWe={toc:[]},YWe="wrapper";function HWe(t){let{components:e,...n}=t;return(0,s.kt)(YWe,(0,p.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}HWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function JWe(t){let{components:e,...n}=t;return(0,s.kt)($We,(0,p.Z)({},QWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}JWe.isMDXComponent=!0;const KWe={toc:[]},tIe="wrapper";function eIe(t){let{components:e,...n}=t;return(0,s.kt)(tIe,(0,p.Z)({},KWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eIe.isMDXComponent=!0;const nIe={toc:[]},oIe="wrapper";function pIe(t){let{components:e,...n}=t;return(0,s.kt)(oIe,(0,p.Z)({},nIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pIe.isMDXComponent=!0;const rIe={toc:[]},sIe="wrapper";function cIe(t){let{components:e,...n}=t;return(0,s.kt)(sIe,(0,p.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cIe.isMDXComponent=!0;const iIe={toc:[]},aIe="wrapper";function lIe(t){let{components:e,...n}=t;return(0,s.kt)(aIe,(0,p.Z)({},iIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lIe.isMDXComponent=!0;const uIe={toc:[]},mIe="wrapper";function dIe(t){let{components:e,...n}=t;return(0,s.kt)(mIe,(0,p.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dIe.isMDXComponent=!0;const hIe={toc:[]},fIe="wrapper";function kIe(t){let{components:e,...n}=t;return(0,s.kt)(fIe,(0,p.Z)({},hIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kIe.isMDXComponent=!0;const yIe={toc:[]},DIe="wrapper";function MIe(t){let{components:e,...n}=t;return(0,s.kt)(DIe,(0,p.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MIe.isMDXComponent=!0;const XIe={toc:[]},_Ie="wrapper";function wIe(t){let{components:e,...n}=t;return(0,s.kt)(_Ie,(0,p.Z)({},XIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wIe.isMDXComponent=!0;const TIe={toc:[]},gIe="wrapper";function CIe(t){let{components:e,...n}=t;return(0,s.kt)(gIe,(0,p.Z)({},TIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}CIe.isMDXComponent=!0;const xIe={toc:[]},vIe="wrapper";function LIe(t){let{components:e,...n}=t;return(0,s.kt)(vIe,(0,p.Z)({},xIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LIe.isMDXComponent=!0;const ZIe={toc:[]},bIe="wrapper";function NIe(t){let{components:e,...n}=t;return(0,s.kt)(bIe,(0,p.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NIe.isMDXComponent=!0;const AIe={toc:[]},zIe="wrapper";function WIe(t){let{components:e,...n}=t;return(0,s.kt)(zIe,(0,p.Z)({},AIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function SIe(t){let{components:e,...n}=t;return(0,s.kt)(RIe,(0,p.Z)({},IIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}SIe.isMDXComponent=!0;const PIe={toc:[]},EIe="wrapper";function OIe(t){let{components:e,...n}=t;return(0,s.kt)(EIe,(0,p.Z)({},PIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}OIe.isMDXComponent=!0;const GIe={toc:[]},FIe="wrapper";function BIe(t){let{components:e,...n}=t;return(0,s.kt)(FIe,(0,p.Z)({},GIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BIe.isMDXComponent=!0;const UIe={toc:[]},VIe="wrapper";function qIe(t){let{components:e,...n}=t;return(0,s.kt)(VIe,(0,p.Z)({},UIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qIe.isMDXComponent=!0;const jIe={toc:[]},YIe="wrapper";function HIe(t){let{components:e,...n}=t;return(0,s.kt)(YIe,(0,p.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}HIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function JIe(t){let{components:e,...n}=t;return(0,s.kt)($Ie,(0,p.Z)({},QIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}JIe.isMDXComponent=!0;const KIe={toc:[]},tRe="wrapper";function eRe(t){let{components:e,...n}=t;return(0,s.kt)(tRe,(0,p.Z)({},KIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eRe.isMDXComponent=!0;const nRe={toc:[]},oRe="wrapper";function pRe(t){let{components:e,...n}=t;return(0,s.kt)(oRe,(0,p.Z)({},nRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pRe.isMDXComponent=!0;const rRe={toc:[]},sRe="wrapper";function cRe(t){let{components:e,...n}=t;return(0,s.kt)(sRe,(0,p.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cRe.isMDXComponent=!0;const iRe={toc:[]},aRe="wrapper";function lRe(t){let{components:e,...n}=t;return(0,s.kt)(aRe,(0,p.Z)({},iRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lRe.isMDXComponent=!0;const uRe={toc:[]},mRe="wrapper";function dRe(t){let{components:e,...n}=t;return(0,s.kt)(mRe,(0,p.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dRe.isMDXComponent=!0;const hRe={toc:[]},fRe="wrapper";function kRe(t){let{components:e,...n}=t;return(0,s.kt)(fRe,(0,p.Z)({},hRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kRe.isMDXComponent=!0;const yRe={toc:[]},DRe="wrapper";function MRe(t){let{components:e,...n}=t;return(0,s.kt)(DRe,(0,p.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MRe.isMDXComponent=!0;const XRe={toc:[]},_Re="wrapper";function wRe(t){let{components:e,...n}=t;return(0,s.kt)(_Re,(0,p.Z)({},XRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wRe.isMDXComponent=!0;const TRe={toc:[]},gRe="wrapper";function CRe(t){let{components:e,...n}=t;return(0,s.kt)(gRe,(0,p.Z)({},TRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}CRe.isMDXComponent=!0;const xRe={toc:[]},vRe="wrapper";function LRe(t){let{components:e,...n}=t;return(0,s.kt)(vRe,(0,p.Z)({},xRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LRe.isMDXComponent=!0;const ZRe={toc:[]},bRe="wrapper";function NRe(t){let{components:e,...n}=t;return(0,s.kt)(bRe,(0,p.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NRe.isMDXComponent=!0;const ARe={toc:[]},zRe="wrapper";function WRe(t){let{components:e,...n}=t;return(0,s.kt)(zRe,(0,p.Z)({},ARe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function SRe(t){let{components:e,...n}=t;return(0,s.kt)(RRe,(0,p.Z)({},IRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SRe.isMDXComponent=!0;const PRe={toc:[]},ERe="wrapper";function ORe(t){let{components:e,...n}=t;return(0,s.kt)(ERe,(0,p.Z)({},PRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ORe.isMDXComponent=!0;const GRe={toc:[]},FRe="wrapper";function BRe(t){let{components:e,...n}=t;return(0,s.kt)(FRe,(0,p.Z)({},GRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BRe.isMDXComponent=!0;const URe={toc:[]},VRe="wrapper";function qRe(t){let{components:e,...n}=t;return(0,s.kt)(VRe,(0,p.Z)({},URe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qRe.isMDXComponent=!0;const jRe={toc:[]},YRe="wrapper";function HRe(t){let{components:e,...n}=t;return(0,s.kt)(YRe,(0,p.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function JRe(t){let{components:e,...n}=t;return(0,s.kt)($Re,(0,p.Z)({},QRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}JRe.isMDXComponent=!0;const KRe={toc:[]},tSe="wrapper";function eSe(t){let{components:e,...n}=t;return(0,s.kt)(tSe,(0,p.Z)({},KRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eSe.isMDXComponent=!0;const nSe={toc:[]},oSe="wrapper";function pSe(t){let{components:e,...n}=t;return(0,s.kt)(oSe,(0,p.Z)({},nSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pSe.isMDXComponent=!0;const rSe={toc:[]},sSe="wrapper";function cSe(t){let{components:e,...n}=t;return(0,s.kt)(sSe,(0,p.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cSe.isMDXComponent=!0;const iSe={toc:[]},aSe="wrapper";function lSe(t){let{components:e,...n}=t;return(0,s.kt)(aSe,(0,p.Z)({},iSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lSe.isMDXComponent=!0;const uSe={toc:[]},mSe="wrapper";function dSe(t){let{components:e,...n}=t;return(0,s.kt)(mSe,(0,p.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dSe.isMDXComponent=!0;const hSe={toc:[]},fSe="wrapper";function kSe(t){let{components:e,...n}=t;return(0,s.kt)(fSe,(0,p.Z)({},hSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kSe.isMDXComponent=!0;const ySe={toc:[]},DSe="wrapper";function MSe(t){let{components:e,...n}=t;return(0,s.kt)(DSe,(0,p.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}MSe.isMDXComponent=!0;const XSe={toc:[]},_Se="wrapper";function wSe(t){let{components:e,...n}=t;return(0,s.kt)(_Se,(0,p.Z)({},XSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wSe.isMDXComponent=!0;const TSe={toc:[]},gSe="wrapper";function CSe(t){let{components:e,...n}=t;return(0,s.kt)(gSe,(0,p.Z)({},TSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}CSe.isMDXComponent=!0;const xSe={toc:[]},vSe="wrapper";function LSe(t){let{components:e,...n}=t;return(0,s.kt)(vSe,(0,p.Z)({},xSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LSe.isMDXComponent=!0;const ZSe={toc:[]},bSe="wrapper";function NSe(t){let{components:e,...n}=t;return(0,s.kt)(bSe,(0,p.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NSe.isMDXComponent=!0;const ASe={toc:[]},zSe="wrapper";function WSe(t){let{components:e,...n}=t;return(0,s.kt)(zSe,(0,p.Z)({},ASe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}WSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function SSe(t){let{components:e,...n}=t;return(0,s.kt)(RSe,(0,p.Z)({},ISe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SSe.isMDXComponent=!0;const PSe={toc:[]},ESe="wrapper";function OSe(t){let{components:e,...n}=t;return(0,s.kt)(ESe,(0,p.Z)({},PSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}OSe.isMDXComponent=!0;const GSe={toc:[]},FSe="wrapper";function BSe(t){let{components:e,...n}=t;return(0,s.kt)(FSe,(0,p.Z)({},GSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BSe.isMDXComponent=!0;const USe={toc:[]},VSe="wrapper";function qSe(t){let{components:e,...n}=t;return(0,s.kt)(VSe,(0,p.Z)({},USe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qSe.isMDXComponent=!0;const jSe={toc:[]},YSe="wrapper";function HSe(t){let{components:e,...n}=t;return(0,s.kt)(YSe,(0,p.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}HSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function JSe(t){let{components:e,...n}=t;return(0,s.kt)($Se,(0,p.Z)({},QSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}JSe.isMDXComponent=!0;const KSe={toc:[]},tPe="wrapper";function ePe(t){let{components:e,...n}=t;return(0,s.kt)(tPe,(0,p.Z)({},KSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ePe.isMDXComponent=!0;const nPe={toc:[]},oPe="wrapper";function pPe(t){let{components:e,...n}=t;return(0,s.kt)(oPe,(0,p.Z)({},nPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pPe.isMDXComponent=!0;const rPe={toc:[]},sPe="wrapper";function cPe(t){let{components:e,...n}=t;return(0,s.kt)(sPe,(0,p.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cPe.isMDXComponent=!0;const iPe={toc:[]},aPe="wrapper";function lPe(t){let{components:e,...n}=t;return(0,s.kt)(aPe,(0,p.Z)({},iPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lPe.isMDXComponent=!0;const uPe={toc:[]},mPe="wrapper";function dPe(t){let{components:e,...n}=t;return(0,s.kt)(mPe,(0,p.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dPe.isMDXComponent=!0;const hPe={toc:[]},fPe="wrapper";function kPe(t){let{components:e,...n}=t;return(0,s.kt)(fPe,(0,p.Z)({},hPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kPe.isMDXComponent=!0;const yPe={toc:[]},DPe="wrapper";function MPe(t){let{components:e,...n}=t;return(0,s.kt)(DPe,(0,p.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MPe.isMDXComponent=!0;const XPe={toc:[]},_Pe="wrapper";function wPe(t){let{components:e,...n}=t;return(0,s.kt)(_Pe,(0,p.Z)({},XPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}wPe.isMDXComponent=!0;const TPe={toc:[]},gPe="wrapper";function CPe(t){let{components:e,...n}=t;return(0,s.kt)(gPe,(0,p.Z)({},TPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createSignal} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}CPe.isMDXComponent=!0;const xPe={toc:[]},vPe="wrapper";function LPe(t){let{components:e,...n}=t;return(0,s.kt)(vPe,(0,p.Z)({},xPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing lines and polygons."))}LPe.isMDXComponent=!0;const ZPe={toc:[]},bPe="wrapper";function NPe(t){let{components:e,...n}=t;return(0,s.kt)(bPe,(0,p.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NPe.isMDXComponent=!0;const APe={toc:[]},zPe="wrapper";function WPe(t){let{components:e,...n}=t;return(0,s.kt)(zPe,(0,p.Z)({},APe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function SPe(t){let{components:e,...n}=t;return(0,s.kt)(RPe,(0,p.Z)({},IPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}SPe.isMDXComponent=!0;const PPe={toc:[]},EPe="wrapper";function OPe(t){let{components:e,...n}=t;return(0,s.kt)(EPe,(0,p.Z)({},PPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OPe.isMDXComponent=!0;const GPe={toc:[]},FPe="wrapper";function BPe(t){let{components:e,...n}=t;return(0,s.kt)(FPe,(0,p.Z)({},GPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BPe.isMDXComponent=!0;const UPe={toc:[]},VPe="wrapper";function qPe(t){let{components:e,...n}=t;return(0,s.kt)(VPe,(0,p.Z)({},UPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qPe.isMDXComponent=!0;const jPe={toc:[]},YPe="wrapper";function HPe(t){let{components:e,...n}=t;return(0,s.kt)(YPe,(0,p.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}HPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function JPe(t){let{components:e,...n}=t;return(0,s.kt)($Pe,(0,p.Z)({},QPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}JPe.isMDXComponent=!0;const KPe={toc:[]},tEe="wrapper";function eEe(t){let{components:e,...n}=t;return(0,s.kt)(tEe,(0,p.Z)({},KPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eEe.isMDXComponent=!0;const nEe={toc:[]},oEe="wrapper";function pEe(t){let{components:e,...n}=t;return(0,s.kt)(oEe,(0,p.Z)({},nEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pEe.isMDXComponent=!0;const rEe={toc:[]},sEe="wrapper";function cEe(t){let{components:e,...n}=t;return(0,s.kt)(sEe,(0,p.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cEe.isMDXComponent=!0;const iEe={toc:[]},aEe="wrapper";function lEe(t){let{components:e,...n}=t;return(0,s.kt)(aEe,(0,p.Z)({},iEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lEe.isMDXComponent=!0;const uEe={toc:[]},mEe="wrapper";function dEe(t){let{components:e,...n}=t;return(0,s.kt)(mEe,(0,p.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dEe.isMDXComponent=!0;const hEe={toc:[]},fEe="wrapper";function kEe(t){let{components:e,...n}=t;return(0,s.kt)(fEe,(0,p.Z)({},hEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kEe.isMDXComponent=!0;const yEe={toc:[]},DEe="wrapper";function MEe(t){let{components:e,...n}=t;return(0,s.kt)(DEe,(0,p.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}MEe.isMDXComponent=!0;const XEe={toc:[]},_Ee="wrapper";function wEe(t){let{components:e,...n}=t;return(0,s.kt)(_Ee,(0,p.Z)({},XEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wEe.isMDXComponent=!0;const TEe={toc:[]},gEe="wrapper";function CEe(t){let{components:e,...n}=t;return(0,s.kt)(gEe,(0,p.Z)({},TEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CEe.isMDXComponent=!0;const xEe={toc:[]},vEe="wrapper";function LEe(t){let{components:e,...n}=t;return(0,s.kt)(vEe,(0,p.Z)({},xEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LEe.isMDXComponent=!0;const ZEe={toc:[]},bEe="wrapper";function NEe(t){let{components:e,...n}=t;return(0,s.kt)(bEe,(0,p.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NEe.isMDXComponent=!0;const AEe={toc:[]},zEe="wrapper";function WEe(t){let{components:e,...n}=t;return(0,s.kt)(zEe,(0,p.Z)({},AEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function SEe(t){let{components:e,...n}=t;return(0,s.kt)(REe,(0,p.Z)({},IEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}SEe.isMDXComponent=!0;const PEe={toc:[]},EEe="wrapper";function OEe(t){let{components:e,...n}=t;return(0,s.kt)(EEe,(0,p.Z)({},PEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OEe.isMDXComponent=!0;const GEe={toc:[]},FEe="wrapper";function BEe(t){let{components:e,...n}=t;return(0,s.kt)(FEe,(0,p.Z)({},GEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}BEe.isMDXComponent=!0;const UEe={toc:[]},VEe="wrapper";function qEe(t){let{components:e,...n}=t;return(0,s.kt)(VEe,(0,p.Z)({},UEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qEe.isMDXComponent=!0;const jEe={toc:[]},YEe="wrapper";function HEe(t){let{components:e,...n}=t;return(0,s.kt)(YEe,(0,p.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}HEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function JEe(t){let{components:e,...n}=t;return(0,s.kt)($Ee,(0,p.Z)({},QEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}JEe.isMDXComponent=!0;const KEe={toc:[]},tOe="wrapper";function eOe(t){let{components:e,...n}=t;return(0,s.kt)(tOe,(0,p.Z)({},KEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}eOe.isMDXComponent=!0;const nOe={toc:[]},oOe="wrapper";function pOe(t){let{components:e,...n}=t;return(0,s.kt)(oOe,(0,p.Z)({},nOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pOe.isMDXComponent=!0;const rOe={toc:[]},sOe="wrapper";function cOe(t){let{components:e,...n}=t;return(0,s.kt)(sOe,(0,p.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}cOe.isMDXComponent=!0;const iOe={toc:[]},aOe="wrapper";function lOe(t){let{components:e,...n}=t;return(0,s.kt)(aOe,(0,p.Z)({},iOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}lOe.isMDXComponent=!0;const uOe={toc:[]},mOe="wrapper";function dOe(t){let{components:e,...n}=t;return(0,s.kt)(mOe,(0,p.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}dOe.isMDXComponent=!0;const hOe={toc:[]},fOe="wrapper";function kOe(t){let{components:e,...n}=t;return(0,s.kt)(fOe,(0,p.Z)({},hOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}kOe.isMDXComponent=!0;const yOe={toc:[]},DOe="wrapper";function MOe(t){let{components:e,...n}=t;return(0,s.kt)(DOe,(0,p.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MOe.isMDXComponent=!0;const XOe={toc:[]},_Oe="wrapper";function wOe(t){let{components:e,...n}=t;return(0,s.kt)(_Oe,(0,p.Z)({},XOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wOe.isMDXComponent=!0;const TOe={toc:[]},gOe="wrapper";function COe(t){let{components:e,...n}=t;return(0,s.kt)(gOe,(0,p.Z)({},TOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}COe.isMDXComponent=!0;const xOe={toc:[]},vOe="wrapper";function LOe(t){let{components:e,...n}=t;return(0,s.kt)(vOe,(0,p.Z)({},xOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}LOe.isMDXComponent=!0;const ZOe={toc:[]},bOe="wrapper";function NOe(t){let{components:e,...n}=t;return(0,s.kt)(bOe,(0,p.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NOe.isMDXComponent=!0;const AOe={toc:[]},zOe="wrapper";function WOe(t){let{components:e,...n}=t;return(0,s.kt)(zOe,(0,p.Z)({},AOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WOe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function SOe(t){let{components:e,...n}=t;return(0,s.kt)(ROe,(0,p.Z)({},IOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SOe.isMDXComponent=!0;const POe={toc:[]},EOe="wrapper";function OOe(t){let{components:e,...n}=t;return(0,s.kt)(EOe,(0,p.Z)({},POe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}OOe.isMDXComponent=!0;const GOe={toc:[]},FOe="wrapper";function BOe(t){let{components:e,...n}=t;return(0,s.kt)(FOe,(0,p.Z)({},GOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BOe.isMDXComponent=!0;const UOe={toc:[]},VOe="wrapper";function qOe(t){let{components:e,...n}=t;return(0,s.kt)(VOe,(0,p.Z)({},UOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qOe.isMDXComponent=!0;const jOe={toc:[]},YOe="wrapper";function HOe(t){let{components:e,...n}=t;return(0,s.kt)(YOe,(0,p.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}HOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function JOe(t){let{components:e,...n}=t;return(0,s.kt)($Oe,(0,p.Z)({},QOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}JOe.isMDXComponent=!0;const KOe={toc:[]},tGe="wrapper";function eGe(t){let{components:e,...n}=t;return(0,s.kt)(tGe,(0,p.Z)({},KOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}eGe.isMDXComponent=!0;const nGe={toc:[]},oGe="wrapper";function pGe(t){let{components:e,...n}=t;return(0,s.kt)(oGe,(0,p.Z)({},nGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pGe.isMDXComponent=!0;const rGe={toc:[]},sGe="wrapper";function cGe(t){let{components:e,...n}=t;return(0,s.kt)(sGe,(0,p.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}))}cGe.isMDXComponent=!0;const iGe={toc:[]},aGe="wrapper";function lGe(t){let{components:e,...n}=t;return(0,s.kt)(aGe,(0,p.Z)({},iGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lGe.isMDXComponent=!0;const uGe={toc:[]},mGe="wrapper";function dGe(t){let{components:e,...n}=t;return(0,s.kt)(mGe,(0,p.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dGe.isMDXComponent=!0;const hGe={toc:[]},fGe="wrapper";function kGe(t){let{components:e,...n}=t;return(0,s.kt)(fGe,(0,p.Z)({},hGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kGe.isMDXComponent=!0;const yGe={toc:[]},DGe="wrapper";function MGe(t){let{components:e,...n}=t;return(0,s.kt)(DGe,(0,p.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}MGe.isMDXComponent=!0;const XGe={toc:[]},_Ge="wrapper";function wGe(t){let{components:e,...n}=t;return(0,s.kt)(_Ge,(0,p.Z)({},XGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wGe.isMDXComponent=!0;const TGe={toc:[]},gGe="wrapper";function CGe(t){let{components:e,...n}=t;return(0,s.kt)(gGe,(0,p.Z)({},TGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}CGe.isMDXComponent=!0;const xGe={toc:[]},vGe="wrapper";function LGe(t){let{components:e,...n}=t;return(0,s.kt)(vGe,(0,p.Z)({},xGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LGe.isMDXComponent=!0;const ZGe={toc:[]},bGe="wrapper";function NGe(t){let{components:e,...n}=t;return(0,s.kt)(bGe,(0,p.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NGe.isMDXComponent=!0;const AGe={toc:[]},zGe="wrapper";function WGe(t){let{components:e,...n}=t;return(0,s.kt)(zGe,(0,p.Z)({},AGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function SGe(t){let{components:e,...n}=t;return(0,s.kt)(RGe,(0,p.Z)({},IGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}SGe.isMDXComponent=!0;const PGe={toc:[]},EGe="wrapper";function OGe(t){let{components:e,...n}=t;return(0,s.kt)(EGe,(0,p.Z)({},PGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}OGe.isMDXComponent=!0;const GGe={toc:[]},FGe="wrapper";function BGe(t){let{components:e,...n}=t;return(0,s.kt)(FGe,(0,p.Z)({},GGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BGe.isMDXComponent=!0;const UGe={toc:[]},VGe="wrapper";function qGe(t){let{components:e,...n}=t;return(0,s.kt)(VGe,(0,p.Z)({},UGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qGe.isMDXComponent=!0;const jGe={toc:[]},YGe="wrapper";function HGe(t){let{components:e,...n}=t;return(0,s.kt)(YGe,(0,p.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}HGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function JGe(t){let{components:e,...n}=t;return(0,s.kt)($Ge,(0,p.Z)({},QGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}JGe.isMDXComponent=!0;const KGe={toc:[]},tFe="wrapper";function eFe(t){let{components:e,...n}=t;return(0,s.kt)(tFe,(0,p.Z)({},KGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eFe.isMDXComponent=!0;const nFe={toc:[]},oFe="wrapper";function pFe(t){let{components:e,...n}=t;return(0,s.kt)(oFe,(0,p.Z)({},nFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pFe.isMDXComponent=!0;const rFe={toc:[]},sFe="wrapper";function cFe(t){let{components:e,...n}=t;return(0,s.kt)(sFe,(0,p.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cFe.isMDXComponent=!0;const iFe={toc:[]},aFe="wrapper";function lFe(t){let{components:e,...n}=t;return(0,s.kt)(aFe,(0,p.Z)({},iFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lFe.isMDXComponent=!0;const uFe={toc:[]},mFe="wrapper";function dFe(t){let{components:e,...n}=t;return(0,s.kt)(mFe,(0,p.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dFe.isMDXComponent=!0;const hFe={toc:[]},fFe="wrapper";function kFe(t){let{components:e,...n}=t;return(0,s.kt)(fFe,(0,p.Z)({},hFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kFe.isMDXComponent=!0;const yFe={toc:[]},DFe="wrapper";function MFe(t){let{components:e,...n}=t;return(0,s.kt)(DFe,(0,p.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}MFe.isMDXComponent=!0;const XFe={toc:[]},_Fe="wrapper";function wFe(t){let{components:e,...n}=t;return(0,s.kt)(_Fe,(0,p.Z)({},XFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wFe.isMDXComponent=!0;const TFe={toc:[]},gFe="wrapper";function CFe(t){let{components:e,...n}=t;return(0,s.kt)(gFe,(0,p.Z)({},TFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}CFe.isMDXComponent=!0;const xFe={toc:[]},vFe="wrapper";function LFe(t){let{components:e,...n}=t;return(0,s.kt)(vFe,(0,p.Z)({},xFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LFe.isMDXComponent=!0;const ZFe={toc:[]},bFe="wrapper";function NFe(t){let{components:e,...n}=t;return(0,s.kt)(bFe,(0,p.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NFe.isMDXComponent=!0;const AFe={toc:[]},zFe="wrapper";function WFe(t){let{components:e,...n}=t;return(0,s.kt)(zFe,(0,p.Z)({},AFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}WFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function SFe(t){let{components:e,...n}=t;return(0,s.kt)(RFe,(0,p.Z)({},IFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}SFe.isMDXComponent=!0;const PFe={toc:[]},EFe="wrapper";function OFe(t){let{components:e,...n}=t;return(0,s.kt)(EFe,(0,p.Z)({},PFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}OFe.isMDXComponent=!0;const GFe={toc:[]},FFe="wrapper";function BFe(t){let{components:e,...n}=t;return(0,s.kt)(FFe,(0,p.Z)({},GFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}BFe.isMDXComponent=!0;const UFe={toc:[]},VFe="wrapper";function qFe(t){let{components:e,...n}=t;return(0,s.kt)(VFe,(0,p.Z)({},UFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}qFe.isMDXComponent=!0;const jFe={toc:[]},YFe="wrapper";function HFe(t){let{components:e,...n}=t;return(0,s.kt)(YFe,(0,p.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}HFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function JFe(t){let{components:e,...n}=t;return(0,s.kt)($Fe,(0,p.Z)({},QFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JFe.isMDXComponent=!0;const KFe={toc:[]},tBe="wrapper";function eBe(t){let{components:e,...n}=t;return(0,s.kt)(tBe,(0,p.Z)({},KFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}eBe.isMDXComponent=!0;const nBe={toc:[]},oBe="wrapper";function pBe(t){let{components:e,...n}=t;return(0,s.kt)(oBe,(0,p.Z)({},nBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pBe.isMDXComponent=!0;const rBe={toc:[]},sBe="wrapper";function cBe(t){let{components:e,...n}=t;return(0,s.kt)(sBe,(0,p.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}cBe.isMDXComponent=!0;const iBe={toc:[]},aBe="wrapper";function lBe(t){let{components:e,...n}=t;return(0,s.kt)(aBe,(0,p.Z)({},iBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lBe.isMDXComponent=!0;const uBe={toc:[]},mBe="wrapper";function dBe(t){let{components:e,...n}=t;return(0,s.kt)(mBe,(0,p.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dBe.isMDXComponent=!0;const hBe={toc:[]},fBe="wrapper";function kBe(t){let{components:e,...n}=t;return(0,s.kt)(fBe,(0,p.Z)({},hBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kBe.isMDXComponent=!0;const yBe={toc:[]},DBe="wrapper";function MBe(t){let{components:e,...n}=t;return(0,s.kt)(DBe,(0,p.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}MBe.isMDXComponent=!0;const XBe={toc:[]},_Be="wrapper";function wBe(t){let{components:e,...n}=t;return(0,s.kt)(_Be,(0,p.Z)({},XBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wBe.isMDXComponent=!0;const TBe={toc:[]},gBe="wrapper";function CBe(t){let{components:e,...n}=t;return(0,s.kt)(gBe,(0,p.Z)({},TBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}CBe.isMDXComponent=!0;const xBe={toc:[]},vBe="wrapper";function LBe(t){let{components:e,...n}=t;return(0,s.kt)(vBe,(0,p.Z)({},xBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LBe.isMDXComponent=!0;const ZBe={toc:[]},bBe="wrapper";function NBe(t){let{components:e,...n}=t;return(0,s.kt)(bBe,(0,p.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}NBe.isMDXComponent=!0;const ABe={toc:[]},zBe="wrapper";function WBe(t){let{components:e,...n}=t;return(0,s.kt)(zBe,(0,p.Z)({},ABe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}WBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function SBe(t){let{components:e,...n}=t;return(0,s.kt)(RBe,(0,p.Z)({},IBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SBe.isMDXComponent=!0;const PBe={toc:[]},EBe="wrapper";function OBe(t){let{components:e,...n}=t;return(0,s.kt)(EBe,(0,p.Z)({},PBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}OBe.isMDXComponent=!0;const GBe={toc:[]},FBe="wrapper";function BBe(t){let{components:e,...n}=t;return(0,s.kt)(FBe,(0,p.Z)({},GBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BBe.isMDXComponent=!0;const UBe={toc:[]},VBe="wrapper";function qBe(t){let{components:e,...n}=t;return(0,s.kt)(VBe,(0,p.Z)({},UBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qBe.isMDXComponent=!0;const jBe={toc:[]},YBe="wrapper";function HBe(t){let{components:e,...n}=t;return(0,s.kt)(YBe,(0,p.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}HBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function JBe(t){let{components:e,...n}=t;return(0,s.kt)($Be,(0,p.Z)({},QBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}JBe.isMDXComponent=!0;const KBe={toc:[]},tUe="wrapper";function eUe(t){let{components:e,...n}=t;return(0,s.kt)(tUe,(0,p.Z)({},KBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}eUe.isMDXComponent=!0;const nUe={toc:[]},oUe="wrapper";function pUe(t){let{components:e,...n}=t;return(0,s.kt)(oUe,(0,p.Z)({},nUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pUe.isMDXComponent=!0;const rUe={toc:[]},sUe="wrapper";function cUe(t){let{components:e,...n}=t;return(0,s.kt)(sUe,(0,p.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cUe.isMDXComponent=!0;const iUe={toc:[]},aUe="wrapper";function lUe(t){let{components:e,...n}=t;return(0,s.kt)(aUe,(0,p.Z)({},iUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lUe.isMDXComponent=!0;const uUe={toc:[]},mUe="wrapper";function dUe(t){let{components:e,...n}=t;return(0,s.kt)(mUe,(0,p.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dUe.isMDXComponent=!0;const hUe={toc:[]},fUe="wrapper";function kUe(t){let{components:e,...n}=t;return(0,s.kt)(fUe,(0,p.Z)({},hUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kUe.isMDXComponent=!0;const yUe={toc:[]},DUe="wrapper";function MUe(t){let{components:e,...n}=t;return(0,s.kt)(DUe,(0,p.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MUe.isMDXComponent=!0;const XUe={toc:[]},_Ue="wrapper";function wUe(t){let{components:e,...n}=t;return(0,s.kt)(_Ue,(0,p.Z)({},XUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wUe.isMDXComponent=!0;const TUe={toc:[]},gUe="wrapper";function CUe(t){let{components:e,...n}=t;return(0,s.kt)(gUe,(0,p.Z)({},TUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CUe.isMDXComponent=!0;const xUe={toc:[]},vUe="wrapper";function LUe(t){let{components:e,...n}=t;return(0,s.kt)(vUe,(0,p.Z)({},xUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LUe.isMDXComponent=!0;const ZUe={toc:[]},bUe="wrapper";function NUe(t){let{components:e,...n}=t;return(0,s.kt)(bUe,(0,p.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NUe.isMDXComponent=!0;const AUe={toc:[]},zUe="wrapper";function WUe(t){let{components:e,...n}=t;return(0,s.kt)(zUe,(0,p.Z)({},AUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}WUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function SUe(t){let{components:e,...n}=t;return(0,s.kt)(RUe,(0,p.Z)({},IUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}SUe.isMDXComponent=!0;const PUe={toc:[]},EUe="wrapper";function OUe(t){let{components:e,...n}=t;return(0,s.kt)(EUe,(0,p.Z)({},PUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}OUe.isMDXComponent=!0;const GUe={toc:[]},FUe="wrapper";function BUe(t){let{components:e,...n}=t;return(0,s.kt)(FUe,(0,p.Z)({},GUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BUe.isMDXComponent=!0;const UUe={toc:[]},VUe="wrapper";function qUe(t){let{components:e,...n}=t;return(0,s.kt)(VUe,(0,p.Z)({},UUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qUe.isMDXComponent=!0;const jUe={toc:[]},YUe="wrapper";function HUe(t){let{components:e,...n}=t;return(0,s.kt)(YUe,(0,p.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}HUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function JUe(t){let{components:e,...n}=t;return(0,s.kt)($Ue,(0,p.Z)({},QUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}JUe.isMDXComponent=!0;const KUe={toc:[]},tVe="wrapper";function eVe(t){let{components:e,...n}=t;return(0,s.kt)(tVe,(0,p.Z)({},KUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eVe.isMDXComponent=!0;const nVe={toc:[]},oVe="wrapper";function pVe(t){let{components:e,...n}=t;return(0,s.kt)(oVe,(0,p.Z)({},nVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pVe.isMDXComponent=!0;const rVe={toc:[]},sVe="wrapper";function cVe(t){let{components:e,...n}=t;return(0,s.kt)(sVe,(0,p.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cVe.isMDXComponent=!0;const iVe={toc:[]},aVe="wrapper";function lVe(t){let{components:e,...n}=t;return(0,s.kt)(aVe,(0,p.Z)({},iVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lVe.isMDXComponent=!0;const uVe={toc:[]},mVe="wrapper";function dVe(t){let{components:e,...n}=t;return(0,s.kt)(mVe,(0,p.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}dVe.isMDXComponent=!0;const hVe={toc:[]},fVe="wrapper";function kVe(t){let{components:e,...n}=t;return(0,s.kt)(fVe,(0,p.Z)({},hVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}kVe.isMDXComponent=!0;const yVe={toc:[]},DVe="wrapper";function MVe(t){let{components:e,...n}=t;return(0,s.kt)(DVe,(0,p.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}MVe.isMDXComponent=!0;const XVe={toc:[]},_Ve="wrapper";function wVe(t){let{components:e,...n}=t;return(0,s.kt)(_Ve,(0,p.Z)({},XVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wVe.isMDXComponent=!0;const TVe={toc:[]},gVe="wrapper";function CVe(t){let{components:e,...n}=t;return(0,s.kt)(gVe,(0,p.Z)({},TVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}CVe.isMDXComponent=!0;const xVe={toc:[]},vVe="wrapper";function LVe(t){let{components:e,...n}=t;return(0,s.kt)(vVe,(0,p.Z)({},xVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LVe.isMDXComponent=!0;const ZVe={toc:[]},bVe="wrapper";function NVe(t){let{components:e,...n}=t;return(0,s.kt)(bVe,(0,p.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}NVe.isMDXComponent=!0;const AVe={toc:[]},zVe="wrapper";function WVe(t){let{components:e,...n}=t;return(0,s.kt)(zVe,(0,p.Z)({},AVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}WVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function SVe(t){let{components:e,...n}=t;return(0,s.kt)(RVe,(0,p.Z)({},IVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}SVe.isMDXComponent=!0;const PVe={toc:[]},EVe="wrapper";function OVe(t){let{components:e,...n}=t;return(0,s.kt)(EVe,(0,p.Z)({},PVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}OVe.isMDXComponent=!0;const GVe={toc:[]},FVe="wrapper";function BVe(t){let{components:e,...n}=t;return(0,s.kt)(FVe,(0,p.Z)({},GVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}BVe.isMDXComponent=!0;const UVe={toc:[]},VVe="wrapper";function qVe(t){let{components:e,...n}=t;return(0,s.kt)(VVe,(0,p.Z)({},UVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qVe.isMDXComponent=!0;const jVe={toc:[]},YVe="wrapper";function HVe(t){let{components:e,...n}=t;return(0,s.kt)(YVe,(0,p.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}HVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function JVe(t){let{components:e,...n}=t;return(0,s.kt)($Ve,(0,p.Z)({},QVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JVe.isMDXComponent=!0;const KVe={toc:[]},tqe="wrapper";function eqe(t){let{components:e,...n}=t;return(0,s.kt)(tqe,(0,p.Z)({},KVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}eqe.isMDXComponent=!0;const nqe={toc:[]},oqe="wrapper";function pqe(t){let{components:e,...n}=t;return(0,s.kt)(oqe,(0,p.Z)({},nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pqe.isMDXComponent=!0;const rqe={toc:[]},sqe="wrapper";function cqe(t){let{components:e,...n}=t;return(0,s.kt)(sqe,(0,p.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cqe.isMDXComponent=!0;const iqe={toc:[]},aqe="wrapper";function lqe(t){let{components:e,...n}=t;return(0,s.kt)(aqe,(0,p.Z)({},iqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lqe.isMDXComponent=!0;const uqe={toc:[]},mqe="wrapper";function dqe(t){let{components:e,...n}=t;return(0,s.kt)(mqe,(0,p.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dqe.isMDXComponent=!0;const hqe={toc:[]},fqe="wrapper";function kqe(t){let{components:e,...n}=t;return(0,s.kt)(fqe,(0,p.Z)({},hqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kqe.isMDXComponent=!0;const yqe={toc:[]},Dqe="wrapper";function Mqe(t){let{components:e,...n}=t;return(0,s.kt)(Dqe,(0,p.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Mqe.isMDXComponent=!0;const Xqe={toc:[]},_qe="wrapper";function wqe(t){let{components:e,...n}=t;return(0,s.kt)(_qe,(0,p.Z)({},Xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wqe.isMDXComponent=!0;const Tqe={toc:[]},gqe="wrapper";function Cqe(t){let{components:e,...n}=t;return(0,s.kt)(gqe,(0,p.Z)({},Tqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cqe.isMDXComponent=!0;const xqe={toc:[]},vqe="wrapper";function Lqe(t){let{components:e,...n}=t;return(0,s.kt)(vqe,(0,p.Z)({},xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]},bqe="wrapper";function Nqe(t){let{components:e,...n}=t;return(0,s.kt)(bqe,(0,p.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Nqe.isMDXComponent=!0;const Aqe={toc:[]},zqe="wrapper";function Wqe(t){let{components:e,...n}=t;return(0,s.kt)(zqe,(0,p.Z)({},Aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Sqe(t){let{components:e,...n}=t;return(0,s.kt)(Rqe,(0,p.Z)({},Iqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Sqe.isMDXComponent=!0;const Pqe={toc:[]},Eqe="wrapper";function Oqe(t){let{components:e,...n}=t;return(0,s.kt)(Eqe,(0,p.Z)({},Pqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Oqe.isMDXComponent=!0;const Gqe={toc:[]},Fqe="wrapper";function Bqe(t){let{components:e,...n}=t;return(0,s.kt)(Fqe,(0,p.Z)({},Gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Bqe.isMDXComponent=!0;const Uqe={toc:[]},Vqe="wrapper";function qqe(t){let{components:e,...n}=t;return(0,s.kt)(Vqe,(0,p.Z)({},Uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Yqe="wrapper";function Hqe(t){let{components:e,...n}=t;return(0,s.kt)(Yqe,(0,p.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Hqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Jqe(t){let{components:e,...n}=t;return(0,s.kt)($qe,(0,p.Z)({},Qqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Jqe.isMDXComponent=!0;const Kqe={toc:[]},tje="wrapper";function eje(t){let{components:e,...n}=t;return(0,s.kt)(tje,(0,p.Z)({},Kqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eje.isMDXComponent=!0;const nje={toc:[]},oje="wrapper";function pje(t){let{components:e,...n}=t;return(0,s.kt)(oje,(0,p.Z)({},nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pje.isMDXComponent=!0;const rje={toc:[]},sje="wrapper";function cje(t){let{components:e,...n}=t;return(0,s.kt)(sje,(0,p.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cje.isMDXComponent=!0;const ije={toc:[]},aje="wrapper";function lje(t){let{components:e,...n}=t;return(0,s.kt)(aje,(0,p.Z)({},ije,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lje.isMDXComponent=!0;const uje={toc:[]},mje="wrapper";function dje(t){let{components:e,...n}=t;return(0,s.kt)(mje,(0,p.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dje.isMDXComponent=!0;const hje={toc:[]},fje="wrapper";function kje(t){let{components:e,...n}=t;return(0,s.kt)(fje,(0,p.Z)({},hje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}kje.isMDXComponent=!0;const yje={toc:[]},Dje="wrapper";function Mje(t){let{components:e,...n}=t;return(0,s.kt)(Dje,(0,p.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Mje.isMDXComponent=!0;const Xje={toc:[]},_je="wrapper";function wje(t){let{components:e,...n}=t;return(0,s.kt)(_je,(0,p.Z)({},Xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wje.isMDXComponent=!0;const Tje={toc:[]},gje="wrapper";function Cje(t){let{components:e,...n}=t;return(0,s.kt)(gje,(0,p.Z)({},Tje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Cje.isMDXComponent=!0;const xje={toc:[]},vje="wrapper";function Lje(t){let{components:e,...n}=t;return(0,s.kt)(vje,(0,p.Z)({},xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Lje.isMDXComponent=!0;const Zje={toc:[]},bje="wrapper";function Nje(t){let{components:e,...n}=t;return(0,s.kt)(bje,(0,p.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Nje.isMDXComponent=!0;const Aje={toc:[]},zje="wrapper";function Wje(t){let{components:e,...n}=t;return(0,s.kt)(zje,(0,p.Z)({},Aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Wje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Sje(t){let{components:e,...n}=t;return(0,s.kt)(Rje,(0,p.Z)({},Ije,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Sje.isMDXComponent=!0;const Pje={toc:[]},Eje="wrapper";function Oje(t){let{components:e,...n}=t;return(0,s.kt)(Eje,(0,p.Z)({},Pje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Oje.isMDXComponent=!0;const Gje={toc:[]},Fje="wrapper";function Bje(t){let{components:e,...n}=t;return(0,s.kt)(Fje,(0,p.Z)({},Gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Bje.isMDXComponent=!0;const Uje={toc:[]},Vje="wrapper";function qje(t){let{components:e,...n}=t;return(0,s.kt)(Vje,(0,p.Z)({},Uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}qje.isMDXComponent=!0;const jje={toc:[]},Yje="wrapper";function Hje(t){let{components:e,...n}=t;return(0,s.kt)(Yje,(0,p.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Hje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Jje(t){let{components:e,...n}=t;return(0,s.kt)($je,(0,p.Z)({},Qje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Jje.isMDXComponent=!0;const Kje={toc:[]},tYe="wrapper";function eYe(t){let{components:e,...n}=t;return(0,s.kt)(tYe,(0,p.Z)({},Kje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eYe.isMDXComponent=!0;const nYe={toc:[]},oYe="wrapper";function pYe(t){let{components:e,...n}=t;return(0,s.kt)(oYe,(0,p.Z)({},nYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pYe.isMDXComponent=!0;const rYe={toc:[]},sYe="wrapper";function cYe(t){let{components:e,...n}=t;return(0,s.kt)(sYe,(0,p.Z)({},rYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cYe.isMDXComponent=!0;const iYe={toc:[]},aYe="wrapper";function lYe(t){let{components:e,...n}=t;return(0,s.kt)(aYe,(0,p.Z)({},iYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lYe.isMDXComponent=!0;const uYe={toc:[]},mYe="wrapper";function dYe(t){let{components:e,...n}=t;return(0,s.kt)(mYe,(0,p.Z)({},uYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dYe.isMDXComponent=!0;const hYe={toc:[]},fYe="wrapper";function kYe(t){let{components:e,...n}=t;return(0,s.kt)(fYe,(0,p.Z)({},hYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kYe.isMDXComponent=!0;const yYe={toc:[]},DYe="wrapper";function MYe(t){let{components:e,...n}=t;return(0,s.kt)(DYe,(0,p.Z)({},yYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MYe.isMDXComponent=!0;const XYe={toc:[]},_Ye="wrapper";function wYe(t){let{components:e,...n}=t;return(0,s.kt)(_Ye,(0,p.Z)({},XYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wYe.isMDXComponent=!0;const TYe={toc:[]},gYe="wrapper";function CYe(t){let{components:e,...n}=t;return(0,s.kt)(gYe,(0,p.Z)({},TYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}CYe.isMDXComponent=!0;const xYe={toc:[]},vYe="wrapper";function LYe(t){let{components:e,...n}=t;return(0,s.kt)(vYe,(0,p.Z)({},xYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LYe.isMDXComponent=!0;const ZYe={toc:[]},bYe="wrapper";function NYe(t){let{components:e,...n}=t;return(0,s.kt)(bYe,(0,p.Z)({},ZYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NYe.isMDXComponent=!0;const AYe={toc:[]},zYe="wrapper";function WYe(t){let{components:e,...n}=t;return(0,s.kt)(zYe,(0,p.Z)({},AYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function SYe(t){let{components:e,...n}=t;return(0,s.kt)(RYe,(0,p.Z)({},IYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}SYe.isMDXComponent=!0;const PYe={toc:[]},EYe="wrapper";function OYe(t){let{components:e,...n}=t;return(0,s.kt)(EYe,(0,p.Z)({},PYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}OYe.isMDXComponent=!0;const GYe={toc:[]},FYe="wrapper";function BYe(t){let{components:e,...n}=t;return(0,s.kt)(FYe,(0,p.Z)({},GYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BYe.isMDXComponent=!0;const UYe={toc:[]},VYe="wrapper";function qYe(t){let{components:e,...n}=t;return(0,s.kt)(VYe,(0,p.Z)({},UYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qYe.isMDXComponent=!0;const jYe={toc:[]},YYe="wrapper";function HYe(t){let{components:e,...n}=t;return(0,s.kt)(YYe,(0,p.Z)({},jYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function JYe(t){let{components:e,...n}=t;return(0,s.kt)($Ye,(0,p.Z)({},QYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}JYe.isMDXComponent=!0;const KYe={toc:[]},tHe="wrapper";function eHe(t){let{components:e,...n}=t;return(0,s.kt)(tHe,(0,p.Z)({},KYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eHe.isMDXComponent=!0;const nHe={toc:[]},oHe="wrapper";function pHe(t){let{components:e,...n}=t;return(0,s.kt)(oHe,(0,p.Z)({},nHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pHe.isMDXComponent=!0;const rHe={toc:[]},sHe="wrapper";function cHe(t){let{components:e,...n}=t;return(0,s.kt)(sHe,(0,p.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cHe.isMDXComponent=!0;const iHe={toc:[]},aHe="wrapper";function lHe(t){let{components:e,...n}=t;return(0,s.kt)(aHe,(0,p.Z)({},iHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lHe.isMDXComponent=!0;const uHe={toc:[]},mHe="wrapper";function dHe(t){let{components:e,...n}=t;return(0,s.kt)(mHe,(0,p.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dHe.isMDXComponent=!0;const hHe={toc:[]},fHe="wrapper";function kHe(t){let{components:e,...n}=t;return(0,s.kt)(fHe,(0,p.Z)({},hHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kHe.isMDXComponent=!0;const yHe={toc:[]},DHe="wrapper";function MHe(t){let{components:e,...n}=t;return(0,s.kt)(DHe,(0,p.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}MHe.isMDXComponent=!0;const XHe={toc:[]},_He="wrapper";function wHe(t){let{components:e,...n}=t;return(0,s.kt)(_He,(0,p.Z)({},XHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wHe.isMDXComponent=!0;const THe={toc:[]},gHe="wrapper";function CHe(t){let{components:e,...n}=t;return(0,s.kt)(gHe,(0,p.Z)({},THe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}CHe.isMDXComponent=!0;const xHe={toc:[]},vHe="wrapper";function LHe(t){let{components:e,...n}=t;return(0,s.kt)(vHe,(0,p.Z)({},xHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LHe.isMDXComponent=!0;const ZHe={toc:[]},bHe="wrapper";function NHe(t){let{components:e,...n}=t;return(0,s.kt)(bHe,(0,p.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NHe.isMDXComponent=!0;const AHe={toc:[]},zHe="wrapper";function WHe(t){let{components:e,...n}=t;return(0,s.kt)(zHe,(0,p.Z)({},AHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}WHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function SHe(t){let{components:e,...n}=t;return(0,s.kt)(RHe,(0,p.Z)({},IHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SHe.isMDXComponent=!0;const PHe={toc:[]},EHe="wrapper";function OHe(t){let{components:e,...n}=t;return(0,s.kt)(EHe,(0,p.Z)({},PHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}OHe.isMDXComponent=!0;const GHe={toc:[]},FHe="wrapper";function BHe(t){let{components:e,...n}=t;return(0,s.kt)(FHe,(0,p.Z)({},GHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BHe.isMDXComponent=!0;const UHe={toc:[]},VHe="wrapper";function qHe(t){let{components:e,...n}=t;return(0,s.kt)(VHe,(0,p.Z)({},UHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qHe.isMDXComponent=!0;const jHe={toc:[]},YHe="wrapper";function HHe(t){let{components:e,...n}=t;return(0,s.kt)(YHe,(0,p.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}HHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function JHe(t){let{components:e,...n}=t;return(0,s.kt)($He,(0,p.Z)({},QHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}JHe.isMDXComponent=!0;const KHe={toc:[]},tQe="wrapper";function eQe(t){let{components:e,...n}=t;return(0,s.kt)(tQe,(0,p.Z)({},KHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eQe.isMDXComponent=!0;const nQe={toc:[]},oQe="wrapper";function pQe(t){let{components:e,...n}=t;return(0,s.kt)(oQe,(0,p.Z)({},nQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pQe.isMDXComponent=!0;const rQe={toc:[]},sQe="wrapper";function cQe(t){let{components:e,...n}=t;return(0,s.kt)(sQe,(0,p.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cQe.isMDXComponent=!0;const iQe={toc:[]},aQe="wrapper";function lQe(t){let{components:e,...n}=t;return(0,s.kt)(aQe,(0,p.Z)({},iQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lQe.isMDXComponent=!0;const uQe={toc:[]},mQe="wrapper";function dQe(t){let{components:e,...n}=t;return(0,s.kt)(mQe,(0,p.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dQe.isMDXComponent=!0;const hQe={toc:[]},fQe="wrapper";function kQe(t){let{components:e,...n}=t;return(0,s.kt)(fQe,(0,p.Z)({},hQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kQe.isMDXComponent=!0;const yQe={toc:[]},DQe="wrapper";function MQe(t){let{components:e,...n}=t;return(0,s.kt)(DQe,(0,p.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MQe.isMDXComponent=!0;const XQe={toc:[]},_Qe="wrapper";function wQe(t){let{components:e,...n}=t;return(0,s.kt)(_Qe,(0,p.Z)({},XQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wQe.isMDXComponent=!0;const TQe={toc:[]},gQe="wrapper";function CQe(t){let{components:e,...n}=t;return(0,s.kt)(gQe,(0,p.Z)({},TQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}CQe.isMDXComponent=!0;const xQe={toc:[]},vQe="wrapper";function LQe(t){let{components:e,...n}=t;return(0,s.kt)(vQe,(0,p.Z)({},xQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LQe.isMDXComponent=!0;const ZQe={toc:[]},bQe="wrapper";function NQe(t){let{components:e,...n}=t;return(0,s.kt)(bQe,(0,p.Z)({},ZQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NQe.isMDXComponent=!0;const AQe={toc:[]},zQe="wrapper";function WQe(t){let{components:e,...n}=t;return(0,s.kt)(zQe,(0,p.Z)({},AQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}WQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function SQe(t){let{components:e,...n}=t;return(0,s.kt)(RQe,(0,p.Z)({},IQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}SQe.isMDXComponent=!0;const PQe={toc:[]},EQe="wrapper";function OQe(t){let{components:e,...n}=t;return(0,s.kt)(EQe,(0,p.Z)({},PQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}OQe.isMDXComponent=!0;const GQe={toc:[]},FQe="wrapper";function BQe(t){let{components:e,...n}=t;return(0,s.kt)(FQe,(0,p.Z)({},GQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}BQe.isMDXComponent=!0;const UQe={toc:[]},VQe="wrapper";function qQe(t){let{components:e,...n}=t;return(0,s.kt)(VQe,(0,p.Z)({},UQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qQe.isMDXComponent=!0;const jQe={toc:[]},YQe="wrapper";function HQe(t){let{components:e,...n}=t;return(0,s.kt)(YQe,(0,p.Z)({},jQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}HQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function JQe(t){let{components:e,...n}=t;return(0,s.kt)($Qe,(0,p.Z)({},QQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}JQe.isMDXComponent=!0;const KQe={toc:[]},t$e="wrapper";function e$e(t){let{components:e,...n}=t;return(0,s.kt)(t$e,(0,p.Z)({},KQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}e$e.isMDXComponent=!0;const n$e={toc:[]},o$e="wrapper";function p$e(t){let{components:e,...n}=t;return(0,s.kt)(o$e,(0,p.Z)({},n$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}p$e.isMDXComponent=!0;const r$e={toc:[]},s$e="wrapper";function c$e(t){let{components:e,...n}=t;return(0,s.kt)(s$e,(0,p.Z)({},r$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}c$e.isMDXComponent=!0;const i$e={toc:[]},a$e="wrapper";function l$e(t){let{components:e,...n}=t;return(0,s.kt)(a$e,(0,p.Z)({},i$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}l$e.isMDXComponent=!0;const u$e={toc:[]},m$e="wrapper";function d$e(t){let{components:e,...n}=t;return(0,s.kt)(m$e,(0,p.Z)({},u$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}d$e.isMDXComponent=!0;const h$e={toc:[]},f$e="wrapper";function k$e(t){let{components:e,...n}=t;return(0,s.kt)(f$e,(0,p.Z)({},h$e,n,{components:e,mdxType:"MDXLayout"}))}k$e.isMDXComponent=!0;const y$e={toc:[]},D$e="wrapper";function M$e(t){let{components:e,...n}=t;return(0,s.kt)(D$e,(0,p.Z)({},y$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}M$e.isMDXComponent=!0;const X$e={toc:[]},_$e="wrapper";function w$e(t){let{components:e,...n}=t;return(0,s.kt)(_$e,(0,p.Z)({},X$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}w$e.isMDXComponent=!0;const T$e={toc:[]},g$e="wrapper";function C$e(t){let{components:e,...n}=t;return(0,s.kt)(g$e,(0,p.Z)({},T$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}C$e.isMDXComponent=!0;const x$e={toc:[]},v$e="wrapper";function L$e(t){let{components:e,...n}=t;return(0,s.kt)(v$e,(0,p.Z)({},x$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}L$e.isMDXComponent=!0;const Z$e={toc:[]},b$e="wrapper";function N$e(t){let{components:e,...n}=t;return(0,s.kt)(b$e,(0,p.Z)({},Z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}N$e.isMDXComponent=!0;const A$e={toc:[]},z$e="wrapper";function W$e(t){let{components:e,...n}=t;return(0,s.kt)(z$e,(0,p.Z)({},A$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}W$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function S$e(t){let{components:e,...n}=t;return(0,s.kt)(R$e,(0,p.Z)({},I$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}S$e.isMDXComponent=!0;const P$e={toc:[]},E$e="wrapper";function O$e(t){let{components:e,...n}=t;return(0,s.kt)(E$e,(0,p.Z)({},P$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}O$e.isMDXComponent=!0;const G$e={toc:[]},F$e="wrapper";function B$e(t){let{components:e,...n}=t;return(0,s.kt)(F$e,(0,p.Z)({},G$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}B$e.isMDXComponent=!0;const U$e={toc:[]},V$e="wrapper";function q$e(t){let{components:e,...n}=t;return(0,s.kt)(V$e,(0,p.Z)({},U$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}q$e.isMDXComponent=!0;const j$e={toc:[]},Y$e="wrapper";function H$e(t){let{components:e,...n}=t;return(0,s.kt)(Y$e,(0,p.Z)({},j$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}H$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function J$e(t){let{components:e,...n}=t;return(0,s.kt)($$e,(0,p.Z)({},Q$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}J$e.isMDXComponent=!0;const K$e={toc:[]},tJe="wrapper";function eJe(t){let{components:e,...n}=t;return(0,s.kt)(tJe,(0,p.Z)({},K$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}eJe.isMDXComponent=!0;const nJe={toc:[]},oJe="wrapper";function pJe(t){let{components:e,...n}=t;return(0,s.kt)(oJe,(0,p.Z)({},nJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}pJe.isMDXComponent=!0;const rJe={toc:[]},sJe="wrapper";function cJe(t){let{components:e,...n}=t;return(0,s.kt)(sJe,(0,p.Z)({},rJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}cJe.isMDXComponent=!0;const iJe={toc:[]},aJe="wrapper";function lJe(t){let{components:e,...n}=t;return(0,s.kt)(aJe,(0,p.Z)({},iJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lJe.isMDXComponent=!0;const uJe={toc:[]},mJe="wrapper";function dJe(t){let{components:e,...n}=t;return(0,s.kt)(mJe,(0,p.Z)({},uJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dJe.isMDXComponent=!0;const hJe={toc:[]},fJe="wrapper";function kJe(t){let{components:e,...n}=t;return(0,s.kt)(fJe,(0,p.Z)({},hJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kJe.isMDXComponent=!0;const yJe={toc:[]},DJe="wrapper";function MJe(t){let{components:e,...n}=t;return(0,s.kt)(DJe,(0,p.Z)({},yJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}MJe.isMDXComponent=!0;const XJe={toc:[]},_Je="wrapper";function wJe(t){let{components:e,...n}=t;return(0,s.kt)(_Je,(0,p.Z)({},XJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wJe.isMDXComponent=!0;const TJe={toc:[]},gJe="wrapper";function CJe(t){let{components:e,...n}=t;return(0,s.kt)(gJe,(0,p.Z)({},TJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CJe.isMDXComponent=!0;const xJe={toc:[]},vJe="wrapper";function LJe(t){let{components:e,...n}=t;return(0,s.kt)(vJe,(0,p.Z)({},xJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LJe.isMDXComponent=!0;const ZJe={toc:[]},bJe="wrapper";function NJe(t){let{components:e,...n}=t;return(0,s.kt)(bJe,(0,p.Z)({},ZJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NJe.isMDXComponent=!0;const AJe={toc:[]},zJe="wrapper";function WJe(t){let{components:e,...n}=t;return(0,s.kt)(zJe,(0,p.Z)({},AJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}WJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function SJe(t){let{components:e,...n}=t;return(0,s.kt)(RJe,(0,p.Z)({},IJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}SJe.isMDXComponent=!0;const PJe={toc:[]},EJe="wrapper";function OJe(t){let{components:e,...n}=t;return(0,s.kt)(EJe,(0,p.Z)({},PJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}OJe.isMDXComponent=!0;const GJe={toc:[]},FJe="wrapper";function BJe(t){let{components:e,...n}=t;return(0,s.kt)(FJe,(0,p.Z)({},GJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}BJe.isMDXComponent=!0;const UJe={toc:[]},VJe="wrapper";function qJe(t){let{components:e,...n}=t;return(0,s.kt)(VJe,(0,p.Z)({},UJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qJe.isMDXComponent=!0;const jJe={toc:[]},YJe="wrapper";function HJe(t){let{components:e,...n}=t;return(0,s.kt)(YJe,(0,p.Z)({},jJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}HJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function JJe(t){let{components:e,...n}=t;return(0,s.kt)($Je,(0,p.Z)({},QJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}JJe.isMDXComponent=!0;const KJe={toc:[]},tKe="wrapper";function eKe(t){let{components:e,...n}=t;return(0,s.kt)(tKe,(0,p.Z)({},KJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eKe.isMDXComponent=!0;const nKe={toc:[]},oKe="wrapper";function pKe(t){let{components:e,...n}=t;return(0,s.kt)(oKe,(0,p.Z)({},nKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pKe.isMDXComponent=!0;const rKe={toc:[]},sKe="wrapper";function cKe(t){let{components:e,...n}=t;return(0,s.kt)(sKe,(0,p.Z)({},rKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cKe.isMDXComponent=!0;const iKe={toc:[]},aKe="wrapper";function lKe(t){let{components:e,...n}=t;return(0,s.kt)(aKe,(0,p.Z)({},iKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lKe.isMDXComponent=!0;const uKe={toc:[]},mKe="wrapper";function dKe(t){let{components:e,...n}=t;return(0,s.kt)(mKe,(0,p.Z)({},uKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dKe.isMDXComponent=!0;const hKe={toc:[]},fKe="wrapper";function kKe(t){let{components:e,...n}=t;return(0,s.kt)(fKe,(0,p.Z)({},hKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kKe.isMDXComponent=!0;const yKe={toc:[]},DKe="wrapper";function MKe(t){let{components:e,...n}=t;return(0,s.kt)(DKe,(0,p.Z)({},yKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MKe.isMDXComponent=!0;const XKe={toc:[]},_Ke="wrapper";function wKe(t){let{components:e,...n}=t;return(0,s.kt)(_Ke,(0,p.Z)({},XKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wKe.isMDXComponent=!0;const TKe={toc:[]},gKe="wrapper";function CKe(t){let{components:e,...n}=t;return(0,s.kt)(gKe,(0,p.Z)({},TKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CKe.isMDXComponent=!0;const xKe={toc:[]},vKe="wrapper";function LKe(t){let{components:e,...n}=t;return(0,s.kt)(vKe,(0,p.Z)({},xKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LKe.isMDXComponent=!0;const ZKe={toc:[]},bKe="wrapper";function NKe(t){let{components:e,...n}=t;return(0,s.kt)(bKe,(0,p.Z)({},ZKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NKe.isMDXComponent=!0;const AKe={toc:[]},zKe="wrapper";function WKe(t){let{components:e,...n}=t;return(0,s.kt)(zKe,(0,p.Z)({},AKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}WKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function SKe(t){let{components:e,...n}=t;return(0,s.kt)(RKe,(0,p.Z)({},IKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}SKe.isMDXComponent=!0;const PKe={toc:[]},EKe="wrapper";function OKe(t){let{components:e,...n}=t;return(0,s.kt)(EKe,(0,p.Z)({},PKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}OKe.isMDXComponent=!0;const GKe={toc:[]},FKe="wrapper";function BKe(t){let{components:e,...n}=t;return(0,s.kt)(FKe,(0,p.Z)({},GKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BKe.isMDXComponent=!0;const UKe={toc:[]},VKe="wrapper";function qKe(t){let{components:e,...n}=t;return(0,s.kt)(VKe,(0,p.Z)({},UKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qKe.isMDXComponent=!0;const jKe={toc:[]},YKe="wrapper";function HKe(t){let{components:e,...n}=t;return(0,s.kt)(YKe,(0,p.Z)({},jKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}HKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function JKe(t){let{components:e,...n}=t;return(0,s.kt)($Ke,(0,p.Z)({},QKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}JKe.isMDXComponent=!0;const KKe={toc:[]},t0e="wrapper";function e0e(t){let{components:e,...n}=t;return(0,s.kt)(t0e,(0,p.Z)({},KKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}e0e.isMDXComponent=!0;const n0e={toc:[]},o0e="wrapper";function p0e(t){let{components:e,...n}=t;return(0,s.kt)(o0e,(0,p.Z)({},n0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}p0e.isMDXComponent=!0;const r0e={toc:[]},s0e="wrapper";function c0e(t){let{components:e,...n}=t;return(0,s.kt)(s0e,(0,p.Z)({},r0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}c0e.isMDXComponent=!0;const i0e={toc:[]},a0e="wrapper";function l0e(t){let{components:e,...n}=t;return(0,s.kt)(a0e,(0,p.Z)({},i0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}l0e.isMDXComponent=!0;const u0e={toc:[]},m0e="wrapper";function d0e(t){let{components:e,...n}=t;return(0,s.kt)(m0e,(0,p.Z)({},u0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}d0e.isMDXComponent=!0;const h0e={toc:[]},f0e="wrapper";function k0e(t){let{components:e,...n}=t;return(0,s.kt)(f0e,(0,p.Z)({},h0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}k0e.isMDXComponent=!0;const y0e={toc:[]},D0e="wrapper";function M0e(t){let{components:e,...n}=t;return(0,s.kt)(D0e,(0,p.Z)({},y0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}M0e.isMDXComponent=!0;const X0e={toc:[]},_0e="wrapper";function w0e(t){let{components:e,...n}=t;return(0,s.kt)(_0e,(0,p.Z)({},X0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}w0e.isMDXComponent=!0;const T0e={toc:[]},g0e="wrapper";function C0e(t){let{components:e,...n}=t;return(0,s.kt)(g0e,(0,p.Z)({},T0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}C0e.isMDXComponent=!0;const x0e={toc:[]},v0e="wrapper";function L0e(t){let{components:e,...n}=t;return(0,s.kt)(v0e,(0,p.Z)({},x0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}L0e.isMDXComponent=!0;const Z0e={toc:[]},b0e="wrapper";function N0e(t){let{components:e,...n}=t;return(0,s.kt)(b0e,(0,p.Z)({},Z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}N0e.isMDXComponent=!0;const A0e={toc:[]},z0e="wrapper";function W0e(t){let{components:e,...n}=t;return(0,s.kt)(z0e,(0,p.Z)({},A0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function S0e(t){let{components:e,...n}=t;return(0,s.kt)(R0e,(0,p.Z)({},I0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}S0e.isMDXComponent=!0;const P0e={toc:[]},E0e="wrapper";function O0e(t){let{components:e,...n}=t;return(0,s.kt)(E0e,(0,p.Z)({},P0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}O0e.isMDXComponent=!0;const G0e={toc:[]},F0e="wrapper";function B0e(t){let{components:e,...n}=t;return(0,s.kt)(F0e,(0,p.Z)({},G0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B0e.isMDXComponent=!0;const U0e={toc:[]},V0e="wrapper";function q0e(t){let{components:e,...n}=t;return(0,s.kt)(V0e,(0,p.Z)({},U0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}q0e.isMDXComponent=!0;const j0e={toc:[]},Y0e="wrapper";function H0e(t){let{components:e,...n}=t;return(0,s.kt)(Y0e,(0,p.Z)({},j0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}H0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function J0e(t){let{components:e,...n}=t;return(0,s.kt)($0e,(0,p.Z)({},Q0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}J0e.isMDXComponent=!0;const K0e={toc:[]},t2e="wrapper";function e2e(t){let{components:e,...n}=t;return(0,s.kt)(t2e,(0,p.Z)({},K0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}e2e.isMDXComponent=!0;const n2e={toc:[]},o2e="wrapper";function p2e(t){let{components:e,...n}=t;return(0,s.kt)(o2e,(0,p.Z)({},n2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}p2e.isMDXComponent=!0;const r2e={toc:[]},s2e="wrapper";function c2e(t){let{components:e,...n}=t;return(0,s.kt)(s2e,(0,p.Z)({},r2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}c2e.isMDXComponent=!0;const i2e={toc:[]},a2e="wrapper";function l2e(t){let{components:e,...n}=t;return(0,s.kt)(a2e,(0,p.Z)({},i2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}l2e.isMDXComponent=!0;const u2e={toc:[]},m2e="wrapper";function d2e(t){let{components:e,...n}=t;return(0,s.kt)(m2e,(0,p.Z)({},u2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}d2e.isMDXComponent=!0;const h2e={toc:[]},f2e="wrapper";function k2e(t){let{components:e,...n}=t;return(0,s.kt)(f2e,(0,p.Z)({},h2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}k2e.isMDXComponent=!0;const y2e={toc:[]},D2e="wrapper";function M2e(t){let{components:e,...n}=t;return(0,s.kt)(D2e,(0,p.Z)({},y2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}M2e.isMDXComponent=!0;const X2e={toc:[]},_2e="wrapper";function w2e(t){let{components:e,...n}=t;return(0,s.kt)(_2e,(0,p.Z)({},X2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}w2e.isMDXComponent=!0;const T2e={toc:[]},g2e="wrapper";function C2e(t){let{components:e,...n}=t;return(0,s.kt)(g2e,(0,p.Z)({},T2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}C2e.isMDXComponent=!0;const x2e={toc:[]},v2e="wrapper";function L2e(t){let{components:e,...n}=t;return(0,s.kt)(v2e,(0,p.Z)({},x2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}L2e.isMDXComponent=!0;const Z2e={toc:[]},b2e="wrapper";function N2e(t){let{components:e,...n}=t;return(0,s.kt)(b2e,(0,p.Z)({},Z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}N2e.isMDXComponent=!0;const A2e={toc:[]},z2e="wrapper";function W2e(t){let{components:e,...n}=t;return(0,s.kt)(z2e,(0,p.Z)({},A2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}W2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function S2e(t){let{components:e,...n}=t;return(0,s.kt)(R2e,(0,p.Z)({},I2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}S2e.isMDXComponent=!0;const P2e={toc:[]},E2e="wrapper";function O2e(t){let{components:e,...n}=t;return(0,s.kt)(E2e,(0,p.Z)({},P2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}O2e.isMDXComponent=!0;const G2e={toc:[]},F2e="wrapper";function B2e(t){let{components:e,...n}=t;return(0,s.kt)(F2e,(0,p.Z)({},G2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}B2e.isMDXComponent=!0;const U2e={toc:[]},V2e="wrapper";function q2e(t){let{components:e,...n}=t;return(0,s.kt)(V2e,(0,p.Z)({},U2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}q2e.isMDXComponent=!0;const j2e={toc:[]},Y2e="wrapper";function H2e(t){let{components:e,...n}=t;return(0,s.kt)(Y2e,(0,p.Z)({},j2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}H2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function J2e(t){let{components:e,...n}=t;return(0,s.kt)($2e,(0,p.Z)({},Q2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}J2e.isMDXComponent=!0;const K2e={toc:[]},t6e="wrapper";function e6e(t){let{components:e,...n}=t;return(0,s.kt)(t6e,(0,p.Z)({},K2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}e6e.isMDXComponent=!0;const n6e={toc:[]},o6e="wrapper";function p6e(t){let{components:e,...n}=t;return(0,s.kt)(o6e,(0,p.Z)({},n6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}p6e.isMDXComponent=!0;const r6e={toc:[]},s6e="wrapper";function c6e(t){let{components:e,...n}=t;return(0,s.kt)(s6e,(0,p.Z)({},r6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}c6e.isMDXComponent=!0;const i6e={toc:[]},a6e="wrapper";function l6e(t){let{components:e,...n}=t;return(0,s.kt)(a6e,(0,p.Z)({},i6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}l6e.isMDXComponent=!0;const u6e={toc:[]},m6e="wrapper";function d6e(t){let{components:e,...n}=t;return(0,s.kt)(m6e,(0,p.Z)({},u6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}d6e.isMDXComponent=!0;const h6e={toc:[]},f6e="wrapper";function k6e(t){let{components:e,...n}=t;return(0,s.kt)(f6e,(0,p.Z)({},h6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k6e.isMDXComponent=!0;const y6e={toc:[]},D6e="wrapper";function M6e(t){let{components:e,...n}=t;return(0,s.kt)(D6e,(0,p.Z)({},y6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}M6e.isMDXComponent=!0;const X6e={toc:[]},_6e="wrapper";function w6e(t){let{components:e,...n}=t;return(0,s.kt)(_6e,(0,p.Z)({},X6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w6e.isMDXComponent=!0;const T6e={toc:[]},g6e="wrapper";function C6e(t){let{components:e,...n}=t;return(0,s.kt)(g6e,(0,p.Z)({},T6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}C6e.isMDXComponent=!0;const x6e={toc:[]},v6e="wrapper";function L6e(t){let{components:e,...n}=t;return(0,s.kt)(v6e,(0,p.Z)({},x6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}L6e.isMDXComponent=!0;const Z6e={toc:[]},b6e="wrapper";function N6e(t){let{components:e,...n}=t;return(0,s.kt)(b6e,(0,p.Z)({},Z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}N6e.isMDXComponent=!0;const A6e={toc:[]},z6e="wrapper";function W6e(t){let{components:e,...n}=t;return(0,s.kt)(z6e,(0,p.Z)({},A6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}W6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function S6e(t){let{components:e,...n}=t;return(0,s.kt)(R6e,(0,p.Z)({},I6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}S6e.isMDXComponent=!0;const P6e={toc:[]},E6e="wrapper";function O6e(t){let{components:e,...n}=t;return(0,s.kt)(E6e,(0,p.Z)({},P6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}O6e.isMDXComponent=!0;const G6e={toc:[]},F6e="wrapper";function B6e(t){let{components:e,...n}=t;return(0,s.kt)(F6e,(0,p.Z)({},G6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}B6e.isMDXComponent=!0;const U6e={toc:[]},V6e="wrapper";function q6e(t){let{components:e,...n}=t;return(0,s.kt)(V6e,(0,p.Z)({},U6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q6e.isMDXComponent=!0;const j6e={toc:[]},Y6e="wrapper";function H6e(t){let{components:e,...n}=t;return(0,s.kt)(Y6e,(0,p.Z)({},j6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}H6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function J6e(t){let{components:e,...n}=t;return(0,s.kt)($6e,(0,p.Z)({},Q6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}J6e.isMDXComponent=!0;const K6e={toc:[]},t3e="wrapper";function e3e(t){let{components:e,...n}=t;return(0,s.kt)(t3e,(0,p.Z)({},K6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}e3e.isMDXComponent=!0;const n3e={toc:[]},o3e="wrapper";function p3e(t){let{components:e,...n}=t;return(0,s.kt)(o3e,(0,p.Z)({},n3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}p3e.isMDXComponent=!0;const r3e={toc:[]},s3e="wrapper";function c3e(t){let{components:e,...n}=t;return(0,s.kt)(s3e,(0,p.Z)({},r3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c3e.isMDXComponent=!0;const i3e={toc:[]},a3e="wrapper";function l3e(t){let{components:e,...n}=t;return(0,s.kt)(a3e,(0,p.Z)({},i3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l3e.isMDXComponent=!0;const u3e={toc:[]},m3e="wrapper";function d3e(t){let{components:e,...n}=t;return(0,s.kt)(m3e,(0,p.Z)({},u3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}d3e.isMDXComponent=!0;const h3e={toc:[]},f3e="wrapper";function k3e(t){let{components:e,...n}=t;return(0,s.kt)(f3e,(0,p.Z)({},h3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}k3e.isMDXComponent=!0;const y3e={toc:[]},D3e="wrapper";function M3e(t){let{components:e,...n}=t;return(0,s.kt)(D3e,(0,p.Z)({},y3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}M3e.isMDXComponent=!0;const X3e={toc:[]},_3e="wrapper";function w3e(t){let{components:e,...n}=t;return(0,s.kt)(_3e,(0,p.Z)({},X3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w3e.isMDXComponent=!0;const T3e={toc:[]},g3e="wrapper";function C3e(t){let{components:e,...n}=t;return(0,s.kt)(g3e,(0,p.Z)({},T3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}C3e.isMDXComponent=!0;const x3e={toc:[]},v3e="wrapper";function L3e(t){let{components:e,...n}=t;return(0,s.kt)(v3e,(0,p.Z)({},x3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L3e.isMDXComponent=!0;const Z3e={toc:[]},b3e="wrapper";function N3e(t){let{components:e,...n}=t;return(0,s.kt)(b3e,(0,p.Z)({},Z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}N3e.isMDXComponent=!0;const A3e={toc:[]},z3e="wrapper";function W3e(t){let{components:e,...n}=t;return(0,s.kt)(z3e,(0,p.Z)({},A3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}W3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function S3e(t){let{components:e,...n}=t;return(0,s.kt)(R3e,(0,p.Z)({},I3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S3e.isMDXComponent=!0;const P3e={toc:[]},E3e="wrapper";function O3e(t){let{components:e,...n}=t;return(0,s.kt)(E3e,(0,p.Z)({},P3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}O3e.isMDXComponent=!0;const G3e={toc:[]},F3e="wrapper";function B3e(t){let{components:e,...n}=t;return(0,s.kt)(F3e,(0,p.Z)({},G3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}B3e.isMDXComponent=!0;const U3e={toc:[]},V3e="wrapper";function q3e(t){let{components:e,...n}=t;return(0,s.kt)(V3e,(0,p.Z)({},U3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}q3e.isMDXComponent=!0;const j3e={toc:[]},Y3e="wrapper";function H3e(t){let{components:e,...n}=t;return(0,s.kt)(Y3e,(0,p.Z)({},j3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}H3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function J3e(t){let{components:e,...n}=t;return(0,s.kt)($3e,(0,p.Z)({},Q3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}J3e.isMDXComponent=!0;const K3e={toc:[]},t5e="wrapper";function e5e(t){let{components:e,...n}=t;return(0,s.kt)(t5e,(0,p.Z)({},K3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}e5e.isMDXComponent=!0;const n5e={toc:[]},o5e="wrapper";function p5e(t){let{components:e,...n}=t;return(0,s.kt)(o5e,(0,p.Z)({},n5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}p5e.isMDXComponent=!0;const r5e={toc:[]},s5e="wrapper";function c5e(t){let{components:e,...n}=t;return(0,s.kt)(s5e,(0,p.Z)({},r5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c5e.isMDXComponent=!0;const i5e={toc:[]},a5e="wrapper";function l5e(t){let{components:e,...n}=t;return(0,s.kt)(a5e,(0,p.Z)({},i5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l5e.isMDXComponent=!0;const u5e={toc:[]},m5e="wrapper";function d5e(t){let{components:e,...n}=t;return(0,s.kt)(m5e,(0,p.Z)({},u5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}d5e.isMDXComponent=!0;const h5e={toc:[]},f5e="wrapper";function k5e(t){let{components:e,...n}=t;return(0,s.kt)(f5e,(0,p.Z)({},h5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}k5e.isMDXComponent=!0;const y5e={toc:[]},D5e="wrapper";function M5e(t){let{components:e,...n}=t;return(0,s.kt)(D5e,(0,p.Z)({},y5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}M5e.isMDXComponent=!0;const X5e={toc:[]},_5e="wrapper";function w5e(t){let{components:e,...n}=t;return(0,s.kt)(_5e,(0,p.Z)({},X5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w5e.isMDXComponent=!0;const T5e={toc:[]},g5e="wrapper";function C5e(t){let{components:e,...n}=t;return(0,s.kt)(g5e,(0,p.Z)({},T5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}C5e.isMDXComponent=!0;const x5e={toc:[]},v5e="wrapper";function L5e(t){let{components:e,...n}=t;return(0,s.kt)(v5e,(0,p.Z)({},x5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}L5e.isMDXComponent=!0;const Z5e={toc:[]},b5e="wrapper";function N5e(t){let{components:e,...n}=t;return(0,s.kt)(b5e,(0,p.Z)({},Z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}N5e.isMDXComponent=!0;const A5e={toc:[]},z5e="wrapper";function W5e(t){let{components:e,...n}=t;return(0,s.kt)(z5e,(0,p.Z)({},A5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}W5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function S5e(t){let{components:e,...n}=t;return(0,s.kt)(R5e,(0,p.Z)({},I5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}S5e.isMDXComponent=!0;const P5e={toc:[]},E5e="wrapper";function O5e(t){let{components:e,...n}=t;return(0,s.kt)(E5e,(0,p.Z)({},P5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}O5e.isMDXComponent=!0;const G5e={toc:[]},F5e="wrapper";function B5e(t){let{components:e,...n}=t;return(0,s.kt)(F5e,(0,p.Z)({},G5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}B5e.isMDXComponent=!0;const U5e={toc:[]},V5e="wrapper";function q5e(t){let{components:e,...n}=t;return(0,s.kt)(V5e,(0,p.Z)({},U5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q5e.isMDXComponent=!0;const j5e={toc:[]},Y5e="wrapper";function H5e(t){let{components:e,...n}=t;return(0,s.kt)(Y5e,(0,p.Z)({},j5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}H5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function J5e(t){let{components:e,...n}=t;return(0,s.kt)($5e,(0,p.Z)({},Q5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}J5e.isMDXComponent=!0;const K5e={toc:[]},t1e="wrapper";function e1e(t){let{components:e,...n}=t;return(0,s.kt)(t1e,(0,p.Z)({},K5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}e1e.isMDXComponent=!0;const n1e={toc:[]},o1e="wrapper";function p1e(t){let{components:e,...n}=t;return(0,s.kt)(o1e,(0,p.Z)({},n1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}p1e.isMDXComponent=!0;const r1e={toc:[]},s1e="wrapper";function c1e(t){let{components:e,...n}=t;return(0,s.kt)(s1e,(0,p.Z)({},r1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}c1e.isMDXComponent=!0;const i1e={toc:[]},a1e="wrapper";function l1e(t){let{components:e,...n}=t;return(0,s.kt)(a1e,(0,p.Z)({},i1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}l1e.isMDXComponent=!0;const u1e={toc:[]},m1e="wrapper";function d1e(t){let{components:e,...n}=t;return(0,s.kt)(m1e,(0,p.Z)({},u1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d1e.isMDXComponent=!0;const h1e={toc:[]},f1e="wrapper";function k1e(t){let{components:e,...n}=t;return(0,s.kt)(f1e,(0,p.Z)({},h1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}k1e.isMDXComponent=!0;const y1e={toc:[]},D1e="wrapper";function M1e(t){let{components:e,...n}=t;return(0,s.kt)(D1e,(0,p.Z)({},y1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}M1e.isMDXComponent=!0;const X1e={toc:[]},_1e="wrapper";function w1e(t){let{components:e,...n}=t;return(0,s.kt)(_1e,(0,p.Z)({},X1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}w1e.isMDXComponent=!0;const T1e={toc:[]},g1e="wrapper";function C1e(t){let{components:e,...n}=t;return(0,s.kt)(g1e,(0,p.Z)({},T1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}C1e.isMDXComponent=!0;const x1e={toc:[]},v1e="wrapper";function L1e(t){let{components:e,...n}=t;return(0,s.kt)(v1e,(0,p.Z)({},x1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}L1e.isMDXComponent=!0;const Z1e={toc:[]},b1e="wrapper";function N1e(t){let{components:e,...n}=t;return(0,s.kt)(b1e,(0,p.Z)({},Z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}N1e.isMDXComponent=!0;const A1e={toc:[]},z1e="wrapper";function W1e(t){let{components:e,...n}=t;return(0,s.kt)(z1e,(0,p.Z)({},A1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}W1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function S1e(t){let{components:e,...n}=t;return(0,s.kt)(R1e,(0,p.Z)({},I1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}S1e.isMDXComponent=!0;const P1e={toc:[]},E1e="wrapper";function O1e(t){let{components:e,...n}=t;return(0,s.kt)(E1e,(0,p.Z)({},P1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}O1e.isMDXComponent=!0;const G1e={toc:[]},F1e="wrapper";function B1e(t){let{components:e,...n}=t;return(0,s.kt)(F1e,(0,p.Z)({},G1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}B1e.isMDXComponent=!0;const U1e={toc:[]},V1e="wrapper";function q1e(t){let{components:e,...n}=t;return(0,s.kt)(V1e,(0,p.Z)({},U1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}q1e.isMDXComponent=!0;const j1e={toc:[]},Y1e="wrapper";function H1e(t){let{components:e,...n}=t;return(0,s.kt)(Y1e,(0,p.Z)({},j1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}H1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function J1e(t){let{components:e,...n}=t;return(0,s.kt)($1e,(0,p.Z)({},Q1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}J1e.isMDXComponent=!0;const K1e={toc:[]},t4e="wrapper";function e4e(t){let{components:e,...n}=t;return(0,s.kt)(t4e,(0,p.Z)({},K1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}e4e.isMDXComponent=!0;const n4e={toc:[]},o4e="wrapper";function p4e(t){let{components:e,...n}=t;return(0,s.kt)(o4e,(0,p.Z)({},n4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}p4e.isMDXComponent=!0;const r4e={toc:[]},s4e="wrapper";function c4e(t){let{components:e,...n}=t;return(0,s.kt)(s4e,(0,p.Z)({},r4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}c4e.isMDXComponent=!0;const i4e={toc:[]},a4e="wrapper";function l4e(t){let{components:e,...n}=t;return(0,s.kt)(a4e,(0,p.Z)({},i4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}l4e.isMDXComponent=!0;const u4e={toc:[]},m4e="wrapper";function d4e(t){let{components:e,...n}=t;return(0,s.kt)(m4e,(0,p.Z)({},u4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}d4e.isMDXComponent=!0;const h4e={toc:[]},f4e="wrapper";function k4e(t){let{components:e,...n}=t;return(0,s.kt)(f4e,(0,p.Z)({},h4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}k4e.isMDXComponent=!0;const y4e={toc:[]},D4e="wrapper";function M4e(t){let{components:e,...n}=t;return(0,s.kt)(D4e,(0,p.Z)({},y4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M4e.isMDXComponent=!0;const X4e={toc:[]},_4e="wrapper";function w4e(t){let{components:e,...n}=t;return(0,s.kt)(_4e,(0,p.Z)({},X4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}w4e.isMDXComponent=!0;const T4e={toc:[]},g4e="wrapper";function C4e(t){let{components:e,...n}=t;return(0,s.kt)(g4e,(0,p.Z)({},T4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}C4e.isMDXComponent=!0;const x4e={toc:[]},v4e="wrapper";function L4e(t){let{components:e,...n}=t;return(0,s.kt)(v4e,(0,p.Z)({},x4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}L4e.isMDXComponent=!0;const Z4e={toc:[]},b4e="wrapper";function N4e(t){let{components:e,...n}=t;return(0,s.kt)(b4e,(0,p.Z)({},Z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}N4e.isMDXComponent=!0;const A4e={toc:[]},z4e="wrapper";function W4e(t){let{components:e,...n}=t;return(0,s.kt)(z4e,(0,p.Z)({},A4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}W4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function S4e(t){let{components:e,...n}=t;return(0,s.kt)(R4e,(0,p.Z)({},I4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}S4e.isMDXComponent=!0;const P4e={toc:[]},E4e="wrapper";function O4e(t){let{components:e,...n}=t;return(0,s.kt)(E4e,(0,p.Z)({},P4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}O4e.isMDXComponent=!0;const G4e={toc:[]},F4e="wrapper";function B4e(t){let{components:e,...n}=t;return(0,s.kt)(F4e,(0,p.Z)({},G4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}B4e.isMDXComponent=!0;const U4e={toc:[]},V4e="wrapper";function q4e(t){let{components:e,...n}=t;return(0,s.kt)(V4e,(0,p.Z)({},U4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}q4e.isMDXComponent=!0;const j4e={toc:[]},Y4e="wrapper";function H4e(t){let{components:e,...n}=t;return(0,s.kt)(Y4e,(0,p.Z)({},j4e,n,{components:e,mdxType:"MDXLayout"}))}H4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function J4e(t){let{components:e,...n}=t;return(0,s.kt)($4e,(0,p.Z)({},Q4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}J4e.isMDXComponent=!0;const K4e={toc:[]},t8e="wrapper";function e8e(t){let{components:e,...n}=t;return(0,s.kt)(t8e,(0,p.Z)({},K4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}e8e.isMDXComponent=!0;const n8e={toc:[]},o8e="wrapper";function p8e(t){let{components:e,...n}=t;return(0,s.kt)(o8e,(0,p.Z)({},n8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}p8e.isMDXComponent=!0;const r8e={toc:[]},s8e="wrapper";function c8e(t){let{components:e,...n}=t;return(0,s.kt)(s8e,(0,p.Z)({},r8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}c8e.isMDXComponent=!0;const i8e={toc:[]},a8e="wrapper";function l8e(t){let{components:e,...n}=t;return(0,s.kt)(a8e,(0,p.Z)({},i8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}l8e.isMDXComponent=!0;const u8e={toc:[]},m8e="wrapper";function d8e(t){let{components:e,...n}=t;return(0,s.kt)(m8e,(0,p.Z)({},u8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}d8e.isMDXComponent=!0;const h8e={toc:[]},f8e="wrapper";function k8e(t){let{components:e,...n}=t;return(0,s.kt)(f8e,(0,p.Z)({},h8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}k8e.isMDXComponent=!0;const y8e={toc:[]},D8e="wrapper";function M8e(t){let{components:e,...n}=t;return(0,s.kt)(D8e,(0,p.Z)({},y8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}M8e.isMDXComponent=!0;const X8e={toc:[]},_8e="wrapper";function w8e(t){let{components:e,...n}=t;return(0,s.kt)(_8e,(0,p.Z)({},X8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}w8e.isMDXComponent=!0;const T8e={toc:[]},g8e="wrapper";function C8e(t){let{components:e,...n}=t;return(0,s.kt)(g8e,(0,p.Z)({},T8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}C8e.isMDXComponent=!0;const x8e={toc:[]},v8e="wrapper";function L8e(t){let{components:e,...n}=t;return(0,s.kt)(v8e,(0,p.Z)({},x8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}L8e.isMDXComponent=!0;const Z8e={toc:[]},b8e="wrapper";function N8e(t){let{components:e,...n}=t;return(0,s.kt)(b8e,(0,p.Z)({},Z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}N8e.isMDXComponent=!0;const A8e={toc:[]},z8e="wrapper";function W8e(t){let{components:e,...n}=t;return(0,s.kt)(z8e,(0,p.Z)({},A8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}W8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function S8e(t){let{components:e,...n}=t;return(0,s.kt)(R8e,(0,p.Z)({},I8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}S8e.isMDXComponent=!0;const P8e={toc:[]},E8e="wrapper";function O8e(t){let{components:e,...n}=t;return(0,s.kt)(E8e,(0,p.Z)({},P8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}O8e.isMDXComponent=!0;const G8e={toc:[]},F8e="wrapper";function B8e(t){let{components:e,...n}=t;return(0,s.kt)(F8e,(0,p.Z)({},G8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}B8e.isMDXComponent=!0;const U8e={toc:[]},V8e="wrapper";function q8e(t){let{components:e,...n}=t;return(0,s.kt)(V8e,(0,p.Z)({},U8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}q8e.isMDXComponent=!0;const j8e={toc:[]},Y8e="wrapper";function H8e(t){let{components:e,...n}=t;return(0,s.kt)(Y8e,(0,p.Z)({},j8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}H8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function J8e(t){let{components:e,...n}=t;return(0,s.kt)($8e,(0,p.Z)({},Q8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}J8e.isMDXComponent=!0;const K8e={toc:[]},t7e="wrapper";function e7e(t){let{components:e,...n}=t;return(0,s.kt)(t7e,(0,p.Z)({},K8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}e7e.isMDXComponent=!0;const n7e={toc:[]},o7e="wrapper";function p7e(t){let{components:e,...n}=t;return(0,s.kt)(o7e,(0,p.Z)({},n7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}p7e.isMDXComponent=!0;const r7e={toc:[]},s7e="wrapper";function c7e(t){let{components:e,...n}=t;return(0,s.kt)(s7e,(0,p.Z)({},r7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}c7e.isMDXComponent=!0;const i7e={toc:[]},a7e="wrapper";function l7e(t){let{components:e,...n}=t;return(0,s.kt)(a7e,(0,p.Z)({},i7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}l7e.isMDXComponent=!0;const u7e={toc:[]},m7e="wrapper";function d7e(t){let{components:e,...n}=t;return(0,s.kt)(m7e,(0,p.Z)({},u7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}d7e.isMDXComponent=!0;const h7e={toc:[]},f7e="wrapper";function k7e(t){let{components:e,...n}=t;return(0,s.kt)(f7e,(0,p.Z)({},h7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}k7e.isMDXComponent=!0;const y7e={toc:[]},D7e="wrapper";function M7e(t){let{components:e,...n}=t;return(0,s.kt)(D7e,(0,p.Z)({},y7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}M7e.isMDXComponent=!0;const X7e={toc:[]},_7e="wrapper";function w7e(t){let{components:e,...n}=t;return(0,s.kt)(_7e,(0,p.Z)({},X7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}w7e.isMDXComponent=!0;const T7e={toc:[]},g7e="wrapper";function C7e(t){let{components:e,...n}=t;return(0,s.kt)(g7e,(0,p.Z)({},T7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}C7e.isMDXComponent=!0;const x7e={toc:[]},v7e="wrapper";function L7e(t){let{components:e,...n}=t;return(0,s.kt)(v7e,(0,p.Z)({},x7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}L7e.isMDXComponent=!0;const Z7e={toc:[]},b7e="wrapper";function N7e(t){let{components:e,...n}=t;return(0,s.kt)(b7e,(0,p.Z)({},Z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}N7e.isMDXComponent=!0;const A7e={toc:[]},z7e="wrapper";function W7e(t){let{components:e,...n}=t;return(0,s.kt)(z7e,(0,p.Z)({},A7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}W7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function S7e(t){let{components:e,...n}=t;return(0,s.kt)(R7e,(0,p.Z)({},I7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}S7e.isMDXComponent=!0;const P7e={toc:[]},E7e="wrapper";function O7e(t){let{components:e,...n}=t;return(0,s.kt)(E7e,(0,p.Z)({},P7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}O7e.isMDXComponent=!0;const G7e={toc:[]},F7e="wrapper";function B7e(t){let{components:e,...n}=t;return(0,s.kt)(F7e,(0,p.Z)({},G7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}B7e.isMDXComponent=!0;const U7e={toc:[]},V7e="wrapper";function q7e(t){let{components:e,...n}=t;return(0,s.kt)(V7e,(0,p.Z)({},U7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}q7e.isMDXComponent=!0;const j7e={toc:[]},Y7e="wrapper";function H7e(t){let{components:e,...n}=t;return(0,s.kt)(Y7e,(0,p.Z)({},j7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}H7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function J7e(t){let{components:e,...n}=t;return(0,s.kt)($7e,(0,p.Z)({},Q7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}J7e.isMDXComponent=!0;const K7e={toc:[]},t9e="wrapper";function e9e(t){let{components:e,...n}=t;return(0,s.kt)(t9e,(0,p.Z)({},K7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}e9e.isMDXComponent=!0;const n9e={toc:[]},o9e="wrapper";function p9e(t){let{components:e,...n}=t;return(0,s.kt)(o9e,(0,p.Z)({},n9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p9e.isMDXComponent=!0;const r9e={toc:[]},s9e="wrapper";function c9e(t){let{components:e,...n}=t;return(0,s.kt)(s9e,(0,p.Z)({},r9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c9e.isMDXComponent=!0;const i9e={toc:[]},a9e="wrapper";function l9e(t){let{components:e,...n}=t;return(0,s.kt)(a9e,(0,p.Z)({},i9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l9e.isMDXComponent=!0;const u9e={toc:[]},m9e="wrapper";function d9e(t){let{components:e,...n}=t;return(0,s.kt)(m9e,(0,p.Z)({},u9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}d9e.isMDXComponent=!0;const h9e={toc:[]},f9e="wrapper";function k9e(t){let{components:e,...n}=t;return(0,s.kt)(f9e,(0,p.Z)({},h9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}k9e.isMDXComponent=!0;const y9e={toc:[]},D9e="wrapper";function M9e(t){let{components:e,...n}=t;return(0,s.kt)(D9e,(0,p.Z)({},y9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}M9e.isMDXComponent=!0;const X9e={toc:[]},_9e="wrapper";function w9e(t){let{components:e,...n}=t;return(0,s.kt)(_9e,(0,p.Z)({},X9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}w9e.isMDXComponent=!0;const T9e={toc:[]},g9e="wrapper";function C9e(t){let{components:e,...n}=t;return(0,s.kt)(g9e,(0,p.Z)({},T9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C9e.isMDXComponent=!0;const x9e={toc:[]},v9e="wrapper";function L9e(t){let{components:e,...n}=t;return(0,s.kt)(v9e,(0,p.Z)({},x9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L9e.isMDXComponent=!0;const Z9e={toc:[]},b9e="wrapper";function N9e(t){let{components:e,...n}=t;return(0,s.kt)(b9e,(0,p.Z)({},Z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N9e.isMDXComponent=!0;const A9e={toc:[]},z9e="wrapper";function W9e(t){let{components:e,...n}=t;return(0,s.kt)(z9e,(0,p.Z)({},A9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function S9e(t){let{components:e,...n}=t;return(0,s.kt)(R9e,(0,p.Z)({},I9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}S9e.isMDXComponent=!0;const P9e={toc:[]},E9e="wrapper";function O9e(t){let{components:e,...n}=t;return(0,s.kt)(E9e,(0,p.Z)({},P9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O9e.isMDXComponent=!0;const G9e={toc:[]},F9e="wrapper";function B9e(t){let{components:e,...n}=t;return(0,s.kt)(F9e,(0,p.Z)({},G9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B9e.isMDXComponent=!0;const U9e={toc:[]},V9e="wrapper";function q9e(t){let{components:e,...n}=t;return(0,s.kt)(V9e,(0,p.Z)({},U9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q9e.isMDXComponent=!0;const j9e={toc:[]},Y9e="wrapper";function H9e(t){let{components:e,...n}=t;return(0,s.kt)(Y9e,(0,p.Z)({},j9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}H9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function J9e(t){let{components:e,...n}=t;return(0,s.kt)($9e,(0,p.Z)({},Q9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}J9e.isMDXComponent=!0;const K9e={toc:[]},ttn="wrapper";function etn(t){let{components:e,...n}=t;return(0,s.kt)(ttn,(0,p.Z)({},K9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}etn.isMDXComponent=!0;const ntn={toc:[]},otn="wrapper";function ptn(t){let{components:e,...n}=t;return(0,s.kt)(otn,(0,p.Z)({},ntn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}ptn.isMDXComponent=!0;const rtn={toc:[]},stn="wrapper";function ctn(t){let{components:e,...n}=t;return(0,s.kt)(stn,(0,p.Z)({},rtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ctn.isMDXComponent=!0;const itn={toc:[]},atn="wrapper";function ltn(t){let{components:e,...n}=t;return(0,s.kt)(atn,(0,p.Z)({},itn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}ltn.isMDXComponent=!0;const utn={toc:[]},mtn="wrapper";function dtn(t){let{components:e,...n}=t;return(0,s.kt)(mtn,(0,p.Z)({},utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dtn.isMDXComponent=!0;const htn={toc:[]},ftn="wrapper";function ktn(t){let{components:e,...n}=t;return(0,s.kt)(ftn,(0,p.Z)({},htn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}ktn.isMDXComponent=!0;const ytn={toc:[]},Dtn="wrapper";function Mtn(t){let{components:e,...n}=t;return(0,s.kt)(Dtn,(0,p.Z)({},ytn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mtn.isMDXComponent=!0;const Xtn={toc:[]},_tn="wrapper";function wtn(t){let{components:e,...n}=t;return(0,s.kt)(_tn,(0,p.Z)({},Xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wtn.isMDXComponent=!0;const Ttn={toc:[]},gtn="wrapper";function Ctn(t){let{components:e,...n}=t;return(0,s.kt)(gtn,(0,p.Z)({},Ttn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ctn.isMDXComponent=!0;const xtn={toc:[]},vtn="wrapper";function Ltn(t){let{components:e,...n}=t;return(0,s.kt)(vtn,(0,p.Z)({},xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]},btn="wrapper";function Ntn(t){let{components:e,...n}=t;return(0,s.kt)(btn,(0,p.Z)({},Ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ntn.isMDXComponent=!0;const Atn={toc:[]},ztn="wrapper";function Wtn(t){let{components:e,...n}=t;return(0,s.kt)(ztn,(0,p.Z)({},Atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wtn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Stn(t){let{components:e,...n}=t;return(0,s.kt)(Rtn,(0,p.Z)({},Itn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Stn.isMDXComponent=!0;const Ptn={toc:[]},Etn="wrapper";function Otn(t){let{components:e,...n}=t;return(0,s.kt)(Etn,(0,p.Z)({},Ptn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Otn.isMDXComponent=!0;const Gtn={toc:[]},Ftn="wrapper";function Btn(t){let{components:e,...n}=t;return(0,s.kt)(Ftn,(0,p.Z)({},Gtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Btn.isMDXComponent=!0;const Utn={toc:[]},Vtn="wrapper";function qtn(t){let{components:e,...n}=t;return(0,s.kt)(Vtn,(0,p.Z)({},Utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Ytn="wrapper";function Htn(t){let{components:e,...n}=t;return(0,s.kt)(Ytn,(0,p.Z)({},jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Htn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Jtn(t){let{components:e,...n}=t;return(0,s.kt)($tn,(0,p.Z)({},Qtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Jtn.isMDXComponent=!0;const Ktn={toc:[]},ten="wrapper";function een(t){let{components:e,...n}=t;return(0,s.kt)(ten,(0,p.Z)({},Ktn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}een.isMDXComponent=!0;const nen={toc:[]},oen="wrapper";function pen(t){let{components:e,...n}=t;return(0,s.kt)(oen,(0,p.Z)({},nen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pen.isMDXComponent=!0;const ren={toc:[]},sen="wrapper";function cen(t){let{components:e,...n}=t;return(0,s.kt)(sen,(0,p.Z)({},ren,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}cen.isMDXComponent=!0;const ien={toc:[]},aen="wrapper";function len(t){let{components:e,...n}=t;return(0,s.kt)(aen,(0,p.Z)({},ien,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}len.isMDXComponent=!0;const uen={toc:[]},men="wrapper";function den(t){let{components:e,...n}=t;return(0,s.kt)(men,(0,p.Z)({},uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}den.isMDXComponent=!0;const hen={toc:[]},fen="wrapper";function ken(t){let{components:e,...n}=t;return(0,s.kt)(fen,(0,p.Z)({},hen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ken.isMDXComponent=!0;const yen={toc:[]},Den="wrapper";function Men(t){let{components:e,...n}=t;return(0,s.kt)(Den,(0,p.Z)({},yen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Men.isMDXComponent=!0;const Xen={toc:[]},_en="wrapper";function wen(t){let{components:e,...n}=t;return(0,s.kt)(_en,(0,p.Z)({},Xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}wen.isMDXComponent=!0;const Ten={toc:[]},gen="wrapper";function Cen(t){let{components:e,...n}=t;return(0,s.kt)(gen,(0,p.Z)({},Ten,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Cen.isMDXComponent=!0;const xen={toc:[]},ven="wrapper";function Len(t){let{components:e,...n}=t;return(0,s.kt)(ven,(0,p.Z)({},xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Len.isMDXComponent=!0;const Zen={toc:[]},ben="wrapper";function Nen(t){let{components:e,...n}=t;return(0,s.kt)(ben,(0,p.Z)({},Zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Nen.isMDXComponent=!0;const Aen={toc:[]},zen="wrapper";function Wen(t){let{components:e,...n}=t;return(0,s.kt)(zen,(0,p.Z)({},Aen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Wen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Sen(t){let{components:e,...n}=t;return(0,s.kt)(Ren,(0,p.Z)({},Ien,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Sen.isMDXComponent=!0;const Pen={toc:[]},Een="wrapper";function Oen(t){let{components:e,...n}=t;return(0,s.kt)(Een,(0,p.Z)({},Pen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Oen.isMDXComponent=!0;const Gen={toc:[]},Fen="wrapper";function Ben(t){let{components:e,...n}=t;return(0,s.kt)(Fen,(0,p.Z)({},Gen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ben.isMDXComponent=!0;const Uen={toc:[]},Ven="wrapper";function qen(t){let{components:e,...n}=t;return(0,s.kt)(Ven,(0,p.Z)({},Uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qen.isMDXComponent=!0;const jen={toc:[]},Yen="wrapper";function Hen(t){let{components:e,...n}=t;return(0,s.kt)(Yen,(0,p.Z)({},jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Jen(t){let{components:e,...n}=t;return(0,s.kt)($en,(0,p.Z)({},Qen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Jen.isMDXComponent=!0;const Ken={toc:[]},tnn="wrapper";function enn(t){let{components:e,...n}=t;return(0,s.kt)(tnn,(0,p.Z)({},Ken,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}enn.isMDXComponent=!0;const nnn={toc:[]},onn="wrapper";function pnn(t){let{components:e,...n}=t;return(0,s.kt)(onn,(0,p.Z)({},nnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pnn.isMDXComponent=!0;const rnn={toc:[]},snn="wrapper";function cnn(t){let{components:e,...n}=t;return(0,s.kt)(snn,(0,p.Z)({},rnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cnn.isMDXComponent=!0;const inn={toc:[]},ann="wrapper";function lnn(t){let{components:e,...n}=t;return(0,s.kt)(ann,(0,p.Z)({},inn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lnn.isMDXComponent=!0;const unn={toc:[]},mnn="wrapper";function dnn(t){let{components:e,...n}=t;return(0,s.kt)(mnn,(0,p.Z)({},unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dnn.isMDXComponent=!0;const hnn={toc:[]},fnn="wrapper";function knn(t){let{components:e,...n}=t;return(0,s.kt)(fnn,(0,p.Z)({},hnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}knn.isMDXComponent=!0;const ynn={toc:[]},Dnn="wrapper";function Mnn(t){let{components:e,...n}=t;return(0,s.kt)(Dnn,(0,p.Z)({},ynn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mnn.isMDXComponent=!0;const Xnn={toc:[]},_nn="wrapper";function wnn(t){let{components:e,...n}=t;return(0,s.kt)(_nn,(0,p.Z)({},Xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wnn.isMDXComponent=!0;const Tnn={toc:[]},gnn="wrapper";function Cnn(t){let{components:e,...n}=t;return(0,s.kt)(gnn,(0,p.Z)({},Tnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Cnn.isMDXComponent=!0;const xnn={toc:[]},vnn="wrapper";function Lnn(t){let{components:e,...n}=t;return(0,s.kt)(vnn,(0,p.Z)({},xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lnn.isMDXComponent=!0;const Znn={toc:[]},bnn="wrapper";function Nnn(t){let{components:e,...n}=t;return(0,s.kt)(bnn,(0,p.Z)({},Znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Nnn.isMDXComponent=!0;const Ann={toc:[]},znn="wrapper";function Wnn(t){let{components:e,...n}=t;return(0,s.kt)(znn,(0,p.Z)({},Ann,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Snn(t){let{components:e,...n}=t;return(0,s.kt)(Rnn,(0,p.Z)({},Inn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Snn.isMDXComponent=!0;const Pnn={toc:[]},Enn="wrapper";function Onn(t){let{components:e,...n}=t;return(0,s.kt)(Enn,(0,p.Z)({},Pnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Onn.isMDXComponent=!0;const Gnn={toc:[]},Fnn="wrapper";function Bnn(t){let{components:e,...n}=t;return(0,s.kt)(Fnn,(0,p.Z)({},Gnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Bnn.isMDXComponent=!0;const Unn={toc:[]},Vnn="wrapper";function qnn(t){let{components:e,...n}=t;return(0,s.kt)(Vnn,(0,p.Z)({},Unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Ynn="wrapper";function Hnn(t){let{components:e,...n}=t;return(0,s.kt)(Ynn,(0,p.Z)({},jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Hnn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Jnn(t){let{components:e,...n}=t;return(0,s.kt)($nn,(0,p.Z)({},Qnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jnn.isMDXComponent=!0;const Knn={toc:[]},ton="wrapper";function eon(t){let{components:e,...n}=t;return(0,s.kt)(ton,(0,p.Z)({},Knn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eon.isMDXComponent=!0;const non={toc:[]},oon="wrapper";function pon(t){let{components:e,...n}=t;return(0,s.kt)(oon,(0,p.Z)({},non,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pon.isMDXComponent=!0;const ron={toc:[]},son="wrapper";function con(t){let{components:e,...n}=t;return(0,s.kt)(son,(0,p.Z)({},ron,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}con.isMDXComponent=!0;const ion={toc:[]},aon="wrapper";function lon(t){let{components:e,...n}=t;return(0,s.kt)(aon,(0,p.Z)({},ion,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lon.isMDXComponent=!0;const uon={toc:[]},mon="wrapper";function don(t){let{components:e,...n}=t;return(0,s.kt)(mon,(0,p.Z)({},uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}don.isMDXComponent=!0;const hon={toc:[]},fon="wrapper";function kon(t){let{components:e,...n}=t;return(0,s.kt)(fon,(0,p.Z)({},hon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}kon.isMDXComponent=!0;const yon={toc:[]},Don="wrapper";function Mon(t){let{components:e,...n}=t;return(0,s.kt)(Don,(0,p.Z)({},yon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Mon.isMDXComponent=!0;const Xon={toc:[]},_on="wrapper";function won(t){let{components:e,...n}=t;return(0,s.kt)(_on,(0,p.Z)({},Xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}won.isMDXComponent=!0;const Ton={toc:[]},gon="wrapper";function Con(t){let{components:e,...n}=t;return(0,s.kt)(gon,(0,p.Z)({},Ton,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Con.isMDXComponent=!0;const xon={toc:[]},von="wrapper";function Lon(t){let{components:e,...n}=t;return(0,s.kt)(von,(0,p.Z)({},xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Lon.isMDXComponent=!0;const Zon={toc:[]},bon="wrapper";function Non(t){let{components:e,...n}=t;return(0,s.kt)(bon,(0,p.Z)({},Zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Non.isMDXComponent=!0;const Aon={toc:[]},zon="wrapper";function Won(t){let{components:e,...n}=t;return(0,s.kt)(zon,(0,p.Z)({},Aon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Won.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Son(t){let{components:e,...n}=t;return(0,s.kt)(Ron,(0,p.Z)({},Ion,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Son.isMDXComponent=!0;const Pon={toc:[]},Eon="wrapper";function Oon(t){let{components:e,...n}=t;return(0,s.kt)(Eon,(0,p.Z)({},Pon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Oon.isMDXComponent=!0;const Gon={toc:[]},Fon="wrapper";function Bon(t){let{components:e,...n}=t;return(0,s.kt)(Fon,(0,p.Z)({},Gon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bon.isMDXComponent=!0;const Uon={toc:[]},Von="wrapper";function qon(t){let{components:e,...n}=t;return(0,s.kt)(Von,(0,p.Z)({},Uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qon.isMDXComponent=!0;const jon={toc:[]},Yon="wrapper";function Hon(t){let{components:e,...n}=t;return(0,s.kt)(Yon,(0,p.Z)({},jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Hon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Jon(t){let{components:e,...n}=t;return(0,s.kt)($on,(0,p.Z)({},Qon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Jon.isMDXComponent=!0;const Kon={toc:[]},tpn="wrapper";function epn(t){let{components:e,...n}=t;return(0,s.kt)(tpn,(0,p.Z)({},Kon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}epn.isMDXComponent=!0;const npn={toc:[]},opn="wrapper";function ppn(t){let{components:e,...n}=t;return(0,s.kt)(opn,(0,p.Z)({},npn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ppn.isMDXComponent=!0;const rpn={toc:[]},spn="wrapper";function cpn(t){let{components:e,...n}=t;return(0,s.kt)(spn,(0,p.Z)({},rpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cpn.isMDXComponent=!0;const ipn={toc:[]},apn="wrapper";function lpn(t){let{components:e,...n}=t;return(0,s.kt)(apn,(0,p.Z)({},ipn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lpn.isMDXComponent=!0;const upn={toc:[]},mpn="wrapper";function dpn(t){let{components:e,...n}=t;return(0,s.kt)(mpn,(0,p.Z)({},upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}dpn.isMDXComponent=!0;const hpn={toc:[]},fpn="wrapper";function kpn(t){let{components:e,...n}=t;return(0,s.kt)(fpn,(0,p.Z)({},hpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kpn.isMDXComponent=!0;const ypn={toc:[]},Dpn="wrapper";function Mpn(t){let{components:e,...n}=t;return(0,s.kt)(Dpn,(0,p.Z)({},ypn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mpn.isMDXComponent=!0;const Xpn={toc:[]},_pn="wrapper";function wpn(t){let{components:e,...n}=t;return(0,s.kt)(_pn,(0,p.Z)({},Xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wpn.isMDXComponent=!0;const Tpn={toc:[]},gpn="wrapper";function Cpn(t){let{components:e,...n}=t;return(0,s.kt)(gpn,(0,p.Z)({},Tpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Cpn.isMDXComponent=!0;const xpn={toc:[]},vpn="wrapper";function Lpn(t){let{components:e,...n}=t;return(0,s.kt)(vpn,(0,p.Z)({},xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]},bpn="wrapper";function Npn(t){let{components:e,...n}=t;return(0,s.kt)(bpn,(0,p.Z)({},Zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Npn.isMDXComponent=!0;const Apn={toc:[]},zpn="wrapper";function Wpn(t){let{components:e,...n}=t;return(0,s.kt)(zpn,(0,p.Z)({},Apn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Wpn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Spn(t){let{components:e,...n}=t;return(0,s.kt)(Rpn,(0,p.Z)({},Ipn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Spn.isMDXComponent=!0;const Ppn={toc:[]},Epn="wrapper";function Opn(t){let{components:e,...n}=t;return(0,s.kt)(Epn,(0,p.Z)({},Ppn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Opn.isMDXComponent=!0;const Gpn={toc:[]},Fpn="wrapper";function Bpn(t){let{components:e,...n}=t;return(0,s.kt)(Fpn,(0,p.Z)({},Gpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Bpn.isMDXComponent=!0;const Upn={toc:[]},Vpn="wrapper";function qpn(t){let{components:e,...n}=t;return(0,s.kt)(Vpn,(0,p.Z)({},Upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Ypn="wrapper";function Hpn(t){let{components:e,...n}=t;return(0,s.kt)(Ypn,(0,p.Z)({},jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Hpn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Jpn(t){let{components:e,...n}=t;return(0,s.kt)($pn,(0,p.Z)({},Qpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Jpn.isMDXComponent=!0;const Kpn={toc:[]},trn="wrapper";function ern(t){let{components:e,...n}=t;return(0,s.kt)(trn,(0,p.Z)({},Kpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ern.isMDXComponent=!0;const nrn={toc:[]},orn="wrapper";function prn(t){let{components:e,...n}=t;return(0,s.kt)(orn,(0,p.Z)({},nrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}prn.isMDXComponent=!0;const rrn={toc:[]},srn="wrapper";function crn(t){let{components:e,...n}=t;return(0,s.kt)(srn,(0,p.Z)({},rrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}crn.isMDXComponent=!0;const irn={toc:[]},arn="wrapper";function lrn(t){let{components:e,...n}=t;return(0,s.kt)(arn,(0,p.Z)({},irn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}lrn.isMDXComponent=!0;const urn={toc:[]},mrn="wrapper";function drn(t){let{components:e,...n}=t;return(0,s.kt)(mrn,(0,p.Z)({},urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}drn.isMDXComponent=!0;const hrn={toc:[]},frn="wrapper";function krn(t){let{components:e,...n}=t;return(0,s.kt)(frn,(0,p.Z)({},hrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}krn.isMDXComponent=!0;const yrn={toc:[]},Drn="wrapper";function Mrn(t){let{components:e,...n}=t;return(0,s.kt)(Drn,(0,p.Z)({},yrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mrn.isMDXComponent=!0;const Xrn={toc:[]},_rn="wrapper";function wrn(t){let{components:e,...n}=t;return(0,s.kt)(_rn,(0,p.Z)({},Xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wrn.isMDXComponent=!0;const Trn={toc:[]},grn="wrapper";function Crn(t){let{components:e,...n}=t;return(0,s.kt)(grn,(0,p.Z)({},Trn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Crn.isMDXComponent=!0;const xrn={toc:[]},vrn="wrapper";function Lrn(t){let{components:e,...n}=t;return(0,s.kt)(vrn,(0,p.Z)({},xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]},brn="wrapper";function Nrn(t){let{components:e,...n}=t;return(0,s.kt)(brn,(0,p.Z)({},Zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nrn.isMDXComponent=!0;const Arn={toc:[]},zrn="wrapper";function Wrn(t){let{components:e,...n}=t;return(0,s.kt)(zrn,(0,p.Z)({},Arn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wrn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Srn(t){let{components:e,...n}=t;return(0,s.kt)(Rrn,(0,p.Z)({},Irn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Srn.isMDXComponent=!0;const Prn={toc:[]},Ern="wrapper";function Orn(t){let{components:e,...n}=t;return(0,s.kt)(Ern,(0,p.Z)({},Prn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Orn.isMDXComponent=!0;const Grn={toc:[]},Frn="wrapper";function Brn(t){let{components:e,...n}=t;return(0,s.kt)(Frn,(0,p.Z)({},Grn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Brn.isMDXComponent=!0;const Urn={toc:[]},Vrn="wrapper";function qrn(t){let{components:e,...n}=t;return(0,s.kt)(Vrn,(0,p.Z)({},Urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Yrn="wrapper";function Hrn(t){let{components:e,...n}=t;return(0,s.kt)(Yrn,(0,p.Z)({},jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Hrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Jrn(t){let{components:e,...n}=t;return(0,s.kt)($rn,(0,p.Z)({},Qrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Jrn.isMDXComponent=!0;const Krn={toc:[]},tsn="wrapper";function esn(t){let{components:e,...n}=t;return(0,s.kt)(tsn,(0,p.Z)({},Krn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}esn.isMDXComponent=!0;const nsn={toc:[]},osn="wrapper";function psn(t){let{components:e,...n}=t;return(0,s.kt)(osn,(0,p.Z)({},nsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}psn.isMDXComponent=!0;const rsn={toc:[]},ssn="wrapper";function csn(t){let{components:e,...n}=t;return(0,s.kt)(ssn,(0,p.Z)({},rsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}csn.isMDXComponent=!0;const isn={toc:[]},asn="wrapper";function lsn(t){let{components:e,...n}=t;return(0,s.kt)(asn,(0,p.Z)({},isn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}lsn.isMDXComponent=!0;const usn={toc:[]},msn="wrapper";function dsn(t){let{components:e,...n}=t;return(0,s.kt)(msn,(0,p.Z)({},usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}dsn.isMDXComponent=!0;const hsn={toc:[]},fsn="wrapper";function ksn(t){let{components:e,...n}=t;return(0,s.kt)(fsn,(0,p.Z)({},hsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}ksn.isMDXComponent=!0;const ysn={toc:[]},Dsn="wrapper";function Msn(t){let{components:e,...n}=t;return(0,s.kt)(Dsn,(0,p.Z)({},ysn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Msn.isMDXComponent=!0;const Xsn={toc:[]},_sn="wrapper";function wsn(t){let{components:e,...n}=t;return(0,s.kt)(_sn,(0,p.Z)({},Xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wsn.isMDXComponent=!0;const Tsn={toc:[]},gsn="wrapper";function Csn(t){let{components:e,...n}=t;return(0,s.kt)(gsn,(0,p.Z)({},Tsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Csn.isMDXComponent=!0;const xsn={toc:[]},vsn="wrapper";function Lsn(t){let{components:e,...n}=t;return(0,s.kt)(vsn,(0,p.Z)({},xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]},bsn="wrapper";function Nsn(t){let{components:e,...n}=t;return(0,s.kt)(bsn,(0,p.Z)({},Zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nsn.isMDXComponent=!0;const Asn={toc:[]},zsn="wrapper";function Wsn(t){let{components:e,...n}=t;return(0,s.kt)(zsn,(0,p.Z)({},Asn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Wsn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Ssn(t){let{components:e,...n}=t;return(0,s.kt)(Rsn,(0,p.Z)({},Isn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ssn.isMDXComponent=!0;const Psn={toc:[]},Esn="wrapper";function Osn(t){let{components:e,...n}=t;return(0,s.kt)(Esn,(0,p.Z)({},Psn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Osn.isMDXComponent=!0;const Gsn={toc:[]},Fsn="wrapper";function Bsn(t){let{components:e,...n}=t;return(0,s.kt)(Fsn,(0,p.Z)({},Gsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Bsn.isMDXComponent=!0;const Usn={toc:[]},Vsn="wrapper";function qsn(t){let{components:e,...n}=t;return(0,s.kt)(Vsn,(0,p.Z)({},Usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Ysn="wrapper";function Hsn(t){let{components:e,...n}=t;return(0,s.kt)(Ysn,(0,p.Z)({},jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Hsn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Jsn(t){let{components:e,...n}=t;return(0,s.kt)($sn,(0,p.Z)({},Qsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Jsn.isMDXComponent=!0;const Ksn={toc:[]},tcn="wrapper";function ecn(t){let{components:e,...n}=t;return(0,s.kt)(tcn,(0,p.Z)({},Ksn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ecn.isMDXComponent=!0;const ncn={toc:[]},ocn="wrapper";function pcn(t){let{components:e,...n}=t;return(0,s.kt)(ocn,(0,p.Z)({},ncn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pcn.isMDXComponent=!0;const rcn={toc:[]},scn="wrapper";function ccn(t){let{components:e,...n}=t;return(0,s.kt)(scn,(0,p.Z)({},rcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ccn.isMDXComponent=!0;const icn={toc:[]},acn="wrapper";function lcn(t){let{components:e,...n}=t;return(0,s.kt)(acn,(0,p.Z)({},icn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lcn.isMDXComponent=!0;const ucn={toc:[]},mcn="wrapper";function dcn(t){let{components:e,...n}=t;return(0,s.kt)(mcn,(0,p.Z)({},ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dcn.isMDXComponent=!0;const hcn={toc:[]},fcn="wrapper";function kcn(t){let{components:e,...n}=t;return(0,s.kt)(fcn,(0,p.Z)({},hcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kcn.isMDXComponent=!0;const ycn={toc:[]},Dcn="wrapper";function Mcn(t){let{components:e,...n}=t;return(0,s.kt)(Dcn,(0,p.Z)({},ycn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Mcn.isMDXComponent=!0;const Xcn={toc:[]},_cn="wrapper";function wcn(t){let{components:e,...n}=t;return(0,s.kt)(_cn,(0,p.Z)({},Xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wcn.isMDXComponent=!0;const Tcn={toc:[]},gcn="wrapper";function Ccn(t){let{components:e,...n}=t;return(0,s.kt)(gcn,(0,p.Z)({},Tcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ccn.isMDXComponent=!0;const xcn={toc:[]},vcn="wrapper";function Lcn(t){let{components:e,...n}=t;return(0,s.kt)(vcn,(0,p.Z)({},xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]},bcn="wrapper";function Ncn(t){let{components:e,...n}=t;return(0,s.kt)(bcn,(0,p.Z)({},Zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ncn.isMDXComponent=!0;const Acn={toc:[]},zcn="wrapper";function Wcn(t){let{components:e,...n}=t;return(0,s.kt)(zcn,(0,p.Z)({},Acn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Scn(t){let{components:e,...n}=t;return(0,s.kt)(Rcn,(0,p.Z)({},Icn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Scn.isMDXComponent=!0;const Pcn={toc:[]},Ecn="wrapper";function Ocn(t){let{components:e,...n}=t;return(0,s.kt)(Ecn,(0,p.Z)({},Pcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ocn.isMDXComponent=!0;const Gcn={toc:[]},Fcn="wrapper";function Bcn(t){let{components:e,...n}=t;return(0,s.kt)(Fcn,(0,p.Z)({},Gcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bcn.isMDXComponent=!0;const Ucn={toc:[]},Vcn="wrapper";function qcn(t){let{components:e,...n}=t;return(0,s.kt)(Vcn,(0,p.Z)({},Ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Ycn="wrapper";function Hcn(t){let{components:e,...n}=t;return(0,s.kt)(Ycn,(0,p.Z)({},jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Hcn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Jcn(t){let{components:e,...n}=t;return(0,s.kt)($cn,(0,p.Z)({},Qcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}Jcn.isMDXComponent=!0;const Kcn={toc:[]},tin="wrapper";function ein(t){let{components:e,...n}=t;return(0,s.kt)(tin,(0,p.Z)({},Kcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ein.isMDXComponent=!0;const nin={toc:[]},oin="wrapper";function pin(t){let{components:e,...n}=t;return(0,s.kt)(oin,(0,p.Z)({},nin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pin.isMDXComponent=!0;const rin={toc:[]},sin="wrapper";function cin(t){let{components:e,...n}=t;return(0,s.kt)(sin,(0,p.Z)({},rin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cin.isMDXComponent=!0;const iin={toc:[]},ain="wrapper";function lin(t){let{components:e,...n}=t;return(0,s.kt)(ain,(0,p.Z)({},iin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lin.isMDXComponent=!0;const uin={toc:[]},min="wrapper";function din(t){let{components:e,...n}=t;return(0,s.kt)(min,(0,p.Z)({},uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}din.isMDXComponent=!0;const hin={toc:[]},fin="wrapper";function kin(t){let{components:e,...n}=t;return(0,s.kt)(fin,(0,p.Z)({},hin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}kin.isMDXComponent=!0;const yin={toc:[]},Din="wrapper";function Min(t){let{components:e,...n}=t;return(0,s.kt)(Din,(0,p.Z)({},yin,n,{components:e,mdxType:"MDXLayout"}))}Min.isMDXComponent=!0;const Xin={toc:[]},_in="wrapper";function win(t){let{components:e,...n}=t;return(0,s.kt)(_in,(0,p.Z)({},Xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}win.isMDXComponent=!0;const Tin={toc:[]},gin="wrapper";function Cin(t){let{components:e,...n}=t;return(0,s.kt)(gin,(0,p.Z)({},Tin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cin.isMDXComponent=!0;const xin={toc:[]},vin="wrapper";function Lin(t){let{components:e,...n}=t;return(0,s.kt)(vin,(0,p.Z)({},xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Lin.isMDXComponent=!0;const Zin={toc:[]},bin="wrapper";function Nin(t){let{components:e,...n}=t;return(0,s.kt)(bin,(0,p.Z)({},Zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nin.isMDXComponent=!0;const Ain={toc:[]},zin="wrapper";function Win(t){let{components:e,...n}=t;return(0,s.kt)(zin,(0,p.Z)({},Ain,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Win.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Sin(t){let{components:e,...n}=t;return(0,s.kt)(Rin,(0,p.Z)({},Iin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sin.isMDXComponent=!0;const Pin={toc:[]},Ein="wrapper";function Oin(t){let{components:e,...n}=t;return(0,s.kt)(Ein,(0,p.Z)({},Pin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Oin.isMDXComponent=!0;const Gin={toc:[]},Fin="wrapper";function Bin(t){let{components:e,...n}=t;return(0,s.kt)(Fin,(0,p.Z)({},Gin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bin.isMDXComponent=!0;const Uin={toc:[]},Vin="wrapper";function qin(t){let{components:e,...n}=t;return(0,s.kt)(Vin,(0,p.Z)({},Uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qin.isMDXComponent=!0;const jin={toc:[]},Yin="wrapper";function Hin(t){let{components:e,...n}=t;return(0,s.kt)(Yin,(0,p.Z)({},jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Jin(t){let{components:e,...n}=t;return(0,s.kt)($in,(0,p.Z)({},Qin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jin.isMDXComponent=!0;const Kin={toc:[]},tan="wrapper";function ean(t){let{components:e,...n}=t;return(0,s.kt)(tan,(0,p.Z)({},Kin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ean.isMDXComponent=!0;const nan={toc:[]},oan="wrapper";function pan(t){let{components:e,...n}=t;return(0,s.kt)(oan,(0,p.Z)({},nan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pan.isMDXComponent=!0;const ran={toc:[]},san="wrapper";function can(t){let{components:e,...n}=t;return(0,s.kt)(san,(0,p.Z)({},ran,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}can.isMDXComponent=!0;const ian={toc:[]},aan="wrapper";function lan(t){let{components:e,...n}=t;return(0,s.kt)(aan,(0,p.Z)({},ian,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lan.isMDXComponent=!0;const uan={toc:[]},man="wrapper";function dan(t){let{components:e,...n}=t;return(0,s.kt)(man,(0,p.Z)({},uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dan.isMDXComponent=!0;const han={toc:[]},fan="wrapper";function kan(t){let{components:e,...n}=t;return(0,s.kt)(fan,(0,p.Z)({},han,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kan.isMDXComponent=!0;const yan={toc:[]},Dan="wrapper";function Man(t){let{components:e,...n}=t;return(0,s.kt)(Dan,(0,p.Z)({},yan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Man.isMDXComponent=!0;const Xan={toc:[]},_an="wrapper";function wan(t){let{components:e,...n}=t;return(0,s.kt)(_an,(0,p.Z)({},Xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wan.isMDXComponent=!0;const Tan={toc:[]},gan="wrapper";function Can(t){let{components:e,...n}=t;return(0,s.kt)(gan,(0,p.Z)({},Tan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Can.isMDXComponent=!0;const xan={toc:[]},van="wrapper";function Lan(t){let{components:e,...n}=t;return(0,s.kt)(van,(0,p.Z)({},xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Lan.isMDXComponent=!0;const Zan={toc:[]},ban="wrapper";function Nan(t){let{components:e,...n}=t;return(0,s.kt)(ban,(0,p.Z)({},Zan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nan.isMDXComponent=!0;const Aan={toc:[]},zan="wrapper";function Wan(t){let{components:e,...n}=t;return(0,s.kt)(zan,(0,p.Z)({},Aan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function San(t){let{components:e,...n}=t;return(0,s.kt)(Ran,(0,p.Z)({},Ian,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}San.isMDXComponent=!0;const Pan={toc:[]},Ean="wrapper";function Oan(t){let{components:e,...n}=t;return(0,s.kt)(Ean,(0,p.Z)({},Pan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Oan.isMDXComponent=!0;const Gan={toc:[]},Fan="wrapper";function Ban(t){let{components:e,...n}=t;return(0,s.kt)(Fan,(0,p.Z)({},Gan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ban.isMDXComponent=!0;const Uan={toc:[]},Van="wrapper";function qan(t){let{components:e,...n}=t;return(0,s.kt)(Van,(0,p.Z)({},Uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qan.isMDXComponent=!0;const jan={toc:[]},Yan="wrapper";function Han(t){let{components:e,...n}=t;return(0,s.kt)(Yan,(0,p.Z)({},jan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Han.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Jan(t){let{components:e,...n}=t;return(0,s.kt)($an,(0,p.Z)({},Qan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jan.isMDXComponent=!0;const Kan={toc:[]},tln="wrapper";function eln(t){let{components:e,...n}=t;return(0,s.kt)(tln,(0,p.Z)({},Kan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eln.isMDXComponent=!0;const nln={toc:[]},oln="wrapper";function pln(t){let{components:e,...n}=t;return(0,s.kt)(oln,(0,p.Z)({},nln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pln.isMDXComponent=!0;const rln={toc:[]},sln="wrapper";function cln(t){let{components:e,...n}=t;return(0,s.kt)(sln,(0,p.Z)({},rln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cln.isMDXComponent=!0;const iln={toc:[]},aln="wrapper";function lln(t){let{components:e,...n}=t;return(0,s.kt)(aln,(0,p.Z)({},iln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lln.isMDXComponent=!0;const uln={toc:[]},mln="wrapper";function dln(t){let{components:e,...n}=t;return(0,s.kt)(mln,(0,p.Z)({},uln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dln.isMDXComponent=!0;const hln={toc:[]},fln="wrapper";function kln(t){let{components:e,...n}=t;return(0,s.kt)(fln,(0,p.Z)({},hln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kln.isMDXComponent=!0;const yln={toc:[]},Dln="wrapper";function Mln(t){let{components:e,...n}=t;return(0,s.kt)(Dln,(0,p.Z)({},yln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mln.isMDXComponent=!0;const Xln={toc:[]},_ln="wrapper";function wln(t){let{components:e,...n}=t;return(0,s.kt)(_ln,(0,p.Z)({},Xln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wln.isMDXComponent=!0;const Tln={toc:[]},gln="wrapper";function Cln(t){let{components:e,...n}=t;return(0,s.kt)(gln,(0,p.Z)({},Tln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Cln.isMDXComponent=!0;const xln={toc:[]},vln="wrapper";function Lln(t){let{components:e,...n}=t;return(0,s.kt)(vln,(0,p.Z)({},xln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lln.isMDXComponent=!0;const Zln={toc:[]},bln="wrapper";function Nln(t){let{components:e,...n}=t;return(0,s.kt)(bln,(0,p.Z)({},Zln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nln.isMDXComponent=!0;const Aln={toc:[]},zln="wrapper";function Wln(t){let{components:e,...n}=t;return(0,s.kt)(zln,(0,p.Z)({},Aln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Sln(t){let{components:e,...n}=t;return(0,s.kt)(Rln,(0,p.Z)({},Iln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Sln.isMDXComponent=!0;const Pln={toc:[]},Eln="wrapper";function Oln(t){let{components:e,...n}=t;return(0,s.kt)(Eln,(0,p.Z)({},Pln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Oln.isMDXComponent=!0;const Gln={toc:[]},Fln="wrapper";function Bln(t){let{components:e,...n}=t;return(0,s.kt)(Fln,(0,p.Z)({},Gln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Bln.isMDXComponent=!0;const Uln={toc:[]},Vln="wrapper";function qln(t){let{components:e,...n}=t;return(0,s.kt)(Vln,(0,p.Z)({},Uln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qln.isMDXComponent=!0;const jln={toc:[]},Yln="wrapper";function Hln(t){let{components:e,...n}=t;return(0,s.kt)(Yln,(0,p.Z)({},jln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Hln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Jln(t){let{components:e,...n}=t;return(0,s.kt)($ln,(0,p.Z)({},Qln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Jln.isMDXComponent=!0;const Kln={toc:[]},tun="wrapper";function eun(t){let{components:e,...n}=t;return(0,s.kt)(tun,(0,p.Z)({},Kln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eun.isMDXComponent=!0;const nun={toc:[]},oun="wrapper";function pun(t){let{components:e,...n}=t;return(0,s.kt)(oun,(0,p.Z)({},nun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pun.isMDXComponent=!0;const run={toc:[]},sun="wrapper";function cun(t){let{components:e,...n}=t;return(0,s.kt)(sun,(0,p.Z)({},run,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cun.isMDXComponent=!0;const iun={toc:[]},aun="wrapper";function lun(t){let{components:e,...n}=t;return(0,s.kt)(aun,(0,p.Z)({},iun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lun.isMDXComponent=!0;const uun={toc:[]},mun="wrapper";function dun(t){let{components:e,...n}=t;return(0,s.kt)(mun,(0,p.Z)({},uun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dun.isMDXComponent=!0;const hun={toc:[]},fun="wrapper";function kun(t){let{components:e,...n}=t;return(0,s.kt)(fun,(0,p.Z)({},hun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kun.isMDXComponent=!0;const yun={toc:[]},Dun="wrapper";function Mun(t){let{components:e,...n}=t;return(0,s.kt)(Dun,(0,p.Z)({},yun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mun.isMDXComponent=!0;const Xun={toc:[]},_un="wrapper";function wun(t){let{components:e,...n}=t;return(0,s.kt)(_un,(0,p.Z)({},Xun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wun.isMDXComponent=!0;const Tun={toc:[]},gun="wrapper";function Cun(t){let{components:e,...n}=t;return(0,s.kt)(gun,(0,p.Z)({},Tun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cun.isMDXComponent=!0;const xun={toc:[]},vun="wrapper";function Lun(t){let{components:e,...n}=t;return(0,s.kt)(vun,(0,p.Z)({},xun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lun.isMDXComponent=!0;const Zun={toc:[]},bun="wrapper";function Nun(t){let{components:e,...n}=t;return(0,s.kt)(bun,(0,p.Z)({},Zun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nun.isMDXComponent=!0;const Aun={toc:[]},zun="wrapper";function Wun(t){let{components:e,...n}=t;return(0,s.kt)(zun,(0,p.Z)({},Aun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Sun(t){let{components:e,...n}=t;return(0,s.kt)(Run,(0,p.Z)({},Iun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Sun.isMDXComponent=!0;const Pun={toc:[]},Eun="wrapper";function Oun(t){let{components:e,...n}=t;return(0,s.kt)(Eun,(0,p.Z)({},Pun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Oun.isMDXComponent=!0;const Gun={toc:[]},Fun="wrapper";function Bun(t){let{components:e,...n}=t;return(0,s.kt)(Fun,(0,p.Z)({},Gun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bun.isMDXComponent=!0;const Uun={toc:[]},Vun="wrapper";function qun(t){let{components:e,...n}=t;return(0,s.kt)(Vun,(0,p.Z)({},Uun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qun.isMDXComponent=!0;const jun={toc:[]},Yun="wrapper";function Hun(t){let{components:e,...n}=t;return(0,s.kt)(Yun,(0,p.Z)({},jun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Hun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Jun(t){let{components:e,...n}=t;return(0,s.kt)($un,(0,p.Z)({},Qun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Jun.isMDXComponent=!0;const Kun={toc:[]},tmn="wrapper";function emn(t){let{components:e,...n}=t;return(0,s.kt)(tmn,(0,p.Z)({},Kun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}emn.isMDXComponent=!0;const nmn={toc:[]},omn="wrapper";function pmn(t){let{components:e,...n}=t;return(0,s.kt)(omn,(0,p.Z)({},nmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pmn.isMDXComponent=!0;const rmn={toc:[]},smn="wrapper";function cmn(t){let{components:e,...n}=t;return(0,s.kt)(smn,(0,p.Z)({},rmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cmn.isMDXComponent=!0;const imn={toc:[]},amn="wrapper";function lmn(t){let{components:e,...n}=t;return(0,s.kt)(amn,(0,p.Z)({},imn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lmn.isMDXComponent=!0;const umn={toc:[]},mmn="wrapper";function dmn(t){let{components:e,...n}=t;return(0,s.kt)(mmn,(0,p.Z)({},umn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dmn.isMDXComponent=!0;const hmn={toc:[]},fmn="wrapper";function kmn(t){let{components:e,...n}=t;return(0,s.kt)(fmn,(0,p.Z)({},hmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}kmn.isMDXComponent=!0;const ymn={toc:[]},Dmn="wrapper";function Mmn(t){let{components:e,...n}=t;return(0,s.kt)(Dmn,(0,p.Z)({},ymn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mmn.isMDXComponent=!0;const Xmn={toc:[]},_mn="wrapper";function wmn(t){let{components:e,...n}=t;return(0,s.kt)(_mn,(0,p.Z)({},Xmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wmn.isMDXComponent=!0;const Tmn={toc:[]},gmn="wrapper";function Cmn(t){let{components:e,...n}=t;return(0,s.kt)(gmn,(0,p.Z)({},Tmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Cmn.isMDXComponent=!0;const xmn={toc:[]},vmn="wrapper";function Lmn(t){let{components:e,...n}=t;return(0,s.kt)(vmn,(0,p.Z)({},xmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]},bmn="wrapper";function Nmn(t){let{components:e,...n}=t;return(0,s.kt)(bmn,(0,p.Z)({},Zmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Nmn.isMDXComponent=!0;const Amn={toc:[]},zmn="wrapper";function Wmn(t){let{components:e,...n}=t;return(0,s.kt)(zmn,(0,p.Z)({},Amn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Smn(t){let{components:e,...n}=t;return(0,s.kt)(Rmn,(0,p.Z)({},Imn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Smn.isMDXComponent=!0;const Pmn={toc:[]},Emn="wrapper";function Omn(t){let{components:e,...n}=t;return(0,s.kt)(Emn,(0,p.Z)({},Pmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Omn.isMDXComponent=!0;const Gmn={toc:[]},Fmn="wrapper";function Bmn(t){let{components:e,...n}=t;return(0,s.kt)(Fmn,(0,p.Z)({},Gmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bmn.isMDXComponent=!0;const Umn={toc:[]},Vmn="wrapper";function qmn(t){let{components:e,...n}=t;return(0,s.kt)(Vmn,(0,p.Z)({},Umn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Ymn="wrapper";function Hmn(t){let{components:e,...n}=t;return(0,s.kt)(Ymn,(0,p.Z)({},jmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Hmn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Jmn(t){let{components:e,...n}=t;return(0,s.kt)($mn,(0,p.Z)({},Qmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Jmn.isMDXComponent=!0;const Kmn={toc:[]},tdn="wrapper";function edn(t){let{components:e,...n}=t;return(0,s.kt)(tdn,(0,p.Z)({},Kmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}edn.isMDXComponent=!0;const ndn={toc:[]},odn="wrapper";function pdn(t){let{components:e,...n}=t;return(0,s.kt)(odn,(0,p.Z)({},ndn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pdn.isMDXComponent=!0;const rdn={toc:[]},sdn="wrapper";function cdn(t){let{components:e,...n}=t;return(0,s.kt)(sdn,(0,p.Z)({},rdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cdn.isMDXComponent=!0;const idn={toc:[]},adn="wrapper";function ldn(t){let{components:e,...n}=t;return(0,s.kt)(adn,(0,p.Z)({},idn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}ldn.isMDXComponent=!0;const udn={toc:[]},mdn="wrapper";function ddn(t){let{components:e,...n}=t;return(0,s.kt)(mdn,(0,p.Z)({},udn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ddn.isMDXComponent=!0;const hdn={toc:[]},fdn="wrapper";function kdn(t){let{components:e,...n}=t;return(0,s.kt)(fdn,(0,p.Z)({},hdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kdn.isMDXComponent=!0;const ydn={toc:[]},Ddn="wrapper";function Mdn(t){let{components:e,...n}=t;return(0,s.kt)(Ddn,(0,p.Z)({},ydn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mdn.isMDXComponent=!0;const Xdn={toc:[]},_dn="wrapper";function wdn(t){let{components:e,...n}=t;return(0,s.kt)(_dn,(0,p.Z)({},Xdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wdn.isMDXComponent=!0;const Tdn={toc:[]},gdn="wrapper";function Cdn(t){let{components:e,...n}=t;return(0,s.kt)(gdn,(0,p.Z)({},Tdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Cdn.isMDXComponent=!0;const xdn={toc:[]},vdn="wrapper";function Ldn(t){let{components:e,...n}=t;return(0,s.kt)(vdn,(0,p.Z)({},xdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]},bdn="wrapper";function Ndn(t){let{components:e,...n}=t;return(0,s.kt)(bdn,(0,p.Z)({},Zdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ndn.isMDXComponent=!0;const Adn={toc:[]},zdn="wrapper";function Wdn(t){let{components:e,...n}=t;return(0,s.kt)(zdn,(0,p.Z)({},Adn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Wdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Sdn(t){let{components:e,...n}=t;return(0,s.kt)(Rdn,(0,p.Z)({},Idn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Sdn.isMDXComponent=!0;const Pdn={toc:[]},Edn="wrapper";function Odn(t){let{components:e,...n}=t;return(0,s.kt)(Edn,(0,p.Z)({},Pdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Odn.isMDXComponent=!0;const Gdn={toc:[]},Fdn="wrapper";function Bdn(t){let{components:e,...n}=t;return(0,s.kt)(Fdn,(0,p.Z)({},Gdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Bdn.isMDXComponent=!0;const Udn={toc:[]},Vdn="wrapper";function qdn(t){let{components:e,...n}=t;return(0,s.kt)(Vdn,(0,p.Z)({},Udn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qdn.isMDXComponent=!0;const jdn={toc:[]},Ydn="wrapper";function Hdn(t){let{components:e,...n}=t;return(0,s.kt)(Ydn,(0,p.Z)({},jdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Hdn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Jdn(t){let{components:e,...n}=t;return(0,s.kt)($dn,(0,p.Z)({},Qdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Jdn.isMDXComponent=!0;const Kdn={toc:[]},thn="wrapper";function ehn(t){let{components:e,...n}=t;return(0,s.kt)(thn,(0,p.Z)({},Kdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ehn.isMDXComponent=!0;const nhn={toc:[]},ohn="wrapper";function phn(t){let{components:e,...n}=t;return(0,s.kt)(ohn,(0,p.Z)({},nhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}phn.isMDXComponent=!0;const rhn={toc:[]},shn="wrapper";function chn(t){let{components:e,...n}=t;return(0,s.kt)(shn,(0,p.Z)({},rhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}chn.isMDXComponent=!0;const ihn={toc:[]},ahn="wrapper";function lhn(t){let{components:e,...n}=t;return(0,s.kt)(ahn,(0,p.Z)({},ihn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lhn.isMDXComponent=!0;const uhn={toc:[]},mhn="wrapper";function dhn(t){let{components:e,...n}=t;return(0,s.kt)(mhn,(0,p.Z)({},uhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dhn.isMDXComponent=!0;const hhn={toc:[]},fhn="wrapper";function khn(t){let{components:e,...n}=t;return(0,s.kt)(fhn,(0,p.Z)({},hhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}khn.isMDXComponent=!0;const yhn={toc:[]},Dhn="wrapper";function Mhn(t){let{components:e,...n}=t;return(0,s.kt)(Dhn,(0,p.Z)({},yhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mhn.isMDXComponent=!0;const Xhn={toc:[]},_hn="wrapper";function whn(t){let{components:e,...n}=t;return(0,s.kt)(_hn,(0,p.Z)({},Xhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}whn.isMDXComponent=!0;const Thn={toc:[]},ghn="wrapper";function Chn(t){let{components:e,...n}=t;return(0,s.kt)(ghn,(0,p.Z)({},Thn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Chn.isMDXComponent=!0;const xhn={toc:[]},vhn="wrapper";function Lhn(t){let{components:e,...n}=t;return(0,s.kt)(vhn,(0,p.Z)({},xhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]},bhn="wrapper";function Nhn(t){let{components:e,...n}=t;return(0,s.kt)(bhn,(0,p.Z)({},Zhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nhn.isMDXComponent=!0;const Ahn={toc:[]},zhn="wrapper";function Whn(t){let{components:e,...n}=t;return(0,s.kt)(zhn,(0,p.Z)({},Ahn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Whn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Shn(t){let{components:e,...n}=t;return(0,s.kt)(Rhn,(0,p.Z)({},Ihn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Shn.isMDXComponent=!0;const Phn={toc:[]},Ehn="wrapper";function Ohn(t){let{components:e,...n}=t;return(0,s.kt)(Ehn,(0,p.Z)({},Phn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ohn.isMDXComponent=!0;const Ghn={toc:[]},Fhn="wrapper";function Bhn(t){let{components:e,...n}=t;return(0,s.kt)(Fhn,(0,p.Z)({},Ghn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Bhn.isMDXComponent=!0;const Uhn={toc:[]},Vhn="wrapper";function qhn(t){let{components:e,...n}=t;return(0,s.kt)(Vhn,(0,p.Z)({},Uhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qhn.isMDXComponent=!0;const jhn={toc:[]},Yhn="wrapper";function Hhn(t){let{components:e,...n}=t;return(0,s.kt)(Yhn,(0,p.Z)({},jhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Hhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Jhn(t){let{components:e,...n}=t;return(0,s.kt)($hn,(0,p.Z)({},Qhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Jhn.isMDXComponent=!0;const Khn={toc:[]},tfn="wrapper";function efn(t){let{components:e,...n}=t;return(0,s.kt)(tfn,(0,p.Z)({},Khn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}efn.isMDXComponent=!0;const nfn={toc:[]},ofn="wrapper";function pfn(t){let{components:e,...n}=t;return(0,s.kt)(ofn,(0,p.Z)({},nfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pfn.isMDXComponent=!0;const rfn={toc:[]},sfn="wrapper";function cfn(t){let{components:e,...n}=t;return(0,s.kt)(sfn,(0,p.Z)({},rfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cfn.isMDXComponent=!0;const ifn={toc:[]},afn="wrapper";function lfn(t){let{components:e,...n}=t;return(0,s.kt)(afn,(0,p.Z)({},ifn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lfn.isMDXComponent=!0;const ufn={toc:[]},mfn="wrapper";function dfn(t){let{components:e,...n}=t;return(0,s.kt)(mfn,(0,p.Z)({},ufn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dfn.isMDXComponent=!0;const hfn={toc:[]},ffn="wrapper";function kfn(t){let{components:e,...n}=t;return(0,s.kt)(ffn,(0,p.Z)({},hfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kfn.isMDXComponent=!0;const yfn={toc:[]},Dfn="wrapper";function Mfn(t){let{components:e,...n}=t;return(0,s.kt)(Dfn,(0,p.Z)({},yfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Mfn.isMDXComponent=!0;const Xfn={toc:[]},_fn="wrapper";function wfn(t){let{components:e,...n}=t;return(0,s.kt)(_fn,(0,p.Z)({},Xfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wfn.isMDXComponent=!0;const Tfn={toc:[]},gfn="wrapper";function Cfn(t){let{components:e,...n}=t;return(0,s.kt)(gfn,(0,p.Z)({},Tfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Cfn.isMDXComponent=!0;const xfn={toc:[]},vfn="wrapper";function Lfn(t){let{components:e,...n}=t;return(0,s.kt)(vfn,(0,p.Z)({},xfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]},bfn="wrapper";function Nfn(t){let{components:e,...n}=t;return(0,s.kt)(bfn,(0,p.Z)({},Zfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Nfn.isMDXComponent=!0;const Afn={toc:[]},zfn="wrapper";function Wfn(t){let{components:e,...n}=t;return(0,s.kt)(zfn,(0,p.Z)({},Afn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Sfn(t){let{components:e,...n}=t;return(0,s.kt)(Rfn,(0,p.Z)({},Ifn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sfn.isMDXComponent=!0;const Pfn={toc:[]},Efn="wrapper";function Ofn(t){let{components:e,...n}=t;return(0,s.kt)(Efn,(0,p.Z)({},Pfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ofn.isMDXComponent=!0;const Gfn={toc:[]},Ffn="wrapper";function Bfn(t){let{components:e,...n}=t;return(0,s.kt)(Ffn,(0,p.Z)({},Gfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bfn.isMDXComponent=!0;const Ufn={toc:[]},Vfn="wrapper";function qfn(t){let{components:e,...n}=t;return(0,s.kt)(Vfn,(0,p.Z)({},Ufn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Yfn="wrapper";function Hfn(t){let{components:e,...n}=t;return(0,s.kt)(Yfn,(0,p.Z)({},jfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Hfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Jfn(t){let{components:e,...n}=t;return(0,s.kt)($fn,(0,p.Z)({},Qfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Jfn.isMDXComponent=!0;const Kfn={toc:[]},tkn="wrapper";function ekn(t){let{components:e,...n}=t;return(0,s.kt)(tkn,(0,p.Z)({},Kfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ekn.isMDXComponent=!0;const nkn={toc:[]},okn="wrapper";function pkn(t){let{components:e,...n}=t;return(0,s.kt)(okn,(0,p.Z)({},nkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pkn.isMDXComponent=!0;const rkn={toc:[]},skn="wrapper";function ckn(t){let{components:e,...n}=t;return(0,s.kt)(skn,(0,p.Z)({},rkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ckn.isMDXComponent=!0;const ikn={toc:[]},akn="wrapper";function lkn(t){let{components:e,...n}=t;return(0,s.kt)(akn,(0,p.Z)({},ikn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lkn.isMDXComponent=!0;const ukn={toc:[]},mkn="wrapper";function dkn(t){let{components:e,...n}=t;return(0,s.kt)(mkn,(0,p.Z)({},ukn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dkn.isMDXComponent=!0;const hkn={toc:[]},fkn="wrapper";function kkn(t){let{components:e,...n}=t;return(0,s.kt)(fkn,(0,p.Z)({},hkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kkn.isMDXComponent=!0;const ykn={toc:[]},Dkn="wrapper";function Mkn(t){let{components:e,...n}=t;return(0,s.kt)(Dkn,(0,p.Z)({},ykn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mkn.isMDXComponent=!0;const Xkn={toc:[]},_kn="wrapper";function wkn(t){let{components:e,...n}=t;return(0,s.kt)(_kn,(0,p.Z)({},Xkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}wkn.isMDXComponent=!0;const Tkn={toc:[]},gkn="wrapper";function Ckn(t){let{components:e,...n}=t;return(0,s.kt)(gkn,(0,p.Z)({},Tkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}Ckn.isMDXComponent=!0;const xkn={toc:[]},vkn="wrapper";function Lkn(t){let{components:e,...n}=t;return(0,s.kt)(vkn,(0,p.Z)({},xkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]},bkn="wrapper";function Nkn(t){let{components:e,...n}=t;return(0,s.kt)(bkn,(0,p.Z)({},Zkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Nkn.isMDXComponent=!0;const Akn={toc:[]},zkn="wrapper";function Wkn(t){let{components:e,...n}=t;return(0,s.kt)(zkn,(0,p.Z)({},Akn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Wkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Skn(t){let{components:e,...n}=t;return(0,s.kt)(Rkn,(0,p.Z)({},Ikn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Skn.isMDXComponent=!0;const Pkn={toc:[]},Ekn="wrapper";function Okn(t){let{components:e,...n}=t;return(0,s.kt)(Ekn,(0,p.Z)({},Pkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Okn.isMDXComponent=!0;const Gkn={toc:[]},Fkn="wrapper";function Bkn(t){let{components:e,...n}=t;return(0,s.kt)(Fkn,(0,p.Z)({},Gkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Bkn.isMDXComponent=!0;const Ukn={toc:[]},Vkn="wrapper";function qkn(t){let{components:e,...n}=t;return(0,s.kt)(Vkn,(0,p.Z)({},Ukn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Ykn="wrapper";function Hkn(t){let{components:e,...n}=t;return(0,s.kt)(Ykn,(0,p.Z)({},jkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Hkn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Jkn(t){let{components:e,...n}=t;return(0,s.kt)($kn,(0,p.Z)({},Qkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Jkn.isMDXComponent=!0;const Kkn={toc:[]},tyn="wrapper";function eyn(t){let{components:e,...n}=t;return(0,s.kt)(tyn,(0,p.Z)({},Kkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eyn.isMDXComponent=!0;const nyn={toc:[]},oyn="wrapper";function pyn(t){let{components:e,...n}=t;return(0,s.kt)(oyn,(0,p.Z)({},nyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pyn.isMDXComponent=!0;const ryn={toc:[]},syn="wrapper";function cyn(t){let{components:e,...n}=t;return(0,s.kt)(syn,(0,p.Z)({},ryn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cyn.isMDXComponent=!0;const iyn={toc:[]},ayn="wrapper";function lyn(t){let{components:e,...n}=t;return(0,s.kt)(ayn,(0,p.Z)({},iyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lyn.isMDXComponent=!0;const uyn={toc:[]},myn="wrapper";function dyn(t){let{components:e,...n}=t;return(0,s.kt)(myn,(0,p.Z)({},uyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dyn.isMDXComponent=!0;const hyn={toc:[]},fyn="wrapper";function kyn(t){let{components:e,...n}=t;return(0,s.kt)(fyn,(0,p.Z)({},hyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}kyn.isMDXComponent=!0;const yyn={toc:[]},Dyn="wrapper";function Myn(t){let{components:e,...n}=t;return(0,s.kt)(Dyn,(0,p.Z)({},yyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Myn.isMDXComponent=!0;const Xyn={toc:[]},_yn="wrapper";function wyn(t){let{components:e,...n}=t;return(0,s.kt)(_yn,(0,p.Z)({},Xyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wyn.isMDXComponent=!0;const Tyn={toc:[]},gyn="wrapper";function Cyn(t){let{components:e,...n}=t;return(0,s.kt)(gyn,(0,p.Z)({},Tyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Cyn.isMDXComponent=!0;const xyn={toc:[]},vyn="wrapper";function Lyn(t){let{components:e,...n}=t;return(0,s.kt)(vyn,(0,p.Z)({},xyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]},byn="wrapper";function Nyn(t){let{components:e,...n}=t;return(0,s.kt)(byn,(0,p.Z)({},Zyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Nyn.isMDXComponent=!0;const Ayn={toc:[]},zyn="wrapper";function Wyn(t){let{components:e,...n}=t;return(0,s.kt)(zyn,(0,p.Z)({},Ayn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Wyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Syn(t){let{components:e,...n}=t;return(0,s.kt)(Ryn,(0,p.Z)({},Iyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Syn.isMDXComponent=!0;const Pyn={toc:[]},Eyn="wrapper";function Oyn(t){let{components:e,...n}=t;return(0,s.kt)(Eyn,(0,p.Z)({},Pyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Oyn.isMDXComponent=!0;const Gyn={toc:[]},Fyn="wrapper";function Byn(t){let{components:e,...n}=t;return(0,s.kt)(Fyn,(0,p.Z)({},Gyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Byn.isMDXComponent=!0;const Uyn={toc:[]},Vyn="wrapper";function qyn(t){let{components:e,...n}=t;return(0,s.kt)(Vyn,(0,p.Z)({},Uyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Yyn="wrapper";function Hyn(t){let{components:e,...n}=t;return(0,s.kt)(Yyn,(0,p.Z)({},jyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Hyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Jyn(t){let{components:e,...n}=t;return(0,s.kt)($yn,(0,p.Z)({},Qyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Jyn.isMDXComponent=!0;const Kyn={toc:[]},tDn="wrapper";function eDn(t){let{components:e,...n}=t;return(0,s.kt)(tDn,(0,p.Z)({},Kyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}eDn.isMDXComponent=!0;const nDn={toc:[]},oDn="wrapper";function pDn(t){let{components:e,...n}=t;return(0,s.kt)(oDn,(0,p.Z)({},nDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pDn.isMDXComponent=!0;const rDn={toc:[]},sDn="wrapper";function cDn(t){let{components:e,...n}=t;return(0,s.kt)(sDn,(0,p.Z)({},rDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cDn.isMDXComponent=!0;const iDn={toc:[]},aDn="wrapper";function lDn(t){let{components:e,...n}=t;return(0,s.kt)(aDn,(0,p.Z)({},iDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}lDn.isMDXComponent=!0;const uDn={toc:[]},mDn="wrapper";function dDn(t){let{components:e,...n}=t;return(0,s.kt)(mDn,(0,p.Z)({},uDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}dDn.isMDXComponent=!0;const hDn={toc:[]},fDn="wrapper";function kDn(t){let{components:e,...n}=t;return(0,s.kt)(fDn,(0,p.Z)({},hDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}kDn.isMDXComponent=!0;const yDn={toc:[]},DDn="wrapper";function MDn(t){let{components:e,...n}=t;return(0,s.kt)(DDn,(0,p.Z)({},yDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MDn.isMDXComponent=!0;const XDn={toc:[]},_Dn="wrapper";function wDn(t){let{components:e,...n}=t;return(0,s.kt)(_Dn,(0,p.Z)({},XDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wDn.isMDXComponent=!0;const TDn={toc:[]},gDn="wrapper";function CDn(t){let{components:e,...n}=t;return(0,s.kt)(gDn,(0,p.Z)({},TDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}CDn.isMDXComponent=!0;const xDn={toc:[]},vDn="wrapper";function LDn(t){let{components:e,...n}=t;return(0,s.kt)(vDn,(0,p.Z)({},xDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LDn.isMDXComponent=!0;const ZDn={toc:[]},bDn="wrapper";function NDn(t){let{components:e,...n}=t;return(0,s.kt)(bDn,(0,p.Z)({},ZDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NDn.isMDXComponent=!0;const ADn={toc:[]},zDn="wrapper";function WDn(t){let{components:e,...n}=t;return(0,s.kt)(zDn,(0,p.Z)({},ADn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}WDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function SDn(t){let{components:e,...n}=t;return(0,s.kt)(RDn,(0,p.Z)({},IDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}SDn.isMDXComponent=!0;const PDn={toc:[]},EDn="wrapper";function ODn(t){let{components:e,...n}=t;return(0,s.kt)(EDn,(0,p.Z)({},PDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ODn.isMDXComponent=!0;const GDn={toc:[]},FDn="wrapper";function BDn(t){let{components:e,...n}=t;return(0,s.kt)(FDn,(0,p.Z)({},GDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}BDn.isMDXComponent=!0;const UDn={toc:[]},VDn="wrapper";function qDn(t){let{components:e,...n}=t;return(0,s.kt)(VDn,(0,p.Z)({},UDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qDn.isMDXComponent=!0;const jDn={toc:[]},YDn="wrapper";function HDn(t){let{components:e,...n}=t;return(0,s.kt)(YDn,(0,p.Z)({},jDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}HDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function JDn(t){let{components:e,...n}=t;return(0,s.kt)($Dn,(0,p.Z)({},QDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}JDn.isMDXComponent=!0;const KDn={toc:[]},tMn="wrapper";function eMn(t){let{components:e,...n}=t;return(0,s.kt)(tMn,(0,p.Z)({},KDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}eMn.isMDXComponent=!0;const nMn={toc:[]},oMn="wrapper";function pMn(t){let{components:e,...n}=t;return(0,s.kt)(oMn,(0,p.Z)({},nMn,n,{components:e,mdxType:"MDXLayout"}))}pMn.isMDXComponent=!0;const rMn={toc:[]},sMn="wrapper";function cMn(t){let{components:e,...n}=t;return(0,s.kt)(sMn,(0,p.Z)({},rMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cMn.isMDXComponent=!0;const iMn={toc:[]},aMn="wrapper";function lMn(t){let{components:e,...n}=t;return(0,s.kt)(aMn,(0,p.Z)({},iMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lMn.isMDXComponent=!0;const uMn={toc:[]},mMn="wrapper";function dMn(t){let{components:e,...n}=t;return(0,s.kt)(mMn,(0,p.Z)({},uMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dMn.isMDXComponent=!0;const hMn={toc:[]},fMn="wrapper";function kMn(t){let{components:e,...n}=t;return(0,s.kt)(fMn,(0,p.Z)({},hMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}kMn.isMDXComponent=!0;const yMn={toc:[]},DMn="wrapper";function MMn(t){let{components:e,...n}=t;return(0,s.kt)(DMn,(0,p.Z)({},yMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}MMn.isMDXComponent=!0;const XMn={toc:[]},_Mn="wrapper";function wMn(t){let{components:e,...n}=t;return(0,s.kt)(_Mn,(0,p.Z)({},XMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}wMn.isMDXComponent=!0;const TMn={toc:[]},gMn="wrapper";function CMn(t){let{components:e,...n}=t;return(0,s.kt)(gMn,(0,p.Z)({},TMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}CMn.isMDXComponent=!0;const xMn={toc:[]},vMn="wrapper";function LMn(t){let{components:e,...n}=t;return(0,s.kt)(vMn,(0,p.Z)({},xMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LMn.isMDXComponent=!0;const ZMn={toc:[]},bMn="wrapper";function NMn(t){let{components:e,...n}=t;return(0,s.kt)(bMn,(0,p.Z)({},ZMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}NMn.isMDXComponent=!0;const AMn={toc:[]},zMn="wrapper";function WMn(t){let{components:e,...n}=t;return(0,s.kt)(zMn,(0,p.Z)({},AMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function SMn(t){let{components:e,...n}=t;return(0,s.kt)(RMn,(0,p.Z)({},IMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}SMn.isMDXComponent=!0;const PMn={toc:[]},EMn="wrapper";function OMn(t){let{components:e,...n}=t;return(0,s.kt)(EMn,(0,p.Z)({},PMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}OMn.isMDXComponent=!0;const GMn={toc:[]},FMn="wrapper";function BMn(t){let{components:e,...n}=t;return(0,s.kt)(FMn,(0,p.Z)({},GMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}BMn.isMDXComponent=!0;const UMn={toc:[]},VMn="wrapper";function qMn(t){let{components:e,...n}=t;return(0,s.kt)(VMn,(0,p.Z)({},UMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qMn.isMDXComponent=!0;const jMn={toc:[]},YMn="wrapper";function HMn(t){let{components:e,...n}=t;return(0,s.kt)(YMn,(0,p.Z)({},jMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}HMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function JMn(t){let{components:e,...n}=t;return(0,s.kt)($Mn,(0,p.Z)({},QMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}JMn.isMDXComponent=!0;const KMn={toc:[]},tXn="wrapper";function eXn(t){let{components:e,...n}=t;return(0,s.kt)(tXn,(0,p.Z)({},KMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}eXn.isMDXComponent=!0;const nXn={toc:[]},oXn="wrapper";function pXn(t){let{components:e,...n}=t;return(0,s.kt)(oXn,(0,p.Z)({},nXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}pXn.isMDXComponent=!0;const rXn={toc:[]},sXn="wrapper";function cXn(t){let{components:e,...n}=t;return(0,s.kt)(sXn,(0,p.Z)({},rXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}cXn.isMDXComponent=!0;const iXn={toc:[]},aXn="wrapper";function lXn(t){let{components:e,...n}=t;return(0,s.kt)(aXn,(0,p.Z)({},iXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}lXn.isMDXComponent=!0;const uXn={toc:[]},mXn="wrapper";function dXn(t){let{components:e,...n}=t;return(0,s.kt)(mXn,(0,p.Z)({},uXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dXn.isMDXComponent=!0;const hXn={toc:[]},fXn="wrapper";function kXn(t){let{components:e,...n}=t;return(0,s.kt)(fXn,(0,p.Z)({},hXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kXn.isMDXComponent=!0;const yXn={toc:[]},DXn="wrapper";function MXn(t){let{components:e,...n}=t;return(0,s.kt)(DXn,(0,p.Z)({},yXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}MXn.isMDXComponent=!0;const XXn={toc:[]},_Xn="wrapper";function wXn(t){let{components:e,...n}=t;return(0,s.kt)(_Xn,(0,p.Z)({},XXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wXn.isMDXComponent=!0;const TXn={toc:[]},gXn="wrapper";function CXn(t){let{components:e,...n}=t;return(0,s.kt)(gXn,(0,p.Z)({},TXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}CXn.isMDXComponent=!0;const xXn={toc:[]},vXn="wrapper";function LXn(t){let{components:e,...n}=t;return(0,s.kt)(vXn,(0,p.Z)({},xXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}LXn.isMDXComponent=!0;const ZXn={toc:[]},bXn="wrapper";function NXn(t){let{components:e,...n}=t;return(0,s.kt)(bXn,(0,p.Z)({},ZXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}NXn.isMDXComponent=!0;const AXn={toc:[]},zXn="wrapper";function WXn(t){let{components:e,...n}=t;return(0,s.kt)(zXn,(0,p.Z)({},AXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function SXn(t){let{components:e,...n}=t;return(0,s.kt)(RXn,(0,p.Z)({},IXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}SXn.isMDXComponent=!0;const PXn={toc:[]},EXn="wrapper";function OXn(t){let{components:e,...n}=t;return(0,s.kt)(EXn,(0,p.Z)({},PXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}OXn.isMDXComponent=!0;const GXn={toc:[]},FXn="wrapper";function BXn(t){let{components:e,...n}=t;return(0,s.kt)(FXn,(0,p.Z)({},GXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}BXn.isMDXComponent=!0;const UXn={toc:[]},VXn="wrapper";function qXn(t){let{components:e,...n}=t;return(0,s.kt)(VXn,(0,p.Z)({},UXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qXn.isMDXComponent=!0;const jXn={toc:[]},YXn="wrapper";function HXn(t){let{components:e,...n}=t;return(0,s.kt)(YXn,(0,p.Z)({},jXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function JXn(t){let{components:e,...n}=t;return(0,s.kt)($Xn,(0,p.Z)({},QXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}JXn.isMDXComponent=!0;const KXn={toc:[]},t_n="wrapper";function e_n(t){let{components:e,...n}=t;return(0,s.kt)(t_n,(0,p.Z)({},KXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}e_n.isMDXComponent=!0;const n_n={toc:[]},o_n="wrapper";function p_n(t){let{components:e,...n}=t;return(0,s.kt)(o_n,(0,p.Z)({},n_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}p_n.isMDXComponent=!0;const r_n={toc:[]},s_n="wrapper";function c_n(t){let{components:e,...n}=t;return(0,s.kt)(s_n,(0,p.Z)({},r_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c_n.isMDXComponent=!0;const i_n={toc:[]},a_n="wrapper";function l_n(t){let{components:e,...n}=t;return(0,s.kt)(a_n,(0,p.Z)({},i_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}l_n.isMDXComponent=!0;const u_n={toc:[]},m_n="wrapper";function d_n(t){let{components:e,...n}=t;return(0,s.kt)(m_n,(0,p.Z)({},u_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d_n.isMDXComponent=!0;const h_n={toc:[]},f_n="wrapper";function k_n(t){let{components:e,...n}=t;return(0,s.kt)(f_n,(0,p.Z)({},h_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}k_n.isMDXComponent=!0;const y_n={toc:[]},D_n="wrapper";function M_n(t){let{components:e,...n}=t;return(0,s.kt)(D_n,(0,p.Z)({},y_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}M_n.isMDXComponent=!0;const X_n={toc:[]},__n="wrapper";function w_n(t){let{components:e,...n}=t;return(0,s.kt)(__n,(0,p.Z)({},X_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}w_n.isMDXComponent=!0;const T_n={toc:[]},g_n="wrapper";function C_n(t){let{components:e,...n}=t;return(0,s.kt)(g_n,(0,p.Z)({},T_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}C_n.isMDXComponent=!0;const x_n={toc:[]},v_n="wrapper";function L_n(t){let{components:e,...n}=t;return(0,s.kt)(v_n,(0,p.Z)({},x_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}L_n.isMDXComponent=!0;const Z_n={toc:[]},b_n="wrapper";function N_n(t){let{components:e,...n}=t;return(0,s.kt)(b_n,(0,p.Z)({},Z_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}N_n.isMDXComponent=!0;const A_n={toc:[]},z_n="wrapper";function W_n(t){let{components:e,...n}=t;return(0,s.kt)(z_n,(0,p.Z)({},A_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}W_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function S_n(t){let{components:e,...n}=t;return(0,s.kt)(R_n,(0,p.Z)({},I_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}S_n.isMDXComponent=!0;const P_n={toc:[]},E_n="wrapper";function O_n(t){let{components:e,...n}=t;return(0,s.kt)(E_n,(0,p.Z)({},P_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O_n.isMDXComponent=!0;const G_n={toc:[]},F_n="wrapper";function B_n(t){let{components:e,...n}=t;return(0,s.kt)(F_n,(0,p.Z)({},G_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}B_n.isMDXComponent=!0;const U_n={toc:[]},V_n="wrapper";function q_n(t){let{components:e,...n}=t;return(0,s.kt)(V_n,(0,p.Z)({},U_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}q_n.isMDXComponent=!0;const j_n={toc:[]},Y_n="wrapper";function H_n(t){let{components:e,...n}=t;return(0,s.kt)(Y_n,(0,p.Z)({},j_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}H_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function J_n(t){let{components:e,...n}=t;return(0,s.kt)($_n,(0,p.Z)({},Q_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}J_n.isMDXComponent=!0;const K_n={toc:[]},twn="wrapper";function ewn(t){let{components:e,...n}=t;return(0,s.kt)(twn,(0,p.Z)({},K_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ewn.isMDXComponent=!0;const nwn={toc:[]},own="wrapper";function pwn(t){let{components:e,...n}=t;return(0,s.kt)(own,(0,p.Z)({},nwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pwn.isMDXComponent=!0;const rwn={toc:[]},swn="wrapper";function cwn(t){let{components:e,...n}=t;return(0,s.kt)(swn,(0,p.Z)({},rwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cwn.isMDXComponent=!0;const iwn={toc:[]},awn="wrapper";function lwn(t){let{components:e,...n}=t;return(0,s.kt)(awn,(0,p.Z)({},iwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lwn.isMDXComponent=!0;const uwn={toc:[]},mwn="wrapper";function dwn(t){let{components:e,...n}=t;return(0,s.kt)(mwn,(0,p.Z)({},uwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dwn.isMDXComponent=!0;const hwn={toc:[]},fwn="wrapper";function kwn(t){let{components:e,...n}=t;return(0,s.kt)(fwn,(0,p.Z)({},hwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kwn.isMDXComponent=!0;const ywn={toc:[]},Dwn="wrapper";function Mwn(t){let{components:e,...n}=t;return(0,s.kt)(Dwn,(0,p.Z)({},ywn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mwn.isMDXComponent=!0;const Xwn={toc:[]},_wn="wrapper";function wwn(t){let{components:e,...n}=t;return(0,s.kt)(_wn,(0,p.Z)({},Xwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wwn.isMDXComponent=!0;const Twn={toc:[]},gwn="wrapper";function Cwn(t){let{components:e,...n}=t;return(0,s.kt)(gwn,(0,p.Z)({},Twn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Cwn.isMDXComponent=!0;const xwn={toc:[]},vwn="wrapper";function Lwn(t){let{components:e,...n}=t;return(0,s.kt)(vwn,(0,p.Z)({},xwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]},bwn="wrapper";function Nwn(t){let{components:e,...n}=t;return(0,s.kt)(bwn,(0,p.Z)({},Zwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nwn.isMDXComponent=!0;const Awn={toc:[]},zwn="wrapper";function Wwn(t){let{components:e,...n}=t;return(0,s.kt)(zwn,(0,p.Z)({},Awn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Swn(t){let{components:e,...n}=t;return(0,s.kt)(Rwn,(0,p.Z)({},Iwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Swn.isMDXComponent=!0;const Pwn={toc:[]},Ewn="wrapper";function Own(t){let{components:e,...n}=t;return(0,s.kt)(Ewn,(0,p.Z)({},Pwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Own.isMDXComponent=!0;const Gwn={toc:[]},Fwn="wrapper";function Bwn(t){let{components:e,...n}=t;return(0,s.kt)(Fwn,(0,p.Z)({},Gwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Bwn.isMDXComponent=!0;const Uwn={toc:[]},Vwn="wrapper";function qwn(t){let{components:e,...n}=t;return(0,s.kt)(Vwn,(0,p.Z)({},Uwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Ywn="wrapper";function Hwn(t){let{components:e,...n}=t;return(0,s.kt)(Ywn,(0,p.Z)({},jwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Hwn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Jwn(t){let{components:e,...n}=t;return(0,s.kt)($wn,(0,p.Z)({},Qwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Jwn.isMDXComponent=!0;const Kwn={toc:[]},tTn="wrapper";function eTn(t){let{components:e,...n}=t;return(0,s.kt)(tTn,(0,p.Z)({},Kwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eTn.isMDXComponent=!0;const nTn={toc:[]},oTn="wrapper";function pTn(t){let{components:e,...n}=t;return(0,s.kt)(oTn,(0,p.Z)({},nTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pTn.isMDXComponent=!0;const rTn={toc:[]},sTn="wrapper";function cTn(t){let{components:e,...n}=t;return(0,s.kt)(sTn,(0,p.Z)({},rTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}cTn.isMDXComponent=!0;const iTn={toc:[]},aTn="wrapper";function lTn(t){let{components:e,...n}=t;return(0,s.kt)(aTn,(0,p.Z)({},iTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lTn.isMDXComponent=!0;const uTn={toc:[]},mTn="wrapper";function dTn(t){let{components:e,...n}=t;return(0,s.kt)(mTn,(0,p.Z)({},uTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}dTn.isMDXComponent=!0;const hTn={toc:[]},fTn="wrapper";function kTn(t){let{components:e,...n}=t;return(0,s.kt)(fTn,(0,p.Z)({},hTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}kTn.isMDXComponent=!0;const yTn={toc:[]},DTn="wrapper";function MTn(t){let{components:e,...n}=t;return(0,s.kt)(DTn,(0,p.Z)({},yTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}MTn.isMDXComponent=!0;const XTn={toc:[]},_Tn="wrapper";function wTn(t){let{components:e,...n}=t;return(0,s.kt)(_Tn,(0,p.Z)({},XTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wTn.isMDXComponent=!0;const TTn={toc:[]},gTn="wrapper";function CTn(t){let{components:e,...n}=t;return(0,s.kt)(gTn,(0,p.Z)({},TTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}CTn.isMDXComponent=!0;const xTn={toc:[]},vTn="wrapper";function LTn(t){let{components:e,...n}=t;return(0,s.kt)(vTn,(0,p.Z)({},xTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}LTn.isMDXComponent=!0;const ZTn={toc:[]},bTn="wrapper";function NTn(t){let{components:e,...n}=t;return(0,s.kt)(bTn,(0,p.Z)({},ZTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}NTn.isMDXComponent=!0;const ATn={toc:[]},zTn="wrapper";function WTn(t){let{components:e,...n}=t;return(0,s.kt)(zTn,(0,p.Z)({},ATn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}WTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function STn(t){let{components:e,...n}=t;return(0,s.kt)(RTn,(0,p.Z)({},ITn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}STn.isMDXComponent=!0;const PTn={toc:[]},ETn="wrapper";function OTn(t){let{components:e,...n}=t;return(0,s.kt)(ETn,(0,p.Z)({},PTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}OTn.isMDXComponent=!0;const GTn={toc:[]},FTn="wrapper";function BTn(t){let{components:e,...n}=t;return(0,s.kt)(FTn,(0,p.Z)({},GTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}BTn.isMDXComponent=!0;const UTn={toc:[]},VTn="wrapper";function qTn(t){let{components:e,...n}=t;return(0,s.kt)(VTn,(0,p.Z)({},UTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}qTn.isMDXComponent=!0;const jTn={toc:[]},YTn="wrapper";function HTn(t){let{components:e,...n}=t;return(0,s.kt)(YTn,(0,p.Z)({},jTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}HTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function JTn(t){let{components:e,...n}=t;return(0,s.kt)($Tn,(0,p.Z)({},QTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}JTn.isMDXComponent=!0;const KTn={toc:[]},tgn="wrapper";function egn(t){let{components:e,...n}=t;return(0,s.kt)(tgn,(0,p.Z)({},KTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}egn.isMDXComponent=!0;const ngn={toc:[]},ogn="wrapper";function pgn(t){let{components:e,...n}=t;return(0,s.kt)(ogn,(0,p.Z)({},ngn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pgn.isMDXComponent=!0;const rgn={toc:[]},sgn="wrapper";function cgn(t){let{components:e,...n}=t;return(0,s.kt)(sgn,(0,p.Z)({},rgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}cgn.isMDXComponent=!0;const ign={toc:[]},agn="wrapper";function lgn(t){let{components:e,...n}=t;return(0,s.kt)(agn,(0,p.Z)({},ign,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lgn.isMDXComponent=!0;const ugn={toc:[]},mgn="wrapper";function dgn(t){let{components:e,...n}=t;return(0,s.kt)(mgn,(0,p.Z)({},ugn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}dgn.isMDXComponent=!0;const hgn={toc:[]},fgn="wrapper";function kgn(t){let{components:e,...n}=t;return(0,s.kt)(fgn,(0,p.Z)({},hgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kgn.isMDXComponent=!0;const ygn={toc:[]},Dgn="wrapper";function Mgn(t){let{components:e,...n}=t;return(0,s.kt)(Dgn,(0,p.Z)({},ygn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mgn.isMDXComponent=!0;const Xgn={toc:[]},_gn="wrapper";function wgn(t){let{components:e,...n}=t;return(0,s.kt)(_gn,(0,p.Z)({},Xgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wgn.isMDXComponent=!0;const Tgn={toc:[]},ggn="wrapper";function Cgn(t){let{components:e,...n}=t;return(0,s.kt)(ggn,(0,p.Z)({},Tgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Cgn.isMDXComponent=!0;const xgn={toc:[]},vgn="wrapper";function Lgn(t){let{components:e,...n}=t;return(0,s.kt)(vgn,(0,p.Z)({},xgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]},bgn="wrapper";function Ngn(t){let{components:e,...n}=t;return(0,s.kt)(bgn,(0,p.Z)({},Zgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ngn.isMDXComponent=!0;const Agn={toc:[]},zgn="wrapper";function Wgn(t){let{components:e,...n}=t;return(0,s.kt)(zgn,(0,p.Z)({},Agn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Sgn(t){let{components:e,...n}=t;return(0,s.kt)(Rgn,(0,p.Z)({},Ign,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Sgn.isMDXComponent=!0;const Pgn={toc:[]},Egn="wrapper";function Ogn(t){let{components:e,...n}=t;return(0,s.kt)(Egn,(0,p.Z)({},Pgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ogn.isMDXComponent=!0;const Ggn={toc:[]},Fgn="wrapper";function Bgn(t){let{components:e,...n}=t;return(0,s.kt)(Fgn,(0,p.Z)({},Ggn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Bgn.isMDXComponent=!0;const Ugn={toc:[]},Vgn="wrapper";function qgn(t){let{components:e,...n}=t;return(0,s.kt)(Vgn,(0,p.Z)({},Ugn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Ygn="wrapper";function Hgn(t){let{components:e,...n}=t;return(0,s.kt)(Ygn,(0,p.Z)({},jgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Hgn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Jgn(t){let{components:e,...n}=t;return(0,s.kt)($gn,(0,p.Z)({},Qgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Jgn.isMDXComponent=!0;const Kgn={toc:[]},tCn="wrapper";function eCn(t){let{components:e,...n}=t;return(0,s.kt)(tCn,(0,p.Z)({},Kgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}eCn.isMDXComponent=!0;const nCn={toc:[]},oCn="wrapper";function pCn(t){let{components:e,...n}=t;return(0,s.kt)(oCn,(0,p.Z)({},nCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pCn.isMDXComponent=!0;const rCn={toc:[]},sCn="wrapper";function cCn(t){let{components:e,...n}=t;return(0,s.kt)(sCn,(0,p.Z)({},rCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cCn.isMDXComponent=!0;const iCn={toc:[]},aCn="wrapper";function lCn(t){let{components:e,...n}=t;return(0,s.kt)(aCn,(0,p.Z)({},iCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lCn.isMDXComponent=!0;const uCn={toc:[]},mCn="wrapper";function dCn(t){let{components:e,...n}=t;return(0,s.kt)(mCn,(0,p.Z)({},uCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dCn.isMDXComponent=!0;const hCn={toc:[]},fCn="wrapper";function kCn(t){let{components:e,...n}=t;return(0,s.kt)(fCn,(0,p.Z)({},hCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kCn.isMDXComponent=!0;const yCn={toc:[]},DCn="wrapper";function MCn(t){let{components:e,...n}=t;return(0,s.kt)(DCn,(0,p.Z)({},yCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}MCn.isMDXComponent=!0;const XCn={toc:[]},_Cn="wrapper";function wCn(t){let{components:e,...n}=t;return(0,s.kt)(_Cn,(0,p.Z)({},XCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wCn.isMDXComponent=!0;const TCn={toc:[]},gCn="wrapper";function CCn(t){let{components:e,...n}=t;return(0,s.kt)(gCn,(0,p.Z)({},TCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}CCn.isMDXComponent=!0;const xCn={toc:[]},vCn="wrapper";function LCn(t){let{components:e,...n}=t;return(0,s.kt)(vCn,(0,p.Z)({},xCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}LCn.isMDXComponent=!0;const ZCn={toc:[]},bCn="wrapper";function NCn(t){let{components:e,...n}=t;return(0,s.kt)(bCn,(0,p.Z)({},ZCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}NCn.isMDXComponent=!0;const ACn={toc:[]},zCn="wrapper";function WCn(t){let{components:e,...n}=t;return(0,s.kt)(zCn,(0,p.Z)({},ACn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}WCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function SCn(t){let{components:e,...n}=t;return(0,s.kt)(RCn,(0,p.Z)({},ICn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}SCn.isMDXComponent=!0;const PCn={toc:[]},ECn="wrapper";function OCn(t){let{components:e,...n}=t;return(0,s.kt)(ECn,(0,p.Z)({},PCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}OCn.isMDXComponent=!0;const GCn={toc:[]},FCn="wrapper";function BCn(t){let{components:e,...n}=t;return(0,s.kt)(FCn,(0,p.Z)({},GCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}BCn.isMDXComponent=!0;const UCn={toc:[]},VCn="wrapper";function qCn(t){let{components:e,...n}=t;return(0,s.kt)(VCn,(0,p.Z)({},UCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qCn.isMDXComponent=!0;const jCn={toc:[]},YCn="wrapper";function HCn(t){let{components:e,...n}=t;return(0,s.kt)(YCn,(0,p.Z)({},jCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}HCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function JCn(t){let{components:e,...n}=t;return(0,s.kt)($Cn,(0,p.Z)({},QCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JCn.isMDXComponent=!0;const KCn={toc:[]},txn="wrapper";function exn(t){let{components:e,...n}=t;return(0,s.kt)(txn,(0,p.Z)({},KCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}exn.isMDXComponent=!0;const nxn={toc:[]},oxn="wrapper";function pxn(t){let{components:e,...n}=t;return(0,s.kt)(oxn,(0,p.Z)({},nxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}pxn.isMDXComponent=!0;const rxn={toc:[]},sxn="wrapper";function cxn(t){let{components:e,...n}=t;return(0,s.kt)(sxn,(0,p.Z)({},rxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cxn.isMDXComponent=!0;const ixn={toc:[]},axn="wrapper";function lxn(t){let{components:e,...n}=t;return(0,s.kt)(axn,(0,p.Z)({},ixn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}lxn.isMDXComponent=!0;const uxn={toc:[]},mxn="wrapper";function dxn(t){let{components:e,...n}=t;return(0,s.kt)(mxn,(0,p.Z)({},uxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dxn.isMDXComponent=!0;const hxn={toc:[]},fxn="wrapper";function kxn(t){let{components:e,...n}=t;return(0,s.kt)(fxn,(0,p.Z)({},hxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kxn.isMDXComponent=!0;const yxn={toc:[]},Dxn="wrapper";function Mxn(t){let{components:e,...n}=t;return(0,s.kt)(Dxn,(0,p.Z)({},yxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mxn.isMDXComponent=!0;const Xxn={toc:[]},_xn="wrapper";function wxn(t){let{components:e,...n}=t;return(0,s.kt)(_xn,(0,p.Z)({},Xxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wxn.isMDXComponent=!0;const Txn={toc:[]},gxn="wrapper";function Cxn(t){let{components:e,...n}=t;return(0,s.kt)(gxn,(0,p.Z)({},Txn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Cxn.isMDXComponent=!0;const xxn={toc:[]},vxn="wrapper";function Lxn(t){let{components:e,...n}=t;return(0,s.kt)(vxn,(0,p.Z)({},xxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]},bxn="wrapper";function Nxn(t){let{components:e,...n}=t;return(0,s.kt)(bxn,(0,p.Z)({},Zxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Nxn.isMDXComponent=!0;const Axn={toc:[]},zxn="wrapper";function Wxn(t){let{components:e,...n}=t;return(0,s.kt)(zxn,(0,p.Z)({},Axn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Wxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Sxn(t){let{components:e,...n}=t;return(0,s.kt)(Rxn,(0,p.Z)({},Ixn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Sxn.isMDXComponent=!0;const Pxn={toc:[]},Exn="wrapper";function Oxn(t){let{components:e,...n}=t;return(0,s.kt)(Exn,(0,p.Z)({},Pxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Oxn.isMDXComponent=!0;const Gxn={toc:[]},Fxn="wrapper";function Bxn(t){let{components:e,...n}=t;return(0,s.kt)(Fxn,(0,p.Z)({},Gxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Bxn.isMDXComponent=!0;const Uxn={toc:[]},Vxn="wrapper";function qxn(t){let{components:e,...n}=t;return(0,s.kt)(Vxn,(0,p.Z)({},Uxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Yxn="wrapper";function Hxn(t){let{components:e,...n}=t;return(0,s.kt)(Yxn,(0,p.Z)({},jxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Hxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Jxn(t){let{components:e,...n}=t;return(0,s.kt)($xn,(0,p.Z)({},Qxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Jxn.isMDXComponent=!0;const Kxn={toc:[]},tvn="wrapper";function evn(t){let{components:e,...n}=t;return(0,s.kt)(tvn,(0,p.Z)({},Kxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}evn.isMDXComponent=!0;const nvn={toc:[]},ovn="wrapper";function pvn(t){let{components:e,...n}=t;return(0,s.kt)(ovn,(0,p.Z)({},nvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pvn.isMDXComponent=!0;const rvn={toc:[]},svn="wrapper";function cvn(t){let{components:e,...n}=t;return(0,s.kt)(svn,(0,p.Z)({},rvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cvn.isMDXComponent=!0;const ivn={toc:[]},avn="wrapper";function lvn(t){let{components:e,...n}=t;return(0,s.kt)(avn,(0,p.Z)({},ivn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lvn.isMDXComponent=!0;const uvn={toc:[]},mvn="wrapper";function dvn(t){let{components:e,...n}=t;return(0,s.kt)(mvn,(0,p.Z)({},uvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dvn.isMDXComponent=!0;const hvn={toc:[]},fvn="wrapper";function kvn(t){let{components:e,...n}=t;return(0,s.kt)(fvn,(0,p.Z)({},hvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}kvn.isMDXComponent=!0;const yvn={toc:[]},Dvn="wrapper";function Mvn(t){let{components:e,...n}=t;return(0,s.kt)(Dvn,(0,p.Z)({},yvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Mvn.isMDXComponent=!0;const Xvn={toc:[]},_vn="wrapper";function wvn(t){let{components:e,...n}=t;return(0,s.kt)(_vn,(0,p.Z)({},Xvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}wvn.isMDXComponent=!0;const Tvn={toc:[]},gvn="wrapper";function Cvn(t){let{components:e,...n}=t;return(0,s.kt)(gvn,(0,p.Z)({},Tvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Cvn.isMDXComponent=!0;const xvn={toc:[]},vvn="wrapper";function Lvn(t){let{components:e,...n}=t;return(0,s.kt)(vvn,(0,p.Z)({},xvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]},bvn="wrapper";function Nvn(t){let{components:e,...n}=t;return(0,s.kt)(bvn,(0,p.Z)({},Zvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Nvn.isMDXComponent=!0;const Avn={toc:[]},zvn="wrapper";function Wvn(t){let{components:e,...n}=t;return(0,s.kt)(zvn,(0,p.Z)({},Avn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Svn(t){let{components:e,...n}=t;return(0,s.kt)(Rvn,(0,p.Z)({},Ivn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Svn.isMDXComponent=!0;const Pvn={toc:[]},Evn="wrapper";function Ovn(t){let{components:e,...n}=t;return(0,s.kt)(Evn,(0,p.Z)({},Pvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ovn.isMDXComponent=!0;const Gvn={toc:[]},Fvn="wrapper";function Bvn(t){let{components:e,...n}=t;return(0,s.kt)(Fvn,(0,p.Z)({},Gvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Bvn.isMDXComponent=!0;const Uvn={toc:[]},Vvn="wrapper";function qvn(t){let{components:e,...n}=t;return(0,s.kt)(Vvn,(0,p.Z)({},Uvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Yvn="wrapper";function Hvn(t){let{components:e,...n}=t;return(0,s.kt)(Yvn,(0,p.Z)({},jvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Hvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Jvn(t){let{components:e,...n}=t;return(0,s.kt)($vn,(0,p.Z)({},Qvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Jvn.isMDXComponent=!0;const Kvn={toc:[]},tLn="wrapper";function eLn(t){let{components:e,...n}=t;return(0,s.kt)(tLn,(0,p.Z)({},Kvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}eLn.isMDXComponent=!0;const nLn={toc:[]},oLn="wrapper";function pLn(t){let{components:e,...n}=t;return(0,s.kt)(oLn,(0,p.Z)({},nLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pLn.isMDXComponent=!0;const rLn={toc:[]},sLn="wrapper";function cLn(t){let{components:e,...n}=t;return(0,s.kt)(sLn,(0,p.Z)({},rLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cLn.isMDXComponent=!0;const iLn={toc:[]},aLn="wrapper";function lLn(t){let{components:e,...n}=t;return(0,s.kt)(aLn,(0,p.Z)({},iLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lLn.isMDXComponent=!0;const uLn={toc:[]},mLn="wrapper";function dLn(t){let{components:e,...n}=t;return(0,s.kt)(mLn,(0,p.Z)({},uLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}dLn.isMDXComponent=!0;const hLn={toc:[]},fLn="wrapper";function kLn(t){let{components:e,...n}=t;return(0,s.kt)(fLn,(0,p.Z)({},hLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}kLn.isMDXComponent=!0;const yLn={toc:[]},DLn="wrapper";function MLn(t){let{components:e,...n}=t;return(0,s.kt)(DLn,(0,p.Z)({},yLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}MLn.isMDXComponent=!0;const XLn={toc:[]},_Ln="wrapper";function wLn(t){let{components:e,...n}=t;return(0,s.kt)(_Ln,(0,p.Z)({},XLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}wLn.isMDXComponent=!0;const TLn={toc:[]},gLn="wrapper";function CLn(t){let{components:e,...n}=t;return(0,s.kt)(gLn,(0,p.Z)({},TLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}CLn.isMDXComponent=!0;const xLn={toc:[]},vLn="wrapper";function LLn(t){let{components:e,...n}=t;return(0,s.kt)(vLn,(0,p.Z)({},xLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LLn.isMDXComponent=!0;const ZLn={toc:[]},bLn="wrapper";function NLn(t){let{components:e,...n}=t;return(0,s.kt)(bLn,(0,p.Z)({},ZLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NLn.isMDXComponent=!0;const ALn={toc:[]},zLn="wrapper";function WLn(t){let{components:e,...n}=t;return(0,s.kt)(zLn,(0,p.Z)({},ALn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function SLn(t){let{components:e,...n}=t;return(0,s.kt)(RLn,(0,p.Z)({},ILn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SLn.isMDXComponent=!0;const PLn={toc:[]},ELn="wrapper";function OLn(t){let{components:e,...n}=t;return(0,s.kt)(ELn,(0,p.Z)({},PLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}OLn.isMDXComponent=!0;const GLn={toc:[]},FLn="wrapper";function BLn(t){let{components:e,...n}=t;return(0,s.kt)(FLn,(0,p.Z)({},GLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}BLn.isMDXComponent=!0;const ULn={toc:[]},VLn="wrapper";function qLn(t){let{components:e,...n}=t;return(0,s.kt)(VLn,(0,p.Z)({},ULn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qLn.isMDXComponent=!0;const jLn={toc:[]},YLn="wrapper";function HLn(t){let{components:e,...n}=t;return(0,s.kt)(YLn,(0,p.Z)({},jLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}HLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function JLn(t){let{components:e,...n}=t;return(0,s.kt)($Ln,(0,p.Z)({},QLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}JLn.isMDXComponent=!0;const KLn={toc:[]},tZn="wrapper";function eZn(t){let{components:e,...n}=t;return(0,s.kt)(tZn,(0,p.Z)({},KLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eZn.isMDXComponent=!0;const nZn={toc:[]},oZn="wrapper";function pZn(t){let{components:e,...n}=t;return(0,s.kt)(oZn,(0,p.Z)({},nZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pZn.isMDXComponent=!0;const rZn={toc:[]},sZn="wrapper";function cZn(t){let{components:e,...n}=t;return(0,s.kt)(sZn,(0,p.Z)({},rZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cZn.isMDXComponent=!0;const iZn={toc:[]},aZn="wrapper";function lZn(t){let{components:e,...n}=t;return(0,s.kt)(aZn,(0,p.Z)({},iZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lZn.isMDXComponent=!0;const uZn={toc:[]},mZn="wrapper";function dZn(t){let{components:e,...n}=t;return(0,s.kt)(mZn,(0,p.Z)({},uZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dZn.isMDXComponent=!0;const hZn={toc:[]},fZn="wrapper";function kZn(t){let{components:e,...n}=t;return(0,s.kt)(fZn,(0,p.Z)({},hZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kZn.isMDXComponent=!0;const yZn={toc:[]},DZn="wrapper";function MZn(t){let{components:e,...n}=t;return(0,s.kt)(DZn,(0,p.Z)({},yZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MZn.isMDXComponent=!0;const XZn={toc:[]},_Zn="wrapper";function wZn(t){let{components:e,...n}=t;return(0,s.kt)(_Zn,(0,p.Z)({},XZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wZn.isMDXComponent=!0;const TZn={toc:[]},gZn="wrapper";function CZn(t){let{components:e,...n}=t;return(0,s.kt)(gZn,(0,p.Z)({},TZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}CZn.isMDXComponent=!0;const xZn={toc:[]},vZn="wrapper";function LZn(t){let{components:e,...n}=t;return(0,s.kt)(vZn,(0,p.Z)({},xZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}LZn.isMDXComponent=!0;const ZZn={toc:[]},bZn="wrapper";function NZn(t){let{components:e,...n}=t;return(0,s.kt)(bZn,(0,p.Z)({},ZZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NZn.isMDXComponent=!0;const AZn={toc:[]},zZn="wrapper";function WZn(t){let{components:e,...n}=t;return(0,s.kt)(zZn,(0,p.Z)({},AZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}WZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function SZn(t){let{components:e,...n}=t;return(0,s.kt)(RZn,(0,p.Z)({},IZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}SZn.isMDXComponent=!0;const PZn={toc:[]},EZn="wrapper";function OZn(t){let{components:e,...n}=t;return(0,s.kt)(EZn,(0,p.Z)({},PZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}OZn.isMDXComponent=!0;const GZn={toc:[]},FZn="wrapper";function BZn(t){let{components:e,...n}=t;return(0,s.kt)(FZn,(0,p.Z)({},GZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}BZn.isMDXComponent=!0;const UZn={toc:[]},VZn="wrapper";function qZn(t){let{components:e,...n}=t;return(0,s.kt)(VZn,(0,p.Z)({},UZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qZn.isMDXComponent=!0;const jZn={toc:[]},YZn="wrapper";function HZn(t){let{components:e,...n}=t;return(0,s.kt)(YZn,(0,p.Z)({},jZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}HZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function JZn(t){let{components:e,...n}=t;return(0,s.kt)($Zn,(0,p.Z)({},QZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}JZn.isMDXComponent=!0;const KZn={toc:[]},tbn="wrapper";function ebn(t){let{components:e,...n}=t;return(0,s.kt)(tbn,(0,p.Z)({},KZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ebn.isMDXComponent=!0;const nbn={toc:[]},obn="wrapper";function pbn(t){let{components:e,...n}=t;return(0,s.kt)(obn,(0,p.Z)({},nbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pbn.isMDXComponent=!0;const rbn={toc:[]},sbn="wrapper";function cbn(t){let{components:e,...n}=t;return(0,s.kt)(sbn,(0,p.Z)({},rbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cbn.isMDXComponent=!0;const ibn={toc:[]},abn="wrapper";function lbn(t){let{components:e,...n}=t;return(0,s.kt)(abn,(0,p.Z)({},ibn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lbn.isMDXComponent=!0;const ubn={toc:[]},mbn="wrapper";function dbn(t){let{components:e,...n}=t;return(0,s.kt)(mbn,(0,p.Z)({},ubn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dbn.isMDXComponent=!0;const hbn={toc:[]},fbn="wrapper";function kbn(t){let{components:e,...n}=t;return(0,s.kt)(fbn,(0,p.Z)({},hbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kbn.isMDXComponent=!0;const ybn={toc:[]},Dbn="wrapper";function Mbn(t){let{components:e,...n}=t;return(0,s.kt)(Dbn,(0,p.Z)({},ybn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mbn.isMDXComponent=!0;const Xbn={toc:[]},_bn="wrapper";function wbn(t){let{components:e,...n}=t;return(0,s.kt)(_bn,(0,p.Z)({},Xbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wbn.isMDXComponent=!0;const Tbn={toc:[]},gbn="wrapper";function Cbn(t){let{components:e,...n}=t;return(0,s.kt)(gbn,(0,p.Z)({},Tbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Cbn.isMDXComponent=!0;const xbn={toc:[]},vbn="wrapper";function Lbn(t){let{components:e,...n}=t;return(0,s.kt)(vbn,(0,p.Z)({},xbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]},bbn="wrapper";function Nbn(t){let{components:e,...n}=t;return(0,s.kt)(bbn,(0,p.Z)({},Zbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Nbn.isMDXComponent=!0;const Abn={toc:[]},zbn="wrapper";function Wbn(t){let{components:e,...n}=t;return(0,s.kt)(zbn,(0,p.Z)({},Abn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Sbn(t){let{components:e,...n}=t;return(0,s.kt)(Rbn,(0,p.Z)({},Ibn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Sbn.isMDXComponent=!0;const Pbn={toc:[]},Ebn="wrapper";function Obn(t){let{components:e,...n}=t;return(0,s.kt)(Ebn,(0,p.Z)({},Pbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Obn.isMDXComponent=!0;const Gbn={toc:[]},Fbn="wrapper";function Bbn(t){let{components:e,...n}=t;return(0,s.kt)(Fbn,(0,p.Z)({},Gbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Bbn.isMDXComponent=!0;const Ubn={toc:[]},Vbn="wrapper";function qbn(t){let{components:e,...n}=t;return(0,s.kt)(Vbn,(0,p.Z)({},Ubn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Ybn="wrapper";function Hbn(t){let{components:e,...n}=t;return(0,s.kt)(Ybn,(0,p.Z)({},jbn,n,{components:e,mdxType:"MDXLayout"}))}Hbn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Jbn(t){let{components:e,...n}=t;return(0,s.kt)($bn,(0,p.Z)({},Qbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jbn.isMDXComponent=!0;const Kbn={toc:[]},tNn="wrapper";function eNn(t){let{components:e,...n}=t;return(0,s.kt)(tNn,(0,p.Z)({},Kbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}eNn.isMDXComponent=!0;const nNn={toc:[]},oNn="wrapper";function pNn(t){let{components:e,...n}=t;return(0,s.kt)(oNn,(0,p.Z)({},nNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pNn.isMDXComponent=!0;const rNn={toc:[]},sNn="wrapper";function cNn(t){let{components:e,...n}=t;return(0,s.kt)(sNn,(0,p.Z)({},rNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cNn.isMDXComponent=!0;const iNn={toc:[]},aNn="wrapper";function lNn(t){let{components:e,...n}=t;return(0,s.kt)(aNn,(0,p.Z)({},iNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lNn.isMDXComponent=!0;const uNn={toc:[]},mNn="wrapper";function dNn(t){let{components:e,...n}=t;return(0,s.kt)(mNn,(0,p.Z)({},uNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dNn.isMDXComponent=!0;const hNn={toc:[]},fNn="wrapper";function kNn(t){let{components:e,...n}=t;return(0,s.kt)(fNn,(0,p.Z)({},hNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}kNn.isMDXComponent=!0;const yNn={toc:[]},DNn="wrapper";function MNn(t){let{components:e,...n}=t;return(0,s.kt)(DNn,(0,p.Z)({},yNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}MNn.isMDXComponent=!0;const XNn={toc:[]},_Nn="wrapper";function wNn(t){let{components:e,...n}=t;return(0,s.kt)(_Nn,(0,p.Z)({},XNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wNn.isMDXComponent=!0;const TNn={toc:[]},gNn="wrapper";function CNn(t){let{components:e,...n}=t;return(0,s.kt)(gNn,(0,p.Z)({},TNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}CNn.isMDXComponent=!0;const xNn={toc:[]},vNn="wrapper";function LNn(t){let{components:e,...n}=t;return(0,s.kt)(vNn,(0,p.Z)({},xNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LNn.isMDXComponent=!0;const ZNn={toc:[]},bNn="wrapper";function NNn(t){let{components:e,...n}=t;return(0,s.kt)(bNn,(0,p.Z)({},ZNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}NNn.isMDXComponent=!0;const ANn={toc:[]},zNn="wrapper";function WNn(t){let{components:e,...n}=t;return(0,s.kt)(zNn,(0,p.Z)({},ANn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}WNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function SNn(t){let{components:e,...n}=t;return(0,s.kt)(RNn,(0,p.Z)({},INn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}SNn.isMDXComponent=!0;const PNn={toc:[]},ENn="wrapper";function ONn(t){let{components:e,...n}=t;return(0,s.kt)(ENn,(0,p.Z)({},PNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ONn.isMDXComponent=!0;const GNn={toc:[]},FNn="wrapper";function BNn(t){let{components:e,...n}=t;return(0,s.kt)(FNn,(0,p.Z)({},GNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}BNn.isMDXComponent=!0;const UNn={toc:[]},VNn="wrapper";function qNn(t){let{components:e,...n}=t;return(0,s.kt)(VNn,(0,p.Z)({},UNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}qNn.isMDXComponent=!0;const jNn={toc:[]},YNn="wrapper";function HNn(t){let{components:e,...n}=t;return(0,s.kt)(YNn,(0,p.Z)({},jNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}HNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function JNn(t){let{components:e,...n}=t;return(0,s.kt)($Nn,(0,p.Z)({},QNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}JNn.isMDXComponent=!0;const KNn={toc:[]},tAn="wrapper";function eAn(t){let{components:e,...n}=t;return(0,s.kt)(tAn,(0,p.Z)({},KNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}eAn.isMDXComponent=!0;const nAn={toc:[]},oAn="wrapper";function pAn(t){let{components:e,...n}=t;return(0,s.kt)(oAn,(0,p.Z)({},nAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}pAn.isMDXComponent=!0;const rAn={toc:[]},sAn="wrapper";function cAn(t){let{components:e,...n}=t;return(0,s.kt)(sAn,(0,p.Z)({},rAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cAn.isMDXComponent=!0;const iAn={toc:[]},aAn="wrapper";function lAn(t){let{components:e,...n}=t;return(0,s.kt)(aAn,(0,p.Z)({},iAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lAn.isMDXComponent=!0;const uAn={toc:[]},mAn="wrapper";function dAn(t){let{components:e,...n}=t;return(0,s.kt)(mAn,(0,p.Z)({},uAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dAn.isMDXComponent=!0;const hAn={toc:[]},fAn="wrapper";function kAn(t){let{components:e,...n}=t;return(0,s.kt)(fAn,(0,p.Z)({},hAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kAn.isMDXComponent=!0;const yAn={toc:[]},DAn="wrapper";function MAn(t){let{components:e,...n}=t;return(0,s.kt)(DAn,(0,p.Z)({},yAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MAn.isMDXComponent=!0;const XAn={toc:[]},_An="wrapper";function wAn(t){let{components:e,...n}=t;return(0,s.kt)(_An,(0,p.Z)({},XAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}wAn.isMDXComponent=!0;const TAn={toc:[]},gAn="wrapper";function CAn(t){let{components:e,...n}=t;return(0,s.kt)(gAn,(0,p.Z)({},TAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CAn.isMDXComponent=!0;const xAn={toc:[]},vAn="wrapper";function LAn(t){let{components:e,...n}=t;return(0,s.kt)(vAn,(0,p.Z)({},xAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LAn.isMDXComponent=!0;const ZAn={toc:[]},bAn="wrapper";function NAn(t){let{components:e,...n}=t;return(0,s.kt)(bAn,(0,p.Z)({},ZAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}NAn.isMDXComponent=!0;const AAn={toc:[]},zAn="wrapper";function WAn(t){let{components:e,...n}=t;return(0,s.kt)(zAn,(0,p.Z)({},AAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}WAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function SAn(t){let{components:e,...n}=t;return(0,s.kt)(RAn,(0,p.Z)({},IAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}SAn.isMDXComponent=!0;const PAn={toc:[]},EAn="wrapper";function OAn(t){let{components:e,...n}=t;return(0,s.kt)(EAn,(0,p.Z)({},PAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}OAn.isMDXComponent=!0;const GAn={toc:[]},FAn="wrapper";function BAn(t){let{components:e,...n}=t;return(0,s.kt)(FAn,(0,p.Z)({},GAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BAn.isMDXComponent=!0;const UAn={toc:[]},VAn="wrapper";function qAn(t){let{components:e,...n}=t;return(0,s.kt)(VAn,(0,p.Z)({},UAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}qAn.isMDXComponent=!0;const jAn={toc:[]},YAn="wrapper";function HAn(t){let{components:e,...n}=t;return(0,s.kt)(YAn,(0,p.Z)({},jAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}HAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function JAn(t){let{components:e,...n}=t;return(0,s.kt)($An,(0,p.Z)({},QAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}JAn.isMDXComponent=!0;const KAn={toc:[]},tzn="wrapper";function ezn(t){let{components:e,...n}=t;return(0,s.kt)(tzn,(0,p.Z)({},KAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ezn.isMDXComponent=!0;const nzn={toc:[]},ozn="wrapper";function pzn(t){let{components:e,...n}=t;return(0,s.kt)(ozn,(0,p.Z)({},nzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pzn.isMDXComponent=!0;const rzn={toc:[]},szn="wrapper";function czn(t){let{components:e,...n}=t;return(0,s.kt)(szn,(0,p.Z)({},rzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}czn.isMDXComponent=!0;const izn={toc:[]},azn="wrapper";function lzn(t){let{components:e,...n}=t;return(0,s.kt)(azn,(0,p.Z)({},izn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}lzn.isMDXComponent=!0;const uzn={toc:[]},mzn="wrapper";function dzn(t){let{components:e,...n}=t;return(0,s.kt)(mzn,(0,p.Z)({},uzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dzn.isMDXComponent=!0;const hzn={toc:[]},fzn="wrapper";function kzn(t){let{components:e,...n}=t;return(0,s.kt)(fzn,(0,p.Z)({},hzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}kzn.isMDXComponent=!0;const yzn={toc:[]},Dzn="wrapper";function Mzn(t){let{components:e,...n}=t;return(0,s.kt)(Dzn,(0,p.Z)({},yzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Mzn.isMDXComponent=!0;const Xzn={toc:[]},_zn="wrapper";function wzn(t){let{components:e,...n}=t;return(0,s.kt)(_zn,(0,p.Z)({},Xzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}wzn.isMDXComponent=!0;const Tzn={toc:[]},gzn="wrapper";function Czn(t){let{components:e,...n}=t;return(0,s.kt)(gzn,(0,p.Z)({},Tzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Czn.isMDXComponent=!0;const xzn={toc:[]},vzn="wrapper";function Lzn(t){let{components:e,...n}=t;return(0,s.kt)(vzn,(0,p.Z)({},xzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]},bzn="wrapper";function Nzn(t){let{components:e,...n}=t;return(0,s.kt)(bzn,(0,p.Z)({},Zzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Nzn.isMDXComponent=!0;const Azn={toc:[]},zzn="wrapper";function Wzn(t){let{components:e,...n}=t;return(0,s.kt)(zzn,(0,p.Z)({},Azn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Szn(t){let{components:e,...n}=t;return(0,s.kt)(Rzn,(0,p.Z)({},Izn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Szn.isMDXComponent=!0;const Pzn={toc:[]},Ezn="wrapper";function Ozn(t){let{components:e,...n}=t;return(0,s.kt)(Ezn,(0,p.Z)({},Pzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ozn.isMDXComponent=!0;const Gzn={toc:[]},Fzn="wrapper";function Bzn(t){let{components:e,...n}=t;return(0,s.kt)(Fzn,(0,p.Z)({},Gzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Bzn.isMDXComponent=!0;const Uzn={toc:[]},Vzn="wrapper";function qzn(t){let{components:e,...n}=t;return(0,s.kt)(Vzn,(0,p.Z)({},Uzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Yzn="wrapper";function Hzn(t){let{components:e,...n}=t;return(0,s.kt)(Yzn,(0,p.Z)({},jzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Hzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Jzn(t){let{components:e,...n}=t;return(0,s.kt)($zn,(0,p.Z)({},Qzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Jzn.isMDXComponent=!0;const Kzn={toc:[]},tWn="wrapper";function eWn(t){let{components:e,...n}=t;return(0,s.kt)(tWn,(0,p.Z)({},Kzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}eWn.isMDXComponent=!0;const nWn={toc:[]},oWn="wrapper";function pWn(t){let{components:e,...n}=t;return(0,s.kt)(oWn,(0,p.Z)({},nWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pWn.isMDXComponent=!0;const rWn={toc:[]},sWn="wrapper";function cWn(t){let{components:e,...n}=t;return(0,s.kt)(sWn,(0,p.Z)({},rWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cWn.isMDXComponent=!0;const iWn={toc:[]},aWn="wrapper";function lWn(t){let{components:e,...n}=t;return(0,s.kt)(aWn,(0,p.Z)({},iWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lWn.isMDXComponent=!0;const uWn={toc:[]},mWn="wrapper";function dWn(t){let{components:e,...n}=t;return(0,s.kt)(mWn,(0,p.Z)({},uWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dWn.isMDXComponent=!0;const hWn={toc:[]},fWn="wrapper";function kWn(t){let{components:e,...n}=t;return(0,s.kt)(fWn,(0,p.Z)({},hWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kWn.isMDXComponent=!0;const yWn={toc:[]},DWn="wrapper";function MWn(t){let{components:e,...n}=t;return(0,s.kt)(DWn,(0,p.Z)({},yWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}MWn.isMDXComponent=!0;const XWn={toc:[]},_Wn="wrapper";function wWn(t){let{components:e,...n}=t;return(0,s.kt)(_Wn,(0,p.Z)({},XWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wWn.isMDXComponent=!0;const TWn={toc:[]},gWn="wrapper";function CWn(t){let{components:e,...n}=t;return(0,s.kt)(gWn,(0,p.Z)({},TWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}CWn.isMDXComponent=!0;const xWn={toc:[]},vWn="wrapper";function LWn(t){let{components:e,...n}=t;return(0,s.kt)(vWn,(0,p.Z)({},xWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LWn.isMDXComponent=!0;const ZWn={toc:[]},bWn="wrapper";function NWn(t){let{components:e,...n}=t;return(0,s.kt)(bWn,(0,p.Z)({},ZWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}NWn.isMDXComponent=!0;const AWn={toc:[]},zWn="wrapper";function WWn(t){let{components:e,...n}=t;return(0,s.kt)(zWn,(0,p.Z)({},AWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}WWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function SWn(t){let{components:e,...n}=t;return(0,s.kt)(RWn,(0,p.Z)({},IWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}SWn.isMDXComponent=!0;const PWn={toc:[]},EWn="wrapper";function OWn(t){let{components:e,...n}=t;return(0,s.kt)(EWn,(0,p.Z)({},PWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}OWn.isMDXComponent=!0;const GWn={toc:[]},FWn="wrapper";function BWn(t){let{components:e,...n}=t;return(0,s.kt)(FWn,(0,p.Z)({},GWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}BWn.isMDXComponent=!0;const UWn={toc:[]},VWn="wrapper";function qWn(t){let{components:e,...n}=t;return(0,s.kt)(VWn,(0,p.Z)({},UWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qWn.isMDXComponent=!0;const jWn={toc:[]},YWn="wrapper";function HWn(t){let{components:e,...n}=t;return(0,s.kt)(YWn,(0,p.Z)({},jWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}HWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function JWn(t){let{components:e,...n}=t;return(0,s.kt)($Wn,(0,p.Z)({},QWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}JWn.isMDXComponent=!0;const KWn={toc:[]},tIn="wrapper";function eIn(t){let{components:e,...n}=t;return(0,s.kt)(tIn,(0,p.Z)({},KWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eIn.isMDXComponent=!0;const nIn={toc:[]},oIn="wrapper";function pIn(t){let{components:e,...n}=t;return(0,s.kt)(oIn,(0,p.Z)({},nIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pIn.isMDXComponent=!0;const rIn={toc:[]},sIn="wrapper";function cIn(t){let{components:e,...n}=t;return(0,s.kt)(sIn,(0,p.Z)({},rIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cIn.isMDXComponent=!0;const iIn={toc:[]},aIn="wrapper";function lIn(t){let{components:e,...n}=t;return(0,s.kt)(aIn,(0,p.Z)({},iIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}lIn.isMDXComponent=!0;const uIn={toc:[]},mIn="wrapper";function dIn(t){let{components:e,...n}=t;return(0,s.kt)(mIn,(0,p.Z)({},uIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dIn.isMDXComponent=!0;const hIn={toc:[]},fIn="wrapper";function kIn(t){let{components:e,...n}=t;return(0,s.kt)(fIn,(0,p.Z)({},hIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kIn.isMDXComponent=!0;const yIn={toc:[]},DIn="wrapper";function MIn(t){let{components:e,...n}=t;return(0,s.kt)(DIn,(0,p.Z)({},yIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}MIn.isMDXComponent=!0;const XIn={toc:[]},_In="wrapper";function wIn(t){let{components:e,...n}=t;return(0,s.kt)(_In,(0,p.Z)({},XIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wIn.isMDXComponent=!0;const TIn={toc:[]},gIn="wrapper";function CIn(t){let{components:e,...n}=t;return(0,s.kt)(gIn,(0,p.Z)({},TIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}CIn.isMDXComponent=!0;const xIn={toc:[]},vIn="wrapper";function LIn(t){let{components:e,...n}=t;return(0,s.kt)(vIn,(0,p.Z)({},xIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}LIn.isMDXComponent=!0;const ZIn={toc:[]},bIn="wrapper";function NIn(t){let{components:e,...n}=t;return(0,s.kt)(bIn,(0,p.Z)({},ZIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NIn.isMDXComponent=!0;const AIn={toc:[]},zIn="wrapper";function WIn(t){let{components:e,...n}=t;return(0,s.kt)(zIn,(0,p.Z)({},AIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}WIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function SIn(t){let{components:e,...n}=t;return(0,s.kt)(RIn,(0,p.Z)({},IIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}SIn.isMDXComponent=!0;const PIn={toc:[]},EIn="wrapper";function OIn(t){let{components:e,...n}=t;return(0,s.kt)(EIn,(0,p.Z)({},PIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}OIn.isMDXComponent=!0;const GIn={toc:[]},FIn="wrapper";function BIn(t){let{components:e,...n}=t;return(0,s.kt)(FIn,(0,p.Z)({},GIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}BIn.isMDXComponent=!0;const UIn={toc:[]},VIn="wrapper";function qIn(t){let{components:e,...n}=t;return(0,s.kt)(VIn,(0,p.Z)({},UIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qIn.isMDXComponent=!0;const jIn={toc:[]},YIn="wrapper";function HIn(t){let{components:e,...n}=t;return(0,s.kt)(YIn,(0,p.Z)({},jIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}HIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function JIn(t){let{components:e,...n}=t;return(0,s.kt)($In,(0,p.Z)({},QIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}JIn.isMDXComponent=!0;const KIn={toc:[]},tRn="wrapper";function eRn(t){let{components:e,...n}=t;return(0,s.kt)(tRn,(0,p.Z)({},KIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}eRn.isMDXComponent=!0;const nRn={toc:[]},oRn="wrapper";function pRn(t){let{components:e,...n}=t;return(0,s.kt)(oRn,(0,p.Z)({},nRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pRn.isMDXComponent=!0;const rRn={toc:[]},sRn="wrapper";function cRn(t){let{components:e,...n}=t;return(0,s.kt)(sRn,(0,p.Z)({},rRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cRn.isMDXComponent=!0;const iRn={toc:[]},aRn="wrapper";function lRn(t){let{components:e,...n}=t;return(0,s.kt)(aRn,(0,p.Z)({},iRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lRn.isMDXComponent=!0;const uRn={toc:[]},mRn="wrapper";function dRn(t){let{components:e,...n}=t;return(0,s.kt)(mRn,(0,p.Z)({},uRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dRn.isMDXComponent=!0;const hRn={toc:[]},fRn="wrapper";function kRn(t){let{components:e,...n}=t;return(0,s.kt)(fRn,(0,p.Z)({},hRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kRn.isMDXComponent=!0;const yRn={toc:[]},DRn="wrapper";function MRn(t){let{components:e,...n}=t;return(0,s.kt)(DRn,(0,p.Z)({},yRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}MRn.isMDXComponent=!0;const XRn={toc:[]},_Rn="wrapper";function wRn(t){let{components:e,...n}=t;return(0,s.kt)(_Rn,(0,p.Z)({},XRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wRn.isMDXComponent=!0;const TRn={toc:[]},gRn="wrapper";function CRn(t){let{components:e,...n}=t;return(0,s.kt)(gRn,(0,p.Z)({},TRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CRn.isMDXComponent=!0;const xRn={toc:[]},vRn="wrapper";function LRn(t){let{components:e,...n}=t;return(0,s.kt)(vRn,(0,p.Z)({},xRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LRn.isMDXComponent=!0;const ZRn={toc:[]},bRn="wrapper";function NRn(t){let{components:e,...n}=t;return(0,s.kt)(bRn,(0,p.Z)({},ZRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NRn.isMDXComponent=!0;const ARn={toc:[]},zRn="wrapper";function WRn(t){let{components:e,...n}=t;return(0,s.kt)(zRn,(0,p.Z)({},ARn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}WRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function SRn(t){let{components:e,...n}=t;return(0,s.kt)(RRn,(0,p.Z)({},IRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}SRn.isMDXComponent=!0;const PRn={toc:[]},ERn="wrapper";function ORn(t){let{components:e,...n}=t;return(0,s.kt)(ERn,(0,p.Z)({},PRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ORn.isMDXComponent=!0;const GRn={toc:[]},FRn="wrapper";function BRn(t){let{components:e,...n}=t;return(0,s.kt)(FRn,(0,p.Z)({},GRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}BRn.isMDXComponent=!0;const URn={toc:[]},VRn="wrapper";function qRn(t){let{components:e,...n}=t;return(0,s.kt)(VRn,(0,p.Z)({},URn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qRn.isMDXComponent=!0;const jRn={toc:[]},YRn="wrapper";function HRn(t){let{components:e,...n}=t;return(0,s.kt)(YRn,(0,p.Z)({},jRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}HRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function JRn(t){let{components:e,...n}=t;return(0,s.kt)($Rn,(0,p.Z)({},QRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}JRn.isMDXComponent=!0;const KRn={toc:[]},tSn="wrapper";function eSn(t){let{components:e,...n}=t;return(0,s.kt)(tSn,(0,p.Z)({},KRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}eSn.isMDXComponent=!0;const nSn={toc:[]},oSn="wrapper";function pSn(t){let{components:e,...n}=t;return(0,s.kt)(oSn,(0,p.Z)({},nSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pSn.isMDXComponent=!0;const rSn={toc:[]},sSn="wrapper";function cSn(t){let{components:e,...n}=t;return(0,s.kt)(sSn,(0,p.Z)({},rSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}cSn.isMDXComponent=!0;const iSn={toc:[]},aSn="wrapper";function lSn(t){let{components:e,...n}=t;return(0,s.kt)(aSn,(0,p.Z)({},iSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lSn.isMDXComponent=!0;const uSn={toc:[]},mSn="wrapper";function dSn(t){let{components:e,...n}=t;return(0,s.kt)(mSn,(0,p.Z)({},uSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}dSn.isMDXComponent=!0;const hSn={toc:[]},fSn="wrapper";function kSn(t){let{components:e,...n}=t;return(0,s.kt)(fSn,(0,p.Z)({},hSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kSn.isMDXComponent=!0;const ySn={toc:[]},DSn="wrapper";function MSn(t){let{components:e,...n}=t;return(0,s.kt)(DSn,(0,p.Z)({},ySn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}MSn.isMDXComponent=!0;const XSn={toc:[]},_Sn="wrapper";function wSn(t){let{components:e,...n}=t;return(0,s.kt)(_Sn,(0,p.Z)({},XSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}wSn.isMDXComponent=!0;const TSn={toc:[]},gSn="wrapper";function CSn(t){let{components:e,...n}=t;return(0,s.kt)(gSn,(0,p.Z)({},TSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}CSn.isMDXComponent=!0;const xSn={toc:[]},vSn="wrapper";function LSn(t){let{components:e,...n}=t;return(0,s.kt)(vSn,(0,p.Z)({},xSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}LSn.isMDXComponent=!0;const ZSn={toc:[]},bSn="wrapper";function NSn(t){let{components:e,...n}=t;return(0,s.kt)(bSn,(0,p.Z)({},ZSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NSn.isMDXComponent=!0;const ASn={toc:[]},zSn="wrapper";function WSn(t){let{components:e,...n}=t;return(0,s.kt)(zSn,(0,p.Z)({},ASn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}WSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function SSn(t){let{components:e,...n}=t;return(0,s.kt)(RSn,(0,p.Z)({},ISn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}SSn.isMDXComponent=!0;const PSn={toc:[]},ESn="wrapper";function OSn(t){let{components:e,...n}=t;return(0,s.kt)(ESn,(0,p.Z)({},PSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OSn.isMDXComponent=!0;const GSn={toc:[]},FSn="wrapper";function BSn(t){let{components:e,...n}=t;return(0,s.kt)(FSn,(0,p.Z)({},GSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}BSn.isMDXComponent=!0;const USn={toc:[]},VSn="wrapper";function qSn(t){let{components:e,...n}=t;return(0,s.kt)(VSn,(0,p.Z)({},USn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qSn.isMDXComponent=!0;const jSn={toc:[]},YSn="wrapper";function HSn(t){let{components:e,...n}=t;return(0,s.kt)(YSn,(0,p.Z)({},jSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}HSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function JSn(t){let{components:e,...n}=t;return(0,s.kt)($Sn,(0,p.Z)({},QSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}JSn.isMDXComponent=!0;const KSn={toc:[]},tPn="wrapper";function ePn(t){let{components:e,...n}=t;return(0,s.kt)(tPn,(0,p.Z)({},KSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ePn.isMDXComponent=!0;const nPn={toc:[]},oPn="wrapper";function pPn(t){let{components:e,...n}=t;return(0,s.kt)(oPn,(0,p.Z)({},nPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pPn.isMDXComponent=!0;const rPn={toc:[]},sPn="wrapper";function cPn(t){let{components:e,...n}=t;return(0,s.kt)(sPn,(0,p.Z)({},rPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cPn.isMDXComponent=!0;const iPn={toc:[]},aPn="wrapper";function lPn(t){let{components:e,...n}=t;return(0,s.kt)(aPn,(0,p.Z)({},iPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lPn.isMDXComponent=!0;const uPn={toc:[]},mPn="wrapper";function dPn(t){let{components:e,...n}=t;return(0,s.kt)(mPn,(0,p.Z)({},uPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dPn.isMDXComponent=!0;const hPn={toc:[]},fPn="wrapper";function kPn(t){let{components:e,...n}=t;return(0,s.kt)(fPn,(0,p.Z)({},hPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kPn.isMDXComponent=!0;const yPn={toc:[]},DPn="wrapper";function MPn(t){let{components:e,...n}=t;return(0,s.kt)(DPn,(0,p.Z)({},yPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MPn.isMDXComponent=!0;const XPn={toc:[]},_Pn="wrapper";function wPn(t){let{components:e,...n}=t;return(0,s.kt)(_Pn,(0,p.Z)({},XPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wPn.isMDXComponent=!0;const TPn={toc:[]},gPn="wrapper";function CPn(t){let{components:e,...n}=t;return(0,s.kt)(gPn,(0,p.Z)({},TPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}CPn.isMDXComponent=!0;const xPn={toc:[]},vPn="wrapper";function LPn(t){let{components:e,...n}=t;return(0,s.kt)(vPn,(0,p.Z)({},xPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LPn.isMDXComponent=!0;const ZPn={toc:[]},bPn="wrapper";function NPn(t){let{components:e,...n}=t;return(0,s.kt)(bPn,(0,p.Z)({},ZPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}NPn.isMDXComponent=!0;const APn={toc:[]},zPn="wrapper";function WPn(t){let{components:e,...n}=t;return(0,s.kt)(zPn,(0,p.Z)({},APn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function SPn(t){let{components:e,...n}=t;return(0,s.kt)(RPn,(0,p.Z)({},IPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}SPn.isMDXComponent=!0;const PPn={toc:[]},EPn="wrapper";function OPn(t){let{components:e,...n}=t;return(0,s.kt)(EPn,(0,p.Z)({},PPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}OPn.isMDXComponent=!0;const GPn={toc:[]},FPn="wrapper";function BPn(t){let{components:e,...n}=t;return(0,s.kt)(FPn,(0,p.Z)({},GPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BPn.isMDXComponent=!0;const UPn={toc:[]},VPn="wrapper";function qPn(t){let{components:e,...n}=t;return(0,s.kt)(VPn,(0,p.Z)({},UPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qPn.isMDXComponent=!0;const jPn={toc:[]},YPn="wrapper";function HPn(t){let{components:e,...n}=t;return(0,s.kt)(YPn,(0,p.Z)({},jPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}HPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function JPn(t){let{components:e,...n}=t;return(0,s.kt)($Pn,(0,p.Z)({},QPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}JPn.isMDXComponent=!0;const KPn={toc:[]},tEn="wrapper";function eEn(t){let{components:e,...n}=t;return(0,s.kt)(tEn,(0,p.Z)({},KPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eEn.isMDXComponent=!0;const nEn={toc:[]},oEn="wrapper";function pEn(t){let{components:e,...n}=t;return(0,s.kt)(oEn,(0,p.Z)({},nEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pEn.isMDXComponent=!0;const rEn={toc:[]},sEn="wrapper";function cEn(t){let{components:e,...n}=t;return(0,s.kt)(sEn,(0,p.Z)({},rEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cEn.isMDXComponent=!0;const iEn={toc:[]},aEn="wrapper";function lEn(t){let{components:e,...n}=t;return(0,s.kt)(aEn,(0,p.Z)({},iEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lEn.isMDXComponent=!0;const uEn={toc:[]},mEn="wrapper";function dEn(t){let{components:e,...n}=t;return(0,s.kt)(mEn,(0,p.Z)({},uEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dEn.isMDXComponent=!0;const hEn={toc:[]},fEn="wrapper";function kEn(t){let{components:e,...n}=t;return(0,s.kt)(fEn,(0,p.Z)({},hEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kEn.isMDXComponent=!0;const yEn={toc:[]},DEn="wrapper";function MEn(t){let{components:e,...n}=t;return(0,s.kt)(DEn,(0,p.Z)({},yEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MEn.isMDXComponent=!0;const XEn={toc:[]},_En="wrapper";function wEn(t){let{components:e,...n}=t;return(0,s.kt)(_En,(0,p.Z)({},XEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wEn.isMDXComponent=!0;const TEn={toc:[]},gEn="wrapper";function CEn(t){let{components:e,...n}=t;return(0,s.kt)(gEn,(0,p.Z)({},TEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}CEn.isMDXComponent=!0;const xEn={toc:[]},vEn="wrapper";function LEn(t){let{components:e,...n}=t;return(0,s.kt)(vEn,(0,p.Z)({},xEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LEn.isMDXComponent=!0;const ZEn={toc:[]},bEn="wrapper";function NEn(t){let{components:e,...n}=t;return(0,s.kt)(bEn,(0,p.Z)({},ZEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NEn.isMDXComponent=!0;const AEn={toc:[]},zEn="wrapper";function WEn(t){let{components:e,...n}=t;return(0,s.kt)(zEn,(0,p.Z)({},AEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function SEn(t){let{components:e,...n}=t;return(0,s.kt)(REn,(0,p.Z)({},IEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SEn.isMDXComponent=!0;const PEn={toc:[]},EEn="wrapper";function OEn(t){let{components:e,...n}=t;return(0,s.kt)(EEn,(0,p.Z)({},PEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OEn.isMDXComponent=!0;const GEn={toc:[]},FEn="wrapper";function BEn(t){let{components:e,...n}=t;return(0,s.kt)(FEn,(0,p.Z)({},GEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}BEn.isMDXComponent=!0;const UEn={toc:[]},VEn="wrapper";function qEn(t){let{components:e,...n}=t;return(0,s.kt)(VEn,(0,p.Z)({},UEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qEn.isMDXComponent=!0;const jEn={toc:[]},YEn="wrapper";function HEn(t){let{components:e,...n}=t;return(0,s.kt)(YEn,(0,p.Z)({},jEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}HEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function JEn(t){let{components:e,...n}=t;return(0,s.kt)($En,(0,p.Z)({},QEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JEn.isMDXComponent=!0;const KEn={toc:[]},tOn="wrapper";function eOn(t){let{components:e,...n}=t;return(0,s.kt)(tOn,(0,p.Z)({},KEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eOn.isMDXComponent=!0;const nOn={toc:[]},oOn="wrapper";function pOn(t){let{components:e,...n}=t;return(0,s.kt)(oOn,(0,p.Z)({},nOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pOn.isMDXComponent=!0;const rOn={toc:[]},sOn="wrapper";function cOn(t){let{components:e,...n}=t;return(0,s.kt)(sOn,(0,p.Z)({},rOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cOn.isMDXComponent=!0;const iOn={toc:[]},aOn="wrapper";function lOn(t){let{components:e,...n}=t;return(0,s.kt)(aOn,(0,p.Z)({},iOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lOn.isMDXComponent=!0;const uOn={toc:[]},mOn="wrapper";function dOn(t){let{components:e,...n}=t;return(0,s.kt)(mOn,(0,p.Z)({},uOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dOn.isMDXComponent=!0;const hOn={toc:[]},fOn="wrapper";function kOn(t){let{components:e,...n}=t;return(0,s.kt)(fOn,(0,p.Z)({},hOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kOn.isMDXComponent=!0;const yOn={toc:[]},DOn="wrapper";function MOn(t){let{components:e,...n}=t;return(0,s.kt)(DOn,(0,p.Z)({},yOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MOn.isMDXComponent=!0;const XOn={toc:[]},_On="wrapper";function wOn(t){let{components:e,...n}=t;return(0,s.kt)(_On,(0,p.Z)({},XOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wOn.isMDXComponent=!0;const TOn={toc:[]},gOn="wrapper";function COn(t){let{components:e,...n}=t;return(0,s.kt)(gOn,(0,p.Z)({},TOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}COn.isMDXComponent=!0;const xOn={toc:[]},vOn="wrapper";function LOn(t){let{components:e,...n}=t;return(0,s.kt)(vOn,(0,p.Z)({},xOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}LOn.isMDXComponent=!0;const ZOn={toc:[]},bOn="wrapper";function NOn(t){let{components:e,...n}=t;return(0,s.kt)(bOn,(0,p.Z)({},ZOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}NOn.isMDXComponent=!0;const AOn={toc:[]},zOn="wrapper";function WOn(t){let{components:e,...n}=t;return(0,s.kt)(zOn,(0,p.Z)({},AOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WOn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function SOn(t){let{components:e,...n}=t;return(0,s.kt)(ROn,(0,p.Z)({},IOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}SOn.isMDXComponent=!0;const POn={toc:[]},EOn="wrapper";function OOn(t){let{components:e,...n}=t;return(0,s.kt)(EOn,(0,p.Z)({},POn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}OOn.isMDXComponent=!0;const GOn={toc:[]},FOn="wrapper";function BOn(t){let{components:e,...n}=t;return(0,s.kt)(FOn,(0,p.Z)({},GOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}BOn.isMDXComponent=!0;const UOn={toc:[]},VOn="wrapper";function qOn(t){let{components:e,...n}=t;return(0,s.kt)(VOn,(0,p.Z)({},UOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qOn.isMDXComponent=!0;const jOn={toc:[]},YOn="wrapper";function HOn(t){let{components:e,...n}=t;return(0,s.kt)(YOn,(0,p.Z)({},jOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function JOn(t){let{components:e,...n}=t;return(0,s.kt)($On,(0,p.Z)({},QOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}JOn.isMDXComponent=!0;const KOn={toc:[]},tGn="wrapper";function eGn(t){let{components:e,...n}=t;return(0,s.kt)(tGn,(0,p.Z)({},KOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}eGn.isMDXComponent=!0;const nGn={toc:[]},oGn="wrapper";function pGn(t){let{components:e,...n}=t;return(0,s.kt)(oGn,(0,p.Z)({},nGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pGn.isMDXComponent=!0;const rGn={toc:[]},sGn="wrapper";function cGn(t){let{components:e,...n}=t;return(0,s.kt)(sGn,(0,p.Z)({},rGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}cGn.isMDXComponent=!0;const iGn={toc:[]},aGn="wrapper";function lGn(t){let{components:e,...n}=t;return(0,s.kt)(aGn,(0,p.Z)({},iGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lGn.isMDXComponent=!0;const uGn={toc:[]},mGn="wrapper";function dGn(t){let{components:e,...n}=t;return(0,s.kt)(mGn,(0,p.Z)({},uGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}dGn.isMDXComponent=!0;const hGn={toc:[]},fGn="wrapper";function kGn(t){let{components:e,...n}=t;return(0,s.kt)(fGn,(0,p.Z)({},hGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kGn.isMDXComponent=!0;const yGn={toc:[]},DGn="wrapper";function MGn(t){let{components:e,...n}=t;return(0,s.kt)(DGn,(0,p.Z)({},yGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}MGn.isMDXComponent=!0;const XGn={toc:[]},_Gn="wrapper";function wGn(t){let{components:e,...n}=t;return(0,s.kt)(_Gn,(0,p.Z)({},XGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wGn.isMDXComponent=!0;const TGn={toc:[]},gGn="wrapper";function CGn(t){let{components:e,...n}=t;return(0,s.kt)(gGn,(0,p.Z)({},TGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}CGn.isMDXComponent=!0;const xGn={toc:[]},vGn="wrapper";function LGn(t){let{components:e,...n}=t;return(0,s.kt)(vGn,(0,p.Z)({},xGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LGn.isMDXComponent=!0;const ZGn={toc:[]},bGn="wrapper";function NGn(t){let{components:e,...n}=t;return(0,s.kt)(bGn,(0,p.Z)({},ZGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}NGn.isMDXComponent=!0;const AGn={toc:[]},zGn="wrapper";function WGn(t){let{components:e,...n}=t;return(0,s.kt)(zGn,(0,p.Z)({},AGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}WGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function SGn(t){let{components:e,...n}=t;return(0,s.kt)(RGn,(0,p.Z)({},IGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}SGn.isMDXComponent=!0;const PGn={toc:[]},EGn="wrapper";function OGn(t){let{components:e,...n}=t;return(0,s.kt)(EGn,(0,p.Z)({},PGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}OGn.isMDXComponent=!0;const GGn={toc:[]},FGn="wrapper";function BGn(t){let{components:e,...n}=t;return(0,s.kt)(FGn,(0,p.Z)({},GGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BGn.isMDXComponent=!0;const UGn={toc:[]},VGn="wrapper";function qGn(t){let{components:e,...n}=t;return(0,s.kt)(VGn,(0,p.Z)({},UGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qGn.isMDXComponent=!0;const jGn={toc:[]},YGn="wrapper";function HGn(t){let{components:e,...n}=t;return(0,s.kt)(YGn,(0,p.Z)({},jGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}HGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function JGn(t){let{components:e,...n}=t;return(0,s.kt)($Gn,(0,p.Z)({},QGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}JGn.isMDXComponent=!0;const KGn={toc:[]},tFn="wrapper";function eFn(t){let{components:e,...n}=t;return(0,s.kt)(tFn,(0,p.Z)({},KGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}eFn.isMDXComponent=!0;const nFn={toc:[]},oFn="wrapper";function pFn(t){let{components:e,...n}=t;return(0,s.kt)(oFn,(0,p.Z)({},nFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pFn.isMDXComponent=!0;const rFn={toc:[]},sFn="wrapper";function cFn(t){let{components:e,...n}=t;return(0,s.kt)(sFn,(0,p.Z)({},rFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cFn.isMDXComponent=!0;const iFn={toc:[]},aFn="wrapper";function lFn(t){let{components:e,...n}=t;return(0,s.kt)(aFn,(0,p.Z)({},iFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lFn.isMDXComponent=!0;const uFn={toc:[]},mFn="wrapper";function dFn(t){let{components:e,...n}=t;return(0,s.kt)(mFn,(0,p.Z)({},uFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}dFn.isMDXComponent=!0;const hFn={toc:[]},fFn="wrapper";function kFn(t){let{components:e,...n}=t;return(0,s.kt)(fFn,(0,p.Z)({},hFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}kFn.isMDXComponent=!0;const yFn={toc:[]},DFn="wrapper";function MFn(t){let{components:e,...n}=t;return(0,s.kt)(DFn,(0,p.Z)({},yFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MFn.isMDXComponent=!0;const XFn={toc:[]},_Fn="wrapper";function wFn(t){let{components:e,...n}=t;return(0,s.kt)(_Fn,(0,p.Z)({},XFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wFn.isMDXComponent=!0;const TFn={toc:[]},gFn="wrapper";function CFn(t){let{components:e,...n}=t;return(0,s.kt)(gFn,(0,p.Z)({},TFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}CFn.isMDXComponent=!0;const xFn={toc:[]},vFn="wrapper";function LFn(t){let{components:e,...n}=t;return(0,s.kt)(vFn,(0,p.Z)({},xFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LFn.isMDXComponent=!0;const ZFn={toc:[]},bFn="wrapper";function NFn(t){let{components:e,...n}=t;return(0,s.kt)(bFn,(0,p.Z)({},ZFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NFn.isMDXComponent=!0;const AFn={toc:[]},zFn="wrapper";function WFn(t){let{components:e,...n}=t;return(0,s.kt)(zFn,(0,p.Z)({},AFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function SFn(t){let{components:e,...n}=t;return(0,s.kt)(RFn,(0,p.Z)({},IFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SFn.isMDXComponent=!0;const PFn={toc:[]},EFn="wrapper";function OFn(t){let{components:e,...n}=t;return(0,s.kt)(EFn,(0,p.Z)({},PFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OFn.isMDXComponent=!0;const GFn={toc:[]},FFn="wrapper";function BFn(t){let{components:e,...n}=t;return(0,s.kt)(FFn,(0,p.Z)({},GFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BFn.isMDXComponent=!0;const UFn={toc:[]},VFn="wrapper";function qFn(t){let{components:e,...n}=t;return(0,s.kt)(VFn,(0,p.Z)({},UFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qFn.isMDXComponent=!0;const jFn={toc:[]},YFn="wrapper";function HFn(t){let{components:e,...n}=t;return(0,s.kt)(YFn,(0,p.Z)({},jFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}HFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function JFn(t){let{components:e,...n}=t;return(0,s.kt)($Fn,(0,p.Z)({},QFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}JFn.isMDXComponent=!0;const KFn={toc:[]},tBn="wrapper";function eBn(t){let{components:e,...n}=t;return(0,s.kt)(tBn,(0,p.Z)({},KFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}eBn.isMDXComponent=!0;const nBn={toc:[]},oBn="wrapper";function pBn(t){let{components:e,...n}=t;return(0,s.kt)(oBn,(0,p.Z)({},nBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}pBn.isMDXComponent=!0;const rBn={toc:[]},sBn="wrapper";function cBn(t){let{components:e,...n}=t;return(0,s.kt)(sBn,(0,p.Z)({},rBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cBn.isMDXComponent=!0;const iBn={toc:[]},aBn="wrapper";function lBn(t){let{components:e,...n}=t;return(0,s.kt)(aBn,(0,p.Z)({},iBn,n,{components:e,mdxType:"MDXLayout"}))}lBn.isMDXComponent=!0;const uBn={toc:[]},mBn="wrapper";function dBn(t){let{components:e,...n}=t;return(0,s.kt)(mBn,(0,p.Z)({},uBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dBn.isMDXComponent=!0;const hBn={toc:[]},fBn="wrapper";function kBn(t){let{components:e,...n}=t;return(0,s.kt)(fBn,(0,p.Z)({},hBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kBn.isMDXComponent=!0;const yBn={toc:[]},DBn="wrapper";function MBn(t){let{components:e,...n}=t;return(0,s.kt)(DBn,(0,p.Z)({},yBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MBn.isMDXComponent=!0;const XBn={toc:[]},_Bn="wrapper";function wBn(t){let{components:e,...n}=t;return(0,s.kt)(_Bn,(0,p.Z)({},XBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wBn.isMDXComponent=!0;const TBn={toc:[]},gBn="wrapper";function CBn(t){let{components:e,...n}=t;return(0,s.kt)(gBn,(0,p.Z)({},TBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}CBn.isMDXComponent=!0;const xBn={toc:[]},vBn="wrapper";function LBn(t){let{components:e,...n}=t;return(0,s.kt)(vBn,(0,p.Z)({},xBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LBn.isMDXComponent=!0;const ZBn={toc:[]},bBn="wrapper";function NBn(t){let{components:e,...n}=t;return(0,s.kt)(bBn,(0,p.Z)({},ZBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}NBn.isMDXComponent=!0;const ABn={toc:[]},zBn="wrapper";function WBn(t){let{components:e,...n}=t;return(0,s.kt)(zBn,(0,p.Z)({},ABn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}WBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function SBn(t){let{components:e,...n}=t;return(0,s.kt)(RBn,(0,p.Z)({},IBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}SBn.isMDXComponent=!0;const PBn={toc:[]},EBn="wrapper";function OBn(t){let{components:e,...n}=t;return(0,s.kt)(EBn,(0,p.Z)({},PBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OBn.isMDXComponent=!0;const GBn={toc:[]},FBn="wrapper";function BBn(t){let{components:e,...n}=t;return(0,s.kt)(FBn,(0,p.Z)({},GBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}BBn.isMDXComponent=!0;const UBn={toc:[]},VBn="wrapper";function qBn(t){let{components:e,...n}=t;return(0,s.kt)(VBn,(0,p.Z)({},UBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}qBn.isMDXComponent=!0;const jBn={toc:[]},YBn="wrapper";function HBn(t){let{components:e,...n}=t;return(0,s.kt)(YBn,(0,p.Z)({},jBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}HBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function JBn(t){let{components:e,...n}=t;return(0,s.kt)($Bn,(0,p.Z)({},QBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}JBn.isMDXComponent=!0;const KBn={toc:[]},tUn="wrapper";function eUn(t){let{components:e,...n}=t;return(0,s.kt)(tUn,(0,p.Z)({},KBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}eUn.isMDXComponent=!0;const nUn={toc:[]},oUn="wrapper";function pUn(t){let{components:e,...n}=t;return(0,s.kt)(oUn,(0,p.Z)({},nUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pUn.isMDXComponent=!0;const rUn={toc:[]},sUn="wrapper";function cUn(t){let{components:e,...n}=t;return(0,s.kt)(sUn,(0,p.Z)({},rUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cUn.isMDXComponent=!0;const iUn={toc:[]},aUn="wrapper";function lUn(t){let{components:e,...n}=t;return(0,s.kt)(aUn,(0,p.Z)({},iUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lUn.isMDXComponent=!0;const uUn={toc:[]},mUn="wrapper";function dUn(t){let{components:e,...n}=t;return(0,s.kt)(mUn,(0,p.Z)({},uUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}dUn.isMDXComponent=!0;const hUn={toc:[]},fUn="wrapper";function kUn(t){let{components:e,...n}=t;return(0,s.kt)(fUn,(0,p.Z)({},hUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}kUn.isMDXComponent=!0;const yUn={toc:[]},DUn="wrapper";function MUn(t){let{components:e,...n}=t;return(0,s.kt)(DUn,(0,p.Z)({},yUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}MUn.isMDXComponent=!0;const XUn={toc:[]},_Un="wrapper";function wUn(t){let{components:e,...n}=t;return(0,s.kt)(_Un,(0,p.Z)({},XUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}wUn.isMDXComponent=!0;const TUn={toc:[]},gUn="wrapper";function CUn(t){let{components:e,...n}=t;return(0,s.kt)(gUn,(0,p.Z)({},TUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}CUn.isMDXComponent=!0;const xUn={toc:[]},vUn="wrapper";function LUn(t){let{components:e,...n}=t;return(0,s.kt)(vUn,(0,p.Z)({},xUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}LUn.isMDXComponent=!0;const ZUn={toc:[]},bUn="wrapper";function NUn(t){let{components:e,...n}=t;return(0,s.kt)(bUn,(0,p.Z)({},ZUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NUn.isMDXComponent=!0;const AUn={toc:[]},zUn="wrapper";function WUn(t){let{components:e,...n}=t;return(0,s.kt)(zUn,(0,p.Z)({},AUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}WUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function SUn(t){let{components:e,...n}=t;return(0,s.kt)(RUn,(0,p.Z)({},IUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}SUn.isMDXComponent=!0;const PUn={toc:[]},EUn="wrapper";function OUn(t){let{components:e,...n}=t;return(0,s.kt)(EUn,(0,p.Z)({},PUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}OUn.isMDXComponent=!0;const GUn={toc:[]},FUn="wrapper";function BUn(t){let{components:e,...n}=t;return(0,s.kt)(FUn,(0,p.Z)({},GUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}BUn.isMDXComponent=!0;const UUn={toc:[]},VUn="wrapper";function qUn(t){let{components:e,...n}=t;return(0,s.kt)(VUn,(0,p.Z)({},UUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}qUn.isMDXComponent=!0;const jUn={toc:[]},YUn="wrapper";function HUn(t){let{components:e,...n}=t;return(0,s.kt)(YUn,(0,p.Z)({},jUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}HUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function JUn(t){let{components:e,...n}=t;return(0,s.kt)($Un,(0,p.Z)({},QUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}JUn.isMDXComponent=!0;const KUn={toc:[]},tVn="wrapper";function eVn(t){let{components:e,...n}=t;return(0,s.kt)(tVn,(0,p.Z)({},KUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eVn.isMDXComponent=!0;const nVn={toc:[]},oVn="wrapper";function pVn(t){let{components:e,...n}=t;return(0,s.kt)(oVn,(0,p.Z)({},nVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pVn.isMDXComponent=!0;const rVn={toc:[]},sVn="wrapper";function cVn(t){let{components:e,...n}=t;return(0,s.kt)(sVn,(0,p.Z)({},rVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cVn.isMDXComponent=!0;const iVn={toc:[]},aVn="wrapper";function lVn(t){let{components:e,...n}=t;return(0,s.kt)(aVn,(0,p.Z)({},iVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}lVn.isMDXComponent=!0;const uVn={toc:[]},mVn="wrapper";function dVn(t){let{components:e,...n}=t;return(0,s.kt)(mVn,(0,p.Z)({},uVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dVn.isMDXComponent=!0;const hVn={toc:[]},fVn="wrapper";function kVn(t){let{components:e,...n}=t;return(0,s.kt)(fVn,(0,p.Z)({},hVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kVn.isMDXComponent=!0;const yVn={toc:[]},DVn="wrapper";function MVn(t){let{components:e,...n}=t;return(0,s.kt)(DVn,(0,p.Z)({},yVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MVn.isMDXComponent=!0;const XVn={toc:[]},_Vn="wrapper";function wVn(t){let{components:e,...n}=t;return(0,s.kt)(_Vn,(0,p.Z)({},XVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wVn.isMDXComponent=!0;const TVn={toc:[]},gVn="wrapper";function CVn(t){let{components:e,...n}=t;return(0,s.kt)(gVn,(0,p.Z)({},TVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CVn.isMDXComponent=!0;const xVn={toc:[]},vVn="wrapper";function LVn(t){let{components:e,...n}=t;return(0,s.kt)(vVn,(0,p.Z)({},xVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LVn.isMDXComponent=!0;const ZVn={toc:[]},bVn="wrapper";function NVn(t){let{components:e,...n}=t;return(0,s.kt)(bVn,(0,p.Z)({},ZVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NVn.isMDXComponent=!0;const AVn={toc:[]},zVn="wrapper";function WVn(t){let{components:e,...n}=t;return(0,s.kt)(zVn,(0,p.Z)({},AVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}WVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function SVn(t){let{components:e,...n}=t;return(0,s.kt)(RVn,(0,p.Z)({},IVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}SVn.isMDXComponent=!0;const PVn={toc:[]},EVn="wrapper";function OVn(t){let{components:e,...n}=t;return(0,s.kt)(EVn,(0,p.Z)({},PVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OVn.isMDXComponent=!0;const GVn={toc:[]},FVn="wrapper";function BVn(t){let{components:e,...n}=t;return(0,s.kt)(FVn,(0,p.Z)({},GVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}BVn.isMDXComponent=!0;const UVn={toc:[]},VVn="wrapper";function qVn(t){let{components:e,...n}=t;return(0,s.kt)(VVn,(0,p.Z)({},UVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qVn.isMDXComponent=!0;const jVn={toc:[]},YVn="wrapper";function HVn(t){let{components:e,...n}=t;return(0,s.kt)(YVn,(0,p.Z)({},jVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}HVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function JVn(t){let{components:e,...n}=t;return(0,s.kt)($Vn,(0,p.Z)({},QVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}JVn.isMDXComponent=!0;const KVn={toc:[]},tqn="wrapper";function eqn(t){let{components:e,...n}=t;return(0,s.kt)(tqn,(0,p.Z)({},KVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eqn.isMDXComponent=!0;const nqn={toc:[]},oqn="wrapper";function pqn(t){let{components:e,...n}=t;return(0,s.kt)(oqn,(0,p.Z)({},nqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pqn.isMDXComponent=!0;const rqn={toc:[]},sqn="wrapper";function cqn(t){let{components:e,...n}=t;return(0,s.kt)(sqn,(0,p.Z)({},rqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cqn.isMDXComponent=!0;const iqn={toc:[]},aqn="wrapper";function lqn(t){let{components:e,...n}=t;return(0,s.kt)(aqn,(0,p.Z)({},iqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lqn.isMDXComponent=!0;const uqn={toc:[]},mqn="wrapper";function dqn(t){let{components:e,...n}=t;return(0,s.kt)(mqn,(0,p.Z)({},uqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dqn.isMDXComponent=!0;const hqn={toc:[]},fqn="wrapper";function kqn(t){let{components:e,...n}=t;return(0,s.kt)(fqn,(0,p.Z)({},hqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kqn.isMDXComponent=!0;const yqn={toc:[]},Dqn="wrapper";function Mqn(t){let{components:e,...n}=t;return(0,s.kt)(Dqn,(0,p.Z)({},yqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mqn.isMDXComponent=!0;const Xqn={toc:[]},_qn="wrapper";function wqn(t){let{components:e,...n}=t;return(0,s.kt)(_qn,(0,p.Z)({},Xqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wqn.isMDXComponent=!0;const Tqn={toc:[]},gqn="wrapper";function Cqn(t){let{components:e,...n}=t;return(0,s.kt)(gqn,(0,p.Z)({},Tqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Cqn.isMDXComponent=!0;const xqn={toc:[]},vqn="wrapper";function Lqn(t){let{components:e,...n}=t;return(0,s.kt)(vqn,(0,p.Z)({},xqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lqn.isMDXComponent=!0;const Zqn={toc:[]},bqn="wrapper";function Nqn(t){let{components:e,...n}=t;return(0,s.kt)(bqn,(0,p.Z)({},Zqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nqn.isMDXComponent=!0;const Aqn={toc:[]},zqn="wrapper";function Wqn(t){let{components:e,...n}=t;return(0,s.kt)(zqn,(0,p.Z)({},Aqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Sqn(t){let{components:e,...n}=t;return(0,s.kt)(Rqn,(0,p.Z)({},Iqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Sqn.isMDXComponent=!0;const Pqn={toc:[]},Eqn="wrapper";function Oqn(t){let{components:e,...n}=t;return(0,s.kt)(Eqn,(0,p.Z)({},Pqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Oqn.isMDXComponent=!0;const Gqn={toc:[]},Fqn="wrapper";function Bqn(t){let{components:e,...n}=t;return(0,s.kt)(Fqn,(0,p.Z)({},Gqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Bqn.isMDXComponent=!0;const Uqn={toc:[]},Vqn="wrapper";function qqn(t){let{components:e,...n}=t;return(0,s.kt)(Vqn,(0,p.Z)({},Uqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Yqn="wrapper";function Hqn(t){let{components:e,...n}=t;return(0,s.kt)(Yqn,(0,p.Z)({},jqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Hqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Jqn(t){let{components:e,...n}=t;return(0,s.kt)($qn,(0,p.Z)({},Qqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Jqn.isMDXComponent=!0;const Kqn={toc:[]},tjn="wrapper";function ejn(t){let{components:e,...n}=t;return(0,s.kt)(tjn,(0,p.Z)({},Kqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ejn.isMDXComponent=!0;const njn={toc:[]},ojn="wrapper";function pjn(t){let{components:e,...n}=t;return(0,s.kt)(ojn,(0,p.Z)({},njn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pjn.isMDXComponent=!0;const rjn={toc:[]},sjn="wrapper";function cjn(t){let{components:e,...n}=t;return(0,s.kt)(sjn,(0,p.Z)({},rjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cjn.isMDXComponent=!0;const ijn={toc:[]},ajn="wrapper";function ljn(t){let{components:e,...n}=t;return(0,s.kt)(ajn,(0,p.Z)({},ijn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ljn.isMDXComponent=!0;const ujn={toc:[]},mjn="wrapper";function djn(t){let{components:e,...n}=t;return(0,s.kt)(mjn,(0,p.Z)({},ujn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}djn.isMDXComponent=!0;const hjn={toc:[]},fjn="wrapper";function kjn(t){let{components:e,...n}=t;return(0,s.kt)(fjn,(0,p.Z)({},hjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kjn.isMDXComponent=!0;const yjn={toc:[]},Djn="wrapper";function Mjn(t){let{components:e,...n}=t;return(0,s.kt)(Djn,(0,p.Z)({},yjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Mjn.isMDXComponent=!0;const Xjn={toc:[]},_jn="wrapper";function wjn(t){let{components:e,...n}=t;return(0,s.kt)(_jn,(0,p.Z)({},Xjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wjn.isMDXComponent=!0;const Tjn={toc:[]},gjn="wrapper";function Cjn(t){let{components:e,...n}=t;return(0,s.kt)(gjn,(0,p.Z)({},Tjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Cjn.isMDXComponent=!0;const xjn={toc:[]},vjn="wrapper";function Ljn(t){let{components:e,...n}=t;return(0,s.kt)(vjn,(0,p.Z)({},xjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ljn.isMDXComponent=!0;const Zjn={toc:[]},bjn="wrapper";function Njn(t){let{components:e,...n}=t;return(0,s.kt)(bjn,(0,p.Z)({},Zjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Njn.isMDXComponent=!0;const Ajn={toc:[]},zjn="wrapper";function Wjn(t){let{components:e,...n}=t;return(0,s.kt)(zjn,(0,p.Z)({},Ajn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Sjn(t){let{components:e,...n}=t;return(0,s.kt)(Rjn,(0,p.Z)({},Ijn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Sjn.isMDXComponent=!0;const Pjn={toc:[]},Ejn="wrapper";function Ojn(t){let{components:e,...n}=t;return(0,s.kt)(Ejn,(0,p.Z)({},Pjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ojn.isMDXComponent=!0;const Gjn={toc:[]},Fjn="wrapper";function Bjn(t){let{components:e,...n}=t;return(0,s.kt)(Fjn,(0,p.Z)({},Gjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bjn.isMDXComponent=!0;const Ujn={toc:[]},Vjn="wrapper";function qjn(t){let{components:e,...n}=t;return(0,s.kt)(Vjn,(0,p.Z)({},Ujn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Yjn="wrapper";function Hjn(t){let{components:e,...n}=t;return(0,s.kt)(Yjn,(0,p.Z)({},jjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Hjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Jjn(t){let{components:e,...n}=t;return(0,s.kt)($jn,(0,p.Z)({},Qjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Jjn.isMDXComponent=!0;const Kjn={toc:[]},tYn="wrapper";function eYn(t){let{components:e,...n}=t;return(0,s.kt)(tYn,(0,p.Z)({},Kjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eYn.isMDXComponent=!0;const nYn={toc:[]},oYn="wrapper";function pYn(t){let{components:e,...n}=t;return(0,s.kt)(oYn,(0,p.Z)({},nYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pYn.isMDXComponent=!0;const rYn={toc:[]},sYn="wrapper";function cYn(t){let{components:e,...n}=t;return(0,s.kt)(sYn,(0,p.Z)({},rYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cYn.isMDXComponent=!0;const iYn={toc:[]},aYn="wrapper";function lYn(t){let{components:e,...n}=t;return(0,s.kt)(aYn,(0,p.Z)({},iYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lYn.isMDXComponent=!0;const uYn={toc:[]},mYn="wrapper";function dYn(t){let{components:e,...n}=t;return(0,s.kt)(mYn,(0,p.Z)({},uYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dYn.isMDXComponent=!0;const hYn={toc:[]},fYn="wrapper";function kYn(t){let{components:e,...n}=t;return(0,s.kt)(fYn,(0,p.Z)({},hYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kYn.isMDXComponent=!0;const yYn={toc:[]},DYn="wrapper";function MYn(t){let{components:e,...n}=t;return(0,s.kt)(DYn,(0,p.Z)({},yYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MYn.isMDXComponent=!0;const XYn={toc:[]},_Yn="wrapper";function wYn(t){let{components:e,...n}=t;return(0,s.kt)(_Yn,(0,p.Z)({},XYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wYn.isMDXComponent=!0;const TYn={toc:[]},gYn="wrapper";function CYn(t){let{components:e,...n}=t;return(0,s.kt)(gYn,(0,p.Z)({},TYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CYn.isMDXComponent=!0;const xYn={toc:[]},vYn="wrapper";function LYn(t){let{components:e,...n}=t;return(0,s.kt)(vYn,(0,p.Z)({},xYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LYn.isMDXComponent=!0;const ZYn={toc:[]},bYn="wrapper";function NYn(t){let{components:e,...n}=t;return(0,s.kt)(bYn,(0,p.Z)({},ZYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NYn.isMDXComponent=!0;const AYn={toc:[]},zYn="wrapper";function WYn(t){let{components:e,...n}=t;return(0,s.kt)(zYn,(0,p.Z)({},AYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function SYn(t){let{components:e,...n}=t;return(0,s.kt)(RYn,(0,p.Z)({},IYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SYn.isMDXComponent=!0;const PYn={toc:[]},EYn="wrapper";function OYn(t){let{components:e,...n}=t;return(0,s.kt)(EYn,(0,p.Z)({},PYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}OYn.isMDXComponent=!0;const GYn={toc:[]},FYn="wrapper";function BYn(t){let{components:e,...n}=t;return(0,s.kt)(FYn,(0,p.Z)({},GYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BYn.isMDXComponent=!0;const UYn={toc:[]},VYn="wrapper";function qYn(t){let{components:e,...n}=t;return(0,s.kt)(VYn,(0,p.Z)({},UYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qYn.isMDXComponent=!0;const jYn={toc:[]},YYn="wrapper";function HYn(t){let{components:e,...n}=t;return(0,s.kt)(YYn,(0,p.Z)({},jYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function JYn(t){let{components:e,...n}=t;return(0,s.kt)($Yn,(0,p.Z)({},QYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}JYn.isMDXComponent=!0;const KYn={toc:[]},tHn="wrapper";function eHn(t){let{components:e,...n}=t;return(0,s.kt)(tHn,(0,p.Z)({},KYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eHn.isMDXComponent=!0;const nHn={toc:[]},oHn="wrapper";function pHn(t){let{components:e,...n}=t;return(0,s.kt)(oHn,(0,p.Z)({},nHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pHn.isMDXComponent=!0;const rHn={toc:[]},sHn="wrapper";function cHn(t){let{components:e,...n}=t;return(0,s.kt)(sHn,(0,p.Z)({},rHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}cHn.isMDXComponent=!0;const iHn={toc:[]},aHn="wrapper";function lHn(t){let{components:e,...n}=t;return(0,s.kt)(aHn,(0,p.Z)({},iHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lHn.isMDXComponent=!0;const uHn={toc:[]},mHn="wrapper";function dHn(t){let{components:e,...n}=t;return(0,s.kt)(mHn,(0,p.Z)({},uHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dHn.isMDXComponent=!0;const hHn={toc:[]},fHn="wrapper";function kHn(t){let{components:e,...n}=t;return(0,s.kt)(fHn,(0,p.Z)({},hHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kHn.isMDXComponent=!0;const yHn={toc:[]},DHn="wrapper";function MHn(t){let{components:e,...n}=t;return(0,s.kt)(DHn,(0,p.Z)({},yHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}MHn.isMDXComponent=!0;const XHn={toc:[]},_Hn="wrapper";function wHn(t){let{components:e,...n}=t;return(0,s.kt)(_Hn,(0,p.Z)({},XHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wHn.isMDXComponent=!0;const THn={toc:[]},gHn="wrapper";function CHn(t){let{components:e,...n}=t;return(0,s.kt)(gHn,(0,p.Z)({},THn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}CHn.isMDXComponent=!0;const xHn={toc:[]},vHn="wrapper";function LHn(t){let{components:e,...n}=t;return(0,s.kt)(vHn,(0,p.Z)({},xHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LHn.isMDXComponent=!0;const ZHn={toc:[]},bHn="wrapper";function NHn(t){let{components:e,...n}=t;return(0,s.kt)(bHn,(0,p.Z)({},ZHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}NHn.isMDXComponent=!0;const AHn={toc:[]},zHn="wrapper";function WHn(t){let{components:e,...n}=t;return(0,s.kt)(zHn,(0,p.Z)({},AHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}WHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function SHn(t){let{components:e,...n}=t;return(0,s.kt)(RHn,(0,p.Z)({},IHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}SHn.isMDXComponent=!0;const PHn={toc:[]},EHn="wrapper";function OHn(t){let{components:e,...n}=t;return(0,s.kt)(EHn,(0,p.Z)({},PHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}OHn.isMDXComponent=!0;const GHn={toc:[]},FHn="wrapper";function BHn(t){let{components:e,...n}=t;return(0,s.kt)(FHn,(0,p.Z)({},GHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BHn.isMDXComponent=!0;const UHn={toc:[]},VHn="wrapper";function qHn(t){let{components:e,...n}=t;return(0,s.kt)(VHn,(0,p.Z)({},UHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qHn.isMDXComponent=!0;const jHn={toc:[]},YHn="wrapper";function HHn(t){let{components:e,...n}=t;return(0,s.kt)(YHn,(0,p.Z)({},jHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}HHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function JHn(t){let{components:e,...n}=t;return(0,s.kt)($Hn,(0,p.Z)({},QHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}JHn.isMDXComponent=!0;const KHn={toc:[]},tQn="wrapper";function eQn(t){let{components:e,...n}=t;return(0,s.kt)(tQn,(0,p.Z)({},KHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}eQn.isMDXComponent=!0;const nQn={toc:[]},oQn="wrapper";function pQn(t){let{components:e,...n}=t;return(0,s.kt)(oQn,(0,p.Z)({},nQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pQn.isMDXComponent=!0;const rQn={toc:[]},sQn="wrapper";function cQn(t){let{components:e,...n}=t;return(0,s.kt)(sQn,(0,p.Z)({},rQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}cQn.isMDXComponent=!0;const iQn={toc:[]},aQn="wrapper";function lQn(t){let{components:e,...n}=t;return(0,s.kt)(aQn,(0,p.Z)({},iQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}lQn.isMDXComponent=!0;const uQn={toc:[]},mQn="wrapper";function dQn(t){let{components:e,...n}=t;return(0,s.kt)(mQn,(0,p.Z)({},uQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dQn.isMDXComponent=!0;const hQn={toc:[]},fQn="wrapper";function kQn(t){let{components:e,...n}=t;return(0,s.kt)(fQn,(0,p.Z)({},hQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kQn.isMDXComponent=!0;const yQn={toc:[]},DQn="wrapper";function MQn(t){let{components:e,...n}=t;return(0,s.kt)(DQn,(0,p.Z)({},yQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MQn.isMDXComponent=!0;const XQn={toc:[]},_Qn="wrapper";function wQn(t){let{components:e,...n}=t;return(0,s.kt)(_Qn,(0,p.Z)({},XQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wQn.isMDXComponent=!0;const TQn={toc:[]},gQn="wrapper";function CQn(t){let{components:e,...n}=t;return(0,s.kt)(gQn,(0,p.Z)({},TQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CQn.isMDXComponent=!0;const xQn={toc:[]},vQn="wrapper";function LQn(t){let{components:e,...n}=t;return(0,s.kt)(vQn,(0,p.Z)({},xQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LQn.isMDXComponent=!0;const ZQn={toc:[]},bQn="wrapper";function NQn(t){let{components:e,...n}=t;return(0,s.kt)(bQn,(0,p.Z)({},ZQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}NQn.isMDXComponent=!0;const AQn={toc:[]},zQn="wrapper";function WQn(t){let{components:e,...n}=t;return(0,s.kt)(zQn,(0,p.Z)({},AQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}WQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function SQn(t){let{components:e,...n}=t;return(0,s.kt)(RQn,(0,p.Z)({},IQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}SQn.isMDXComponent=!0;const PQn={toc:[]},EQn="wrapper";function OQn(t){let{components:e,...n}=t;return(0,s.kt)(EQn,(0,p.Z)({},PQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}OQn.isMDXComponent=!0;const GQn={toc:[]},FQn="wrapper";function BQn(t){let{components:e,...n}=t;return(0,s.kt)(FQn,(0,p.Z)({},GQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}BQn.isMDXComponent=!0;const UQn={toc:[]},VQn="wrapper";function qQn(t){let{components:e,...n}=t;return(0,s.kt)(VQn,(0,p.Z)({},UQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qQn.isMDXComponent=!0;const jQn={toc:[]},YQn="wrapper";function HQn(t){let{components:e,...n}=t;return(0,s.kt)(YQn,(0,p.Z)({},jQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}HQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function JQn(t){let{components:e,...n}=t;return(0,s.kt)($Qn,(0,p.Z)({},QQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}JQn.isMDXComponent=!0;const KQn={toc:[]},t$n="wrapper";function e$n(t){let{components:e,...n}=t;return(0,s.kt)(t$n,(0,p.Z)({},KQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e$n.isMDXComponent=!0;const n$n={toc:[]},o$n="wrapper";function p$n(t){let{components:e,...n}=t;return(0,s.kt)(o$n,(0,p.Z)({},n$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}p$n.isMDXComponent=!0;const r$n={toc:[]},s$n="wrapper";function c$n(t){let{components:e,...n}=t;return(0,s.kt)(s$n,(0,p.Z)({},r$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}c$n.isMDXComponent=!0;const i$n={toc:[]},a$n="wrapper";function l$n(t){let{components:e,...n}=t;return(0,s.kt)(a$n,(0,p.Z)({},i$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}l$n.isMDXComponent=!0;const u$n={toc:[]},m$n="wrapper";function d$n(t){let{components:e,...n}=t;return(0,s.kt)(m$n,(0,p.Z)({},u$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}d$n.isMDXComponent=!0;const h$n={toc:[]},f$n="wrapper";function k$n(t){let{components:e,...n}=t;return(0,s.kt)(f$n,(0,p.Z)({},h$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}k$n.isMDXComponent=!0;const y$n={toc:[]},D$n="wrapper";function M$n(t){let{components:e,...n}=t;return(0,s.kt)(D$n,(0,p.Z)({},y$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}M$n.isMDXComponent=!0;const X$n={toc:[]},_$n="wrapper";function w$n(t){let{components:e,...n}=t;return(0,s.kt)(_$n,(0,p.Z)({},X$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}w$n.isMDXComponent=!0;const T$n={toc:[]},g$n="wrapper";function C$n(t){let{components:e,...n}=t;return(0,s.kt)(g$n,(0,p.Z)({},T$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}C$n.isMDXComponent=!0;const x$n={toc:[]},v$n="wrapper";function L$n(t){let{components:e,...n}=t;return(0,s.kt)(v$n,(0,p.Z)({},x$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}L$n.isMDXComponent=!0;const Z$n={toc:[]},b$n="wrapper";function N$n(t){let{components:e,...n}=t;return(0,s.kt)(b$n,(0,p.Z)({},Z$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}N$n.isMDXComponent=!0;const A$n={toc:[]},z$n="wrapper";function W$n(t){let{components:e,...n}=t;return(0,s.kt)(z$n,(0,p.Z)({},A$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}W$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function S$n(t){let{components:e,...n}=t;return(0,s.kt)(R$n,(0,p.Z)({},I$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}S$n.isMDXComponent=!0;const P$n={toc:[]},E$n="wrapper";function O$n(t){let{components:e,...n}=t;return(0,s.kt)(E$n,(0,p.Z)({},P$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}O$n.isMDXComponent=!0;const G$n={toc:[]},F$n="wrapper";function B$n(t){let{components:e,...n}=t;return(0,s.kt)(F$n,(0,p.Z)({},G$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}B$n.isMDXComponent=!0;const U$n={toc:[]},V$n="wrapper";function q$n(t){let{components:e,...n}=t;return(0,s.kt)(V$n,(0,p.Z)({},U$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}q$n.isMDXComponent=!0;const j$n={toc:[]},Y$n="wrapper";function H$n(t){let{components:e,...n}=t;return(0,s.kt)(Y$n,(0,p.Z)({},j$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}H$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function J$n(t){let{components:e,...n}=t;return(0,s.kt)($$n,(0,p.Z)({},Q$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}J$n.isMDXComponent=!0;const K$n={toc:[]},tJn="wrapper";function eJn(t){let{components:e,...n}=t;return(0,s.kt)(tJn,(0,p.Z)({},K$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}eJn.isMDXComponent=!0;const nJn={toc:[]},oJn="wrapper";function pJn(t){let{components:e,...n}=t;return(0,s.kt)(oJn,(0,p.Z)({},nJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pJn.isMDXComponent=!0;const rJn={toc:[]},sJn="wrapper";function cJn(t){let{components:e,...n}=t;return(0,s.kt)(sJn,(0,p.Z)({},rJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cJn.isMDXComponent=!0;const iJn={toc:[]},aJn="wrapper";function lJn(t){let{components:e,...n}=t;return(0,s.kt)(aJn,(0,p.Z)({},iJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lJn.isMDXComponent=!0;const uJn={toc:[]},mJn="wrapper";function dJn(t){let{components:e,...n}=t;return(0,s.kt)(mJn,(0,p.Z)({},uJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dJn.isMDXComponent=!0;const hJn={toc:[]},fJn="wrapper";function kJn(t){let{components:e,...n}=t;return(0,s.kt)(fJn,(0,p.Z)({},hJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}kJn.isMDXComponent=!0;const yJn={toc:[]},DJn="wrapper";function MJn(t){let{components:e,...n}=t;return(0,s.kt)(DJn,(0,p.Z)({},yJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}MJn.isMDXComponent=!0;const XJn={toc:[]},_Jn="wrapper";function wJn(t){let{components:e,...n}=t;return(0,s.kt)(_Jn,(0,p.Z)({},XJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wJn.isMDXComponent=!0;const TJn={toc:[]},gJn="wrapper";function CJn(t){let{components:e,...n}=t;return(0,s.kt)(gJn,(0,p.Z)({},TJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.kt)("inlineCode",{parentName:"a"},"Img"))," instead."))}CJn.isMDXComponent=!0;const xJn={toc:[]},vJn="wrapper";function LJn(t){let{components:e,...n}=t;return(0,s.kt)(vJn,(0,p.Z)({},xJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A Node for drawing and animating SVG images."))}LJn.isMDXComponent=!0;const ZJn={toc:[]},bJn="wrapper";function NJn(t){let{components:e,...n}=t;return(0,s.kt)(bJn,(0,p.Z)({},ZJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NJn.isMDXComponent=!0;const AJn={toc:[]},zJn="wrapper";function WJn(t){let{components:e,...n}=t;return(0,s.kt)(zJn,(0,p.Z)({},AJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function SJn(t){let{components:e,...n}=t;return(0,s.kt)(RJn,(0,p.Z)({},IJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}SJn.isMDXComponent=!0;const PJn={toc:[]},EJn="wrapper";function OJn(t){let{components:e,...n}=t;return(0,s.kt)(EJn,(0,p.Z)({},PJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OJn.isMDXComponent=!0;const GJn={toc:[]},FJn="wrapper";function BJn(t){let{components:e,...n}=t;return(0,s.kt)(FJn,(0,p.Z)({},GJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BJn.isMDXComponent=!0;const UJn={toc:[]},VJn="wrapper";function qJn(t){let{components:e,...n}=t;return(0,s.kt)(VJn,(0,p.Z)({},UJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qJn.isMDXComponent=!0;const jJn={toc:[]},YJn="wrapper";function HJn(t){let{components:e,...n}=t;return(0,s.kt)(YJn,(0,p.Z)({},jJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}HJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function JJn(t){let{components:e,...n}=t;return(0,s.kt)($Jn,(0,p.Z)({},QJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}JJn.isMDXComponent=!0;const KJn={toc:[]},tKn="wrapper";function eKn(t){let{components:e,...n}=t;return(0,s.kt)(tKn,(0,p.Z)({},KJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eKn.isMDXComponent=!0;const nKn={toc:[]},oKn="wrapper";function pKn(t){let{components:e,...n}=t;return(0,s.kt)(oKn,(0,p.Z)({},nKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pKn.isMDXComponent=!0;const rKn={toc:[]},sKn="wrapper";function cKn(t){let{components:e,...n}=t;return(0,s.kt)(sKn,(0,p.Z)({},rKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cKn.isMDXComponent=!0;const iKn={toc:[]},aKn="wrapper";function lKn(t){let{components:e,...n}=t;return(0,s.kt)(aKn,(0,p.Z)({},iKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lKn.isMDXComponent=!0;const uKn={toc:[]},mKn="wrapper";function dKn(t){let{components:e,...n}=t;return(0,s.kt)(mKn,(0,p.Z)({},uKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dKn.isMDXComponent=!0;const hKn={toc:[]},fKn="wrapper";function kKn(t){let{components:e,...n}=t;return(0,s.kt)(fKn,(0,p.Z)({},hKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kKn.isMDXComponent=!0;const yKn={toc:[]},DKn="wrapper";function MKn(t){let{components:e,...n}=t;return(0,s.kt)(DKn,(0,p.Z)({},yKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MKn.isMDXComponent=!0;const XKn={toc:[]},_Kn="wrapper";function wKn(t){let{components:e,...n}=t;return(0,s.kt)(_Kn,(0,p.Z)({},XKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}wKn.isMDXComponent=!0;const TKn={toc:[]},gKn="wrapper";function CKn(t){let{components:e,...n}=t;return(0,s.kt)(gKn,(0,p.Z)({},TKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}CKn.isMDXComponent=!0;const xKn={toc:[]},vKn="wrapper";function LKn(t){let{components:e,...n}=t;return(0,s.kt)(vKn,(0,p.Z)({},xKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}LKn.isMDXComponent=!0;const ZKn={toc:[]},bKn="wrapper";function NKn(t){let{components:e,...n}=t;return(0,s.kt)(bKn,(0,p.Z)({},ZKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}NKn.isMDXComponent=!0;const AKn={toc:[]},zKn="wrapper";function WKn(t){let{components:e,...n}=t;return(0,s.kt)(zKn,(0,p.Z)({},AKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}WKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function SKn(t){let{components:e,...n}=t;return(0,s.kt)(RKn,(0,p.Z)({},IKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}SKn.isMDXComponent=!0;const PKn={toc:[]},EKn="wrapper";function OKn(t){let{components:e,...n}=t;return(0,s.kt)(EKn,(0,p.Z)({},PKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}OKn.isMDXComponent=!0;const GKn={toc:[]},FKn="wrapper";function BKn(t){let{components:e,...n}=t;return(0,s.kt)(FKn,(0,p.Z)({},GKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}BKn.isMDXComponent=!0;const UKn={toc:[]},VKn="wrapper";function qKn(t){let{components:e,...n}=t;return(0,s.kt)(VKn,(0,p.Z)({},UKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qKn.isMDXComponent=!0;const jKn={toc:[]},YKn="wrapper";function HKn(t){let{components:e,...n}=t;return(0,s.kt)(YKn,(0,p.Z)({},jKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}HKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function JKn(t){let{components:e,...n}=t;return(0,s.kt)($Kn,(0,p.Z)({},QKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}JKn.isMDXComponent=!0;const KKn={toc:[]},t0n="wrapper";function e0n(t){let{components:e,...n}=t;return(0,s.kt)(t0n,(0,p.Z)({},KKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}e0n.isMDXComponent=!0;const n0n={toc:[]},o0n="wrapper";function p0n(t){let{components:e,...n}=t;return(0,s.kt)(o0n,(0,p.Z)({},n0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}p0n.isMDXComponent=!0;const r0n={toc:[]},s0n="wrapper";function c0n(t){let{components:e,...n}=t;return(0,s.kt)(s0n,(0,p.Z)({},r0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}c0n.isMDXComponent=!0;const i0n={toc:[]},a0n="wrapper";function l0n(t){let{components:e,...n}=t;return(0,s.kt)(a0n,(0,p.Z)({},i0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}l0n.isMDXComponent=!0;const u0n={toc:[]},m0n="wrapper";function d0n(t){let{components:e,...n}=t;return(0,s.kt)(m0n,(0,p.Z)({},u0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}d0n.isMDXComponent=!0;const h0n={toc:[]},f0n="wrapper";function k0n(t){let{components:e,...n}=t;return(0,s.kt)(f0n,(0,p.Z)({},h0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}k0n.isMDXComponent=!0;const y0n={toc:[]},D0n="wrapper";function M0n(t){let{components:e,...n}=t;return(0,s.kt)(D0n,(0,p.Z)({},y0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}M0n.isMDXComponent=!0;const X0n={toc:[]},_0n="wrapper";function w0n(t){let{components:e,...n}=t;return(0,s.kt)(_0n,(0,p.Z)({},X0n,n,{components:e,mdxType:"MDXLayout"}))}w0n.isMDXComponent=!0;const T0n={toc:[]},g0n="wrapper";function C0n(t){let{components:e,...n}=t;return(0,s.kt)(g0n,(0,p.Z)({},T0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"SVG string to be rendered"))}C0n.isMDXComponent=!0;const x0n={toc:[]},v0n="wrapper";function L0n(t){let{components:e,...n}=t;return(0,s.kt)(v0n,(0,p.Z)({},x0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}L0n.isMDXComponent=!0;const Z0n={toc:[]},b0n="wrapper";function N0n(t){let{components:e,...n}=t;return(0,s.kt)(b0n,(0,p.Z)({},Z0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}N0n.isMDXComponent=!0;const A0n={toc:[]},z0n="wrapper";function W0n(t){let{components:e,...n}=t;return(0,s.kt)(z0n,(0,p.Z)({},A0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function S0n(t){let{components:e,...n}=t;return(0,s.kt)(R0n,(0,p.Z)({},I0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}S0n.isMDXComponent=!0;const P0n={toc:[]},E0n="wrapper";function O0n(t){let{components:e,...n}=t;return(0,s.kt)(E0n,(0,p.Z)({},P0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O0n.isMDXComponent=!0;const G0n={toc:[]},F0n="wrapper";function B0n(t){let{components:e,...n}=t;return(0,s.kt)(F0n,(0,p.Z)({},G0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}B0n.isMDXComponent=!0;const U0n={toc:[]},V0n="wrapper";function q0n(t){let{components:e,...n}=t;return(0,s.kt)(V0n,(0,p.Z)({},U0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Child to wrap all SVG node"))}q0n.isMDXComponent=!0;const j0n={toc:[]},Y0n="wrapper";function H0n(t){let{components:e,...n}=t;return(0,s.kt)(Y0n,(0,p.Z)({},j0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}H0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function J0n(t){let{components:e,...n}=t;return(0,s.kt)($0n,(0,p.Z)({},Q0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}J0n.isMDXComponent=!0;const K0n={toc:[]},t2n="wrapper";function e2n(t){let{components:e,...n}=t;return(0,s.kt)(t2n,(0,p.Z)({},K0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}e2n.isMDXComponent=!0;const n2n={toc:[]},o2n="wrapper";function p2n(t){let{components:e,...n}=t;return(0,s.kt)(o2n,(0,p.Z)({},n2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}p2n.isMDXComponent=!0;const r2n={toc:[]},s2n="wrapper";function c2n(t){let{components:e,...n}=t;return(0,s.kt)(s2n,(0,p.Z)({},r2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c2n.isMDXComponent=!0;const i2n={toc:[]},a2n="wrapper";function l2n(t){let{components:e,...n}=t;return(0,s.kt)(a2n,(0,p.Z)({},i2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}l2n.isMDXComponent=!0;const u2n={toc:[]},m2n="wrapper";function d2n(t){let{components:e,...n}=t;return(0,s.kt)(m2n,(0,p.Z)({},u2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}d2n.isMDXComponent=!0;const h2n={toc:[]},f2n="wrapper";function k2n(t){let{components:e,...n}=t;return(0,s.kt)(f2n,(0,p.Z)({},h2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}k2n.isMDXComponent=!0;const y2n={toc:[]},D2n="wrapper";function M2n(t){let{components:e,...n}=t;return(0,s.kt)(D2n,(0,p.Z)({},y2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}M2n.isMDXComponent=!0;const X2n={toc:[]},_2n="wrapper";function w2n(t){let{components:e,...n}=t;return(0,s.kt)(_2n,(0,p.Z)({},X2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}w2n.isMDXComponent=!0;const T2n={toc:[]},g2n="wrapper";function C2n(t){let{components:e,...n}=t;return(0,s.kt)(g2n,(0,p.Z)({},T2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}C2n.isMDXComponent=!0;const x2n={toc:[]},v2n="wrapper";function L2n(t){let{components:e,...n}=t;return(0,s.kt)(v2n,(0,p.Z)({},x2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}L2n.isMDXComponent=!0;const Z2n={toc:[]},b2n="wrapper";function N2n(t){let{components:e,...n}=t;return(0,s.kt)(b2n,(0,p.Z)({},Z2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShape"),"."))}N2n.isMDXComponent=!0;const A2n={toc:[]},z2n="wrapper";function W2n(t){let{components:e,...n}=t;return(0,s.kt)(z2n,(0,p.Z)({},A2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}W2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function S2n(t){let{components:e,...n}=t;return(0,s.kt)(R2n,(0,p.Z)({},I2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}S2n.isMDXComponent=!0;const P2n={toc:[]},E2n="wrapper";function O2n(t){let{components:e,...n}=t;return(0,s.kt)(E2n,(0,p.Z)({},P2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}O2n.isMDXComponent=!0;const G2n={toc:[]},F2n="wrapper";function B2n(t){let{components:e,...n}=t;return(0,s.kt)(F2n,(0,p.Z)({},G2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}B2n.isMDXComponent=!0;const U2n={toc:[]},V2n="wrapper";function q2n(t){let{components:e,...n}=t;return(0,s.kt)(V2n,(0,p.Z)({},U2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}q2n.isMDXComponent=!0;const j2n={toc:[]},Y2n="wrapper";function H2n(t){let{components:e,...n}=t;return(0,s.kt)(Y2n,(0,p.Z)({},j2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}H2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function J2n(t){let{components:e,...n}=t;return(0,s.kt)($2n,(0,p.Z)({},Q2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}J2n.isMDXComponent=!0;const K2n={toc:[]},t6n="wrapper";function e6n(t){let{components:e,...n}=t;return(0,s.kt)(t6n,(0,p.Z)({},K2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e6n.isMDXComponent=!0;const n6n={toc:[]},o6n="wrapper";function p6n(t){let{components:e,...n}=t;return(0,s.kt)(o6n,(0,p.Z)({},n6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}p6n.isMDXComponent=!0;const r6n={toc:[]},s6n="wrapper";function c6n(t){let{components:e,...n}=t;return(0,s.kt)(s6n,(0,p.Z)({},r6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c6n.isMDXComponent=!0;const i6n={toc:[]},a6n="wrapper";function l6n(t){let{components:e,...n}=t;return(0,s.kt)(a6n,(0,p.Z)({},i6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}l6n.isMDXComponent=!0;const u6n={toc:[]},m6n="wrapper";function d6n(t){let{components:e,...n}=t;return(0,s.kt)(m6n,(0,p.Z)({},u6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d6n.isMDXComponent=!0;const h6n={toc:[]},f6n="wrapper";function k6n(t){let{components:e,...n}=t;return(0,s.kt)(f6n,(0,p.Z)({},h6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}k6n.isMDXComponent=!0;const y6n={toc:[]},D6n="wrapper";function M6n(t){let{components:e,...n}=t;return(0,s.kt)(D6n,(0,p.Z)({},y6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}M6n.isMDXComponent=!0;const X6n={toc:[]},_6n="wrapper";function w6n(t){let{components:e,...n}=t;return(0,s.kt)(_6n,(0,p.Z)({},X6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}w6n.isMDXComponent=!0;const T6n={toc:[]},g6n="wrapper";function C6n(t){let{components:e,...n}=t;return(0,s.kt)(g6n,(0,p.Z)({},T6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C6n.isMDXComponent=!0;const x6n={toc:[]},v6n="wrapper";function L6n(t){let{components:e,...n}=t;return(0,s.kt)(v6n,(0,p.Z)({},x6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L6n.isMDXComponent=!0;const Z6n={toc:[]},b6n="wrapper";function N6n(t){let{components:e,...n}=t;return(0,s.kt)(b6n,(0,p.Z)({},Z6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N6n.isMDXComponent=!0;const A6n={toc:[]},z6n="wrapper";function W6n(t){let{components:e,...n}=t;return(0,s.kt)(z6n,(0,p.Z)({},A6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function S6n(t){let{components:e,...n}=t;return(0,s.kt)(R6n,(0,p.Z)({},I6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}S6n.isMDXComponent=!0;const P6n={toc:[]},E6n="wrapper";function O6n(t){let{components:e,...n}=t;return(0,s.kt)(E6n,(0,p.Z)({},P6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O6n.isMDXComponent=!0;const G6n={toc:[]},F6n="wrapper";function B6n(t){let{components:e,...n}=t;return(0,s.kt)(F6n,(0,p.Z)({},G6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B6n.isMDXComponent=!0;const U6n={toc:[]},V6n="wrapper";function q6n(t){let{components:e,...n}=t;return(0,s.kt)(V6n,(0,p.Z)({},U6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q6n.isMDXComponent=!0;const j6n={toc:[]},Y6n="wrapper";function H6n(t){let{components:e,...n}=t;return(0,s.kt)(Y6n,(0,p.Z)({},j6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}H6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function J6n(t){let{components:e,...n}=t;return(0,s.kt)($6n,(0,p.Z)({},Q6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}J6n.isMDXComponent=!0;const K6n={toc:[]},t3n="wrapper";function e3n(t){let{components:e,...n}=t;return(0,s.kt)(t3n,(0,p.Z)({},K6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e3n.isMDXComponent=!0;const n3n={toc:[]},o3n="wrapper";function p3n(t){let{components:e,...n}=t;return(0,s.kt)(o3n,(0,p.Z)({},n3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}p3n.isMDXComponent=!0;const r3n={toc:[]},s3n="wrapper";function c3n(t){let{components:e,...n}=t;return(0,s.kt)(s3n,(0,p.Z)({},r3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c3n.isMDXComponent=!0;const i3n={toc:[]},a3n="wrapper";function l3n(t){let{components:e,...n}=t;return(0,s.kt)(a3n,(0,p.Z)({},i3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}l3n.isMDXComponent=!0;const u3n={toc:[]},m3n="wrapper";function d3n(t){let{components:e,...n}=t;return(0,s.kt)(m3n,(0,p.Z)({},u3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d3n.isMDXComponent=!0;const h3n={toc:[]},f3n="wrapper";function k3n(t){let{components:e,...n}=t;return(0,s.kt)(f3n,(0,p.Z)({},h3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}k3n.isMDXComponent=!0;const y3n={toc:[]},D3n="wrapper";function M3n(t){let{components:e,...n}=t;return(0,s.kt)(D3n,(0,p.Z)({},y3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M3n.isMDXComponent=!0;const X3n={toc:[]},_3n="wrapper";function w3n(t){let{components:e,...n}=t;return(0,s.kt)(_3n,(0,p.Z)({},X3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}w3n.isMDXComponent=!0;const T3n={toc:[]},g3n="wrapper";function C3n(t){let{components:e,...n}=t;return(0,s.kt)(g3n,(0,p.Z)({},T3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}C3n.isMDXComponent=!0;const x3n={toc:[]},v3n="wrapper";function L3n(t){let{components:e,...n}=t;return(0,s.kt)(v3n,(0,p.Z)({},x3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}L3n.isMDXComponent=!0;const Z3n={toc:[]},b3n="wrapper";function N3n(t){let{components:e,...n}=t;return(0,s.kt)(b3n,(0,p.Z)({},Z3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N3n.isMDXComponent=!0;const A3n={toc:[]},z3n="wrapper";function W3n(t){let{components:e,...n}=t;return(0,s.kt)(z3n,(0,p.Z)({},A3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}W3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function S3n(t){let{components:e,...n}=t;return(0,s.kt)(R3n,(0,p.Z)({},I3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}S3n.isMDXComponent=!0;const P3n={toc:[]},E3n="wrapper";function O3n(t){let{components:e,...n}=t;return(0,s.kt)(E3n,(0,p.Z)({},P3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}O3n.isMDXComponent=!0;const G3n={toc:[]},F3n="wrapper";function B3n(t){let{components:e,...n}=t;return(0,s.kt)(F3n,(0,p.Z)({},G3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B3n.isMDXComponent=!0;const U3n={toc:[]},V3n="wrapper";function q3n(t){let{components:e,...n}=t;return(0,s.kt)(V3n,(0,p.Z)({},U3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a tweening list to tween between two SVG nodes."))}q3n.isMDXComponent=!0;const j3n={toc:[]},Y3n="wrapper";function H3n(t){let{components:e,...n}=t;return(0,s.kt)(Y3n,(0,p.Z)({},j3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial node,"))}H3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function J3n(t){let{components:e,...n}=t;return(0,s.kt)($3n,(0,p.Z)({},Q3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The final node."))}J3n.isMDXComponent=!0;const K3n={toc:[]},t5n="wrapper";function e5n(t){let{components:e,...n}=t;return(0,s.kt)(t5n,(0,p.Z)({},K3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}e5n.isMDXComponent=!0;const n5n={toc:[]},o5n="wrapper";function p5n(t){let{components:e,...n}=t;return(0,s.kt)(o5n,(0,p.Z)({},n5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function."))}p5n.isMDXComponent=!0;const r5n={toc:[]},s5n="wrapper";function c5n(t){let{components:e,...n}=t;return(0,s.kt)(s5n,(0,p.Z)({},r5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}c5n.isMDXComponent=!0;const i5n={toc:[]},a5n="wrapper";function l5n(t){let{components:e,...n}=t;return(0,s.kt)(a5n,(0,p.Z)({},i5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}l5n.isMDXComponent=!0;const u5n={toc:[]},m5n="wrapper";function d5n(t){let{components:e,...n}=t;return(0,s.kt)(m5n,(0,p.Z)({},u5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get all SVG nodes with the given id."))}d5n.isMDXComponent=!0;const h5n={toc:[]},f5n="wrapper";function k5n(t){let{components:e,...n}=t;return(0,s.kt)(f5n,(0,p.Z)({},h5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An id to query."))}k5n.isMDXComponent=!0;const y5n={toc:[]},D5n="wrapper";function M5n(t){let{components:e,...n}=t;return(0,s.kt)(D5n,(0,p.Z)({},y5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}M5n.isMDXComponent=!0;const X5n={toc:[]},_5n="wrapper";function w5n(t){let{components:e,...n}=t;return(0,s.kt)(_5n,(0,p.Z)({},X5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}w5n.isMDXComponent=!0;const T5n={toc:[]},g5n="wrapper";function C5n(t){let{components:e,...n}=t;return(0,s.kt)(g5n,(0,p.Z)({},T5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}C5n.isMDXComponent=!0;const x5n={toc:[]},v5n="wrapper";function L5n(t){let{components:e,...n}=t;return(0,s.kt)(v5n,(0,p.Z)({},x5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}L5n.isMDXComponent=!0;const Z5n={toc:[]},b5n="wrapper";function N5n(t){let{components:e,...n}=t;return(0,s.kt)(b5n,(0,p.Z)({},Z5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}N5n.isMDXComponent=!0;const A5n={toc:[]},z5n="wrapper";function W5n(t){let{components:e,...n}=t;return(0,s.kt)(z5n,(0,p.Z)({},A5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}W5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function S5n(t){let{components:e,...n}=t;return(0,s.kt)(R5n,(0,p.Z)({},I5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}S5n.isMDXComponent=!0;const P5n={toc:[]},E5n="wrapper";function O5n(t){let{components:e,...n}=t;return(0,s.kt)(E5n,(0,p.Z)({},P5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}O5n.isMDXComponent=!0;const G5n={toc:[]},F5n="wrapper";function B5n(t){let{components:e,...n}=t;return(0,s.kt)(F5n,(0,p.Z)({},G5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}B5n.isMDXComponent=!0;const U5n={toc:[]},V5n="wrapper";function q5n(t){let{components:e,...n}=t;return(0,s.kt)(V5n,(0,p.Z)({},U5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}q5n.isMDXComponent=!0;const j5n={toc:[]},Y5n="wrapper";function H5n(t){let{components:e,...n}=t;return(0,s.kt)(Y5n,(0,p.Z)({},j5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}H5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function J5n(t){let{components:e,...n}=t;return(0,s.kt)($5n,(0,p.Z)({},Q5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}J5n.isMDXComponent=!0;const K5n={toc:[]},t1n="wrapper";function e1n(t){let{components:e,...n}=t;return(0,s.kt)(t1n,(0,p.Z)({},K5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}e1n.isMDXComponent=!0;const n1n={toc:[]},o1n="wrapper";function p1n(t){let{components:e,...n}=t;return(0,s.kt)(o1n,(0,p.Z)({},n1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}p1n.isMDXComponent=!0;const r1n={toc:[]},s1n="wrapper";function c1n(t){let{components:e,...n}=t;return(0,s.kt)(s1n,(0,p.Z)({},r1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}c1n.isMDXComponent=!0;const i1n={toc:[]},a1n="wrapper";function l1n(t){let{components:e,...n}=t;return(0,s.kt)(a1n,(0,p.Z)({},i1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}l1n.isMDXComponent=!0;const u1n={toc:[]},m1n="wrapper";function d1n(t){let{components:e,...n}=t;return(0,s.kt)(m1n,(0,p.Z)({},u1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}d1n.isMDXComponent=!0;const h1n={toc:[]},f1n="wrapper";function k1n(t){let{components:e,...n}=t;return(0,s.kt)(f1n,(0,p.Z)({},h1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}k1n.isMDXComponent=!0;const y1n={toc:[]},D1n="wrapper";function M1n(t){let{components:e,...n}=t;return(0,s.kt)(D1n,(0,p.Z)({},y1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}M1n.isMDXComponent=!0;const X1n={toc:[]},_1n="wrapper";function w1n(t){let{components:e,...n}=t;return(0,s.kt)(_1n,(0,p.Z)({},X1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}w1n.isMDXComponent=!0;const T1n={toc:[]},g1n="wrapper";function C1n(t){let{components:e,...n}=t;return(0,s.kt)(g1n,(0,p.Z)({},T1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}C1n.isMDXComponent=!0;const x1n={toc:[]},v1n="wrapper";function L1n(t){let{components:e,...n}=t;return(0,s.kt)(v1n,(0,p.Z)({},x1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}L1n.isMDXComponent=!0;const Z1n={toc:[]},b1n="wrapper";function N1n(t){let{components:e,...n}=t;return(0,s.kt)(b1n,(0,p.Z)({},Z1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}N1n.isMDXComponent=!0;const A1n={toc:[]},z1n="wrapper";function W1n(t){let{components:e,...n}=t;return(0,s.kt)(z1n,(0,p.Z)({},A1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}W1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function S1n(t){let{components:e,...n}=t;return(0,s.kt)(R1n,(0,p.Z)({},I1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}S1n.isMDXComponent=!0;const P1n={toc:[]},E1n="wrapper";function O1n(t){let{components:e,...n}=t;return(0,s.kt)(E1n,(0,p.Z)({},P1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}O1n.isMDXComponent=!0;const G1n={toc:[]},F1n="wrapper";function B1n(t){let{components:e,...n}=t;return(0,s.kt)(F1n,(0,p.Z)({},G1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}B1n.isMDXComponent=!0;const U1n={toc:[]},V1n="wrapper";function q1n(t){let{components:e,...n}=t;return(0,s.kt)(V1n,(0,p.Z)({},U1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}q1n.isMDXComponent=!0;const j1n={toc:[]},Y1n="wrapper";function H1n(t){let{components:e,...n}=t;return(0,s.kt)(Y1n,(0,p.Z)({},j1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}H1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function J1n(t){let{components:e,...n}=t;return(0,s.kt)($1n,(0,p.Z)({},Q1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}J1n.isMDXComponent=!0;const K1n={toc:[]},t4n="wrapper";function e4n(t){let{components:e,...n}=t;return(0,s.kt)(t4n,(0,p.Z)({},K1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}e4n.isMDXComponent=!0;const n4n={toc:[]},o4n="wrapper";function p4n(t){let{components:e,...n}=t;return(0,s.kt)(o4n,(0,p.Z)({},n4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}p4n.isMDXComponent=!0;const r4n={toc:[]},s4n="wrapper";function c4n(t){let{components:e,...n}=t;return(0,s.kt)(s4n,(0,p.Z)({},r4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}c4n.isMDXComponent=!0;const i4n={toc:[]},a4n="wrapper";function l4n(t){let{components:e,...n}=t;return(0,s.kt)(a4n,(0,p.Z)({},i4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}l4n.isMDXComponent=!0;const u4n={toc:[]},m4n="wrapper";function d4n(t){let{components:e,...n}=t;return(0,s.kt)(m4n,(0,p.Z)({},u4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}d4n.isMDXComponent=!0;const h4n={toc:[]},f4n="wrapper";function k4n(t){let{components:e,...n}=t;return(0,s.kt)(f4n,(0,p.Z)({},h4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}k4n.isMDXComponent=!0;const y4n={toc:[]},D4n="wrapper";function M4n(t){let{components:e,...n}=t;return(0,s.kt)(D4n,(0,p.Z)({},y4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}M4n.isMDXComponent=!0;const X4n={toc:[]},_4n="wrapper";function w4n(t){let{components:e,...n}=t;return(0,s.kt)(_4n,(0,p.Z)({},X4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}w4n.isMDXComponent=!0;const T4n={toc:[]},g4n="wrapper";function C4n(t){let{components:e,...n}=t;return(0,s.kt)(g4n,(0,p.Z)({},T4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}C4n.isMDXComponent=!0;const x4n={toc:[]},v4n="wrapper";function L4n(t){let{components:e,...n}=t;return(0,s.kt)(v4n,(0,p.Z)({},x4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}L4n.isMDXComponent=!0;const Z4n={toc:[]},b4n="wrapper";function N4n(t){let{components:e,...n}=t;return(0,s.kt)(b4n,(0,p.Z)({},Z4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}N4n.isMDXComponent=!0;const A4n={toc:[]},z4n="wrapper";function W4n(t){let{components:e,...n}=t;return(0,s.kt)(z4n,(0,p.Z)({},A4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}W4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function S4n(t){let{components:e,...n}=t;return(0,s.kt)(R4n,(0,p.Z)({},I4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}S4n.isMDXComponent=!0;const P4n={toc:[]},E4n="wrapper";function O4n(t){let{components:e,...n}=t;return(0,s.kt)(E4n,(0,p.Z)({},P4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}O4n.isMDXComponent=!0;const G4n={toc:[]},F4n="wrapper";function B4n(t){let{components:e,...n}=t;return(0,s.kt)(F4n,(0,p.Z)({},G4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert an SVG string to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}B4n.isMDXComponent=!0;const U4n={toc:[]},V4n="wrapper";function q4n(t){let{components:e,...n}=t;return(0,s.kt)(V4n,(0,p.Z)({},U4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An SVG string to be parsed."))}q4n.isMDXComponent=!0;const j4n={toc:[]},Y4n="wrapper";function H4n(t){let{components:e,...n}=t;return(0,s.kt)(Y4n,(0,p.Z)({},j4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}H4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function J4n(t){let{components:e,...n}=t;return(0,s.kt)($4n,(0,p.Z)({},Q4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}J4n.isMDXComponent=!0;const K4n={toc:[]},t8n="wrapper";function e8n(t){let{components:e,...n}=t;return(0,s.kt)(t8n,(0,p.Z)({},K4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e8n.isMDXComponent=!0;const n8n={toc:[]},o8n="wrapper";function p8n(t){let{components:e,...n}=t;return(0,s.kt)(o8n,(0,p.Z)({},n8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}p8n.isMDXComponent=!0;const r8n={toc:[]},s8n="wrapper";function c8n(t){let{components:e,...n}=t;return(0,s.kt)(s8n,(0,p.Z)({},r8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}c8n.isMDXComponent=!0;const i8n={toc:[]},a8n="wrapper";function l8n(t){let{components:e,...n}=t;return(0,s.kt)(a8n,(0,p.Z)({},i8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}l8n.isMDXComponent=!0;const u8n={toc:[]},m8n="wrapper";function d8n(t){let{components:e,...n}=t;return(0,s.kt)(m8n,(0,p.Z)({},u8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}d8n.isMDXComponent=!0;const h8n={toc:[]},f8n="wrapper";function k8n(t){let{components:e,...n}=t;return(0,s.kt)(f8n,(0,p.Z)({},h8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}k8n.isMDXComponent=!0;const y8n={toc:[]},D8n="wrapper";function M8n(t){let{components:e,...n}=t;return(0,s.kt)(D8n,(0,p.Z)({},y8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}M8n.isMDXComponent=!0;const X8n={toc:[]},_8n="wrapper";function w8n(t){let{components:e,...n}=t;return(0,s.kt)(_8n,(0,p.Z)({},X8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}w8n.isMDXComponent=!0;const T8n={toc:[]},g8n="wrapper";function C8n(t){let{components:e,...n}=t;return(0,s.kt)(g8n,(0,p.Z)({},T8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}C8n.isMDXComponent=!0;const x8n={toc:[]},v8n="wrapper";function L8n(t){let{components:e,...n}=t;return(0,s.kt)(v8n,(0,p.Z)({},x8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}L8n.isMDXComponent=!0;const Z8n={toc:[]},b8n="wrapper";function N8n(t){let{components:e,...n}=t;return(0,s.kt)(b8n,(0,p.Z)({},Z8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}N8n.isMDXComponent=!0;const A8n={toc:[]},z8n="wrapper";function W8n(t){let{components:e,...n}=t;return(0,s.kt)(z8n,(0,p.Z)({},A8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}W8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function S8n(t){let{components:e,...n}=t;return(0,s.kt)(R8n,(0,p.Z)({},I8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}S8n.isMDXComponent=!0;const P8n={toc:[]},E8n="wrapper";function O8n(t){let{components:e,...n}=t;return(0,s.kt)(E8n,(0,p.Z)({},P8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}O8n.isMDXComponent=!0;const G8n={toc:[]},F8n="wrapper";function B8n(t){let{components:e,...n}=t;return(0,s.kt)(F8n,(0,p.Z)({},G8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}B8n.isMDXComponent=!0;const U8n={toc:[]},V8n="wrapper";function q8n(t){let{components:e,...n}=t;return(0,s.kt)(V8n,(0,p.Z)({},U8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}q8n.isMDXComponent=!0;const j8n={toc:[]},Y8n="wrapper";function H8n(t){let{components:e,...n}=t;return(0,s.kt)(Y8n,(0,p.Z)({},j8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}H8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function J8n(t){let{components:e,...n}=t;return(0,s.kt)($8n,(0,p.Z)({},Q8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}J8n.isMDXComponent=!0;const K8n={toc:[]},t7n="wrapper";function e7n(t){let{components:e,...n}=t;return(0,s.kt)(t7n,(0,p.Z)({},K8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}e7n.isMDXComponent=!0;const n7n={toc:[]},o7n="wrapper";function p7n(t){let{components:e,...n}=t;return(0,s.kt)(o7n,(0,p.Z)({},n7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p7n.isMDXComponent=!0;const r7n={toc:[]},s7n="wrapper";function c7n(t){let{components:e,...n}=t;return(0,s.kt)(s7n,(0,p.Z)({},r7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}c7n.isMDXComponent=!0;const i7n={toc:[]},a7n="wrapper";function l7n(t){let{components:e,...n}=t;return(0,s.kt)(a7n,(0,p.Z)({},i7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}l7n.isMDXComponent=!0;const u7n={toc:[]},m7n="wrapper";function d7n(t){let{components:e,...n}=t;return(0,s.kt)(m7n,(0,p.Z)({},u7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}d7n.isMDXComponent=!0;const h7n={toc:[]},f7n="wrapper";function k7n(t){let{components:e,...n}=t;return(0,s.kt)(f7n,(0,p.Z)({},h7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}k7n.isMDXComponent=!0;const y7n={toc:[]},D7n="wrapper";function M7n(t){let{components:e,...n}=t;return(0,s.kt)(D7n,(0,p.Z)({},y7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}M7n.isMDXComponent=!0;const X7n={toc:[]},_7n="wrapper";function w7n(t){let{components:e,...n}=t;return(0,s.kt)(_7n,(0,p.Z)({},X7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w7n.isMDXComponent=!0;const T7n={toc:[]},g7n="wrapper";function C7n(t){let{components:e,...n}=t;return(0,s.kt)(g7n,(0,p.Z)({},T7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}C7n.isMDXComponent=!0;const x7n={toc:[]},v7n="wrapper";function L7n(t){let{components:e,...n}=t;return(0,s.kt)(v7n,(0,p.Z)({},x7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L7n.isMDXComponent=!0;const Z7n={toc:[]},b7n="wrapper";function N7n(t){let{components:e,...n}=t;return(0,s.kt)(b7n,(0,p.Z)({},Z7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}N7n.isMDXComponent=!0;const A7n={toc:[]},z7n="wrapper";function W7n(t){let{components:e,...n}=t;return(0,s.kt)(z7n,(0,p.Z)({},A7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}W7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function S7n(t){let{components:e,...n}=t;return(0,s.kt)(R7n,(0,p.Z)({},I7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}S7n.isMDXComponent=!0;const P7n={toc:[]},E7n="wrapper";function O7n(t){let{components:e,...n}=t;return(0,s.kt)(E7n,(0,p.Z)({},P7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}O7n.isMDXComponent=!0;const G7n={toc:[]},F7n="wrapper";function B7n(t){let{components:e,...n}=t;return(0,s.kt)(F7n,(0,p.Z)({},G7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}B7n.isMDXComponent=!0;const U7n={toc:[]},V7n="wrapper";function q7n(t){let{components:e,...n}=t;return(0,s.kt)(V7n,(0,p.Z)({},U7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}q7n.isMDXComponent=!0;const j7n={toc:[]},Y7n="wrapper";function H7n(t){let{components:e,...n}=t;return(0,s.kt)(Y7n,(0,p.Z)({},j7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}H7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function J7n(t){let{components:e,...n}=t;return(0,s.kt)($7n,(0,p.Z)({},Q7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}J7n.isMDXComponent=!0;const K7n={toc:[]},t9n="wrapper";function e9n(t){let{components:e,...n}=t;return(0,s.kt)(t9n,(0,p.Z)({},K7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}e9n.isMDXComponent=!0;const n9n={toc:[]},o9n="wrapper";function p9n(t){let{components:e,...n}=t;return(0,s.kt)(o9n,(0,p.Z)({},n9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}p9n.isMDXComponent=!0;const r9n={toc:[]},s9n="wrapper";function c9n(t){let{components:e,...n}=t;return(0,s.kt)(s9n,(0,p.Z)({},r9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}c9n.isMDXComponent=!0;const i9n={toc:[]},a9n="wrapper";function l9n(t){let{components:e,...n}=t;return(0,s.kt)(a9n,(0,p.Z)({},i9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}l9n.isMDXComponent=!0;const u9n={toc:[]},m9n="wrapper";function d9n(t){let{components:e,...n}=t;return(0,s.kt)(m9n,(0,p.Z)({},u9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}d9n.isMDXComponent=!0;const h9n={toc:[]},f9n="wrapper";function k9n(t){let{components:e,...n}=t;return(0,s.kt)(f9n,(0,p.Z)({},h9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"MotionCanvas Shape properties"))}k9n.isMDXComponent=!0;const y9n={toc:[]},D9n="wrapper";function M9n(t){let{components:e,...n}=t;return(0,s.kt)(D9n,(0,p.Z)({},y9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}M9n.isMDXComponent=!0;const X9n={toc:[]},_9n="wrapper";function w9n(t){let{components:e,...n}=t;return(0,s.kt)(_9n,(0,p.Z)({},X9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Matrix transformation"))}w9n.isMDXComponent=!0;const T9n={toc:[]},g9n="wrapper";function C9n(t){let{components:e,...n}=t;return(0,s.kt)(g9n,(0,p.Z)({},T9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}C9n.isMDXComponent=!0;const x9n={toc:[]},v9n="wrapper";function L9n(t){let{components:e,...n}=t;return(0,s.kt)(v9n,(0,p.Z)({},x9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse an SVG string as ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}L9n.isMDXComponent=!0;const Z9n={toc:[]},b9n="wrapper";function N9n(t){let{components:e,...n}=t;return(0,s.kt)(b9n,(0,p.Z)({},Z9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"And SVG string to be parsed."))}N9n.isMDXComponent=!0;const A9n={toc:[]},z9n="wrapper";function W9n(t){let{components:e,...n}=t;return(0,s.kt)(z9n,(0,p.Z)({},A9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}W9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function S9n(t){let{components:e,...n}=t;return(0,s.kt)(R9n,(0,p.Z)({},I9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}S9n.isMDXComponent=!0;const P9n={toc:[]},E9n="wrapper";function O9n(t){let{components:e,...n}=t;return(0,s.kt)(E9n,(0,p.Z)({},P9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}O9n.isMDXComponent=!0;const G9n={toc:[]},F9n="wrapper";function B9n(t){let{components:e,...n}=t;return(0,s.kt)(F9n,(0,p.Z)({},G9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}B9n.isMDXComponent=!0;const U9n={toc:[]},V9n="wrapper";function q9n(t){let{components:e,...n}=t;return(0,s.kt)(V9n,(0,p.Z)({},U9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q9n.isMDXComponent=!0;const j9n={toc:[]},Y9n="wrapper";function H9n(t){let{components:e,...n}=t;return(0,s.kt)(Y9n,(0,p.Z)({},j9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}H9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function J9n(t){let{components:e,...n}=t;return(0,s.kt)($9n,(0,p.Z)({},Q9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}J9n.isMDXComponent=!0;const K9n={toc:[]},tto="wrapper";function eto(t){let{components:e,...n}=t;return(0,s.kt)(tto,(0,p.Z)({},K9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eto.isMDXComponent=!0;const nto={toc:[]},oto="wrapper";function pto(t){let{components:e,...n}=t;return(0,s.kt)(oto,(0,p.Z)({},nto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(t){let{components:e,...n}=t;return(0,s.kt)(sto,(0,p.Z)({},rto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cto.isMDXComponent=!0;const ito={toc:[]},ato="wrapper";function lto(t){let{components:e,...n}=t;return(0,s.kt)(ato,(0,p.Z)({},ito,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function dto(t){let{components:e,...n}=t;return(0,s.kt)(mto,(0,p.Z)({},uto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dto.isMDXComponent=!0;const hto={toc:[]},fto="wrapper";function kto(t){let{components:e,...n}=t;return(0,s.kt)(fto,(0,p.Z)({},hto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kto.isMDXComponent=!0;const yto={toc:[]},Dto="wrapper";function Mto(t){let{components:e,...n}=t;return(0,s.kt)(Dto,(0,p.Z)({},yto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(t){let{components:e,...n}=t;return(0,s.kt)(_to,(0,p.Z)({},Xto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}wto.isMDXComponent=!0;const Tto={toc:[]},gto="wrapper";function Cto(t){let{components:e,...n}=t;return(0,s.kt)(gto,(0,p.Z)({},Tto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Cto.isMDXComponent=!0;const xto={toc:[]},vto="wrapper";function Lto(t){let{components:e,...n}=t;return(0,s.kt)(vto,(0,p.Z)({},xto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lto.isMDXComponent=!0;const Zto={toc:[]},bto="wrapper";function Nto(t){let{components:e,...n}=t;return(0,s.kt)(bto,(0,p.Z)({},Zto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Nto.isMDXComponent=!0;const Ato={toc:[]},zto="wrapper";function Wto(t){let{components:e,...n}=t;return(0,s.kt)(zto,(0,p.Z)({},Ato,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Wto.isMDXComponent=!0;const Ito={toc:[]},Rto="wrapper";function Sto(t){let{components:e,...n}=t;return(0,s.kt)(Rto,(0,p.Z)({},Ito,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Sto.isMDXComponent=!0;const Pto={toc:[]},Eto="wrapper";function Oto(t){let{components:e,...n}=t;return(0,s.kt)(Eto,(0,p.Z)({},Pto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Oto.isMDXComponent=!0;const Gto={toc:[]},Fto="wrapper";function Bto(t){let{components:e,...n}=t;return(0,s.kt)(Fto,(0,p.Z)({},Gto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Bto.isMDXComponent=!0;const Uto={toc:[]},Vto="wrapper";function qto(t){let{components:e,...n}=t;return(0,s.kt)(Vto,(0,p.Z)({},Uto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qto.isMDXComponent=!0;const jto={toc:[]},Yto="wrapper";function Hto(t){let{components:e,...n}=t;return(0,s.kt)(Yto,(0,p.Z)({},jto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hto.isMDXComponent=!0;const Qto={toc:[]},$to="wrapper";function Jto(t){let{components:e,...n}=t;return(0,s.kt)($to,(0,p.Z)({},Qto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jto.isMDXComponent=!0;const Kto={toc:[]},teo="wrapper";function eeo(t){let{components:e,...n}=t;return(0,s.kt)(teo,(0,p.Z)({},Kto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}eeo.isMDXComponent=!0;const neo={toc:[]},oeo="wrapper";function peo(t){let{components:e,...n}=t;return(0,s.kt)(oeo,(0,p.Z)({},neo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(t){let{components:e,...n}=t;return(0,s.kt)(seo,(0,p.Z)({},reo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ceo.isMDXComponent=!0;const ieo={toc:[]},aeo="wrapper";function leo(t){let{components:e,...n}=t;return(0,s.kt)(aeo,(0,p.Z)({},ieo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function deo(t){let{components:e,...n}=t;return(0,s.kt)(meo,(0,p.Z)({},ueo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}deo.isMDXComponent=!0;const heo={toc:[]},feo="wrapper";function keo(t){let{components:e,...n}=t;return(0,s.kt)(feo,(0,p.Z)({},heo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}keo.isMDXComponent=!0;const yeo={toc:[]},Deo="wrapper";function Meo(t){let{components:e,...n}=t;return(0,s.kt)(Deo,(0,p.Z)({},yeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(t){let{components:e,...n}=t;return(0,s.kt)(_eo,(0,p.Z)({},Xeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}weo.isMDXComponent=!0;const Teo={toc:[]},geo="wrapper";function Ceo(t){let{components:e,...n}=t;return(0,s.kt)(geo,(0,p.Z)({},Teo,n,{components:e,mdxType:"MDXLayout"}))}Ceo.isMDXComponent=!0;const xeo={toc:[]},veo="wrapper";function Leo(t){let{components:e,...n}=t;return(0,s.kt)(veo,(0,p.Z)({},xeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Leo.isMDXComponent=!0;const Zeo={toc:[]},beo="wrapper";function Neo(t){let{components:e,...n}=t;return(0,s.kt)(beo,(0,p.Z)({},Zeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Neo.isMDXComponent=!0;const Aeo={toc:[]},zeo="wrapper";function Weo(t){let{components:e,...n}=t;return(0,s.kt)(zeo,(0,p.Z)({},Aeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Weo.isMDXComponent=!0;const Ieo={toc:[]},Reo="wrapper";function Seo(t){let{components:e,...n}=t;return(0,s.kt)(Reo,(0,p.Z)({},Ieo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Seo.isMDXComponent=!0;const Peo={toc:[]},Eeo="wrapper";function Oeo(t){let{components:e,...n}=t;return(0,s.kt)(Eeo,(0,p.Z)({},Peo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Oeo.isMDXComponent=!0;const Geo={toc:[]},Feo="wrapper";function Beo(t){let{components:e,...n}=t;return(0,s.kt)(Feo,(0,p.Z)({},Geo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Beo.isMDXComponent=!0;const Ueo={toc:[]},Veo="wrapper";function qeo(t){let{components:e,...n}=t;return(0,s.kt)(Veo,(0,p.Z)({},Ueo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qeo.isMDXComponent=!0;const jeo={toc:[]},Yeo="wrapper";function Heo(t){let{components:e,...n}=t;return(0,s.kt)(Yeo,(0,p.Z)({},jeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Heo.isMDXComponent=!0;const Qeo={toc:[]},$eo="wrapper";function Jeo(t){let{components:e,...n}=t;return(0,s.kt)($eo,(0,p.Z)({},Qeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Jeo.isMDXComponent=!0;const Keo={toc:[]},tno="wrapper";function eno(t){let{components:e,...n}=t;return(0,s.kt)(tno,(0,p.Z)({},Keo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eno.isMDXComponent=!0;const nno={toc:[]},ono="wrapper";function pno(t){let{components:e,...n}=t;return(0,s.kt)(ono,(0,p.Z)({},nno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(t){let{components:e,...n}=t;return(0,s.kt)(sno,(0,p.Z)({},rno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cno.isMDXComponent=!0;const ino={toc:[]},ano="wrapper";function lno(t){let{components:e,...n}=t;return(0,s.kt)(ano,(0,p.Z)({},ino,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function dno(t){let{components:e,...n}=t;return(0,s.kt)(mno,(0,p.Z)({},uno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dno.isMDXComponent=!0;const hno={toc:[]},fno="wrapper";function kno(t){let{components:e,...n}=t;return(0,s.kt)(fno,(0,p.Z)({},hno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kno.isMDXComponent=!0;const yno={toc:[]},Dno="wrapper";function Mno(t){let{components:e,...n}=t;return(0,s.kt)(Dno,(0,p.Z)({},yno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(t){let{components:e,...n}=t;return(0,s.kt)(_no,(0,p.Z)({},Xno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wno.isMDXComponent=!0;const Tno={toc:[]},gno="wrapper";function Cno(t){let{components:e,...n}=t;return(0,s.kt)(gno,(0,p.Z)({},Tno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Cno.isMDXComponent=!0;const xno={toc:[]},vno="wrapper";function Lno(t){let{components:e,...n}=t;return(0,s.kt)(vno,(0,p.Z)({},xno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Lno.isMDXComponent=!0;const Zno={toc:[]},bno="wrapper";function Nno(t){let{components:e,...n}=t;return(0,s.kt)(bno,(0,p.Z)({},Zno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Nno.isMDXComponent=!0;const Ano={toc:[]},zno="wrapper";function Wno(t){let{components:e,...n}=t;return(0,s.kt)(zno,(0,p.Z)({},Ano,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Wno.isMDXComponent=!0;const Ino={toc:[]},Rno="wrapper";function Sno(t){let{components:e,...n}=t;return(0,s.kt)(Rno,(0,p.Z)({},Ino,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Sno.isMDXComponent=!0;const Pno={toc:[]},Eno="wrapper";function Ono(t){let{components:e,...n}=t;return(0,s.kt)(Eno,(0,p.Z)({},Pno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ono.isMDXComponent=!0;const Gno={toc:[]},Fno="wrapper";function Bno(t){let{components:e,...n}=t;return(0,s.kt)(Fno,(0,p.Z)({},Gno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bno.isMDXComponent=!0;const Uno={toc:[]},Vno="wrapper";function qno(t){let{components:e,...n}=t;return(0,s.kt)(Vno,(0,p.Z)({},Uno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}qno.isMDXComponent=!0;const jno={toc:[]},Yno="wrapper";function Hno(t){let{components:e,...n}=t;return(0,s.kt)(Yno,(0,p.Z)({},jno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Hno.isMDXComponent=!0;const Qno={toc:[]},$no="wrapper";function Jno(t){let{components:e,...n}=t;return(0,s.kt)($no,(0,p.Z)({},Qno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Jno.isMDXComponent=!0;const Kno={toc:[]},too="wrapper";function eoo(t){let{components:e,...n}=t;return(0,s.kt)(too,(0,p.Z)({},Kno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}eoo.isMDXComponent=!0;const noo={toc:[]},ooo="wrapper";function poo(t){let{components:e,...n}=t;return(0,s.kt)(ooo,(0,p.Z)({},noo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(t){let{components:e,...n}=t;return(0,s.kt)(soo,(0,p.Z)({},roo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}coo.isMDXComponent=!0;const ioo={toc:[]},aoo="wrapper";function loo(t){let{components:e,...n}=t;return(0,s.kt)(aoo,(0,p.Z)({},ioo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function doo(t){let{components:e,...n}=t;return(0,s.kt)(moo,(0,p.Z)({},uoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}doo.isMDXComponent=!0;const hoo={toc:[]},foo="wrapper";function koo(t){let{components:e,...n}=t;return(0,s.kt)(foo,(0,p.Z)({},hoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}koo.isMDXComponent=!0;const yoo={toc:[]},Doo="wrapper";function Moo(t){let{components:e,...n}=t;return(0,s.kt)(Doo,(0,p.Z)({},yoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(t){let{components:e,...n}=t;return(0,s.kt)(_oo,(0,p.Z)({},Xoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}woo.isMDXComponent=!0;const Too={toc:[]},goo="wrapper";function Coo(t){let{components:e,...n}=t;return(0,s.kt)(goo,(0,p.Z)({},Too,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Coo.isMDXComponent=!0;const xoo={toc:[]},voo="wrapper";function Loo(t){let{components:e,...n}=t;return(0,s.kt)(voo,(0,p.Z)({},xoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Loo.isMDXComponent=!0;const Zoo={toc:[]},boo="wrapper";function Noo(t){let{components:e,...n}=t;return(0,s.kt)(boo,(0,p.Z)({},Zoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Noo.isMDXComponent=!0;const Aoo={toc:[]},zoo="wrapper";function Woo(t){let{components:e,...n}=t;return(0,s.kt)(zoo,(0,p.Z)({},Aoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Woo.isMDXComponent=!0;const Ioo={toc:[]},Roo="wrapper";function Soo(t){let{components:e,...n}=t;return(0,s.kt)(Roo,(0,p.Z)({},Ioo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Soo.isMDXComponent=!0;const Poo={toc:[]},Eoo="wrapper";function Ooo(t){let{components:e,...n}=t;return(0,s.kt)(Eoo,(0,p.Z)({},Poo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ooo.isMDXComponent=!0;const Goo={toc:[]},Foo="wrapper";function Boo(t){let{components:e,...n}=t;return(0,s.kt)(Foo,(0,p.Z)({},Goo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Boo.isMDXComponent=!0;const Uoo={toc:[]},Voo="wrapper";function qoo(t){let{components:e,...n}=t;return(0,s.kt)(Voo,(0,p.Z)({},Uoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qoo.isMDXComponent=!0;const joo={toc:[]},Yoo="wrapper";function Hoo(t){let{components:e,...n}=t;return(0,s.kt)(Yoo,(0,p.Z)({},joo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Hoo.isMDXComponent=!0;const Qoo={toc:[]},$oo="wrapper";function Joo(t){let{components:e,...n}=t;return(0,s.kt)($oo,(0,p.Z)({},Qoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Joo.isMDXComponent=!0;const Koo={toc:[]},tpo="wrapper";function epo(t){let{components:e,...n}=t;return(0,s.kt)(tpo,(0,p.Z)({},Koo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}epo.isMDXComponent=!0;const npo={toc:[]},opo="wrapper";function ppo(t){let{components:e,...n}=t;return(0,s.kt)(opo,(0,p.Z)({},npo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(t){let{components:e,...n}=t;return(0,s.kt)(spo,(0,p.Z)({},rpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cpo.isMDXComponent=!0;const ipo={toc:[]},apo="wrapper";function lpo(t){let{components:e,...n}=t;return(0,s.kt)(apo,(0,p.Z)({},ipo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function dpo(t){let{components:e,...n}=t;return(0,s.kt)(mpo,(0,p.Z)({},upo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dpo.isMDXComponent=!0;const hpo={toc:[]},fpo="wrapper";function kpo(t){let{components:e,...n}=t;return(0,s.kt)(fpo,(0,p.Z)({},hpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kpo.isMDXComponent=!0;const ypo={toc:[]},Dpo="wrapper";function Mpo(t){let{components:e,...n}=t;return(0,s.kt)(Dpo,(0,p.Z)({},ypo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(t){let{components:e,...n}=t;return(0,s.kt)(_po,(0,p.Z)({},Xpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},gpo="wrapper";function Cpo(t){let{components:e,...n}=t;return(0,s.kt)(gpo,(0,p.Z)({},Tpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cpo.isMDXComponent=!0;const xpo={toc:[]},vpo="wrapper";function Lpo(t){let{components:e,...n}=t;return(0,s.kt)(vpo,(0,p.Z)({},xpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lpo.isMDXComponent=!0;const Zpo={toc:[]},bpo="wrapper";function Npo(t){let{components:e,...n}=t;return(0,s.kt)(bpo,(0,p.Z)({},Zpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Npo.isMDXComponent=!0;const Apo={toc:[]},zpo="wrapper";function Wpo(t){let{components:e,...n}=t;return(0,s.kt)(zpo,(0,p.Z)({},Apo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Wpo.isMDXComponent=!0;const Ipo={toc:[]},Rpo="wrapper";function Spo(t){let{components:e,...n}=t;return(0,s.kt)(Rpo,(0,p.Z)({},Ipo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Spo.isMDXComponent=!0;const Ppo={toc:[]},Epo="wrapper";function Opo(t){let{components:e,...n}=t;return(0,s.kt)(Epo,(0,p.Z)({},Ppo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Opo.isMDXComponent=!0;const Gpo={toc:[]},Fpo="wrapper";function Bpo(t){let{components:e,...n}=t;return(0,s.kt)(Fpo,(0,p.Z)({},Gpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Bpo.isMDXComponent=!0;const Upo={toc:[]},Vpo="wrapper";function qpo(t){let{components:e,...n}=t;return(0,s.kt)(Vpo,(0,p.Z)({},Upo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}qpo.isMDXComponent=!0;const jpo={toc:[]},Ypo="wrapper";function Hpo(t){let{components:e,...n}=t;return(0,s.kt)(Ypo,(0,p.Z)({},jpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Hpo.isMDXComponent=!0;const Qpo={toc:[]},$po="wrapper";function Jpo(t){let{components:e,...n}=t;return(0,s.kt)($po,(0,p.Z)({},Qpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jpo.isMDXComponent=!0;const Kpo={toc:[]},tro="wrapper";function ero(t){let{components:e,...n}=t;return(0,s.kt)(tro,(0,p.Z)({},Kpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ero.isMDXComponent=!0;const nro={toc:[]},oro="wrapper";function pro(t){let{components:e,...n}=t;return(0,s.kt)(oro,(0,p.Z)({},nro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(t){let{components:e,...n}=t;return(0,s.kt)(sro,(0,p.Z)({},rro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cro.isMDXComponent=!0;const iro={toc:[]},aro="wrapper";function lro(t){let{components:e,...n}=t;return(0,s.kt)(aro,(0,p.Z)({},iro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function dro(t){let{components:e,...n}=t;return(0,s.kt)(mro,(0,p.Z)({},uro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dro.isMDXComponent=!0;const hro={toc:[]},fro="wrapper";function kro(t){let{components:e,...n}=t;return(0,s.kt)(fro,(0,p.Z)({},hro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}kro.isMDXComponent=!0;const yro={toc:[]},Dro="wrapper";function Mro(t){let{components:e,...n}=t;return(0,s.kt)(Dro,(0,p.Z)({},yro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(t){let{components:e,...n}=t;return(0,s.kt)(_ro,(0,p.Z)({},Xro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wro.isMDXComponent=!0;const Tro={toc:[]},gro="wrapper";function Cro(t){let{components:e,...n}=t;return(0,s.kt)(gro,(0,p.Z)({},Tro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Cro.isMDXComponent=!0;const xro={toc:[]},vro="wrapper";function Lro(t){let{components:e,...n}=t;return(0,s.kt)(vro,(0,p.Z)({},xro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lro.isMDXComponent=!0;const Zro={toc:[]},bro="wrapper";function Nro(t){let{components:e,...n}=t;return(0,s.kt)(bro,(0,p.Z)({},Zro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Nro.isMDXComponent=!0;const Aro={toc:[]},zro="wrapper";function Wro(t){let{components:e,...n}=t;return(0,s.kt)(zro,(0,p.Z)({},Aro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Wro.isMDXComponent=!0;const Iro={toc:[]},Rro="wrapper";function Sro(t){let{components:e,...n}=t;return(0,s.kt)(Rro,(0,p.Z)({},Iro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Sro.isMDXComponent=!0;const Pro={toc:[]},Ero="wrapper";function Oro(t){let{components:e,...n}=t;return(0,s.kt)(Ero,(0,p.Z)({},Pro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Oro.isMDXComponent=!0;const Gro={toc:[]},Fro="wrapper";function Bro(t){let{components:e,...n}=t;return(0,s.kt)(Fro,(0,p.Z)({},Gro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Bro.isMDXComponent=!0;const Uro={toc:[]},Vro="wrapper";function qro(t){let{components:e,...n}=t;return(0,s.kt)(Vro,(0,p.Z)({},Uro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qro.isMDXComponent=!0;const jro={toc:[]},Yro="wrapper";function Hro(t){let{components:e,...n}=t;return(0,s.kt)(Yro,(0,p.Z)({},jro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Hro.isMDXComponent=!0;const Qro={toc:[]},$ro="wrapper";function Jro(t){let{components:e,...n}=t;return(0,s.kt)($ro,(0,p.Z)({},Qro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Jro.isMDXComponent=!0;const Kro={toc:[]},tso="wrapper";function eso(t){let{components:e,...n}=t;return(0,s.kt)(tso,(0,p.Z)({},Kro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eso.isMDXComponent=!0;const nso={toc:[]},oso="wrapper";function pso(t){let{components:e,...n}=t;return(0,s.kt)(oso,(0,p.Z)({},nso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(t){let{components:e,...n}=t;return(0,s.kt)(sso,(0,p.Z)({},rso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cso.isMDXComponent=!0;const iso={toc:[]},aso="wrapper";function lso(t){let{components:e,...n}=t;return(0,s.kt)(aso,(0,p.Z)({},iso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function dso(t){let{components:e,...n}=t;return(0,s.kt)(mso,(0,p.Z)({},uso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dso.isMDXComponent=!0;const hso={toc:[]},fso="wrapper";function kso(t){let{components:e,...n}=t;return(0,s.kt)(fso,(0,p.Z)({},hso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}kso.isMDXComponent=!0;const yso={toc:[]},Dso="wrapper";function Mso(t){let{components:e,...n}=t;return(0,s.kt)(Dso,(0,p.Z)({},yso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(t){let{components:e,...n}=t;return(0,s.kt)(_so,(0,p.Z)({},Xso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}wso.isMDXComponent=!0;const Tso={toc:[]},gso="wrapper";function Cso(t){let{components:e,...n}=t;return(0,s.kt)(gso,(0,p.Z)({},Tso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Cso.isMDXComponent=!0;const xso={toc:[]},vso="wrapper";function Lso(t){let{components:e,...n}=t;return(0,s.kt)(vso,(0,p.Z)({},xso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Lso.isMDXComponent=!0;const Zso={toc:[]},bso="wrapper";function Nso(t){let{components:e,...n}=t;return(0,s.kt)(bso,(0,p.Z)({},Zso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Nso.isMDXComponent=!0;const Aso={toc:[]},zso="wrapper";function Wso(t){let{components:e,...n}=t;return(0,s.kt)(zso,(0,p.Z)({},Aso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Wso.isMDXComponent=!0;const Iso={toc:[]},Rso="wrapper";function Sso(t){let{components:e,...n}=t;return(0,s.kt)(Rso,(0,p.Z)({},Iso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Sso.isMDXComponent=!0;const Pso={toc:[]},Eso="wrapper";function Oso(t){let{components:e,...n}=t;return(0,s.kt)(Eso,(0,p.Z)({},Pso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Oso.isMDXComponent=!0;const Gso={toc:[]},Fso="wrapper";function Bso(t){let{components:e,...n}=t;return(0,s.kt)(Fso,(0,p.Z)({},Gso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Bso.isMDXComponent=!0;const Uso={toc:[]},Vso="wrapper";function qso(t){let{components:e,...n}=t;return(0,s.kt)(Vso,(0,p.Z)({},Uso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qso.isMDXComponent=!0;const jso={toc:[]},Yso="wrapper";function Hso(t){let{components:e,...n}=t;return(0,s.kt)(Yso,(0,p.Z)({},jso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hso.isMDXComponent=!0;const Qso={toc:[]},$so="wrapper";function Jso(t){let{components:e,...n}=t;return(0,s.kt)($so,(0,p.Z)({},Qso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Jso.isMDXComponent=!0;const Kso={toc:[]},tco="wrapper";function eco(t){let{components:e,...n}=t;return(0,s.kt)(tco,(0,p.Z)({},Kso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}eco.isMDXComponent=!0;const nco={toc:[]},oco="wrapper";function pco(t){let{components:e,...n}=t;return(0,s.kt)(oco,(0,p.Z)({},nco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(t){let{components:e,...n}=t;return(0,s.kt)(sco,(0,p.Z)({},rco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cco.isMDXComponent=!0;const ico={toc:[]},aco="wrapper";function lco(t){let{components:e,...n}=t;return(0,s.kt)(aco,(0,p.Z)({},ico,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function dco(t){let{components:e,...n}=t;return(0,s.kt)(mco,(0,p.Z)({},uco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dco.isMDXComponent=!0;const hco={toc:[]},fco="wrapper";function kco(t){let{components:e,...n}=t;return(0,s.kt)(fco,(0,p.Z)({},hco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kco.isMDXComponent=!0;const yco={toc:[]},Dco="wrapper";function Mco(t){let{components:e,...n}=t;return(0,s.kt)(Dco,(0,p.Z)({},yco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(t){let{components:e,...n}=t;return(0,s.kt)(_co,(0,p.Z)({},Xco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wco.isMDXComponent=!0;const Tco={toc:[]},gco="wrapper";function Cco(t){let{components:e,...n}=t;return(0,s.kt)(gco,(0,p.Z)({},Tco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Cco.isMDXComponent=!0;const xco={toc:[]},vco="wrapper";function Lco(t){let{components:e,...n}=t;return(0,s.kt)(vco,(0,p.Z)({},xco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lco.isMDXComponent=!0;const Zco={toc:[]},bco="wrapper";function Nco(t){let{components:e,...n}=t;return(0,s.kt)(bco,(0,p.Z)({},Zco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nco.isMDXComponent=!0;const Aco={toc:[]},zco="wrapper";function Wco(t){let{components:e,...n}=t;return(0,s.kt)(zco,(0,p.Z)({},Aco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Wco.isMDXComponent=!0;const Ico={toc:[]},Rco="wrapper";function Sco(t){let{components:e,...n}=t;return(0,s.kt)(Rco,(0,p.Z)({},Ico,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Sco.isMDXComponent=!0;const Pco={toc:[]},Eco="wrapper";function Oco(t){let{components:e,...n}=t;return(0,s.kt)(Eco,(0,p.Z)({},Pco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Oco.isMDXComponent=!0;const Gco={toc:[]},Fco="wrapper";function Bco(t){let{components:e,...n}=t;return(0,s.kt)(Fco,(0,p.Z)({},Gco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Bco.isMDXComponent=!0;const Uco={toc:[]},Vco="wrapper";function qco(t){let{components:e,...n}=t;return(0,s.kt)(Vco,(0,p.Z)({},Uco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qco.isMDXComponent=!0;const jco={toc:[]},Yco="wrapper";function Hco(t){let{components:e,...n}=t;return(0,s.kt)(Yco,(0,p.Z)({},jco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Hco.isMDXComponent=!0;const Qco={toc:[]},$co="wrapper";function Jco(t){let{components:e,...n}=t;return(0,s.kt)($co,(0,p.Z)({},Qco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Jco.isMDXComponent=!0;const Kco={toc:[]},tio="wrapper";function eio(t){let{components:e,...n}=t;return(0,s.kt)(tio,(0,p.Z)({},Kco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}eio.isMDXComponent=!0;const nio={toc:[]},oio="wrapper";function pio(t){let{components:e,...n}=t;return(0,s.kt)(oio,(0,p.Z)({},nio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(t){let{components:e,...n}=t;return(0,s.kt)(sio,(0,p.Z)({},rio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cio.isMDXComponent=!0;const iio={toc:[]},aio="wrapper";function lio(t){let{components:e,...n}=t;return(0,s.kt)(aio,(0,p.Z)({},iio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function dio(t){let{components:e,...n}=t;return(0,s.kt)(mio,(0,p.Z)({},uio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dio.isMDXComponent=!0;const hio={toc:[]},fio="wrapper";function kio(t){let{components:e,...n}=t;return(0,s.kt)(fio,(0,p.Z)({},hio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kio.isMDXComponent=!0;const yio={toc:[]},Dio="wrapper";function Mio(t){let{components:e,...n}=t;return(0,s.kt)(Dio,(0,p.Z)({},yio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(t){let{components:e,...n}=t;return(0,s.kt)(_io,(0,p.Z)({},Xio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wio.isMDXComponent=!0;const Tio={toc:[]},gio="wrapper";function Cio(t){let{components:e,...n}=t;return(0,s.kt)(gio,(0,p.Z)({},Tio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Cio.isMDXComponent=!0;const xio={toc:[]},vio="wrapper";function Lio(t){let{components:e,...n}=t;return(0,s.kt)(vio,(0,p.Z)({},xio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lio.isMDXComponent=!0;const Zio={toc:[]},bio="wrapper";function Nio(t){let{components:e,...n}=t;return(0,s.kt)(bio,(0,p.Z)({},Zio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nio.isMDXComponent=!0;const Aio={toc:[]},zio="wrapper";function Wio(t){let{components:e,...n}=t;return(0,s.kt)(zio,(0,p.Z)({},Aio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wio.isMDXComponent=!0;const Iio={toc:[]},Rio="wrapper";function Sio(t){let{components:e,...n}=t;return(0,s.kt)(Rio,(0,p.Z)({},Iio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Sio.isMDXComponent=!0;const Pio={toc:[]},Eio="wrapper";function Oio(t){let{components:e,...n}=t;return(0,s.kt)(Eio,(0,p.Z)({},Pio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Oio.isMDXComponent=!0;const Gio={toc:[]},Fio="wrapper";function Bio(t){let{components:e,...n}=t;return(0,s.kt)(Fio,(0,p.Z)({},Gio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bio.isMDXComponent=!0;const Uio={toc:[]},Vio="wrapper";function qio(t){let{components:e,...n}=t;return(0,s.kt)(Vio,(0,p.Z)({},Uio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qio.isMDXComponent=!0;const jio={toc:[]},Yio="wrapper";function Hio(t){let{components:e,...n}=t;return(0,s.kt)(Yio,(0,p.Z)({},jio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hio.isMDXComponent=!0;const Qio={toc:[]},$io="wrapper";function Jio(t){let{components:e,...n}=t;return(0,s.kt)($io,(0,p.Z)({},Qio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Jio.isMDXComponent=!0;const Kio={toc:[]},tao="wrapper";function eao(t){let{components:e,...n}=t;return(0,s.kt)(tao,(0,p.Z)({},Kio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}eao.isMDXComponent=!0;const nao={toc:[]},oao="wrapper";function pao(t){let{components:e,...n}=t;return(0,s.kt)(oao,(0,p.Z)({},nao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(t){let{components:e,...n}=t;return(0,s.kt)(sao,(0,p.Z)({},rao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cao.isMDXComponent=!0;const iao={toc:[]},aao="wrapper";function lao(t){let{components:e,...n}=t;return(0,s.kt)(aao,(0,p.Z)({},iao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function dao(t){let{components:e,...n}=t;return(0,s.kt)(mao,(0,p.Z)({},uao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dao.isMDXComponent=!0;const hao={toc:[]},fao="wrapper";function kao(t){let{components:e,...n}=t;return(0,s.kt)(fao,(0,p.Z)({},hao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kao.isMDXComponent=!0;const yao={toc:[]},Dao="wrapper";function Mao(t){let{components:e,...n}=t;return(0,s.kt)(Dao,(0,p.Z)({},yao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(t){let{components:e,...n}=t;return(0,s.kt)(_ao,(0,p.Z)({},Xao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wao.isMDXComponent=!0;const Tao={toc:[]},gao="wrapper";function Cao(t){let{components:e,...n}=t;return(0,s.kt)(gao,(0,p.Z)({},Tao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Cao.isMDXComponent=!0;const xao={toc:[]},vao="wrapper";function Lao(t){let{components:e,...n}=t;return(0,s.kt)(vao,(0,p.Z)({},xao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Lao.isMDXComponent=!0;const Zao={toc:[]},bao="wrapper";function Nao(t){let{components:e,...n}=t;return(0,s.kt)(bao,(0,p.Z)({},Zao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}Nao.isMDXComponent=!0;const Aao={toc:[]},zao="wrapper";function Wao(t){let{components:e,...n}=t;return(0,s.kt)(zao,(0,p.Z)({},Aao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}Wao.isMDXComponent=!0;const Iao={toc:[]},Rao="wrapper";function Sao(t){let{components:e,...n}=t;return(0,s.kt)(Rao,(0,p.Z)({},Iao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Sao.isMDXComponent=!0;const Pao={toc:[]},Eao="wrapper";function Oao(t){let{components:e,...n}=t;return(0,s.kt)(Eao,(0,p.Z)({},Pao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Oao.isMDXComponent=!0;const Gao={toc:[]},Fao="wrapper";function Bao(t){let{components:e,...n}=t;return(0,s.kt)(Fao,(0,p.Z)({},Gao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Bao.isMDXComponent=!0;const Uao={toc:[]},Vao="wrapper";function qao(t){let{components:e,...n}=t;return(0,s.kt)(Vao,(0,p.Z)({},Uao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qao.isMDXComponent=!0;const jao={toc:[]},Yao="wrapper";function Hao(t){let{components:e,...n}=t;return(0,s.kt)(Yao,(0,p.Z)({},jao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Hao.isMDXComponent=!0;const Qao={toc:[]},$ao="wrapper";function Jao(t){let{components:e,...n}=t;return(0,s.kt)($ao,(0,p.Z)({},Qao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Jao.isMDXComponent=!0;const Kao={toc:[]},tlo="wrapper";function elo(t){let{components:e,...n}=t;return(0,s.kt)(tlo,(0,p.Z)({},Kao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}elo.isMDXComponent=!0;const nlo={toc:[]},olo="wrapper";function plo(t){let{components:e,...n}=t;return(0,s.kt)(olo,(0,p.Z)({},nlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(t){let{components:e,...n}=t;return(0,s.kt)(slo,(0,p.Z)({},rlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}clo.isMDXComponent=!0;const ilo={toc:[]},alo="wrapper";function llo(t){let{components:e,...n}=t;return(0,s.kt)(alo,(0,p.Z)({},ilo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function dlo(t){let{components:e,...n}=t;return(0,s.kt)(mlo,(0,p.Z)({},ulo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}dlo.isMDXComponent=!0;const hlo={toc:[]},flo="wrapper";function klo(t){let{components:e,...n}=t;return(0,s.kt)(flo,(0,p.Z)({},hlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}klo.isMDXComponent=!0;const ylo={toc:[]},Dlo="wrapper";function Mlo(t){let{components:e,...n}=t;return(0,s.kt)(Dlo,(0,p.Z)({},ylo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(t){let{components:e,...n}=t;return(0,s.kt)(_lo,(0,p.Z)({},Xlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},glo="wrapper";function Clo(t){let{components:e,...n}=t;return(0,s.kt)(glo,(0,p.Z)({},Tlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Clo.isMDXComponent=!0;const xlo={toc:[]},vlo="wrapper";function Llo(t){let{components:e,...n}=t;return(0,s.kt)(vlo,(0,p.Z)({},xlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Llo.isMDXComponent=!0;const Zlo={toc:[]},blo="wrapper";function Nlo(t){let{components:e,...n}=t;return(0,s.kt)(blo,(0,p.Z)({},Zlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nlo.isMDXComponent=!0;const Alo={toc:[]},zlo="wrapper";function Wlo(t){let{components:e,...n}=t;return(0,s.kt)(zlo,(0,p.Z)({},Alo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Wlo.isMDXComponent=!0;const Ilo={toc:[]},Rlo="wrapper";function Slo(t){let{components:e,...n}=t;return(0,s.kt)(Rlo,(0,p.Z)({},Ilo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Slo.isMDXComponent=!0;const Plo={toc:[]},Elo="wrapper";function Olo(t){let{components:e,...n}=t;return(0,s.kt)(Elo,(0,p.Z)({},Plo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Olo.isMDXComponent=!0;const Glo={toc:[]},Flo="wrapper";function Blo(t){let{components:e,...n}=t;return(0,s.kt)(Flo,(0,p.Z)({},Glo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Blo.isMDXComponent=!0;const Ulo={toc:[]},Vlo="wrapper";function qlo(t){let{components:e,...n}=t;return(0,s.kt)(Vlo,(0,p.Z)({},Ulo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qlo.isMDXComponent=!0;const jlo={toc:[]},Ylo="wrapper";function Hlo(t){let{components:e,...n}=t;return(0,s.kt)(Ylo,(0,p.Z)({},jlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Hlo.isMDXComponent=!0;const Qlo={toc:[]},$lo="wrapper";function Jlo(t){let{components:e,...n}=t;return(0,s.kt)($lo,(0,p.Z)({},Qlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Jlo.isMDXComponent=!0;const Klo={toc:[]},tuo="wrapper";function euo(t){let{components:e,...n}=t;return(0,s.kt)(tuo,(0,p.Z)({},Klo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}euo.isMDXComponent=!0;const nuo={toc:[]},ouo="wrapper";function puo(t){let{components:e,...n}=t;return(0,s.kt)(ouo,(0,p.Z)({},nuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(t){let{components:e,...n}=t;return(0,s.kt)(suo,(0,p.Z)({},ruo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cuo.isMDXComponent=!0;const iuo={toc:[]},auo="wrapper";function luo(t){let{components:e,...n}=t;return(0,s.kt)(auo,(0,p.Z)({},iuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function duo(t){let{components:e,...n}=t;return(0,s.kt)(muo,(0,p.Z)({},uuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}duo.isMDXComponent=!0;const huo={toc:[]},fuo="wrapper";function kuo(t){let{components:e,...n}=t;return(0,s.kt)(fuo,(0,p.Z)({},huo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}kuo.isMDXComponent=!0;const yuo={toc:[]},Duo="wrapper";function Muo(t){let{components:e,...n}=t;return(0,s.kt)(Duo,(0,p.Z)({},yuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(t){let{components:e,...n}=t;return(0,s.kt)(_uo,(0,p.Z)({},Xuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},guo="wrapper";function Cuo(t){let{components:e,...n}=t;return(0,s.kt)(guo,(0,p.Z)({},Tuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Cuo.isMDXComponent=!0;const xuo={toc:[]},vuo="wrapper";function Luo(t){let{components:e,...n}=t;return(0,s.kt)(vuo,(0,p.Z)({},xuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Luo.isMDXComponent=!0;const Zuo={toc:[]},buo="wrapper";function Nuo(t){let{components:e,...n}=t;return(0,s.kt)(buo,(0,p.Z)({},Zuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Nuo.isMDXComponent=!0;const Auo={toc:[]},zuo="wrapper";function Wuo(t){let{components:e,...n}=t;return(0,s.kt)(zuo,(0,p.Z)({},Auo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Wuo.isMDXComponent=!0;const Iuo={toc:[]},Ruo="wrapper";function Suo(t){let{components:e,...n}=t;return(0,s.kt)(Ruo,(0,p.Z)({},Iuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Suo.isMDXComponent=!0;const Puo={toc:[]},Euo="wrapper";function Ouo(t){let{components:e,...n}=t;return(0,s.kt)(Euo,(0,p.Z)({},Puo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ouo.isMDXComponent=!0;const Guo={toc:[]},Fuo="wrapper";function Buo(t){let{components:e,...n}=t;return(0,s.kt)(Fuo,(0,p.Z)({},Guo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Buo.isMDXComponent=!0;const Uuo={toc:[]},Vuo="wrapper";function quo(t){let{components:e,...n}=t;return(0,s.kt)(Vuo,(0,p.Z)({},Uuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}quo.isMDXComponent=!0;const juo={toc:[]},Yuo="wrapper";function Huo(t){let{components:e,...n}=t;return(0,s.kt)(Yuo,(0,p.Z)({},juo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Huo.isMDXComponent=!0;const Quo={toc:[]},$uo="wrapper";function Juo(t){let{components:e,...n}=t;return(0,s.kt)($uo,(0,p.Z)({},Quo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Juo.isMDXComponent=!0;const Kuo={toc:[]},tmo="wrapper";function emo(t){let{components:e,...n}=t;return(0,s.kt)(tmo,(0,p.Z)({},Kuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}emo.isMDXComponent=!0;const nmo={toc:[]},omo="wrapper";function pmo(t){let{components:e,...n}=t;return(0,s.kt)(omo,(0,p.Z)({},nmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(t){let{components:e,...n}=t;return(0,s.kt)(smo,(0,p.Z)({},rmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}cmo.isMDXComponent=!0;const imo={toc:[]},amo="wrapper";function lmo(t){let{components:e,...n}=t;return(0,s.kt)(amo,(0,p.Z)({},imo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function dmo(t){let{components:e,...n}=t;return(0,s.kt)(mmo,(0,p.Z)({},umo,n,{components:e,mdxType:"MDXLayout"}))}dmo.isMDXComponent=!0;const hmo={toc:[]},fmo="wrapper";function kmo(t){let{components:e,...n}=t;return(0,s.kt)(fmo,(0,p.Z)({},hmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kmo.isMDXComponent=!0;const ymo={toc:[]},Dmo="wrapper";function Mmo(t){let{components:e,...n}=t;return(0,s.kt)(Dmo,(0,p.Z)({},ymo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(t){let{components:e,...n}=t;return(0,s.kt)(_mo,(0,p.Z)({},Xmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},gmo="wrapper";function Cmo(t){let{components:e,...n}=t;return(0,s.kt)(gmo,(0,p.Z)({},Tmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Cmo.isMDXComponent=!0;const xmo={toc:[]},vmo="wrapper";function Lmo(t){let{components:e,...n}=t;return(0,s.kt)(vmo,(0,p.Z)({},xmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lmo.isMDXComponent=!0;const Zmo={toc:[]},bmo="wrapper";function Nmo(t){let{components:e,...n}=t;return(0,s.kt)(bmo,(0,p.Z)({},Zmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Nmo.isMDXComponent=!0;const Amo={toc:[]},zmo="wrapper";function Wmo(t){let{components:e,...n}=t;return(0,s.kt)(zmo,(0,p.Z)({},Amo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wmo.isMDXComponent=!0;const Imo={toc:[]},Rmo="wrapper";function Smo(t){let{components:e,...n}=t;return(0,s.kt)(Rmo,(0,p.Z)({},Imo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Smo.isMDXComponent=!0;const Pmo={toc:[]},Emo="wrapper";function Omo(t){let{components:e,...n}=t;return(0,s.kt)(Emo,(0,p.Z)({},Pmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Omo.isMDXComponent=!0;const Gmo={toc:[]},Fmo="wrapper";function Bmo(t){let{components:e,...n}=t;return(0,s.kt)(Fmo,(0,p.Z)({},Gmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bmo.isMDXComponent=!0;const Umo={toc:[]},Vmo="wrapper";function qmo(t){let{components:e,...n}=t;return(0,s.kt)(Vmo,(0,p.Z)({},Umo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qmo.isMDXComponent=!0;const jmo={toc:[]},Ymo="wrapper";function Hmo(t){let{components:e,...n}=t;return(0,s.kt)(Ymo,(0,p.Z)({},jmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Hmo.isMDXComponent=!0;const Qmo={toc:[]},$mo="wrapper";function Jmo(t){let{components:e,...n}=t;return(0,s.kt)($mo,(0,p.Z)({},Qmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Jmo.isMDXComponent=!0;const Kmo={toc:[]},tdo="wrapper";function edo(t){let{components:e,...n}=t;return(0,s.kt)(tdo,(0,p.Z)({},Kmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}edo.isMDXComponent=!0;const ndo={toc:[]},odo="wrapper";function pdo(t){let{components:e,...n}=t;return(0,s.kt)(odo,(0,p.Z)({},ndo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(t){let{components:e,...n}=t;return(0,s.kt)(sdo,(0,p.Z)({},rdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cdo.isMDXComponent=!0;const ido={toc:[]},ado="wrapper";function ldo(t){let{components:e,...n}=t;return(0,s.kt)(ado,(0,p.Z)({},ido,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ddo(t){let{components:e,...n}=t;return(0,s.kt)(mdo,(0,p.Z)({},udo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ddo.isMDXComponent=!0;const hdo={toc:[]},fdo="wrapper";function kdo(t){let{components:e,...n}=t;return(0,s.kt)(fdo,(0,p.Z)({},hdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}kdo.isMDXComponent=!0;const ydo={toc:[]},Ddo="wrapper";function Mdo(t){let{components:e,...n}=t;return(0,s.kt)(Ddo,(0,p.Z)({},ydo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(t){let{components:e,...n}=t;return(0,s.kt)(_do,(0,p.Z)({},Xdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},gdo="wrapper";function Cdo(t){let{components:e,...n}=t;return(0,s.kt)(gdo,(0,p.Z)({},Tdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Cdo.isMDXComponent=!0;const xdo={toc:[]},vdo="wrapper";function Ldo(t){let{components:e,...n}=t;return(0,s.kt)(vdo,(0,p.Z)({},xdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ldo.isMDXComponent=!0;const Zdo={toc:[]},bdo="wrapper";function Ndo(t){let{components:e,...n}=t;return(0,s.kt)(bdo,(0,p.Z)({},Zdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Ndo.isMDXComponent=!0;const Ado={toc:[]},zdo="wrapper";function Wdo(t){let{components:e,...n}=t;return(0,s.kt)(zdo,(0,p.Z)({},Ado,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wdo.isMDXComponent=!0;const Ido={toc:[]},Rdo="wrapper";function Sdo(t){let{components:e,...n}=t;return(0,s.kt)(Rdo,(0,p.Z)({},Ido,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Sdo.isMDXComponent=!0;const Pdo={toc:[]},Edo="wrapper";function Odo(t){let{components:e,...n}=t;return(0,s.kt)(Edo,(0,p.Z)({},Pdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Odo.isMDXComponent=!0;const Gdo={toc:[]},Fdo="wrapper";function Bdo(t){let{components:e,...n}=t;return(0,s.kt)(Fdo,(0,p.Z)({},Gdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bdo.isMDXComponent=!0;const Udo={toc:[]},Vdo="wrapper";function qdo(t){let{components:e,...n}=t;return(0,s.kt)(Vdo,(0,p.Z)({},Udo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qdo.isMDXComponent=!0;const jdo={toc:[]},Ydo="wrapper";function Hdo(t){let{components:e,...n}=t;return(0,s.kt)(Ydo,(0,p.Z)({},jdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Hdo.isMDXComponent=!0;const Qdo={toc:[]},$do="wrapper";function Jdo(t){let{components:e,...n}=t;return(0,s.kt)($do,(0,p.Z)({},Qdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Jdo.isMDXComponent=!0;const Kdo={toc:[]},tho="wrapper";function eho(t){let{components:e,...n}=t;return(0,s.kt)(tho,(0,p.Z)({},Kdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eho.isMDXComponent=!0;const nho={toc:[]},oho="wrapper";function pho(t){let{components:e,...n}=t;return(0,s.kt)(oho,(0,p.Z)({},nho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(t){let{components:e,...n}=t;return(0,s.kt)(sho,(0,p.Z)({},rho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cho.isMDXComponent=!0;const iho={toc:[]},aho="wrapper";function lho(t){let{components:e,...n}=t;return(0,s.kt)(aho,(0,p.Z)({},iho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function dho(t){let{components:e,...n}=t;return(0,s.kt)(mho,(0,p.Z)({},uho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dho.isMDXComponent=!0;const hho={toc:[]},fho="wrapper";function kho(t){let{components:e,...n}=t;return(0,s.kt)(fho,(0,p.Z)({},hho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}kho.isMDXComponent=!0;const yho={toc:[]},Dho="wrapper";function Mho(t){let{components:e,...n}=t;return(0,s.kt)(Dho,(0,p.Z)({},yho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(t){let{components:e,...n}=t;return(0,s.kt)(_ho,(0,p.Z)({},Xho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}who.isMDXComponent=!0;const Tho={toc:[]},gho="wrapper";function Cho(t){let{components:e,...n}=t;return(0,s.kt)(gho,(0,p.Z)({},Tho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Cho.isMDXComponent=!0;const xho={toc:[]},vho="wrapper";function Lho(t){let{components:e,...n}=t;return(0,s.kt)(vho,(0,p.Z)({},xho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lho.isMDXComponent=!0;const Zho={toc:[]},bho="wrapper";function Nho(t){let{components:e,...n}=t;return(0,s.kt)(bho,(0,p.Z)({},Zho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Nho.isMDXComponent=!0;const Aho={toc:[]},zho="wrapper";function Who(t){let{components:e,...n}=t;return(0,s.kt)(zho,(0,p.Z)({},Aho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Who.isMDXComponent=!0;const Iho={toc:[]},Rho="wrapper";function Sho(t){let{components:e,...n}=t;return(0,s.kt)(Rho,(0,p.Z)({},Iho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Sho.isMDXComponent=!0;const Pho={toc:[]},Eho="wrapper";function Oho(t){let{components:e,...n}=t;return(0,s.kt)(Eho,(0,p.Z)({},Pho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Oho.isMDXComponent=!0;const Gho={toc:[]},Fho="wrapper";function Bho(t){let{components:e,...n}=t;return(0,s.kt)(Fho,(0,p.Z)({},Gho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Bho.isMDXComponent=!0;const Uho={toc:[]},Vho="wrapper";function qho(t){let{components:e,...n}=t;return(0,s.kt)(Vho,(0,p.Z)({},Uho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qho.isMDXComponent=!0;const jho={toc:[]},Yho="wrapper";function Hho(t){let{components:e,...n}=t;return(0,s.kt)(Yho,(0,p.Z)({},jho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Hho.isMDXComponent=!0;const Qho={toc:[]},$ho="wrapper";function Jho(t){let{components:e,...n}=t;return(0,s.kt)($ho,(0,p.Z)({},Qho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Jho.isMDXComponent=!0;const Kho={toc:[]},tfo="wrapper";function efo(t){let{components:e,...n}=t;return(0,s.kt)(tfo,(0,p.Z)({},Kho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}efo.isMDXComponent=!0;const nfo={toc:[]},ofo="wrapper";function pfo(t){let{components:e,...n}=t;return(0,s.kt)(ofo,(0,p.Z)({},nfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(t){let{components:e,...n}=t;return(0,s.kt)(sfo,(0,p.Z)({},rfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cfo.isMDXComponent=!0;const ifo={toc:[]},afo="wrapper";function lfo(t){let{components:e,...n}=t;return(0,s.kt)(afo,(0,p.Z)({},ifo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function dfo(t){let{components:e,...n}=t;return(0,s.kt)(mfo,(0,p.Z)({},ufo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dfo.isMDXComponent=!0;const hfo={toc:[]},ffo="wrapper";function kfo(t){let{components:e,...n}=t;return(0,s.kt)(ffo,(0,p.Z)({},hfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kfo.isMDXComponent=!0;const yfo={toc:[]},Dfo="wrapper";function Mfo(t){let{components:e,...n}=t;return(0,s.kt)(Dfo,(0,p.Z)({},yfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(t){let{components:e,...n}=t;return(0,s.kt)(_fo,(0,p.Z)({},Xfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},gfo="wrapper";function Cfo(t){let{components:e,...n}=t;return(0,s.kt)(gfo,(0,p.Z)({},Tfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Cfo.isMDXComponent=!0;const xfo={toc:[]},vfo="wrapper";function Lfo(t){let{components:e,...n}=t;return(0,s.kt)(vfo,(0,p.Z)({},xfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lfo.isMDXComponent=!0;const Zfo={toc:[]},bfo="wrapper";function Nfo(t){let{components:e,...n}=t;return(0,s.kt)(bfo,(0,p.Z)({},Zfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nfo.isMDXComponent=!0;const Afo={toc:[]},zfo="wrapper";function Wfo(t){let{components:e,...n}=t;return(0,s.kt)(zfo,(0,p.Z)({},Afo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Wfo.isMDXComponent=!0;const Ifo={toc:[]},Rfo="wrapper";function Sfo(t){let{components:e,...n}=t;return(0,s.kt)(Rfo,(0,p.Z)({},Ifo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Sfo.isMDXComponent=!0;const Pfo={toc:[]},Efo="wrapper";function Ofo(t){let{components:e,...n}=t;return(0,s.kt)(Efo,(0,p.Z)({},Pfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ofo.isMDXComponent=!0;const Gfo={toc:[]},Ffo="wrapper";function Bfo(t){let{components:e,...n}=t;return(0,s.kt)(Ffo,(0,p.Z)({},Gfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bfo.isMDXComponent=!0;const Ufo={toc:[]},Vfo="wrapper";function qfo(t){let{components:e,...n}=t;return(0,s.kt)(Vfo,(0,p.Z)({},Ufo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qfo.isMDXComponent=!0;const jfo={toc:[]},Yfo="wrapper";function Hfo(t){let{components:e,...n}=t;return(0,s.kt)(Yfo,(0,p.Z)({},jfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Hfo.isMDXComponent=!0;const Qfo={toc:[]},$fo="wrapper";function Jfo(t){let{components:e,...n}=t;return(0,s.kt)($fo,(0,p.Z)({},Qfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Jfo.isMDXComponent=!0;const Kfo={toc:[]},tko="wrapper";function eko(t){let{components:e,...n}=t;return(0,s.kt)(tko,(0,p.Z)({},Kfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eko.isMDXComponent=!0;const nko={toc:[]},oko="wrapper";function pko(t){let{components:e,...n}=t;return(0,s.kt)(oko,(0,p.Z)({},nko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(t){let{components:e,...n}=t;return(0,s.kt)(sko,(0,p.Z)({},rko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cko.isMDXComponent=!0;const iko={toc:[]},ako="wrapper";function lko(t){let{components:e,...n}=t;return(0,s.kt)(ako,(0,p.Z)({},iko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function dko(t){let{components:e,...n}=t;return(0,s.kt)(mko,(0,p.Z)({},uko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dko.isMDXComponent=!0;const hko={toc:[]},fko="wrapper";function kko(t){let{components:e,...n}=t;return(0,s.kt)(fko,(0,p.Z)({},hko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kko.isMDXComponent=!0;const yko={toc:[]},Dko="wrapper";function Mko(t){let{components:e,...n}=t;return(0,s.kt)(Dko,(0,p.Z)({},yko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(t){let{components:e,...n}=t;return(0,s.kt)(_ko,(0,p.Z)({},Xko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wko.isMDXComponent=!0;const Tko={toc:[]},gko="wrapper";function Cko(t){let{components:e,...n}=t;return(0,s.kt)(gko,(0,p.Z)({},Tko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Cko.isMDXComponent=!0;const xko={toc:[]},vko="wrapper";function Lko(t){let{components:e,...n}=t;return(0,s.kt)(vko,(0,p.Z)({},xko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lko.isMDXComponent=!0;const Zko={toc:[]},bko="wrapper";function Nko(t){let{components:e,...n}=t;return(0,s.kt)(bko,(0,p.Z)({},Zko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nko.isMDXComponent=!0;const Ako={toc:[]},zko="wrapper";function Wko(t){let{components:e,...n}=t;return(0,s.kt)(zko,(0,p.Z)({},Ako,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wko.isMDXComponent=!0;const Iko={toc:[]},Rko="wrapper";function Sko(t){let{components:e,...n}=t;return(0,s.kt)(Rko,(0,p.Z)({},Iko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Sko.isMDXComponent=!0;const Pko={toc:[]},Eko="wrapper";function Oko(t){let{components:e,...n}=t;return(0,s.kt)(Eko,(0,p.Z)({},Pko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Oko.isMDXComponent=!0;const Gko={toc:[]},Fko="wrapper";function Bko(t){let{components:e,...n}=t;return(0,s.kt)(Fko,(0,p.Z)({},Gko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bko.isMDXComponent=!0;const Uko={toc:[]},Vko="wrapper";function qko(t){let{components:e,...n}=t;return(0,s.kt)(Vko,(0,p.Z)({},Uko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qko.isMDXComponent=!0;const jko={toc:[]},Yko="wrapper";function Hko(t){let{components:e,...n}=t;return(0,s.kt)(Yko,(0,p.Z)({},jko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Hko.isMDXComponent=!0;const Qko={toc:[]},$ko="wrapper";function Jko(t){let{components:e,...n}=t;return(0,s.kt)($ko,(0,p.Z)({},Qko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Jko.isMDXComponent=!0;const Kko={toc:[]},tyo="wrapper";function eyo(t){let{components:e,...n}=t;return(0,s.kt)(tyo,(0,p.Z)({},Kko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eyo.isMDXComponent=!0;const nyo={toc:[]},oyo="wrapper";function pyo(t){let{components:e,...n}=t;return(0,s.kt)(oyo,(0,p.Z)({},nyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(t){let{components:e,...n}=t;return(0,s.kt)(syo,(0,p.Z)({},ryo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cyo.isMDXComponent=!0;const iyo={toc:[]},ayo="wrapper";function lyo(t){let{components:e,...n}=t;return(0,s.kt)(ayo,(0,p.Z)({},iyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function dyo(t){let{components:e,...n}=t;return(0,s.kt)(myo,(0,p.Z)({},uyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dyo.isMDXComponent=!0;const hyo={toc:[]},fyo="wrapper";function kyo(t){let{components:e,...n}=t;return(0,s.kt)(fyo,(0,p.Z)({},hyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kyo.isMDXComponent=!0;const yyo={toc:[]},Dyo="wrapper";function Myo(t){let{components:e,...n}=t;return(0,s.kt)(Dyo,(0,p.Z)({},yyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(t){let{components:e,...n}=t;return(0,s.kt)(_yo,(0,p.Z)({},Xyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},gyo="wrapper";function Cyo(t){let{components:e,...n}=t;return(0,s.kt)(gyo,(0,p.Z)({},Tyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Cyo.isMDXComponent=!0;const xyo={toc:[]},vyo="wrapper";function Lyo(t){let{components:e,...n}=t;return(0,s.kt)(vyo,(0,p.Z)({},xyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lyo.isMDXComponent=!0;const Zyo={toc:[]},byo="wrapper";function Nyo(t){let{components:e,...n}=t;return(0,s.kt)(byo,(0,p.Z)({},Zyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Nyo.isMDXComponent=!0;const Ayo={toc:[]},zyo="wrapper";function Wyo(t){let{components:e,...n}=t;return(0,s.kt)(zyo,(0,p.Z)({},Ayo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wyo.isMDXComponent=!0;const Iyo={toc:[]},Ryo="wrapper";function Syo(t){let{components:e,...n}=t;return(0,s.kt)(Ryo,(0,p.Z)({},Iyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Syo.isMDXComponent=!0;const Pyo={toc:[]},Eyo="wrapper";function Oyo(t){let{components:e,...n}=t;return(0,s.kt)(Eyo,(0,p.Z)({},Pyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Oyo.isMDXComponent=!0;const Gyo={toc:[]},Fyo="wrapper";function Byo(t){let{components:e,...n}=t;return(0,s.kt)(Fyo,(0,p.Z)({},Gyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Byo.isMDXComponent=!0;const Uyo={toc:[]},Vyo="wrapper";function qyo(t){let{components:e,...n}=t;return(0,s.kt)(Vyo,(0,p.Z)({},Uyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qyo.isMDXComponent=!0;const jyo={toc:[]},Yyo="wrapper";function Hyo(t){let{components:e,...n}=t;return(0,s.kt)(Yyo,(0,p.Z)({},jyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Hyo.isMDXComponent=!0;const Qyo={toc:[]},$yo="wrapper";function Jyo(t){let{components:e,...n}=t;return(0,s.kt)($yo,(0,p.Z)({},Qyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jyo.isMDXComponent=!0;const Kyo={toc:[]},tDo="wrapper";function eDo(t){let{components:e,...n}=t;return(0,s.kt)(tDo,(0,p.Z)({},Kyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}eDo.isMDXComponent=!0;const nDo={toc:[]},oDo="wrapper";function pDo(t){let{components:e,...n}=t;return(0,s.kt)(oDo,(0,p.Z)({},nDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(t){let{components:e,...n}=t;return(0,s.kt)(sDo,(0,p.Z)({},rDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cDo.isMDXComponent=!0;const iDo={toc:[]},aDo="wrapper";function lDo(t){let{components:e,...n}=t;return(0,s.kt)(aDo,(0,p.Z)({},iDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function dDo(t){let{components:e,...n}=t;return(0,s.kt)(mDo,(0,p.Z)({},uDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dDo.isMDXComponent=!0;const hDo={toc:[]},fDo="wrapper";function kDo(t){let{components:e,...n}=t;return(0,s.kt)(fDo,(0,p.Z)({},hDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kDo.isMDXComponent=!0;const yDo={toc:[]},DDo="wrapper";function MDo(t){let{components:e,...n}=t;return(0,s.kt)(DDo,(0,p.Z)({},yDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(t){let{components:e,...n}=t;return(0,s.kt)(_Do,(0,p.Z)({},XDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wDo.isMDXComponent=!0;const TDo={toc:[]},gDo="wrapper";function CDo(t){let{components:e,...n}=t;return(0,s.kt)(gDo,(0,p.Z)({},TDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CDo.isMDXComponent=!0;const xDo={toc:[]},vDo="wrapper";function LDo(t){let{components:e,...n}=t;return(0,s.kt)(vDo,(0,p.Z)({},xDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LDo.isMDXComponent=!0;const ZDo={toc:[]},bDo="wrapper";function NDo(t){let{components:e,...n}=t;return(0,s.kt)(bDo,(0,p.Z)({},ZDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NDo.isMDXComponent=!0;const ADo={toc:[]},zDo="wrapper";function WDo(t){let{components:e,...n}=t;return(0,s.kt)(zDo,(0,p.Z)({},ADo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}WDo.isMDXComponent=!0;const IDo={toc:[]},RDo="wrapper";function SDo(t){let{components:e,...n}=t;return(0,s.kt)(RDo,(0,p.Z)({},IDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}SDo.isMDXComponent=!0;const PDo={toc:[]},EDo="wrapper";function ODo(t){let{components:e,...n}=t;return(0,s.kt)(EDo,(0,p.Z)({},PDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ODo.isMDXComponent=!0;const GDo={toc:[]},FDo="wrapper";function BDo(t){let{components:e,...n}=t;return(0,s.kt)(FDo,(0,p.Z)({},GDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BDo.isMDXComponent=!0;const UDo={toc:[]},VDo="wrapper";function qDo(t){let{components:e,...n}=t;return(0,s.kt)(VDo,(0,p.Z)({},UDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qDo.isMDXComponent=!0;const jDo={toc:[]},YDo="wrapper";function HDo(t){let{components:e,...n}=t;return(0,s.kt)(YDo,(0,p.Z)({},jDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}HDo.isMDXComponent=!0;const QDo={toc:[]},$Do="wrapper";function JDo(t){let{components:e,...n}=t;return(0,s.kt)($Do,(0,p.Z)({},QDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}JDo.isMDXComponent=!0;const KDo={toc:[]},tMo="wrapper";function eMo(t){let{components:e,...n}=t;return(0,s.kt)(tMo,(0,p.Z)({},KDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eMo.isMDXComponent=!0;const nMo={toc:[]},oMo="wrapper";function pMo(t){let{components:e,...n}=t;return(0,s.kt)(oMo,(0,p.Z)({},nMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(t){let{components:e,...n}=t;return(0,s.kt)(sMo,(0,p.Z)({},rMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cMo.isMDXComponent=!0;const iMo={toc:[]},aMo="wrapper";function lMo(t){let{components:e,...n}=t;return(0,s.kt)(aMo,(0,p.Z)({},iMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function dMo(t){let{components:e,...n}=t;return(0,s.kt)(mMo,(0,p.Z)({},uMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dMo.isMDXComponent=!0;const hMo={toc:[]},fMo="wrapper";function kMo(t){let{components:e,...n}=t;return(0,s.kt)(fMo,(0,p.Z)({},hMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kMo.isMDXComponent=!0;const yMo={toc:[]},DMo="wrapper";function MMo(t){let{components:e,...n}=t;return(0,s.kt)(DMo,(0,p.Z)({},yMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(t){let{components:e,...n}=t;return(0,s.kt)(_Mo,(0,p.Z)({},XMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wMo.isMDXComponent=!0;const TMo={toc:[]},gMo="wrapper";function CMo(t){let{components:e,...n}=t;return(0,s.kt)(gMo,(0,p.Z)({},TMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}CMo.isMDXComponent=!0;const xMo={toc:[]},vMo="wrapper";function LMo(t){let{components:e,...n}=t;return(0,s.kt)(vMo,(0,p.Z)({},xMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LMo.isMDXComponent=!0;const ZMo={toc:[]},bMo="wrapper";function NMo(t){let{components:e,...n}=t;return(0,s.kt)(bMo,(0,p.Z)({},ZMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NMo.isMDXComponent=!0;const AMo={toc:[]},zMo="wrapper";function WMo(t){let{components:e,...n}=t;return(0,s.kt)(zMo,(0,p.Z)({},AMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WMo.isMDXComponent=!0;const IMo={toc:[]},RMo="wrapper";function SMo(t){let{components:e,...n}=t;return(0,s.kt)(RMo,(0,p.Z)({},IMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SMo.isMDXComponent=!0;const PMo={toc:[]},EMo="wrapper";function OMo(t){let{components:e,...n}=t;return(0,s.kt)(EMo,(0,p.Z)({},PMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}OMo.isMDXComponent=!0;const GMo={toc:[]},FMo="wrapper";function BMo(t){let{components:e,...n}=t;return(0,s.kt)(FMo,(0,p.Z)({},GMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}BMo.isMDXComponent=!0;const UMo={toc:[]},VMo="wrapper";function qMo(t){let{components:e,...n}=t;return(0,s.kt)(VMo,(0,p.Z)({},UMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qMo.isMDXComponent=!0;const jMo={toc:[]},YMo="wrapper";function HMo(t){let{components:e,...n}=t;return(0,s.kt)(YMo,(0,p.Z)({},jMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}HMo.isMDXComponent=!0;const QMo={toc:[]},$Mo="wrapper";function JMo(t){let{components:e,...n}=t;return(0,s.kt)($Mo,(0,p.Z)({},QMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}JMo.isMDXComponent=!0;const KMo={toc:[]},tXo="wrapper";function eXo(t){let{components:e,...n}=t;return(0,s.kt)(tXo,(0,p.Z)({},KMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}eXo.isMDXComponent=!0;const nXo={toc:[]},oXo="wrapper";function pXo(t){let{components:e,...n}=t;return(0,s.kt)(oXo,(0,p.Z)({},nXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(t){let{components:e,...n}=t;return(0,s.kt)(sXo,(0,p.Z)({},rXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cXo.isMDXComponent=!0;const iXo={toc:[]},aXo="wrapper";function lXo(t){let{components:e,...n}=t;return(0,s.kt)(aXo,(0,p.Z)({},iXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function dXo(t){let{components:e,...n}=t;return(0,s.kt)(mXo,(0,p.Z)({},uXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dXo.isMDXComponent=!0;const hXo={toc:[]},fXo="wrapper";function kXo(t){let{components:e,...n}=t;return(0,s.kt)(fXo,(0,p.Z)({},hXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kXo.isMDXComponent=!0;const yXo={toc:[]},DXo="wrapper";function MXo(t){let{components:e,...n}=t;return(0,s.kt)(DXo,(0,p.Z)({},yXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(t){let{components:e,...n}=t;return(0,s.kt)(_Xo,(0,p.Z)({},XXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wXo.isMDXComponent=!0;const TXo={toc:[]},gXo="wrapper";function CXo(t){let{components:e,...n}=t;return(0,s.kt)(gXo,(0,p.Z)({},TXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}CXo.isMDXComponent=!0;const xXo={toc:[]},vXo="wrapper";function LXo(t){let{components:e,...n}=t;return(0,s.kt)(vXo,(0,p.Z)({},xXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}LXo.isMDXComponent=!0;const ZXo={toc:[]},bXo="wrapper";function NXo(t){let{components:e,...n}=t;return(0,s.kt)(bXo,(0,p.Z)({},ZXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}NXo.isMDXComponent=!0;const AXo={toc:[]},zXo="wrapper";function WXo(t){let{components:e,...n}=t;return(0,s.kt)(zXo,(0,p.Z)({},AXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WXo.isMDXComponent=!0;const IXo={toc:[]},RXo="wrapper";function SXo(t){let{components:e,...n}=t;return(0,s.kt)(RXo,(0,p.Z)({},IXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}SXo.isMDXComponent=!0;const PXo={toc:[]},EXo="wrapper";function OXo(t){let{components:e,...n}=t;return(0,s.kt)(EXo,(0,p.Z)({},PXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}OXo.isMDXComponent=!0;const GXo={toc:[]},FXo="wrapper";function BXo(t){let{components:e,...n}=t;return(0,s.kt)(FXo,(0,p.Z)({},GXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BXo.isMDXComponent=!0;const UXo={toc:[]},VXo="wrapper";function qXo(t){let{components:e,...n}=t;return(0,s.kt)(VXo,(0,p.Z)({},UXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qXo.isMDXComponent=!0;const jXo={toc:[]},YXo="wrapper";function HXo(t){let{components:e,...n}=t;return(0,s.kt)(YXo,(0,p.Z)({},jXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HXo.isMDXComponent=!0;const QXo={toc:[]},$Xo="wrapper";function JXo(t){let{components:e,...n}=t;return(0,s.kt)($Xo,(0,p.Z)({},QXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}JXo.isMDXComponent=!0;const KXo={toc:[]},t_o="wrapper";function e_o(t){let{components:e,...n}=t;return(0,s.kt)(t_o,(0,p.Z)({},KXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}e_o.isMDXComponent=!0;const n_o={toc:[]},o_o="wrapper";function p_o(t){let{components:e,...n}=t;return(0,s.kt)(o_o,(0,p.Z)({},n_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(t){let{components:e,...n}=t;return(0,s.kt)(s_o,(0,p.Z)({},r_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c_o.isMDXComponent=!0;const i_o={toc:[]},a_o="wrapper";function l_o(t){let{components:e,...n}=t;return(0,s.kt)(a_o,(0,p.Z)({},i_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function d_o(t){let{components:e,...n}=t;return(0,s.kt)(m_o,(0,p.Z)({},u_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}d_o.isMDXComponent=!0;const h_o={toc:[]},f_o="wrapper";function k_o(t){let{components:e,...n}=t;return(0,s.kt)(f_o,(0,p.Z)({},h_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}k_o.isMDXComponent=!0;const y_o={toc:[]},D_o="wrapper";function M_o(t){let{components:e,...n}=t;return(0,s.kt)(D_o,(0,p.Z)({},y_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(t){let{components:e,...n}=t;return(0,s.kt)(__o,(0,p.Z)({},X_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w_o.isMDXComponent=!0;const T_o={toc:[]},g_o="wrapper";function C_o(t){let{components:e,...n}=t;return(0,s.kt)(g_o,(0,p.Z)({},T_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}C_o.isMDXComponent=!0;const x_o={toc:[]},v_o="wrapper";function L_o(t){let{components:e,...n}=t;return(0,s.kt)(v_o,(0,p.Z)({},x_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}L_o.isMDXComponent=!0;const Z_o={toc:[]},b_o="wrapper";function N_o(t){let{components:e,...n}=t;return(0,s.kt)(b_o,(0,p.Z)({},Z_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}N_o.isMDXComponent=!0;const A_o={toc:[]},z_o="wrapper";function W_o(t){let{components:e,...n}=t;return(0,s.kt)(z_o,(0,p.Z)({},A_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}W_o.isMDXComponent=!0;const I_o={toc:[]},R_o="wrapper";function S_o(t){let{components:e,...n}=t;return(0,s.kt)(R_o,(0,p.Z)({},I_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}S_o.isMDXComponent=!0;const P_o={toc:[]},E_o="wrapper";function O_o(t){let{components:e,...n}=t;return(0,s.kt)(E_o,(0,p.Z)({},P_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}O_o.isMDXComponent=!0;const G_o={toc:[]},F_o="wrapper";function B_o(t){let{components:e,...n}=t;return(0,s.kt)(F_o,(0,p.Z)({},G_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}B_o.isMDXComponent=!0;const U_o={toc:[]},V_o="wrapper";function q_o(t){let{components:e,...n}=t;return(0,s.kt)(V_o,(0,p.Z)({},U_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q_o.isMDXComponent=!0;const j_o={toc:[]},Y_o="wrapper";function H_o(t){let{components:e,...n}=t;return(0,s.kt)(Y_o,(0,p.Z)({},j_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}H_o.isMDXComponent=!0;const Q_o={toc:[]},$_o="wrapper";function J_o(t){let{components:e,...n}=t;return(0,s.kt)($_o,(0,p.Z)({},Q_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}J_o.isMDXComponent=!0;const K_o={toc:[]},two="wrapper";function ewo(t){let{components:e,...n}=t;return(0,s.kt)(two,(0,p.Z)({},K_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ewo.isMDXComponent=!0;const nwo={toc:[]},owo="wrapper";function pwo(t){let{components:e,...n}=t;return(0,s.kt)(owo,(0,p.Z)({},nwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(t){let{components:e,...n}=t;return(0,s.kt)(swo,(0,p.Z)({},rwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cwo.isMDXComponent=!0;const iwo={toc:[]},awo="wrapper";function lwo(t){let{components:e,...n}=t;return(0,s.kt)(awo,(0,p.Z)({},iwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function dwo(t){let{components:e,...n}=t;return(0,s.kt)(mwo,(0,p.Z)({},uwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dwo.isMDXComponent=!0;const hwo={toc:[]},fwo="wrapper";function kwo(t){let{components:e,...n}=t;return(0,s.kt)(fwo,(0,p.Z)({},hwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}kwo.isMDXComponent=!0;const ywo={toc:[]},Dwo="wrapper";function Mwo(t){let{components:e,...n}=t;return(0,s.kt)(Dwo,(0,p.Z)({},ywo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(t){let{components:e,...n}=t;return(0,s.kt)(_wo,(0,p.Z)({},Xwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wwo.isMDXComponent=!0;const Two={toc:[]},gwo="wrapper";function Cwo(t){let{components:e,...n}=t;return(0,s.kt)(gwo,(0,p.Z)({},Two,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Cwo.isMDXComponent=!0;const xwo={toc:[]},vwo="wrapper";function Lwo(t){let{components:e,...n}=t;return(0,s.kt)(vwo,(0,p.Z)({},xwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Lwo.isMDXComponent=!0;const Zwo={toc:[]},bwo="wrapper";function Nwo(t){let{components:e,...n}=t;return(0,s.kt)(bwo,(0,p.Z)({},Zwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Nwo.isMDXComponent=!0;const Awo={toc:[]},zwo="wrapper";function Wwo(t){let{components:e,...n}=t;return(0,s.kt)(zwo,(0,p.Z)({},Awo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wwo.isMDXComponent=!0;const Iwo={toc:[]},Rwo="wrapper";function Swo(t){let{components:e,...n}=t;return(0,s.kt)(Rwo,(0,p.Z)({},Iwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Swo.isMDXComponent=!0;const Pwo={toc:[]},Ewo="wrapper";function Owo(t){let{components:e,...n}=t;return(0,s.kt)(Ewo,(0,p.Z)({},Pwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Owo.isMDXComponent=!0;const Gwo={toc:[]},Fwo="wrapper";function Bwo(t){let{components:e,...n}=t;return(0,s.kt)(Fwo,(0,p.Z)({},Gwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bwo.isMDXComponent=!0;const Uwo={toc:[]},Vwo="wrapper";function qwo(t){let{components:e,...n}=t;return(0,s.kt)(Vwo,(0,p.Z)({},Uwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qwo.isMDXComponent=!0;const jwo={toc:[]},Ywo="wrapper";function Hwo(t){let{components:e,...n}=t;return(0,s.kt)(Ywo,(0,p.Z)({},jwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Hwo.isMDXComponent=!0;const Qwo={toc:[]},$wo="wrapper";function Jwo(t){let{components:e,...n}=t;return(0,s.kt)($wo,(0,p.Z)({},Qwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Jwo.isMDXComponent=!0;const Kwo={toc:[]},tTo="wrapper";function eTo(t){let{components:e,...n}=t;return(0,s.kt)(tTo,(0,p.Z)({},Kwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}eTo.isMDXComponent=!0;const nTo={toc:[]},oTo="wrapper";function pTo(t){let{components:e,...n}=t;return(0,s.kt)(oTo,(0,p.Z)({},nTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(t){let{components:e,...n}=t;return(0,s.kt)(sTo,(0,p.Z)({},rTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cTo.isMDXComponent=!0;const iTo={toc:[]},aTo="wrapper";function lTo(t){let{components:e,...n}=t;return(0,s.kt)(aTo,(0,p.Z)({},iTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function dTo(t){let{components:e,...n}=t;return(0,s.kt)(mTo,(0,p.Z)({},uTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}dTo.isMDXComponent=!0;const hTo={toc:[]},fTo="wrapper";function kTo(t){let{components:e,...n}=t;return(0,s.kt)(fTo,(0,p.Z)({},hTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}kTo.isMDXComponent=!0;const yTo={toc:[]},DTo="wrapper";function MTo(t){let{components:e,...n}=t;return(0,s.kt)(DTo,(0,p.Z)({},yTo,n,{components:e,mdxType:"MDXLayout"}))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(t){let{components:e,...n}=t;return(0,s.kt)(_To,(0,p.Z)({},XTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wTo.isMDXComponent=!0;const TTo={toc:[]},gTo="wrapper";function CTo(t){let{components:e,...n}=t;return(0,s.kt)(gTo,(0,p.Z)({},TTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}CTo.isMDXComponent=!0;const xTo={toc:[]},vTo="wrapper";function LTo(t){let{components:e,...n}=t;return(0,s.kt)(vTo,(0,p.Z)({},xTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}LTo.isMDXComponent=!0;const ZTo={toc:[]},bTo="wrapper";function NTo(t){let{components:e,...n}=t;return(0,s.kt)(bTo,(0,p.Z)({},ZTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NTo.isMDXComponent=!0;const ATo={toc:[]},zTo="wrapper";function WTo(t){let{components:e,...n}=t;return(0,s.kt)(zTo,(0,p.Z)({},ATo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WTo.isMDXComponent=!0;const ITo={toc:[]},RTo="wrapper";function STo(t){let{components:e,...n}=t;return(0,s.kt)(RTo,(0,p.Z)({},ITo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}STo.isMDXComponent=!0;const PTo={toc:[]},ETo="wrapper";function OTo(t){let{components:e,...n}=t;return(0,s.kt)(ETo,(0,p.Z)({},PTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}OTo.isMDXComponent=!0;const GTo={toc:[]},FTo="wrapper";function BTo(t){let{components:e,...n}=t;return(0,s.kt)(FTo,(0,p.Z)({},GTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BTo.isMDXComponent=!0;const UTo={toc:[]},VTo="wrapper";function qTo(t){let{components:e,...n}=t;return(0,s.kt)(VTo,(0,p.Z)({},UTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qTo.isMDXComponent=!0;const jTo={toc:[]},YTo="wrapper";function HTo(t){let{components:e,...n}=t;return(0,s.kt)(YTo,(0,p.Z)({},jTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}HTo.isMDXComponent=!0;const QTo={toc:[]},$To="wrapper";function JTo(t){let{components:e,...n}=t;return(0,s.kt)($To,(0,p.Z)({},QTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}JTo.isMDXComponent=!0;const KTo={toc:[]},tgo="wrapper";function ego(t){let{components:e,...n}=t;return(0,s.kt)(tgo,(0,p.Z)({},KTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ego.isMDXComponent=!0;const ngo={toc:[]},ogo="wrapper";function pgo(t){let{components:e,...n}=t;return(0,s.kt)(ogo,(0,p.Z)({},ngo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(t){let{components:e,...n}=t;return(0,s.kt)(sgo,(0,p.Z)({},rgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cgo.isMDXComponent=!0;const igo={toc:[]},ago="wrapper";function lgo(t){let{components:e,...n}=t;return(0,s.kt)(ago,(0,p.Z)({},igo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function dgo(t){let{components:e,...n}=t;return(0,s.kt)(mgo,(0,p.Z)({},ugo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dgo.isMDXComponent=!0;const hgo={toc:[]},fgo="wrapper";function kgo(t){let{components:e,...n}=t;return(0,s.kt)(fgo,(0,p.Z)({},hgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kgo.isMDXComponent=!0;const ygo={toc:[]},Dgo="wrapper";function Mgo(t){let{components:e,...n}=t;return(0,s.kt)(Dgo,(0,p.Z)({},ygo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(t){let{components:e,...n}=t;return(0,s.kt)(_go,(0,p.Z)({},Xgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},ggo="wrapper";function Cgo(t){let{components:e,...n}=t;return(0,s.kt)(ggo,(0,p.Z)({},Tgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Cgo.isMDXComponent=!0;const xgo={toc:[]},vgo="wrapper";function Lgo(t){let{components:e,...n}=t;return(0,s.kt)(vgo,(0,p.Z)({},xgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Lgo.isMDXComponent=!0;const Zgo={toc:[]},bgo="wrapper";function Ngo(t){let{components:e,...n}=t;return(0,s.kt)(bgo,(0,p.Z)({},Zgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ngo.isMDXComponent=!0;const Ago={toc:[]},zgo="wrapper";function Wgo(t){let{components:e,...n}=t;return(0,s.kt)(zgo,(0,p.Z)({},Ago,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wgo.isMDXComponent=!0;const Igo={toc:[]},Rgo="wrapper";function Sgo(t){let{components:e,...n}=t;return(0,s.kt)(Rgo,(0,p.Z)({},Igo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Sgo.isMDXComponent=!0;const Pgo={toc:[]},Ego="wrapper";function Ogo(t){let{components:e,...n}=t;return(0,s.kt)(Ego,(0,p.Z)({},Pgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ogo.isMDXComponent=!0;const Ggo={toc:[]},Fgo="wrapper";function Bgo(t){let{components:e,...n}=t;return(0,s.kt)(Fgo,(0,p.Z)({},Ggo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Bgo.isMDXComponent=!0;const Ugo={toc:[]},Vgo="wrapper";function qgo(t){let{components:e,...n}=t;return(0,s.kt)(Vgo,(0,p.Z)({},Ugo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qgo.isMDXComponent=!0;const jgo={toc:[]},Ygo="wrapper";function Hgo(t){let{components:e,...n}=t;return(0,s.kt)(Ygo,(0,p.Z)({},jgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Hgo.isMDXComponent=!0;const Qgo={toc:[]},$go="wrapper";function Jgo(t){let{components:e,...n}=t;return(0,s.kt)($go,(0,p.Z)({},Qgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jgo.isMDXComponent=!0;const Kgo={toc:[]},tCo="wrapper";function eCo(t){let{components:e,...n}=t;return(0,s.kt)(tCo,(0,p.Z)({},Kgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eCo.isMDXComponent=!0;const nCo={toc:[]},oCo="wrapper";function pCo(t){let{components:e,...n}=t;return(0,s.kt)(oCo,(0,p.Z)({},nCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(t){let{components:e,...n}=t;return(0,s.kt)(sCo,(0,p.Z)({},rCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cCo.isMDXComponent=!0;const iCo={toc:[]},aCo="wrapper";function lCo(t){let{components:e,...n}=t;return(0,s.kt)(aCo,(0,p.Z)({},iCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function dCo(t){let{components:e,...n}=t;return(0,s.kt)(mCo,(0,p.Z)({},uCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dCo.isMDXComponent=!0;const hCo={toc:[]},fCo="wrapper";function kCo(t){let{components:e,...n}=t;return(0,s.kt)(fCo,(0,p.Z)({},hCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kCo.isMDXComponent=!0;const yCo={toc:[]},DCo="wrapper";function MCo(t){let{components:e,...n}=t;return(0,s.kt)(DCo,(0,p.Z)({},yCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(t){let{components:e,...n}=t;return(0,s.kt)(_Co,(0,p.Z)({},XCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wCo.isMDXComponent=!0;const TCo={toc:[]},gCo="wrapper";function CCo(t){let{components:e,...n}=t;return(0,s.kt)(gCo,(0,p.Z)({},TCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}CCo.isMDXComponent=!0;const xCo={toc:[]},vCo="wrapper";function LCo(t){let{components:e,...n}=t;return(0,s.kt)(vCo,(0,p.Z)({},xCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LCo.isMDXComponent=!0;const ZCo={toc:[]},bCo="wrapper";function NCo(t){let{components:e,...n}=t;return(0,s.kt)(bCo,(0,p.Z)({},ZCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}NCo.isMDXComponent=!0;const ACo={toc:[]},zCo="wrapper";function WCo(t){let{components:e,...n}=t;return(0,s.kt)(zCo,(0,p.Z)({},ACo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}WCo.isMDXComponent=!0;const ICo={toc:[]},RCo="wrapper";function SCo(t){let{components:e,...n}=t;return(0,s.kt)(RCo,(0,p.Z)({},ICo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}SCo.isMDXComponent=!0;const PCo={toc:[]},ECo="wrapper";function OCo(t){let{components:e,...n}=t;return(0,s.kt)(ECo,(0,p.Z)({},PCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}OCo.isMDXComponent=!0;const GCo={toc:[]},FCo="wrapper";function BCo(t){let{components:e,...n}=t;return(0,s.kt)(FCo,(0,p.Z)({},GCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}BCo.isMDXComponent=!0;const UCo={toc:[]},VCo="wrapper";function qCo(t){let{components:e,...n}=t;return(0,s.kt)(VCo,(0,p.Z)({},UCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qCo.isMDXComponent=!0;const jCo={toc:[]},YCo="wrapper";function HCo(t){let{components:e,...n}=t;return(0,s.kt)(YCo,(0,p.Z)({},jCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}HCo.isMDXComponent=!0;const QCo={toc:[]},$Co="wrapper";function JCo(t){let{components:e,...n}=t;return(0,s.kt)($Co,(0,p.Z)({},QCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}JCo.isMDXComponent=!0;const KCo={toc:[]},txo="wrapper";function exo(t){let{components:e,...n}=t;return(0,s.kt)(txo,(0,p.Z)({},KCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}exo.isMDXComponent=!0;const nxo={toc:[]},oxo="wrapper";function pxo(t){let{components:e,...n}=t;return(0,s.kt)(oxo,(0,p.Z)({},nxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(t){let{components:e,...n}=t;return(0,s.kt)(sxo,(0,p.Z)({},rxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cxo.isMDXComponent=!0;const ixo={toc:[]},axo="wrapper";function lxo(t){let{components:e,...n}=t;return(0,s.kt)(axo,(0,p.Z)({},ixo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function dxo(t){let{components:e,...n}=t;return(0,s.kt)(mxo,(0,p.Z)({},uxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dxo.isMDXComponent=!0;const hxo={toc:[]},fxo="wrapper";function kxo(t){let{components:e,...n}=t;return(0,s.kt)(fxo,(0,p.Z)({},hxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kxo.isMDXComponent=!0;const yxo={toc:[]},Dxo="wrapper";function Mxo(t){let{components:e,...n}=t;return(0,s.kt)(Dxo,(0,p.Z)({},yxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(t){let{components:e,...n}=t;return(0,s.kt)(_xo,(0,p.Z)({},Xxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wxo.isMDXComponent=!0;const Txo={toc:[]},gxo="wrapper";function Cxo(t){let{components:e,...n}=t;return(0,s.kt)(gxo,(0,p.Z)({},Txo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cxo.isMDXComponent=!0;const xxo={toc:[]},vxo="wrapper";function Lxo(t){let{components:e,...n}=t;return(0,s.kt)(vxo,(0,p.Z)({},xxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lxo.isMDXComponent=!0;const Zxo={toc:[]},bxo="wrapper";function Nxo(t){let{components:e,...n}=t;return(0,s.kt)(bxo,(0,p.Z)({},Zxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nxo.isMDXComponent=!0;const Axo={toc:[]},zxo="wrapper";function Wxo(t){let{components:e,...n}=t;return(0,s.kt)(zxo,(0,p.Z)({},Axo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wxo.isMDXComponent=!0;const Ixo={toc:[]},Rxo="wrapper";function Sxo(t){let{components:e,...n}=t;return(0,s.kt)(Rxo,(0,p.Z)({},Ixo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Sxo.isMDXComponent=!0;const Pxo={toc:[]},Exo="wrapper";function Oxo(t){let{components:e,...n}=t;return(0,s.kt)(Exo,(0,p.Z)({},Pxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Oxo.isMDXComponent=!0;const Gxo={toc:[]},Fxo="wrapper";function Bxo(t){let{components:e,...n}=t;return(0,s.kt)(Fxo,(0,p.Z)({},Gxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bxo.isMDXComponent=!0;const Uxo={toc:[]},Vxo="wrapper";function qxo(t){let{components:e,...n}=t;return(0,s.kt)(Vxo,(0,p.Z)({},Uxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qxo.isMDXComponent=!0;const jxo={toc:[]},Yxo="wrapper";function Hxo(t){let{components:e,...n}=t;return(0,s.kt)(Yxo,(0,p.Z)({},jxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Hxo.isMDXComponent=!0;const Qxo={toc:[]},$xo="wrapper";function Jxo(t){let{components:e,...n}=t;return(0,s.kt)($xo,(0,p.Z)({},Qxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Jxo.isMDXComponent=!0;const Kxo={toc:[]},tvo="wrapper";function evo(t){let{components:e,...n}=t;return(0,s.kt)(tvo,(0,p.Z)({},Kxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}evo.isMDXComponent=!0;const nvo={toc:[]},ovo="wrapper";function pvo(t){let{components:e,...n}=t;return(0,s.kt)(ovo,(0,p.Z)({},nvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(t){let{components:e,...n}=t;return(0,s.kt)(svo,(0,p.Z)({},rvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cvo.isMDXComponent=!0;const ivo={toc:[]},avo="wrapper";function lvo(t){let{components:e,...n}=t;return(0,s.kt)(avo,(0,p.Z)({},ivo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function dvo(t){let{components:e,...n}=t;return(0,s.kt)(mvo,(0,p.Z)({},uvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dvo.isMDXComponent=!0;const hvo={toc:[]},fvo="wrapper";function kvo(t){let{components:e,...n}=t;return(0,s.kt)(fvo,(0,p.Z)({},hvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}kvo.isMDXComponent=!0;const yvo={toc:[]},Dvo="wrapper";function Mvo(t){let{components:e,...n}=t;return(0,s.kt)(Dvo,(0,p.Z)({},yvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(t){let{components:e,...n}=t;return(0,s.kt)(_vo,(0,p.Z)({},Xvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wvo.isMDXComponent=!0;const Tvo={toc:[]},gvo="wrapper";function Cvo(t){let{components:e,...n}=t;return(0,s.kt)(gvo,(0,p.Z)({},Tvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Cvo.isMDXComponent=!0;const xvo={toc:[]},vvo="wrapper";function Lvo(t){let{components:e,...n}=t;return(0,s.kt)(vvo,(0,p.Z)({},xvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lvo.isMDXComponent=!0;const Zvo={toc:[]},bvo="wrapper";function Nvo(t){let{components:e,...n}=t;return(0,s.kt)(bvo,(0,p.Z)({},Zvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Nvo.isMDXComponent=!0;const Avo={toc:[]},zvo="wrapper";function Wvo(t){let{components:e,...n}=t;return(0,s.kt)(zvo,(0,p.Z)({},Avo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wvo.isMDXComponent=!0;const Ivo={toc:[]},Rvo="wrapper";function Svo(t){let{components:e,...n}=t;return(0,s.kt)(Rvo,(0,p.Z)({},Ivo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Svo.isMDXComponent=!0;const Pvo={toc:[]},Evo="wrapper";function Ovo(t){let{components:e,...n}=t;return(0,s.kt)(Evo,(0,p.Z)({},Pvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Ovo.isMDXComponent=!0;const Gvo={toc:[]},Fvo="wrapper";function Bvo(t){let{components:e,...n}=t;return(0,s.kt)(Fvo,(0,p.Z)({},Gvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bvo.isMDXComponent=!0;const Uvo={toc:[]},Vvo="wrapper";function qvo(t){let{components:e,...n}=t;return(0,s.kt)(Vvo,(0,p.Z)({},Uvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qvo.isMDXComponent=!0;const jvo={toc:[]},Yvo="wrapper";function Hvo(t){let{components:e,...n}=t;return(0,s.kt)(Yvo,(0,p.Z)({},jvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Hvo.isMDXComponent=!0;const Qvo={toc:[]},$vo="wrapper";function Jvo(t){let{components:e,...n}=t;return(0,s.kt)($vo,(0,p.Z)({},Qvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Jvo.isMDXComponent=!0;const Kvo={toc:[]},tLo="wrapper";function eLo(t){let{components:e,...n}=t;return(0,s.kt)(tLo,(0,p.Z)({},Kvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eLo.isMDXComponent=!0;const nLo={toc:[]},oLo="wrapper";function pLo(t){let{components:e,...n}=t;return(0,s.kt)(oLo,(0,p.Z)({},nLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(t){let{components:e,...n}=t;return(0,s.kt)(sLo,(0,p.Z)({},rLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cLo.isMDXComponent=!0;const iLo={toc:[]},aLo="wrapper";function lLo(t){let{components:e,...n}=t;return(0,s.kt)(aLo,(0,p.Z)({},iLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function dLo(t){let{components:e,...n}=t;return(0,s.kt)(mLo,(0,p.Z)({},uLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dLo.isMDXComponent=!0;const hLo={toc:[]},fLo="wrapper";function kLo(t){let{components:e,...n}=t;return(0,s.kt)(fLo,(0,p.Z)({},hLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kLo.isMDXComponent=!0;const yLo={toc:[]},DLo="wrapper";function MLo(t){let{components:e,...n}=t;return(0,s.kt)(DLo,(0,p.Z)({},yLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(t){let{components:e,...n}=t;return(0,s.kt)(_Lo,(0,p.Z)({},XLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wLo.isMDXComponent=!0;const TLo={toc:[]},gLo="wrapper";function CLo(t){let{components:e,...n}=t;return(0,s.kt)(gLo,(0,p.Z)({},TLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}CLo.isMDXComponent=!0;const xLo={toc:[]},vLo="wrapper";function LLo(t){let{components:e,...n}=t;return(0,s.kt)(vLo,(0,p.Z)({},xLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LLo.isMDXComponent=!0;const ZLo={toc:[]},bLo="wrapper";function NLo(t){let{components:e,...n}=t;return(0,s.kt)(bLo,(0,p.Z)({},ZLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NLo.isMDXComponent=!0;const ALo={toc:[]},zLo="wrapper";function WLo(t){let{components:e,...n}=t;return(0,s.kt)(zLo,(0,p.Z)({},ALo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WLo.isMDXComponent=!0;const ILo={toc:[]},RLo="wrapper";function SLo(t){let{components:e,...n}=t;return(0,s.kt)(RLo,(0,p.Z)({},ILo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}SLo.isMDXComponent=!0;const PLo={toc:[]},ELo="wrapper";function OLo(t){let{components:e,...n}=t;return(0,s.kt)(ELo,(0,p.Z)({},PLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}OLo.isMDXComponent=!0;const GLo={toc:[]},FLo="wrapper";function BLo(t){let{components:e,...n}=t;return(0,s.kt)(FLo,(0,p.Z)({},GLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BLo.isMDXComponent=!0;const ULo={toc:[]},VLo="wrapper";function qLo(t){let{components:e,...n}=t;return(0,s.kt)(VLo,(0,p.Z)({},ULo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qLo.isMDXComponent=!0;const jLo={toc:[]},YLo="wrapper";function HLo(t){let{components:e,...n}=t;return(0,s.kt)(YLo,(0,p.Z)({},jLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}HLo.isMDXComponent=!0;const QLo={toc:[]},$Lo="wrapper";function JLo(t){let{components:e,...n}=t;return(0,s.kt)($Lo,(0,p.Z)({},QLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}JLo.isMDXComponent=!0;const KLo={toc:[]},tZo="wrapper";function eZo(t){let{components:e,...n}=t;return(0,s.kt)(tZo,(0,p.Z)({},KLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eZo.isMDXComponent=!0;const nZo={toc:[]},oZo="wrapper";function pZo(t){let{components:e,...n}=t;return(0,s.kt)(oZo,(0,p.Z)({},nZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(t){let{components:e,...n}=t;return(0,s.kt)(sZo,(0,p.Z)({},rZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cZo.isMDXComponent=!0;const iZo={toc:[]},aZo="wrapper";function lZo(t){let{components:e,...n}=t;return(0,s.kt)(aZo,(0,p.Z)({},iZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function dZo(t){let{components:e,...n}=t;return(0,s.kt)(mZo,(0,p.Z)({},uZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dZo.isMDXComponent=!0;const hZo={toc:[]},fZo="wrapper";function kZo(t){let{components:e,...n}=t;return(0,s.kt)(fZo,(0,p.Z)({},hZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kZo.isMDXComponent=!0;const yZo={toc:[]},DZo="wrapper";function MZo(t){let{components:e,...n}=t;return(0,s.kt)(DZo,(0,p.Z)({},yZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(t){let{components:e,...n}=t;return(0,s.kt)(_Zo,(0,p.Z)({},XZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wZo.isMDXComponent=!0;const TZo={toc:[]},gZo="wrapper";function CZo(t){let{components:e,...n}=t;return(0,s.kt)(gZo,(0,p.Z)({},TZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}CZo.isMDXComponent=!0;const xZo={toc:[]},vZo="wrapper";function LZo(t){let{components:e,...n}=t;return(0,s.kt)(vZo,(0,p.Z)({},xZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LZo.isMDXComponent=!0;const ZZo={toc:[]},bZo="wrapper";function NZo(t){let{components:e,...n}=t;return(0,s.kt)(bZo,(0,p.Z)({},ZZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NZo.isMDXComponent=!0;const AZo={toc:[]},zZo="wrapper";function WZo(t){let{components:e,...n}=t;return(0,s.kt)(zZo,(0,p.Z)({},AZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WZo.isMDXComponent=!0;const IZo={toc:[]},RZo="wrapper";function SZo(t){let{components:e,...n}=t;return(0,s.kt)(RZo,(0,p.Z)({},IZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SZo.isMDXComponent=!0;const PZo={toc:[]},EZo="wrapper";function OZo(t){let{components:e,...n}=t;return(0,s.kt)(EZo,(0,p.Z)({},PZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}OZo.isMDXComponent=!0;const GZo={toc:[]},FZo="wrapper";function BZo(t){let{components:e,...n}=t;return(0,s.kt)(FZo,(0,p.Z)({},GZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BZo.isMDXComponent=!0;const UZo={toc:[]},VZo="wrapper";function qZo(t){let{components:e,...n}=t;return(0,s.kt)(VZo,(0,p.Z)({},UZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qZo.isMDXComponent=!0;const jZo={toc:[]},YZo="wrapper";function HZo(t){let{components:e,...n}=t;return(0,s.kt)(YZo,(0,p.Z)({},jZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HZo.isMDXComponent=!0;const QZo={toc:[]},$Zo="wrapper";function JZo(t){let{components:e,...n}=t;return(0,s.kt)($Zo,(0,p.Z)({},QZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}JZo.isMDXComponent=!0;const KZo={toc:[]},tbo="wrapper";function ebo(t){let{components:e,...n}=t;return(0,s.kt)(tbo,(0,p.Z)({},KZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ebo.isMDXComponent=!0;const nbo={toc:[]},obo="wrapper";function pbo(t){let{components:e,...n}=t;return(0,s.kt)(obo,(0,p.Z)({},nbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(t){let{components:e,...n}=t;return(0,s.kt)(sbo,(0,p.Z)({},rbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cbo.isMDXComponent=!0;const ibo={toc:[]},abo="wrapper";function lbo(t){let{components:e,...n}=t;return(0,s.kt)(abo,(0,p.Z)({},ibo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function dbo(t){let{components:e,...n}=t;return(0,s.kt)(mbo,(0,p.Z)({},ubo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dbo.isMDXComponent=!0;const hbo={toc:[]},fbo="wrapper";function kbo(t){let{components:e,...n}=t;return(0,s.kt)(fbo,(0,p.Z)({},hbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kbo.isMDXComponent=!0;const ybo={toc:[]},Dbo="wrapper";function Mbo(t){let{components:e,...n}=t;return(0,s.kt)(Dbo,(0,p.Z)({},ybo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(t){let{components:e,...n}=t;return(0,s.kt)(_bo,(0,p.Z)({},Xbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},gbo="wrapper";function Cbo(t){let{components:e,...n}=t;return(0,s.kt)(gbo,(0,p.Z)({},Tbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Cbo.isMDXComponent=!0;const xbo={toc:[]},vbo="wrapper";function Lbo(t){let{components:e,...n}=t;return(0,s.kt)(vbo,(0,p.Z)({},xbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lbo.isMDXComponent=!0;const Zbo={toc:[]},bbo="wrapper";function Nbo(t){let{components:e,...n}=t;return(0,s.kt)(bbo,(0,p.Z)({},Zbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Nbo.isMDXComponent=!0;const Abo={toc:[]},zbo="wrapper";function Wbo(t){let{components:e,...n}=t;return(0,s.kt)(zbo,(0,p.Z)({},Abo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wbo.isMDXComponent=!0;const Ibo={toc:[]},Rbo="wrapper";function Sbo(t){let{components:e,...n}=t;return(0,s.kt)(Rbo,(0,p.Z)({},Ibo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sbo.isMDXComponent=!0;const Pbo={toc:[]},Ebo="wrapper";function Obo(t){let{components:e,...n}=t;return(0,s.kt)(Ebo,(0,p.Z)({},Pbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Obo.isMDXComponent=!0;const Gbo={toc:[]},Fbo="wrapper";function Bbo(t){let{components:e,...n}=t;return(0,s.kt)(Fbo,(0,p.Z)({},Gbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bbo.isMDXComponent=!0;const Ubo={toc:[]},Vbo="wrapper";function qbo(t){let{components:e,...n}=t;return(0,s.kt)(Vbo,(0,p.Z)({},Ubo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qbo.isMDXComponent=!0;const jbo={toc:[]},Ybo="wrapper";function Hbo(t){let{components:e,...n}=t;return(0,s.kt)(Ybo,(0,p.Z)({},jbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Hbo.isMDXComponent=!0;const Qbo={toc:[]},$bo="wrapper";function Jbo(t){let{components:e,...n}=t;return(0,s.kt)($bo,(0,p.Z)({},Qbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Jbo.isMDXComponent=!0;const Kbo={toc:[]},tNo="wrapper";function eNo(t){let{components:e,...n}=t;return(0,s.kt)(tNo,(0,p.Z)({},Kbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eNo.isMDXComponent=!0;const nNo={toc:[]},oNo="wrapper";function pNo(t){let{components:e,...n}=t;return(0,s.kt)(oNo,(0,p.Z)({},nNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(t){let{components:e,...n}=t;return(0,s.kt)(sNo,(0,p.Z)({},rNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cNo.isMDXComponent=!0;const iNo={toc:[]},aNo="wrapper";function lNo(t){let{components:e,...n}=t;return(0,s.kt)(aNo,(0,p.Z)({},iNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function dNo(t){let{components:e,...n}=t;return(0,s.kt)(mNo,(0,p.Z)({},uNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dNo.isMDXComponent=!0;const hNo={toc:[]},fNo="wrapper";function kNo(t){let{components:e,...n}=t;return(0,s.kt)(fNo,(0,p.Z)({},hNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kNo.isMDXComponent=!0;const yNo={toc:[]},DNo="wrapper";function MNo(t){let{components:e,...n}=t;return(0,s.kt)(DNo,(0,p.Z)({},yNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(t){let{components:e,...n}=t;return(0,s.kt)(_No,(0,p.Z)({},XNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}wNo.isMDXComponent=!0;const TNo={toc:[]},gNo="wrapper";function CNo(t){let{components:e,...n}=t;return(0,s.kt)(gNo,(0,p.Z)({},TNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a bold text node."))}CNo.isMDXComponent=!0;const xNo={toc:[]},vNo="wrapper";function LNo(t){let{components:e,...n}=t;return(0,s.kt)(vNo,(0,p.Z)({},xNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}LNo.isMDXComponent=!0;const ZNo={toc:[]},bNo="wrapper";function NNo(t){let{components:e,...n}=t;return(0,s.kt)(bNo,(0,p.Z)({},ZNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}NNo.isMDXComponent=!0;const ANo={toc:[]},zNo="wrapper";function WNo(t){let{components:e,...n}=t;return(0,s.kt)(zNo,(0,p.Z)({},ANo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an italic text node."))}WNo.isMDXComponent=!0;const INo={toc:[]},RNo="wrapper";function SNo(t){let{components:e,...n}=t;return(0,s.kt)(RNo,(0,p.Z)({},INo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}SNo.isMDXComponent=!0;const PNo={toc:[]},ENo="wrapper";function ONo(t){let{components:e,...n}=t;return(0,s.kt)(ENo,(0,p.Z)({},PNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ONo.isMDXComponent=!0;const GNo={toc:[]},FNo="wrapper";function BNo(t){let{components:e,...n}=t;return(0,s.kt)(FNo,(0,p.Z)({},GNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}BNo.isMDXComponent=!0;const UNo={toc:[]},VNo="wrapper";function qNo(t){let{components:e,...n}=t;return(0,s.kt)(VNo,(0,p.Z)({},UNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qNo.isMDXComponent=!0;const jNo={toc:[]},YNo="wrapper";function HNo(t){let{components:e,...n}=t;return(0,s.kt)(YNo,(0,p.Z)({},jNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}HNo.isMDXComponent=!0;const QNo={toc:[]},$No="wrapper";function JNo(t){let{components:e,...n}=t;return(0,s.kt)($No,(0,p.Z)({},QNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}JNo.isMDXComponent=!0;const KNo={toc:[]},tAo="wrapper";function eAo(t){let{components:e,...n}=t;return(0,s.kt)(tAo,(0,p.Z)({},KNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}eAo.isMDXComponent=!0;const nAo={toc:[]},oAo="wrapper";function pAo(t){let{components:e,...n}=t;return(0,s.kt)(oAo,(0,p.Z)({},nAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(t){let{components:e,...n}=t;return(0,s.kt)(sAo,(0,p.Z)({},rAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}cAo.isMDXComponent=!0;const iAo={toc:[]},aAo="wrapper";function lAo(t){let{components:e,...n}=t;return(0,s.kt)(aAo,(0,p.Z)({},iAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function dAo(t){let{components:e,...n}=t;return(0,s.kt)(mAo,(0,p.Z)({},uAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dAo.isMDXComponent=!0;const hAo={toc:[]},fAo="wrapper";function kAo(t){let{components:e,...n}=t;return(0,s.kt)(fAo,(0,p.Z)({},hAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kAo.isMDXComponent=!0;const yAo={toc:[]},DAo="wrapper";function MAo(t){let{components:e,...n}=t;return(0,s.kt)(DAo,(0,p.Z)({},yAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(t){let{components:e,...n}=t;return(0,s.kt)(_Ao,(0,p.Z)({},XAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wAo.isMDXComponent=!0;const TAo={toc:[]},gAo="wrapper";function CAo(t){let{components:e,...n}=t;return(0,s.kt)(gAo,(0,p.Z)({},TAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}CAo.isMDXComponent=!0;const xAo={toc:[]},vAo="wrapper";function LAo(t){let{components:e,...n}=t;return(0,s.kt)(vAo,(0,p.Z)({},xAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}LAo.isMDXComponent=!0;const ZAo={toc:[]},bAo="wrapper";function NAo(t){let{components:e,...n}=t;return(0,s.kt)(bAo,(0,p.Z)({},ZAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}NAo.isMDXComponent=!0;const AAo={toc:[]},zAo="wrapper";function WAo(t){let{components:e,...n}=t;return(0,s.kt)(zAo,(0,p.Z)({},AAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}WAo.isMDXComponent=!0;const IAo={toc:[]},RAo="wrapper";function SAo(t){let{components:e,...n}=t;return(0,s.kt)(RAo,(0,p.Z)({},IAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}SAo.isMDXComponent=!0;const PAo={toc:[]},EAo="wrapper";function OAo(t){let{components:e,...n}=t;return(0,s.kt)(EAo,(0,p.Z)({},PAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}OAo.isMDXComponent=!0;const GAo={toc:[]},FAo="wrapper";function BAo(t){let{components:e,...n}=t;return(0,s.kt)(FAo,(0,p.Z)({},GAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}BAo.isMDXComponent=!0;const UAo={toc:[]},VAo="wrapper";function qAo(t){let{components:e,...n}=t;return(0,s.kt)(VAo,(0,p.Z)({},UAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}qAo.isMDXComponent=!0;const jAo={toc:[]},YAo="wrapper";function HAo(t){let{components:e,...n}=t;return(0,s.kt)(YAo,(0,p.Z)({},jAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}HAo.isMDXComponent=!0;const QAo={toc:[]},$Ao="wrapper";function JAo(t){let{components:e,...n}=t;return(0,s.kt)($Ao,(0,p.Z)({},QAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}JAo.isMDXComponent=!0;const KAo={toc:[]},tzo="wrapper";function ezo(t){let{components:e,...n}=t;return(0,s.kt)(tzo,(0,p.Z)({},KAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ezo.isMDXComponent=!0;const nzo={toc:[]},ozo="wrapper";function pzo(t){let{components:e,...n}=t;return(0,s.kt)(ozo,(0,p.Z)({},nzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(t){let{components:e,...n}=t;return(0,s.kt)(szo,(0,p.Z)({},rzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}czo.isMDXComponent=!0;const izo={toc:[]},azo="wrapper";function lzo(t){let{components:e,...n}=t;return(0,s.kt)(azo,(0,p.Z)({},izo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function dzo(t){let{components:e,...n}=t;return(0,s.kt)(mzo,(0,p.Z)({},uzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dzo.isMDXComponent=!0;const hzo={toc:[]},fzo="wrapper";function kzo(t){let{components:e,...n}=t;return(0,s.kt)(fzo,(0,p.Z)({},hzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kzo.isMDXComponent=!0;const yzo={toc:[]},Dzo="wrapper";function Mzo(t){let{components:e,...n}=t;return(0,s.kt)(Dzo,(0,p.Z)({},yzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(t){let{components:e,...n}=t;return(0,s.kt)(_zo,(0,p.Z)({},Xzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},gzo="wrapper";function Czo(t){let{components:e,...n}=t;return(0,s.kt)(gzo,(0,p.Z)({},Tzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Czo.isMDXComponent=!0;const xzo={toc:[]},vzo="wrapper";function Lzo(t){let{components:e,...n}=t;return(0,s.kt)(vzo,(0,p.Z)({},xzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lzo.isMDXComponent=!0;const Zzo={toc:[]},bzo="wrapper";function Nzo(t){let{components:e,...n}=t;return(0,s.kt)(bzo,(0,p.Z)({},Zzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Nzo.isMDXComponent=!0;const Azo={toc:[]},zzo="wrapper";function Wzo(t){let{components:e,...n}=t;return(0,s.kt)(zzo,(0,p.Z)({},Azo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Wzo.isMDXComponent=!0;const Izo={toc:[]},Rzo="wrapper";function Szo(t){let{components:e,...n}=t;return(0,s.kt)(Rzo,(0,p.Z)({},Izo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Szo.isMDXComponent=!0;const Pzo={toc:[]},Ezo="wrapper";function Ozo(t){let{components:e,...n}=t;return(0,s.kt)(Ezo,(0,p.Z)({},Pzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"1"))}Ozo.isMDXComponent=!0;const Gzo={toc:[]},Fzo="wrapper";function Bzo(t){let{components:e,...n}=t;return(0,s.kt)(Fzo,(0,p.Z)({},Gzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}Bzo.isMDXComponent=!0;const Uzo={toc:[]},Vzo="wrapper";function qzo(t){let{components:e,...n}=t;return(0,s.kt)(Vzo,(0,p.Z)({},Uzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qzo.isMDXComponent=!0;const jzo={toc:[]},Yzo="wrapper";function Hzo(t){let{components:e,...n}=t;return(0,s.kt)(Yzo,(0,p.Z)({},jzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Hzo.isMDXComponent=!0;const Qzo={toc:[]},$zo="wrapper";function Jzo(t){let{components:e,...n}=t;return(0,s.kt)($zo,(0,p.Z)({},Qzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Jzo.isMDXComponent=!0;const Kzo={toc:[]},tWo="wrapper";function eWo(t){let{components:e,...n}=t;return(0,s.kt)(tWo,(0,p.Z)({},Kzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}eWo.isMDXComponent=!0;const nWo={toc:[]},oWo="wrapper";function pWo(t){let{components:e,...n}=t;return(0,s.kt)(oWo,(0,p.Z)({},nWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(t){let{components:e,...n}=t;return(0,s.kt)(sWo,(0,p.Z)({},rWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}cWo.isMDXComponent=!0;const iWo={toc:[]},aWo="wrapper";function lWo(t){let{components:e,...n}=t;return(0,s.kt)(aWo,(0,p.Z)({},iWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function dWo(t){let{components:e,...n}=t;return(0,s.kt)(mWo,(0,p.Z)({},uWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dWo.isMDXComponent=!0;const hWo={toc:[]},fWo="wrapper";function kWo(t){let{components:e,...n}=t;return(0,s.kt)(fWo,(0,p.Z)({},hWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kWo.isMDXComponent=!0;const yWo={toc:[]},DWo="wrapper";function MWo(t){let{components:e,...n}=t;return(0,s.kt)(DWo,(0,p.Z)({},yWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(t){let{components:e,...n}=t;return(0,s.kt)(_Wo,(0,p.Z)({},XWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wWo.isMDXComponent=!0;const TWo={toc:[]},gWo="wrapper";function CWo(t){let{components:e,...n}=t;return(0,s.kt)(gWo,(0,p.Z)({},TWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CWo.isMDXComponent=!0;const xWo={toc:[]},vWo="wrapper";function LWo(t){let{components:e,...n}=t;return(0,s.kt)(vWo,(0,p.Z)({},xWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LWo.isMDXComponent=!0;const ZWo={toc:[]},bWo="wrapper";function NWo(t){let{components:e,...n}=t;return(0,s.kt)(bWo,(0,p.Z)({},ZWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}NWo.isMDXComponent=!0;const AWo={toc:[]},zWo="wrapper";function WWo(t){let{components:e,...n}=t;return(0,s.kt)(zWo,(0,p.Z)({},AWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}WWo.isMDXComponent=!0;const IWo={toc:[]},RWo="wrapper";function SWo(t){let{components:e,...n}=t;return(0,s.kt)(RWo,(0,p.Z)({},IWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}SWo.isMDXComponent=!0;const PWo={toc:[]},EWo="wrapper";function OWo(t){let{components:e,...n}=t;return(0,s.kt)(EWo,(0,p.Z)({},PWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}OWo.isMDXComponent=!0;const GWo={toc:[]},FWo="wrapper";function BWo(t){let{components:e,...n}=t;return(0,s.kt)(FWo,(0,p.Z)({},GWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}BWo.isMDXComponent=!0;const UWo={toc:[]},VWo="wrapper";function qWo(t){let{components:e,...n}=t;return(0,s.kt)(VWo,(0,p.Z)({},UWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}qWo.isMDXComponent=!0;const jWo={toc:[]},YWo="wrapper";function HWo(t){let{components:e,...n}=t;return(0,s.kt)(YWo,(0,p.Z)({},jWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}HWo.isMDXComponent=!0;const QWo={toc:[]},$Wo="wrapper";function JWo(t){let{components:e,...n}=t;return(0,s.kt)($Wo,(0,p.Z)({},QWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}JWo.isMDXComponent=!0;const KWo={toc:[]},tIo="wrapper";function eIo(t){let{components:e,...n}=t;return(0,s.kt)(tIo,(0,p.Z)({},KWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}eIo.isMDXComponent=!0;const nIo={toc:[]},oIo="wrapper";function pIo(t){let{components:e,...n}=t;return(0,s.kt)(oIo,(0,p.Z)({},nIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(t){let{components:e,...n}=t;return(0,s.kt)(sIo,(0,p.Z)({},rIo,n,{components:e,mdxType:"MDXLayout"}))}cIo.isMDXComponent=!0;const iIo={toc:[]},aIo="wrapper";function lIo(t){let{components:e,...n}=t;return(0,s.kt)(aIo,(0,p.Z)({},iIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function dIo(t){let{components:e,...n}=t;return(0,s.kt)(mIo,(0,p.Z)({},uIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}dIo.isMDXComponent=!0;const hIo={toc:[]},fIo="wrapper";function kIo(t){let{components:e,...n}=t;return(0,s.kt)(fIo,(0,p.Z)({},hIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kIo.isMDXComponent=!0;const yIo={toc:[]},DIo="wrapper";function MIo(t){let{components:e,...n}=t;return(0,s.kt)(DIo,(0,p.Z)({},yIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(t){let{components:e,...n}=t;return(0,s.kt)(_Io,(0,p.Z)({},XIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wIo.isMDXComponent=!0;const TIo={toc:[]},gIo="wrapper";function CIo(t){let{components:e,...n}=t;return(0,s.kt)(gIo,(0,p.Z)({},TIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}CIo.isMDXComponent=!0;const xIo={toc:[]},vIo="wrapper";function LIo(t){let{components:e,...n}=t;return(0,s.kt)(vIo,(0,p.Z)({},xIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LIo.isMDXComponent=!0;const ZIo={toc:[]},bIo="wrapper";function NIo(t){let{components:e,...n}=t;return(0,s.kt)(bIo,(0,p.Z)({},ZIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}NIo.isMDXComponent=!0;const AIo={toc:[]},zIo="wrapper";function WIo(t){let{components:e,...n}=t;return(0,s.kt)(zIo,(0,p.Z)({},AIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}WIo.isMDXComponent=!0;const IIo={toc:[]},RIo="wrapper";function SIo(t){let{components:e,...n}=t;return(0,s.kt)(RIo,(0,p.Z)({},IIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SIo.isMDXComponent=!0;const PIo={toc:[]},EIo="wrapper";function OIo(t){let{components:e,...n}=t;return(0,s.kt)(EIo,(0,p.Z)({},PIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}OIo.isMDXComponent=!0;const GIo={toc:[]},FIo="wrapper";function BIo(t){let{components:e,...n}=t;return(0,s.kt)(FIo,(0,p.Z)({},GIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BIo.isMDXComponent=!0;const UIo={toc:[]},VIo="wrapper";function qIo(t){let{components:e,...n}=t;return(0,s.kt)(VIo,(0,p.Z)({},UIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qIo.isMDXComponent=!0;const jIo={toc:[]},YIo="wrapper";function HIo(t){let{components:e,...n}=t;return(0,s.kt)(YIo,(0,p.Z)({},jIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HIo.isMDXComponent=!0;const QIo={toc:[]},$Io="wrapper";function JIo(t){let{components:e,...n}=t;return(0,s.kt)($Io,(0,p.Z)({},QIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}JIo.isMDXComponent=!0;const KIo={toc:[]},tRo="wrapper";function eRo(t){let{components:e,...n}=t;return(0,s.kt)(tRo,(0,p.Z)({},KIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}eRo.isMDXComponent=!0;const nRo={toc:[]},oRo="wrapper";function pRo(t){let{components:e,...n}=t;return(0,s.kt)(oRo,(0,p.Z)({},nRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(t){let{components:e,...n}=t;return(0,s.kt)(sRo,(0,p.Z)({},rRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cRo.isMDXComponent=!0;const iRo={toc:[]},aRo="wrapper";function lRo(t){let{components:e,...n}=t;return(0,s.kt)(aRo,(0,p.Z)({},iRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function dRo(t){let{components:e,...n}=t;return(0,s.kt)(mRo,(0,p.Z)({},uRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}dRo.isMDXComponent=!0;const hRo={toc:[]},fRo="wrapper";function kRo(t){let{components:e,...n}=t;return(0,s.kt)(fRo,(0,p.Z)({},hRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}kRo.isMDXComponent=!0;const yRo={toc:[]},DRo="wrapper";function MRo(t){let{components:e,...n}=t;return(0,s.kt)(DRo,(0,p.Z)({},yRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(t){let{components:e,...n}=t;return(0,s.kt)(_Ro,(0,p.Z)({},XRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wRo.isMDXComponent=!0;const TRo={toc:[]},gRo="wrapper";function CRo(t){let{components:e,...n}=t;return(0,s.kt)(gRo,(0,p.Z)({},TRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}CRo.isMDXComponent=!0;const xRo={toc:[]},vRo="wrapper";function LRo(t){let{components:e,...n}=t;return(0,s.kt)(vRo,(0,p.Z)({},xRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}LRo.isMDXComponent=!0;const ZRo={toc:[]},bRo="wrapper";function NRo(t){let{components:e,...n}=t;return(0,s.kt)(bRo,(0,p.Z)({},ZRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}NRo.isMDXComponent=!0;const ARo={toc:[]},zRo="wrapper";function WRo(t){let{components:e,...n}=t;return(0,s.kt)(zRo,(0,p.Z)({},ARo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}WRo.isMDXComponent=!0;const IRo={toc:[]},RRo="wrapper";function SRo(t){let{components:e,...n}=t;return(0,s.kt)(RRo,(0,p.Z)({},IRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}SRo.isMDXComponent=!0;const PRo={toc:[]},ERo="wrapper";function ORo(t){let{components:e,...n}=t;return(0,s.kt)(ERo,(0,p.Z)({},PRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ORo.isMDXComponent=!0;const GRo={toc:[]},FRo="wrapper";function BRo(t){let{components:e,...n}=t;return(0,s.kt)(FRo,(0,p.Z)({},GRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BRo.isMDXComponent=!0;const URo={toc:[]},VRo="wrapper";function qRo(t){let{components:e,...n}=t;return(0,s.kt)(VRo,(0,p.Z)({},URo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qRo.isMDXComponent=!0;const jRo={toc:[]},YRo="wrapper";function HRo(t){let{components:e,...n}=t;return(0,s.kt)(YRo,(0,p.Z)({},jRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}HRo.isMDXComponent=!0;const QRo={toc:[]},$Ro="wrapper";function JRo(t){let{components:e,...n}=t;return(0,s.kt)($Ro,(0,p.Z)({},QRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}JRo.isMDXComponent=!0;const KRo={toc:[]},tSo="wrapper";function eSo(t){let{components:e,...n}=t;return(0,s.kt)(tSo,(0,p.Z)({},KRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eSo.isMDXComponent=!0;const nSo={toc:[]},oSo="wrapper";function pSo(t){let{components:e,...n}=t;return(0,s.kt)(oSo,(0,p.Z)({},nSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(t){let{components:e,...n}=t;return(0,s.kt)(sSo,(0,p.Z)({},rSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cSo.isMDXComponent=!0;const iSo={toc:[]},aSo="wrapper";function lSo(t){let{components:e,...n}=t;return(0,s.kt)(aSo,(0,p.Z)({},iSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function dSo(t){let{components:e,...n}=t;return(0,s.kt)(mSo,(0,p.Z)({},uSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dSo.isMDXComponent=!0;const hSo={toc:[]},fSo="wrapper";function kSo(t){let{components:e,...n}=t;return(0,s.kt)(fSo,(0,p.Z)({},hSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}kSo.isMDXComponent=!0;const ySo={toc:[]},DSo="wrapper";function MSo(t){let{components:e,...n}=t;return(0,s.kt)(DSo,(0,p.Z)({},ySo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(t){let{components:e,...n}=t;return(0,s.kt)(_So,(0,p.Z)({},XSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wSo.isMDXComponent=!0;const TSo={toc:[]},gSo="wrapper";function CSo(t){let{components:e,...n}=t;return(0,s.kt)(gSo,(0,p.Z)({},TSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}CSo.isMDXComponent=!0;const xSo={toc:[]},vSo="wrapper";function LSo(t){let{components:e,...n}=t;return(0,s.kt)(vSo,(0,p.Z)({},xSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LSo.isMDXComponent=!0;const ZSo={toc:[]},bSo="wrapper";function NSo(t){let{components:e,...n}=t;return(0,s.kt)(bSo,(0,p.Z)({},ZSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}NSo.isMDXComponent=!0;const ASo={toc:[]},zSo="wrapper";function WSo(t){let{components:e,...n}=t;return(0,s.kt)(zSo,(0,p.Z)({},ASo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WSo.isMDXComponent=!0;const ISo={toc:[]},RSo="wrapper";function SSo(t){let{components:e,...n}=t;return(0,s.kt)(RSo,(0,p.Z)({},ISo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}SSo.isMDXComponent=!0;const PSo={toc:[]},ESo="wrapper";function OSo(t){let{components:e,...n}=t;return(0,s.kt)(ESo,(0,p.Z)({},PSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}OSo.isMDXComponent=!0;const GSo={toc:[]},FSo="wrapper";function BSo(t){let{components:e,...n}=t;return(0,s.kt)(FSo,(0,p.Z)({},GSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BSo.isMDXComponent=!0;const USo={toc:[]},VSo="wrapper";function qSo(t){let{components:e,...n}=t;return(0,s.kt)(VSo,(0,p.Z)({},USo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qSo.isMDXComponent=!0;const jSo={toc:[]},YSo="wrapper";function HSo(t){let{components:e,...n}=t;return(0,s.kt)(YSo,(0,p.Z)({},jSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}HSo.isMDXComponent=!0;const QSo={toc:[]},$So="wrapper";function JSo(t){let{components:e,...n}=t;return(0,s.kt)($So,(0,p.Z)({},QSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}JSo.isMDXComponent=!0;const KSo={toc:[]},tPo="wrapper";function ePo(t){let{components:e,...n}=t;return(0,s.kt)(tPo,(0,p.Z)({},KSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ePo.isMDXComponent=!0;const nPo={toc:[]},oPo="wrapper";function pPo(t){let{components:e,...n}=t;return(0,s.kt)(oPo,(0,p.Z)({},nPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(t){let{components:e,...n}=t;return(0,s.kt)(sPo,(0,p.Z)({},rPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cPo.isMDXComponent=!0;const iPo={toc:[]},aPo="wrapper";function lPo(t){let{components:e,...n}=t;return(0,s.kt)(aPo,(0,p.Z)({},iPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function dPo(t){let{components:e,...n}=t;return(0,s.kt)(mPo,(0,p.Z)({},uPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dPo.isMDXComponent=!0;const hPo={toc:[]},fPo="wrapper";function kPo(t){let{components:e,...n}=t;return(0,s.kt)(fPo,(0,p.Z)({},hPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kPo.isMDXComponent=!0;const yPo={toc:[]},DPo="wrapper";function MPo(t){let{components:e,...n}=t;return(0,s.kt)(DPo,(0,p.Z)({},yPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(t){let{components:e,...n}=t;return(0,s.kt)(_Po,(0,p.Z)({},XPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wPo.isMDXComponent=!0;const TPo={toc:[]},gPo="wrapper";function CPo(t){let{components:e,...n}=t;return(0,s.kt)(gPo,(0,p.Z)({},TPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CPo.isMDXComponent=!0;const xPo={toc:[]},vPo="wrapper";function LPo(t){let{components:e,...n}=t;return(0,s.kt)(vPo,(0,p.Z)({},xPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LPo.isMDXComponent=!0;const ZPo={toc:[]},bPo="wrapper";function NPo(t){let{components:e,...n}=t;return(0,s.kt)(bPo,(0,p.Z)({},ZPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NPo.isMDXComponent=!0;const APo={toc:[]},zPo="wrapper";function WPo(t){let{components:e,...n}=t;return(0,s.kt)(zPo,(0,p.Z)({},APo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}WPo.isMDXComponent=!0;const IPo={toc:[]},RPo="wrapper";function SPo(t){let{components:e,...n}=t;return(0,s.kt)(RPo,(0,p.Z)({},IPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}SPo.isMDXComponent=!0;const PPo={toc:[]},EPo="wrapper";function OPo(t){let{components:e,...n}=t;return(0,s.kt)(EPo,(0,p.Z)({},PPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}OPo.isMDXComponent=!0;const GPo={toc:[]},FPo="wrapper";function BPo(t){let{components:e,...n}=t;return(0,s.kt)(FPo,(0,p.Z)({},GPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BPo.isMDXComponent=!0;const UPo={toc:[]},VPo="wrapper";function qPo(t){let{components:e,...n}=t;return(0,s.kt)(VPo,(0,p.Z)({},UPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qPo.isMDXComponent=!0;const jPo={toc:[]},YPo="wrapper";function HPo(t){let{components:e,...n}=t;return(0,s.kt)(YPo,(0,p.Z)({},jPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}HPo.isMDXComponent=!0;const QPo={toc:[]},$Po="wrapper";function JPo(t){let{components:e,...n}=t;return(0,s.kt)($Po,(0,p.Z)({},QPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}JPo.isMDXComponent=!0;const KPo={toc:[]},tEo="wrapper";function eEo(t){let{components:e,...n}=t;return(0,s.kt)(tEo,(0,p.Z)({},KPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eEo.isMDXComponent=!0;const nEo={toc:[]},oEo="wrapper";function pEo(t){let{components:e,...n}=t;return(0,s.kt)(oEo,(0,p.Z)({},nEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(t){let{components:e,...n}=t;return(0,s.kt)(sEo,(0,p.Z)({},rEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cEo.isMDXComponent=!0;const iEo={toc:[]},aEo="wrapper";function lEo(t){let{components:e,...n}=t;return(0,s.kt)(aEo,(0,p.Z)({},iEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function dEo(t){let{components:e,...n}=t;return(0,s.kt)(mEo,(0,p.Z)({},uEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dEo.isMDXComponent=!0;const hEo={toc:[]},fEo="wrapper";function kEo(t){let{components:e,...n}=t;return(0,s.kt)(fEo,(0,p.Z)({},hEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kEo.isMDXComponent=!0;const yEo={toc:[]},DEo="wrapper";function MEo(t){let{components:e,...n}=t;return(0,s.kt)(DEo,(0,p.Z)({},yEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(t){let{components:e,...n}=t;return(0,s.kt)(_Eo,(0,p.Z)({},XEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wEo.isMDXComponent=!0;const TEo={toc:[]},gEo="wrapper";function CEo(t){let{components:e,...n}=t;return(0,s.kt)(gEo,(0,p.Z)({},TEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}CEo.isMDXComponent=!0;const xEo={toc:[]},vEo="wrapper";function LEo(t){let{components:e,...n}=t;return(0,s.kt)(vEo,(0,p.Z)({},xEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LEo.isMDXComponent=!0;const ZEo={toc:[]},bEo="wrapper";function NEo(t){let{components:e,...n}=t;return(0,s.kt)(bEo,(0,p.Z)({},ZEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NEo.isMDXComponent=!0;const AEo={toc:[]},zEo="wrapper";function WEo(t){let{components:e,...n}=t;return(0,s.kt)(zEo,(0,p.Z)({},AEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}WEo.isMDXComponent=!0;const IEo={toc:[]},REo="wrapper";function SEo(t){let{components:e,...n}=t;return(0,s.kt)(REo,(0,p.Z)({},IEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}SEo.isMDXComponent=!0;const PEo={toc:[]},EEo="wrapper";function OEo(t){let{components:e,...n}=t;return(0,s.kt)(EEo,(0,p.Z)({},PEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}OEo.isMDXComponent=!0;const GEo={toc:[]},FEo="wrapper";function BEo(t){let{components:e,...n}=t;return(0,s.kt)(FEo,(0,p.Z)({},GEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}BEo.isMDXComponent=!0;const UEo={toc:[]},VEo="wrapper";function qEo(t){let{components:e,...n}=t;return(0,s.kt)(VEo,(0,p.Z)({},UEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qEo.isMDXComponent=!0;const jEo={toc:[]},YEo="wrapper";function HEo(t){let{components:e,...n}=t;return(0,s.kt)(YEo,(0,p.Z)({},jEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}HEo.isMDXComponent=!0;const QEo={toc:[]},$Eo="wrapper";function JEo(t){let{components:e,...n}=t;return(0,s.kt)($Eo,(0,p.Z)({},QEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}JEo.isMDXComponent=!0;const KEo={toc:[]},tOo="wrapper";function eOo(t){let{components:e,...n}=t;return(0,s.kt)(tOo,(0,p.Z)({},KEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eOo.isMDXComponent=!0;const nOo={toc:[]},oOo="wrapper";function pOo(t){let{components:e,...n}=t;return(0,s.kt)(oOo,(0,p.Z)({},nOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(t){let{components:e,...n}=t;return(0,s.kt)(sOo,(0,p.Z)({},rOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cOo.isMDXComponent=!0;const iOo={toc:[]},aOo="wrapper";function lOo(t){let{components:e,...n}=t;return(0,s.kt)(aOo,(0,p.Z)({},iOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function dOo(t){let{components:e,...n}=t;return(0,s.kt)(mOo,(0,p.Z)({},uOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dOo.isMDXComponent=!0;const hOo={toc:[]},fOo="wrapper";function kOo(t){let{components:e,...n}=t;return(0,s.kt)(fOo,(0,p.Z)({},hOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kOo.isMDXComponent=!0;const yOo={toc:[]},DOo="wrapper";function MOo(t){let{components:e,...n}=t;return(0,s.kt)(DOo,(0,p.Z)({},yOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(t){let{components:e,...n}=t;return(0,s.kt)(_Oo,(0,p.Z)({},XOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wOo.isMDXComponent=!0;const TOo={toc:[]},gOo="wrapper";function COo(t){let{components:e,...n}=t;return(0,s.kt)(gOo,(0,p.Z)({},TOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}COo.isMDXComponent=!0;const xOo={toc:[]},vOo="wrapper";function LOo(t){let{components:e,...n}=t;return(0,s.kt)(vOo,(0,p.Z)({},xOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LOo.isMDXComponent=!0;const ZOo={toc:[]},bOo="wrapper";function NOo(t){let{components:e,...n}=t;return(0,s.kt)(bOo,(0,p.Z)({},ZOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NOo.isMDXComponent=!0;const AOo={toc:[]},zOo="wrapper";function WOo(t){let{components:e,...n}=t;return(0,s.kt)(zOo,(0,p.Z)({},AOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WOo.isMDXComponent=!0;const IOo={toc:[]},ROo="wrapper";function SOo(t){let{components:e,...n}=t;return(0,s.kt)(ROo,(0,p.Z)({},IOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}SOo.isMDXComponent=!0;const POo={toc:[]},EOo="wrapper";function OOo(t){let{components:e,...n}=t;return(0,s.kt)(EOo,(0,p.Z)({},POo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}OOo.isMDXComponent=!0;const GOo={toc:[]},FOo="wrapper";function BOo(t){let{components:e,...n}=t;return(0,s.kt)(FOo,(0,p.Z)({},GOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BOo.isMDXComponent=!0;const UOo={toc:[]},VOo="wrapper";function qOo(t){let{components:e,...n}=t;return(0,s.kt)(VOo,(0,p.Z)({},UOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qOo.isMDXComponent=!0;const jOo={toc:[]},YOo="wrapper";function HOo(t){let{components:e,...n}=t;return(0,s.kt)(YOo,(0,p.Z)({},jOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}HOo.isMDXComponent=!0;const QOo={toc:[]},$Oo="wrapper";function JOo(t){let{components:e,...n}=t;return(0,s.kt)($Oo,(0,p.Z)({},QOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JOo.isMDXComponent=!0;const KOo={toc:[]},tGo="wrapper";function eGo(t){let{components:e,...n}=t;return(0,s.kt)(tGo,(0,p.Z)({},KOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}eGo.isMDXComponent=!0;const nGo={toc:[]},oGo="wrapper";function pGo(t){let{components:e,...n}=t;return(0,s.kt)(oGo,(0,p.Z)({},nGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(t){let{components:e,...n}=t;return(0,s.kt)(sGo,(0,p.Z)({},rGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cGo.isMDXComponent=!0;const iGo={toc:[]},aGo="wrapper";function lGo(t){let{components:e,...n}=t;return(0,s.kt)(aGo,(0,p.Z)({},iGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function dGo(t){let{components:e,...n}=t;return(0,s.kt)(mGo,(0,p.Z)({},uGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dGo.isMDXComponent=!0;const hGo={toc:[]},fGo="wrapper";function kGo(t){let{components:e,...n}=t;return(0,s.kt)(fGo,(0,p.Z)({},hGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kGo.isMDXComponent=!0;const yGo={toc:[]},DGo="wrapper";function MGo(t){let{components:e,...n}=t;return(0,s.kt)(DGo,(0,p.Z)({},yGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(t){let{components:e,...n}=t;return(0,s.kt)(_Go,(0,p.Z)({},XGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wGo.isMDXComponent=!0;const TGo={toc:[]},gGo="wrapper";function CGo(t){let{components:e,...n}=t;return(0,s.kt)(gGo,(0,p.Z)({},TGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CGo.isMDXComponent=!0;const xGo={toc:[]},vGo="wrapper";function LGo(t){let{components:e,...n}=t;return(0,s.kt)(vGo,(0,p.Z)({},xGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LGo.isMDXComponent=!0;const ZGo={toc:[]},bGo="wrapper";function NGo(t){let{components:e,...n}=t;return(0,s.kt)(bGo,(0,p.Z)({},ZGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NGo.isMDXComponent=!0;const AGo={toc:[]},zGo="wrapper";function WGo(t){let{components:e,...n}=t;return(0,s.kt)(zGo,(0,p.Z)({},AGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}WGo.isMDXComponent=!0;const IGo={toc:[]},RGo="wrapper";function SGo(t){let{components:e,...n}=t;return(0,s.kt)(RGo,(0,p.Z)({},IGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}SGo.isMDXComponent=!0;const PGo={toc:[]},EGo="wrapper";function OGo(t){let{components:e,...n}=t;return(0,s.kt)(EGo,(0,p.Z)({},PGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}OGo.isMDXComponent=!0;const GGo={toc:[]},FGo="wrapper";function BGo(t){let{components:e,...n}=t;return(0,s.kt)(FGo,(0,p.Z)({},GGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BGo.isMDXComponent=!0;const UGo={toc:[]},VGo="wrapper";function qGo(t){let{components:e,...n}=t;return(0,s.kt)(VGo,(0,p.Z)({},UGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qGo.isMDXComponent=!0;const jGo={toc:[]},YGo="wrapper";function HGo(t){let{components:e,...n}=t;return(0,s.kt)(YGo,(0,p.Z)({},jGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}HGo.isMDXComponent=!0;const QGo={toc:[]},$Go="wrapper";function JGo(t){let{components:e,...n}=t;return(0,s.kt)($Go,(0,p.Z)({},QGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}JGo.isMDXComponent=!0;const KGo={toc:[]},tFo="wrapper";function eFo(t){let{components:e,...n}=t;return(0,s.kt)(tFo,(0,p.Z)({},KGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eFo.isMDXComponent=!0;const nFo={toc:[]},oFo="wrapper";function pFo(t){let{components:e,...n}=t;return(0,s.kt)(oFo,(0,p.Z)({},nFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(t){let{components:e,...n}=t;return(0,s.kt)(sFo,(0,p.Z)({},rFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cFo.isMDXComponent=!0;const iFo={toc:[]},aFo="wrapper";function lFo(t){let{components:e,...n}=t;return(0,s.kt)(aFo,(0,p.Z)({},iFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function dFo(t){let{components:e,...n}=t;return(0,s.kt)(mFo,(0,p.Z)({},uFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dFo.isMDXComponent=!0;const hFo={toc:[]},fFo="wrapper";function kFo(t){let{components:e,...n}=t;return(0,s.kt)(fFo,(0,p.Z)({},hFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kFo.isMDXComponent=!0;const yFo={toc:[]},DFo="wrapper";function MFo(t){let{components:e,...n}=t;return(0,s.kt)(DFo,(0,p.Z)({},yFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(t){let{components:e,...n}=t;return(0,s.kt)(_Fo,(0,p.Z)({},XFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wFo.isMDXComponent=!0;const TFo={toc:[]},gFo="wrapper";function CFo(t){let{components:e,...n}=t;return(0,s.kt)(gFo,(0,p.Z)({},TFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}CFo.isMDXComponent=!0;const xFo={toc:[]},vFo="wrapper";function LFo(t){let{components:e,...n}=t;return(0,s.kt)(vFo,(0,p.Z)({},xFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LFo.isMDXComponent=!0;const ZFo={toc:[]},bFo="wrapper";function NFo(t){let{components:e,...n}=t;return(0,s.kt)(bFo,(0,p.Z)({},ZFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NFo.isMDXComponent=!0;const AFo={toc:[]},zFo="wrapper";function WFo(t){let{components:e,...n}=t;return(0,s.kt)(zFo,(0,p.Z)({},AFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WFo.isMDXComponent=!0;const IFo={toc:[]},RFo="wrapper";function SFo(t){let{components:e,...n}=t;return(0,s.kt)(RFo,(0,p.Z)({},IFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SFo.isMDXComponent=!0;const PFo={toc:[]},EFo="wrapper";function OFo(t){let{components:e,...n}=t;return(0,s.kt)(EFo,(0,p.Z)({},PFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}OFo.isMDXComponent=!0;const GFo={toc:[]},FFo="wrapper";function BFo(t){let{components:e,...n}=t;return(0,s.kt)(FFo,(0,p.Z)({},GFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}BFo.isMDXComponent=!0;const UFo={toc:[]},VFo="wrapper";function qFo(t){let{components:e,...n}=t;return(0,s.kt)(VFo,(0,p.Z)({},UFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qFo.isMDXComponent=!0;const jFo={toc:[]},YFo="wrapper";function HFo(t){let{components:e,...n}=t;return(0,s.kt)(YFo,(0,p.Z)({},jFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}HFo.isMDXComponent=!0;const QFo={toc:[]},$Fo="wrapper";function JFo(t){let{components:e,...n}=t;return(0,s.kt)($Fo,(0,p.Z)({},QFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}JFo.isMDXComponent=!0;const KFo={toc:[]},tBo="wrapper";function eBo(t){let{components:e,...n}=t;return(0,s.kt)(tBo,(0,p.Z)({},KFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}eBo.isMDXComponent=!0;const nBo={toc:[]},oBo="wrapper";function pBo(t){let{components:e,...n}=t;return(0,s.kt)(oBo,(0,p.Z)({},nBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(t){let{components:e,...n}=t;return(0,s.kt)(sBo,(0,p.Z)({},rBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cBo.isMDXComponent=!0;const iBo={toc:[]},aBo="wrapper";function lBo(t){let{components:e,...n}=t;return(0,s.kt)(aBo,(0,p.Z)({},iBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function dBo(t){let{components:e,...n}=t;return(0,s.kt)(mBo,(0,p.Z)({},uBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dBo.isMDXComponent=!0;const hBo={toc:[]},fBo="wrapper";function kBo(t){let{components:e,...n}=t;return(0,s.kt)(fBo,(0,p.Z)({},hBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kBo.isMDXComponent=!0;const yBo={toc:[]},DBo="wrapper";function MBo(t){let{components:e,...n}=t;return(0,s.kt)(DBo,(0,p.Z)({},yBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(t){let{components:e,...n}=t;return(0,s.kt)(_Bo,(0,p.Z)({},XBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wBo.isMDXComponent=!0;const TBo={toc:[]},gBo="wrapper";function CBo(t){let{components:e,...n}=t;return(0,s.kt)(gBo,(0,p.Z)({},TBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}CBo.isMDXComponent=!0;const xBo={toc:[]},vBo="wrapper";function LBo(t){let{components:e,...n}=t;return(0,s.kt)(vBo,(0,p.Z)({},xBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}LBo.isMDXComponent=!0;const ZBo={toc:[]},bBo="wrapper";function NBo(t){let{components:e,...n}=t;return(0,s.kt)(bBo,(0,p.Z)({},ZBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}NBo.isMDXComponent=!0;const ABo={toc:[]},zBo="wrapper";function WBo(t){let{components:e,...n}=t;return(0,s.kt)(zBo,(0,p.Z)({},ABo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WBo.isMDXComponent=!0;const IBo={toc:[]},RBo="wrapper";function SBo(t){let{components:e,...n}=t;return(0,s.kt)(RBo,(0,p.Z)({},IBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}SBo.isMDXComponent=!0;const PBo={toc:[]},EBo="wrapper";function OBo(t){let{components:e,...n}=t;return(0,s.kt)(EBo,(0,p.Z)({},PBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}OBo.isMDXComponent=!0;const GBo={toc:[]},FBo="wrapper";function BBo(t){let{components:e,...n}=t;return(0,s.kt)(FBo,(0,p.Z)({},GBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BBo.isMDXComponent=!0;const UBo={toc:[]},VBo="wrapper";function qBo(t){let{components:e,...n}=t;return(0,s.kt)(VBo,(0,p.Z)({},UBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qBo.isMDXComponent=!0;const jBo={toc:[]},YBo="wrapper";function HBo(t){let{components:e,...n}=t;return(0,s.kt)(YBo,(0,p.Z)({},jBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HBo.isMDXComponent=!0;const QBo={toc:[]},$Bo="wrapper";function JBo(t){let{components:e,...n}=t;return(0,s.kt)($Bo,(0,p.Z)({},QBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}JBo.isMDXComponent=!0;const KBo={toc:[]},tUo="wrapper";function eUo(t){let{components:e,...n}=t;return(0,s.kt)(tUo,(0,p.Z)({},KBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}eUo.isMDXComponent=!0;const nUo={toc:[]},oUo="wrapper";function pUo(t){let{components:e,...n}=t;return(0,s.kt)(oUo,(0,p.Z)({},nUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(t){let{components:e,...n}=t;return(0,s.kt)(sUo,(0,p.Z)({},rUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cUo.isMDXComponent=!0;const iUo={toc:[]},aUo="wrapper";function lUo(t){let{components:e,...n}=t;return(0,s.kt)(aUo,(0,p.Z)({},iUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function dUo(t){let{components:e,...n}=t;return(0,s.kt)(mUo,(0,p.Z)({},uUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dUo.isMDXComponent=!0;const hUo={toc:[]},fUo="wrapper";function kUo(t){let{components:e,...n}=t;return(0,s.kt)(fUo,(0,p.Z)({},hUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kUo.isMDXComponent=!0;const yUo={toc:[]},DUo="wrapper";function MUo(t){let{components:e,...n}=t;return(0,s.kt)(DUo,(0,p.Z)({},yUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(t){let{components:e,...n}=t;return(0,s.kt)(_Uo,(0,p.Z)({},XUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wUo.isMDXComponent=!0;const TUo={toc:[]},gUo="wrapper";function CUo(t){let{components:e,...n}=t;return(0,s.kt)(gUo,(0,p.Z)({},TUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}CUo.isMDXComponent=!0;const xUo={toc:[]},vUo="wrapper";function LUo(t){let{components:e,...n}=t;return(0,s.kt)(vUo,(0,p.Z)({},xUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LUo.isMDXComponent=!0;const ZUo={toc:[]},bUo="wrapper";function NUo(t){let{components:e,...n}=t;return(0,s.kt)(bUo,(0,p.Z)({},ZUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NUo.isMDXComponent=!0;const AUo={toc:[]},zUo="wrapper";function WUo(t){let{components:e,...n}=t;return(0,s.kt)(zUo,(0,p.Z)({},AUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WUo.isMDXComponent=!0;const IUo={toc:[]},RUo="wrapper";function SUo(t){let{components:e,...n}=t;return(0,s.kt)(RUo,(0,p.Z)({},IUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}SUo.isMDXComponent=!0;const PUo={toc:[]},EUo="wrapper";function OUo(t){let{components:e,...n}=t;return(0,s.kt)(EUo,(0,p.Z)({},PUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}OUo.isMDXComponent=!0;const GUo={toc:[]},FUo="wrapper";function BUo(t){let{components:e,...n}=t;return(0,s.kt)(FUo,(0,p.Z)({},GUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BUo.isMDXComponent=!0;const UUo={toc:[]},VUo="wrapper";function qUo(t){let{components:e,...n}=t;return(0,s.kt)(VUo,(0,p.Z)({},UUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qUo.isMDXComponent=!0;const jUo={toc:[]},YUo="wrapper";function HUo(t){let{components:e,...n}=t;return(0,s.kt)(YUo,(0,p.Z)({},jUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}HUo.isMDXComponent=!0;const QUo={toc:[]},$Uo="wrapper";function JUo(t){let{components:e,...n}=t;return(0,s.kt)($Uo,(0,p.Z)({},QUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}JUo.isMDXComponent=!0;const KUo={toc:[]},tVo="wrapper";function eVo(t){let{components:e,...n}=t;return(0,s.kt)(tVo,(0,p.Z)({},KUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eVo.isMDXComponent=!0;const nVo={toc:[]},oVo="wrapper";function pVo(t){let{components:e,...n}=t;return(0,s.kt)(oVo,(0,p.Z)({},nVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(t){let{components:e,...n}=t;return(0,s.kt)(sVo,(0,p.Z)({},rVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cVo.isMDXComponent=!0;const iVo={toc:[]},aVo="wrapper";function lVo(t){let{components:e,...n}=t;return(0,s.kt)(aVo,(0,p.Z)({},iVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function dVo(t){let{components:e,...n}=t;return(0,s.kt)(mVo,(0,p.Z)({},uVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dVo.isMDXComponent=!0;const hVo={toc:[]},fVo="wrapper";function kVo(t){let{components:e,...n}=t;return(0,s.kt)(fVo,(0,p.Z)({},hVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}kVo.isMDXComponent=!0;const yVo={toc:[]},DVo="wrapper";function MVo(t){let{components:e,...n}=t;return(0,s.kt)(DVo,(0,p.Z)({},yVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(t){let{components:e,...n}=t;return(0,s.kt)(_Vo,(0,p.Z)({},XVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wVo.isMDXComponent=!0;const TVo={toc:[]},gVo="wrapper";function CVo(t){let{components:e,...n}=t;return(0,s.kt)(gVo,(0,p.Z)({},TVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}CVo.isMDXComponent=!0;const xVo={toc:[]},vVo="wrapper";function LVo(t){let{components:e,...n}=t;return(0,s.kt)(vVo,(0,p.Z)({},xVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}LVo.isMDXComponent=!0;const ZVo={toc:[]},bVo="wrapper";function NVo(t){let{components:e,...n}=t;return(0,s.kt)(bVo,(0,p.Z)({},ZVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NVo.isMDXComponent=!0;const AVo={toc:[]},zVo="wrapper";function WVo(t){let{components:e,...n}=t;return(0,s.kt)(zVo,(0,p.Z)({},AVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}WVo.isMDXComponent=!0;const IVo={toc:[]},RVo="wrapper";function SVo(t){let{components:e,...n}=t;return(0,s.kt)(RVo,(0,p.Z)({},IVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SVo.isMDXComponent=!0;const PVo={toc:[]},EVo="wrapper";function OVo(t){let{components:e,...n}=t;return(0,s.kt)(EVo,(0,p.Z)({},PVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}OVo.isMDXComponent=!0;const GVo={toc:[]},FVo="wrapper";function BVo(t){let{components:e,...n}=t;return(0,s.kt)(FVo,(0,p.Z)({},GVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}BVo.isMDXComponent=!0;const UVo={toc:[]},VVo="wrapper";function qVo(t){let{components:e,...n}=t;return(0,s.kt)(VVo,(0,p.Z)({},UVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qVo.isMDXComponent=!0;const jVo={toc:[]},YVo="wrapper";function HVo(t){let{components:e,...n}=t;return(0,s.kt)(YVo,(0,p.Z)({},jVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}HVo.isMDXComponent=!0;const QVo={toc:[]},$Vo="wrapper";function JVo(t){let{components:e,...n}=t;return(0,s.kt)($Vo,(0,p.Z)({},QVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}JVo.isMDXComponent=!0;const KVo={toc:[]},tqo="wrapper";function eqo(t){let{components:e,...n}=t;return(0,s.kt)(tqo,(0,p.Z)({},KVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}eqo.isMDXComponent=!0;const nqo={toc:[]},oqo="wrapper";function pqo(t){let{components:e,...n}=t;return(0,s.kt)(oqo,(0,p.Z)({},nqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(t){let{components:e,...n}=t;return(0,s.kt)(sqo,(0,p.Z)({},rqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cqo.isMDXComponent=!0;const iqo={toc:[]},aqo="wrapper";function lqo(t){let{components:e,...n}=t;return(0,s.kt)(aqo,(0,p.Z)({},iqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function dqo(t){let{components:e,...n}=t;return(0,s.kt)(mqo,(0,p.Z)({},uqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}dqo.isMDXComponent=!0;const hqo={toc:[]},fqo="wrapper";function kqo(t){let{components:e,...n}=t;return(0,s.kt)(fqo,(0,p.Z)({},hqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}kqo.isMDXComponent=!0;const yqo={toc:[]},Dqo="wrapper";function Mqo(t){let{components:e,...n}=t;return(0,s.kt)(Dqo,(0,p.Z)({},yqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(t){let{components:e,...n}=t;return(0,s.kt)(_qo,(0,p.Z)({},Xqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},gqo="wrapper";function Cqo(t){let{components:e,...n}=t;return(0,s.kt)(gqo,(0,p.Z)({},Tqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Cqo.isMDXComponent=!0;const xqo={toc:[]},vqo="wrapper";function Lqo(t){let{components:e,...n}=t;return(0,s.kt)(vqo,(0,p.Z)({},xqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Lqo.isMDXComponent=!0;const Zqo={toc:[]},bqo="wrapper";function Nqo(t){let{components:e,...n}=t;return(0,s.kt)(bqo,(0,p.Z)({},Zqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Nqo.isMDXComponent=!0;const Aqo={toc:[]},zqo="wrapper";function Wqo(t){let{components:e,...n}=t;return(0,s.kt)(zqo,(0,p.Z)({},Aqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Wqo.isMDXComponent=!0;const Iqo={toc:[]},Rqo="wrapper";function Sqo(t){let{components:e,...n}=t;return(0,s.kt)(Rqo,(0,p.Z)({},Iqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Sqo.isMDXComponent=!0;const Pqo={toc:[]},Eqo="wrapper";function Oqo(t){let{components:e,...n}=t;return(0,s.kt)(Eqo,(0,p.Z)({},Pqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Oqo.isMDXComponent=!0;const Gqo={toc:[]},Fqo="wrapper";function Bqo(t){let{components:e,...n}=t;return(0,s.kt)(Fqo,(0,p.Z)({},Gqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Bqo.isMDXComponent=!0;const Uqo={toc:[]},Vqo="wrapper";function qqo(t){let{components:e,...n}=t;return(0,s.kt)(Vqo,(0,p.Z)({},Uqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qqo.isMDXComponent=!0;const jqo={toc:[]},Yqo="wrapper";function Hqo(t){let{components:e,...n}=t;return(0,s.kt)(Yqo,(0,p.Z)({},jqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Hqo.isMDXComponent=!0;const Qqo={toc:[]},$qo="wrapper";function Jqo(t){let{components:e,...n}=t;return(0,s.kt)($qo,(0,p.Z)({},Qqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Jqo.isMDXComponent=!0;const Kqo={toc:[]},tjo="wrapper";function ejo(t){let{components:e,...n}=t;return(0,s.kt)(tjo,(0,p.Z)({},Kqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ejo.isMDXComponent=!0;const njo={toc:[]},ojo="wrapper";function pjo(t){let{components:e,...n}=t;return(0,s.kt)(ojo,(0,p.Z)({},njo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(t){let{components:e,...n}=t;return(0,s.kt)(sjo,(0,p.Z)({},rjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cjo.isMDXComponent=!0;const ijo={toc:[]},ajo="wrapper";function ljo(t){let{components:e,...n}=t;return(0,s.kt)(ajo,(0,p.Z)({},ijo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function djo(t){let{components:e,...n}=t;return(0,s.kt)(mjo,(0,p.Z)({},ujo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}djo.isMDXComponent=!0;const hjo={toc:[]},fjo="wrapper";function kjo(t){let{components:e,...n}=t;return(0,s.kt)(fjo,(0,p.Z)({},hjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}kjo.isMDXComponent=!0;const yjo={toc:[]},Djo="wrapper";function Mjo(t){let{components:e,...n}=t;return(0,s.kt)(Djo,(0,p.Z)({},yjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(t){let{components:e,...n}=t;return(0,s.kt)(_jo,(0,p.Z)({},Xjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},gjo="wrapper";function Cjo(t){let{components:e,...n}=t;return(0,s.kt)(gjo,(0,p.Z)({},Tjo,n,{components:e,mdxType:"MDXLayout"}))}Cjo.isMDXComponent=!0;const xjo={toc:[]},vjo="wrapper";function Ljo(t){let{components:e,...n}=t;return(0,s.kt)(vjo,(0,p.Z)({},xjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ljo.isMDXComponent=!0;const Zjo={toc:[]},bjo="wrapper";function Njo(t){let{components:e,...n}=t;return(0,s.kt)(bjo,(0,p.Z)({},Zjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Njo.isMDXComponent=!0;const Ajo={toc:[]},zjo="wrapper";function Wjo(t){let{components:e,...n}=t;return(0,s.kt)(zjo,(0,p.Z)({},Ajo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wjo.isMDXComponent=!0;const Ijo={toc:[]},Rjo="wrapper";function Sjo(t){let{components:e,...n}=t;return(0,s.kt)(Rjo,(0,p.Z)({},Ijo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Sjo.isMDXComponent=!0;const Pjo={toc:[]},Ejo="wrapper";function Ojo(t){let{components:e,...n}=t;return(0,s.kt)(Ejo,(0,p.Z)({},Pjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ojo.isMDXComponent=!0;const Gjo={toc:[]},Fjo="wrapper";function Bjo(t){let{components:e,...n}=t;return(0,s.kt)(Fjo,(0,p.Z)({},Gjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Bjo.isMDXComponent=!0;const Ujo={toc:[]},Vjo="wrapper";function qjo(t){let{components:e,...n}=t;return(0,s.kt)(Vjo,(0,p.Z)({},Ujo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}qjo.isMDXComponent=!0;const jjo={toc:[]},Yjo="wrapper";function Hjo(t){let{components:e,...n}=t;return(0,s.kt)(Yjo,(0,p.Z)({},jjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Hjo.isMDXComponent=!0;const Qjo={toc:[]},$jo="wrapper";function Jjo(t){let{components:e,...n}=t;return(0,s.kt)($jo,(0,p.Z)({},Qjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Jjo.isMDXComponent=!0;const Kjo={toc:[]},tYo="wrapper";function eYo(t){let{components:e,...n}=t;return(0,s.kt)(tYo,(0,p.Z)({},Kjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}eYo.isMDXComponent=!0;const nYo={toc:[]},oYo="wrapper";function pYo(t){let{components:e,...n}=t;return(0,s.kt)(oYo,(0,p.Z)({},nYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(t){let{components:e,...n}=t;return(0,s.kt)(sYo,(0,p.Z)({},rYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}cYo.isMDXComponent=!0;const iYo={toc:[]},aYo="wrapper";function lYo(t){let{components:e,...n}=t;return(0,s.kt)(aYo,(0,p.Z)({},iYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function dYo(t){let{components:e,...n}=t;return(0,s.kt)(mYo,(0,p.Z)({},uYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}dYo.isMDXComponent=!0;const hYo={toc:[]},fYo="wrapper";function kYo(t){let{components:e,...n}=t;return(0,s.kt)(fYo,(0,p.Z)({},hYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}kYo.isMDXComponent=!0;const yYo={toc:[]},DYo="wrapper";function MYo(t){let{components:e,...n}=t;return(0,s.kt)(DYo,(0,p.Z)({},yYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(t){let{components:e,...n}=t;return(0,s.kt)(_Yo,(0,p.Z)({},XYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wYo.isMDXComponent=!0;const TYo={toc:[]},gYo="wrapper";function CYo(t){let{components:e,...n}=t;return(0,s.kt)(gYo,(0,p.Z)({},TYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}CYo.isMDXComponent=!0;const xYo={toc:[]},vYo="wrapper";function LYo(t){let{components:e,...n}=t;return(0,s.kt)(vYo,(0,p.Z)({},xYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}LYo.isMDXComponent=!0;const ZYo={toc:[]},bYo="wrapper";function NYo(t){let{components:e,...n}=t;return(0,s.kt)(bYo,(0,p.Z)({},ZYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}NYo.isMDXComponent=!0;const AYo={toc:[]},zYo="wrapper";function WYo(t){let{components:e,...n}=t;return(0,s.kt)(zYo,(0,p.Z)({},AYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}WYo.isMDXComponent=!0;const IYo={toc:[]},RYo="wrapper";function SYo(t){let{components:e,...n}=t;return(0,s.kt)(RYo,(0,p.Z)({},IYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}SYo.isMDXComponent=!0;const PYo={toc:[]},EYo="wrapper";function OYo(t){let{components:e,...n}=t;return(0,s.kt)(EYo,(0,p.Z)({},PYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}OYo.isMDXComponent=!0;const GYo={toc:[]},FYo="wrapper";function BYo(t){let{components:e,...n}=t;return(0,s.kt)(FYo,(0,p.Z)({},GYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}BYo.isMDXComponent=!0;const UYo={toc:[]},VYo="wrapper";function qYo(t){let{components:e,...n}=t;return(0,s.kt)(VYo,(0,p.Z)({},UYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qYo.isMDXComponent=!0;const jYo={toc:[]},YYo="wrapper";function HYo(t){let{components:e,...n}=t;return(0,s.kt)(YYo,(0,p.Z)({},jYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}HYo.isMDXComponent=!0;const QYo={toc:[]},$Yo="wrapper";function JYo(t){let{components:e,...n}=t;return(0,s.kt)($Yo,(0,p.Z)({},QYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JYo.isMDXComponent=!0;const KYo={toc:[]},tHo="wrapper";function eHo(t){let{components:e,...n}=t;return(0,s.kt)(tHo,(0,p.Z)({},KYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eHo.isMDXComponent=!0;const nHo={toc:[]},oHo="wrapper";function pHo(t){let{components:e,...n}=t;return(0,s.kt)(oHo,(0,p.Z)({},nHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(t){let{components:e,...n}=t;return(0,s.kt)(sHo,(0,p.Z)({},rHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}cHo.isMDXComponent=!0;const iHo={toc:[]},aHo="wrapper";function lHo(t){let{components:e,...n}=t;return(0,s.kt)(aHo,(0,p.Z)({},iHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function dHo(t){let{components:e,...n}=t;return(0,s.kt)(mHo,(0,p.Z)({},uHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dHo.isMDXComponent=!0;const hHo={toc:[]},fHo="wrapper";function kHo(t){let{components:e,...n}=t;return(0,s.kt)(fHo,(0,p.Z)({},hHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kHo.isMDXComponent=!0;const yHo={toc:[]},DHo="wrapper";function MHo(t){let{components:e,...n}=t;return(0,s.kt)(DHo,(0,p.Z)({},yHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(t){let{components:e,...n}=t;return(0,s.kt)(_Ho,(0,p.Z)({},XHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wHo.isMDXComponent=!0;const THo={toc:[]},gHo="wrapper";function CHo(t){let{components:e,...n}=t;return(0,s.kt)(gHo,(0,p.Z)({},THo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}CHo.isMDXComponent=!0;const xHo={toc:[]},vHo="wrapper";function LHo(t){let{components:e,...n}=t;return(0,s.kt)(vHo,(0,p.Z)({},xHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LHo.isMDXComponent=!0;const ZHo={toc:[]},bHo="wrapper";function NHo(t){let{components:e,...n}=t;return(0,s.kt)(bHo,(0,p.Z)({},ZHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}NHo.isMDXComponent=!0;const AHo={toc:[]},zHo="wrapper";function WHo(t){let{components:e,...n}=t;return(0,s.kt)(zHo,(0,p.Z)({},AHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WHo.isMDXComponent=!0;const IHo={toc:[]},RHo="wrapper";function SHo(t){let{components:e,...n}=t;return(0,s.kt)(RHo,(0,p.Z)({},IHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}SHo.isMDXComponent=!0;const PHo={toc:[]},EHo="wrapper";function OHo(t){let{components:e,...n}=t;return(0,s.kt)(EHo,(0,p.Z)({},PHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}OHo.isMDXComponent=!0;const GHo={toc:[]},FHo="wrapper";function BHo(t){let{components:e,...n}=t;return(0,s.kt)(FHo,(0,p.Z)({},GHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}BHo.isMDXComponent=!0;const UHo={toc:[]},VHo="wrapper";function qHo(t){let{components:e,...n}=t;return(0,s.kt)(VHo,(0,p.Z)({},UHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qHo.isMDXComponent=!0;const jHo={toc:[]},YHo="wrapper";function HHo(t){let{components:e,...n}=t;return(0,s.kt)(YHo,(0,p.Z)({},jHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}HHo.isMDXComponent=!0;const QHo={toc:[]},$Ho="wrapper";function JHo(t){let{components:e,...n}=t;return(0,s.kt)($Ho,(0,p.Z)({},QHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}JHo.isMDXComponent=!0;const KHo={toc:[]},tQo="wrapper";function eQo(t){let{components:e,...n}=t;return(0,s.kt)(tQo,(0,p.Z)({},KHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}eQo.isMDXComponent=!0;const nQo={toc:[]},oQo="wrapper";function pQo(t){let{components:e,...n}=t;return(0,s.kt)(oQo,(0,p.Z)({},nQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(t){let{components:e,...n}=t;return(0,s.kt)(sQo,(0,p.Z)({},rQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cQo.isMDXComponent=!0;const iQo={toc:[]},aQo="wrapper";function lQo(t){let{components:e,...n}=t;return(0,s.kt)(aQo,(0,p.Z)({},iQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function dQo(t){let{components:e,...n}=t;return(0,s.kt)(mQo,(0,p.Z)({},uQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}dQo.isMDXComponent=!0;const hQo={toc:[]},fQo="wrapper";function kQo(t){let{components:e,...n}=t;return(0,s.kt)(fQo,(0,p.Z)({},hQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kQo.isMDXComponent=!0;const yQo={toc:[]},DQo="wrapper";function MQo(t){let{components:e,...n}=t;return(0,s.kt)(DQo,(0,p.Z)({},yQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(t){let{components:e,...n}=t;return(0,s.kt)(_Qo,(0,p.Z)({},XQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}wQo.isMDXComponent=!0;const TQo={toc:[]},gQo="wrapper";function CQo(t){let{components:e,...n}=t;return(0,s.kt)(gQo,(0,p.Z)({},TQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}CQo.isMDXComponent=!0;const xQo={toc:[]},vQo="wrapper";function LQo(t){let{components:e,...n}=t;return(0,s.kt)(vQo,(0,p.Z)({},xQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}LQo.isMDXComponent=!0;const ZQo={toc:[]},bQo="wrapper";function NQo(t){let{components:e,...n}=t;return(0,s.kt)(bQo,(0,p.Z)({},ZQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NQo.isMDXComponent=!0;const AQo={toc:[]},zQo="wrapper";function WQo(t){let{components:e,...n}=t;return(0,s.kt)(zQo,(0,p.Z)({},AQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WQo.isMDXComponent=!0;const IQo={toc:[]},RQo="wrapper";function SQo(t){let{components:e,...n}=t;return(0,s.kt)(RQo,(0,p.Z)({},IQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}SQo.isMDXComponent=!0;const PQo={toc:[]},EQo="wrapper";function OQo(t){let{components:e,...n}=t;return(0,s.kt)(EQo,(0,p.Z)({},PQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}OQo.isMDXComponent=!0;const GQo={toc:[]},FQo="wrapper";function BQo(t){let{components:e,...n}=t;return(0,s.kt)(FQo,(0,p.Z)({},GQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BQo.isMDXComponent=!0;const UQo={toc:[]},VQo="wrapper";function qQo(t){let{components:e,...n}=t;return(0,s.kt)(VQo,(0,p.Z)({},UQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qQo.isMDXComponent=!0;const jQo={toc:[]},YQo="wrapper";function HQo(t){let{components:e,...n}=t;return(0,s.kt)(YQo,(0,p.Z)({},jQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}HQo.isMDXComponent=!0;const QQo={toc:[]},$Qo="wrapper";function JQo(t){let{components:e,...n}=t;return(0,s.kt)($Qo,(0,p.Z)({},QQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}JQo.isMDXComponent=!0;const KQo={toc:[]},t$o="wrapper";function e$o(t){let{components:e,...n}=t;return(0,s.kt)(t$o,(0,p.Z)({},KQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e$o.isMDXComponent=!0;const n$o={toc:[]},o$o="wrapper";function p$o(t){let{components:e,...n}=t;return(0,s.kt)(o$o,(0,p.Z)({},n$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find a node by its key."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(t){let{components:e,...n}=t;return(0,s.kt)(s$o,(0,p.Z)({},r$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The key of the node."))}c$o.isMDXComponent=!0;const i$o={toc:[]},a$o="wrapper";function l$o(t){let{components:e,...n}=t;return(0,s.kt)(a$o,(0,p.Z)({},i$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function d$o(t){let{components:e,...n}=t;return(0,s.kt)(m$o,(0,p.Z)({},u$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d$o.isMDXComponent=!0;const h$o={toc:[]},f$o="wrapper";function k$o(t){let{components:e,...n}=t;return(0,s.kt)(f$o,(0,p.Z)({},h$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}k$o.isMDXComponent=!0;const y$o={toc:[]},D$o="wrapper";function M$o(t){let{components:e,...n}=t;return(0,s.kt)(D$o,(0,p.Z)({},y$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(t){let{components:e,...n}=t;return(0,s.kt)(_$o,(0,p.Z)({},X$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}w$o.isMDXComponent=!0;const T$o={toc:[]},g$o="wrapper";function C$o(t){let{components:e,...n}=t;return(0,s.kt)(g$o,(0,p.Z)({},T$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}C$o.isMDXComponent=!0;const x$o={toc:[]},v$o="wrapper";function L$o(t){let{components:e,...n}=t;return(0,s.kt)(v$o,(0,p.Z)({},x$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}L$o.isMDXComponent=!0;const Z$o={toc:[]},b$o="wrapper";function N$o(t){let{components:e,...n}=t;return(0,s.kt)(b$o,(0,p.Z)({},Z$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}N$o.isMDXComponent=!0;const A$o={toc:[]},z$o="wrapper";function W$o(t){let{components:e,...n}=t;return(0,s.kt)(z$o,(0,p.Z)({},A$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}W$o.isMDXComponent=!0;const I$o={toc:[]},R$o="wrapper";function S$o(t){let{components:e,...n}=t;return(0,s.kt)(R$o,(0,p.Z)({},I$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}S$o.isMDXComponent=!0;const P$o={toc:[]},E$o="wrapper";function O$o(t){let{components:e,...n}=t;return(0,s.kt)(E$o,(0,p.Z)({},P$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}O$o.isMDXComponent=!0;const G$o={toc:[]},F$o="wrapper";function B$o(t){let{components:e,...n}=t;return(0,s.kt)(F$o,(0,p.Z)({},G$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}B$o.isMDXComponent=!0;const U$o={toc:[]},V$o="wrapper";function q$o(t){let{components:e,...n}=t;return(0,s.kt)(V$o,(0,p.Z)({},U$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q$o.isMDXComponent=!0;const j$o={toc:[]},Y$o="wrapper";function H$o(t){let{components:e,...n}=t;return(0,s.kt)(Y$o,(0,p.Z)({},j$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}H$o.isMDXComponent=!0;const Q$o={toc:[]},$$o="wrapper";function J$o(t){let{components:e,...n}=t;return(0,s.kt)($$o,(0,p.Z)({},Q$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}J$o.isMDXComponent=!0;const K$o={toc:[]},tJo="wrapper";function eJo(t){let{components:e,...n}=t;return(0,s.kt)(tJo,(0,p.Z)({},K$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}eJo.isMDXComponent=!0;const nJo={toc:[]},oJo="wrapper";function pJo(t){let{components:e,...n}=t;return(0,s.kt)(oJo,(0,p.Z)({},nJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(t){let{components:e,...n}=t;return(0,s.kt)(sJo,(0,p.Z)({},rJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cJo.isMDXComponent=!0;const iJo={toc:[]},aJo="wrapper";function lJo(t){let{components:e,...n}=t;return(0,s.kt)(aJo,(0,p.Z)({},iJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function dJo(t){let{components:e,...n}=t;return(0,s.kt)(mJo,(0,p.Z)({},uJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dJo.isMDXComponent=!0;const hJo={toc:[]},fJo="wrapper";function kJo(t){let{components:e,...n}=t;return(0,s.kt)(fJo,(0,p.Z)({},hJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kJo.isMDXComponent=!0;const yJo={toc:[]},DJo="wrapper";function MJo(t){let{components:e,...n}=t;return(0,s.kt)(DJo,(0,p.Z)({},yJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(t){let{components:e,...n}=t;return(0,s.kt)(_Jo,(0,p.Z)({},XJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wJo.isMDXComponent=!0;const TJo={toc:[]},gJo="wrapper";function CJo(t){let{components:e,...n}=t;return(0,s.kt)(gJo,(0,p.Z)({},TJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}CJo.isMDXComponent=!0;const xJo={toc:[]},vJo="wrapper";function LJo(t){let{components:e,...n}=t;return(0,s.kt)(vJo,(0,p.Z)({},xJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LJo.isMDXComponent=!0;const ZJo={toc:[]},bJo="wrapper";function NJo(t){let{components:e,...n}=t;return(0,s.kt)(bJo,(0,p.Z)({},ZJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NJo.isMDXComponent=!0;const AJo={toc:[]},zJo="wrapper";function WJo(t){let{components:e,...n}=t;return(0,s.kt)(zJo,(0,p.Z)({},AJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}WJo.isMDXComponent=!0;const IJo={toc:[]},RJo="wrapper";function SJo(t){let{components:e,...n}=t;return(0,s.kt)(RJo,(0,p.Z)({},IJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}SJo.isMDXComponent=!0;const PJo={toc:[]},EJo="wrapper";function OJo(t){let{components:e,...n}=t;return(0,s.kt)(EJo,(0,p.Z)({},PJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OJo.isMDXComponent=!0;const GJo={toc:[]},FJo="wrapper";function BJo(t){let{components:e,...n}=t;return(0,s.kt)(FJo,(0,p.Z)({},GJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}BJo.isMDXComponent=!0;const UJo={toc:[]},VJo="wrapper";function qJo(t){let{components:e,...n}=t;return(0,s.kt)(VJo,(0,p.Z)({},UJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qJo.isMDXComponent=!0;const jJo={toc:[]},YJo="wrapper";function HJo(t){let{components:e,...n}=t;return(0,s.kt)(YJo,(0,p.Z)({},jJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}HJo.isMDXComponent=!0;const QJo={toc:[]},$Jo="wrapper";function JJo(t){let{components:e,...n}=t;return(0,s.kt)($Jo,(0,p.Z)({},QJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}JJo.isMDXComponent=!0;const KJo={toc:[]},tKo="wrapper";function eKo(t){let{components:e,...n}=t;return(0,s.kt)(tKo,(0,p.Z)({},KJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}eKo.isMDXComponent=!0;const nKo={toc:[]},oKo="wrapper";function pKo(t){let{components:e,...n}=t;return(0,s.kt)(oKo,(0,p.Z)({},nKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(t){let{components:e,...n}=t;return(0,s.kt)(sKo,(0,p.Z)({},rKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cKo.isMDXComponent=!0;const iKo={toc:[]},aKo="wrapper";function lKo(t){let{components:e,...n}=t;return(0,s.kt)(aKo,(0,p.Z)({},iKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function dKo(t){let{components:e,...n}=t;return(0,s.kt)(mKo,(0,p.Z)({},uKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dKo.isMDXComponent=!0;const hKo={toc:[]},fKo="wrapper";function kKo(t){let{components:e,...n}=t;return(0,s.kt)(fKo,(0,p.Z)({},hKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kKo.isMDXComponent=!0;const yKo={toc:[]},DKo="wrapper";function MKo(t){let{components:e,...n}=t;return(0,s.kt)(DKo,(0,p.Z)({},yKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(t){let{components:e,...n}=t;return(0,s.kt)(_Ko,(0,p.Z)({},XKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wKo.isMDXComponent=!0;const TKo={toc:[]},gKo="wrapper";function CKo(t){let{components:e,...n}=t;return(0,s.kt)(gKo,(0,p.Z)({},TKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}CKo.isMDXComponent=!0;const xKo={toc:[]},vKo="wrapper";function LKo(t){let{components:e,...n}=t;return(0,s.kt)(vKo,(0,p.Z)({},xKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LKo.isMDXComponent=!0;const ZKo={toc:[]},bKo="wrapper";function NKo(t){let{components:e,...n}=t;return(0,s.kt)(bKo,(0,p.Z)({},ZKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NKo.isMDXComponent=!0;const AKo={toc:[]},zKo="wrapper";function WKo(t){let{components:e,...n}=t;return(0,s.kt)(zKo,(0,p.Z)({},AKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}WKo.isMDXComponent=!0;const IKo={toc:[]},RKo="wrapper";function SKo(t){let{components:e,...n}=t;return(0,s.kt)(RKo,(0,p.Z)({},IKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}SKo.isMDXComponent=!0;const PKo={toc:[]},EKo="wrapper";function OKo(t){let{components:e,...n}=t;return(0,s.kt)(EKo,(0,p.Z)({},PKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}OKo.isMDXComponent=!0;const GKo={toc:[]},FKo="wrapper";function BKo(t){let{components:e,...n}=t;return(0,s.kt)(FKo,(0,p.Z)({},GKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BKo.isMDXComponent=!0;const UKo={toc:[]},VKo="wrapper";function qKo(t){let{components:e,...n}=t;return(0,s.kt)(VKo,(0,p.Z)({},UKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qKo.isMDXComponent=!0;const jKo={toc:[]},YKo="wrapper";function HKo(t){let{components:e,...n}=t;return(0,s.kt)(YKo,(0,p.Z)({},jKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}HKo.isMDXComponent=!0;const QKo={toc:[]},$Ko="wrapper";function JKo(t){let{components:e,...n}=t;return(0,s.kt)($Ko,(0,p.Z)({},QKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}JKo.isMDXComponent=!0;const KKo={toc:[]},t0o="wrapper";function e0o(t){let{components:e,...n}=t;return(0,s.kt)(t0o,(0,p.Z)({},KKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}e0o.isMDXComponent=!0;const n0o={toc:[]},o0o="wrapper";function p0o(t){let{components:e,...n}=t;return(0,s.kt)(o0o,(0,p.Z)({},n0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(t){let{components:e,...n}=t;return(0,s.kt)(s0o,(0,p.Z)({},r0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}c0o.isMDXComponent=!0;const i0o={toc:[]},a0o="wrapper";function l0o(t){let{components:e,...n}=t;return(0,s.kt)(a0o,(0,p.Z)({},i0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function d0o(t){let{components:e,...n}=t;return(0,s.kt)(m0o,(0,p.Z)({},u0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}d0o.isMDXComponent=!0;const h0o={toc:[]},f0o="wrapper";function k0o(t){let{components:e,...n}=t;return(0,s.kt)(f0o,(0,p.Z)({},h0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}k0o.isMDXComponent=!0;const y0o={toc:[]},D0o="wrapper";function M0o(t){let{components:e,...n}=t;return(0,s.kt)(D0o,(0,p.Z)({},y0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(t){let{components:e,...n}=t;return(0,s.kt)(_0o,(0,p.Z)({},X0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}w0o.isMDXComponent=!0;const T0o={toc:[]},g0o="wrapper";function C0o(t){let{components:e,...n}=t;return(0,s.kt)(g0o,(0,p.Z)({},T0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C0o.isMDXComponent=!0;const x0o={toc:[]},v0o="wrapper";function L0o(t){let{components:e,...n}=t;return(0,s.kt)(v0o,(0,p.Z)({},x0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}L0o.isMDXComponent=!0;const Z0o={toc:[]},b0o="wrapper";function N0o(t){let{components:e,...n}=t;return(0,s.kt)(b0o,(0,p.Z)({},Z0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}N0o.isMDXComponent=!0;const A0o={toc:[]},z0o="wrapper";function W0o(t){let{components:e,...n}=t;return(0,s.kt)(z0o,(0,p.Z)({},A0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}W0o.isMDXComponent=!0;const I0o={toc:[]},R0o="wrapper";function S0o(t){let{components:e,...n}=t;return(0,s.kt)(R0o,(0,p.Z)({},I0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}S0o.isMDXComponent=!0;const P0o={toc:[]},E0o="wrapper";function O0o(t){let{components:e,...n}=t;return(0,s.kt)(E0o,(0,p.Z)({},P0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O0o.isMDXComponent=!0;const G0o={toc:[]},F0o="wrapper";function B0o(t){let{components:e,...n}=t;return(0,s.kt)(F0o,(0,p.Z)({},G0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}B0o.isMDXComponent=!0;const U0o={toc:[]},V0o="wrapper";function q0o(t){let{components:e,...n}=t;return(0,s.kt)(V0o,(0,p.Z)({},U0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}q0o.isMDXComponent=!0;const j0o={toc:[]},Y0o="wrapper";function H0o(t){let{components:e,...n}=t;return(0,s.kt)(Y0o,(0,p.Z)({},j0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}H0o.isMDXComponent=!0;const Q0o={toc:[]},$0o="wrapper";function J0o(t){let{components:e,...n}=t;return(0,s.kt)($0o,(0,p.Z)({},Q0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}J0o.isMDXComponent=!0;const K0o={toc:[]},t2o="wrapper";function e2o(t){let{components:e,...n}=t;return(0,s.kt)(t2o,(0,p.Z)({},K0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}e2o.isMDXComponent=!0;const n2o={toc:[]},o2o="wrapper";function p2o(t){let{components:e,...n}=t;return(0,s.kt)(o2o,(0,p.Z)({},n2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(t){let{components:e,...n}=t;return(0,s.kt)(s2o,(0,p.Z)({},r2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}c2o.isMDXComponent=!0;const i2o={toc:[]},a2o="wrapper";function l2o(t){let{components:e,...n}=t;return(0,s.kt)(a2o,(0,p.Z)({},i2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function d2o(t){let{components:e,...n}=t;return(0,s.kt)(m2o,(0,p.Z)({},u2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}d2o.isMDXComponent=!0;const h2o={toc:[]},f2o="wrapper";function k2o(t){let{components:e,...n}=t;return(0,s.kt)(f2o,(0,p.Z)({},h2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}k2o.isMDXComponent=!0;const y2o={toc:[]},D2o="wrapper";function M2o(t){let{components:e,...n}=t;return(0,s.kt)(D2o,(0,p.Z)({},y2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(t){let{components:e,...n}=t;return(0,s.kt)(_2o,(0,p.Z)({},X2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w2o.isMDXComponent=!0;const T2o={toc:[]},g2o="wrapper";function C2o(t){let{components:e,...n}=t;return(0,s.kt)(g2o,(0,p.Z)({},T2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}C2o.isMDXComponent=!0;const x2o={toc:[]},v2o="wrapper";function L2o(t){let{components:e,...n}=t;return(0,s.kt)(v2o,(0,p.Z)({},x2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}L2o.isMDXComponent=!0;const Z2o={toc:[]},b2o="wrapper";function N2o(t){let{components:e,...n}=t;return(0,s.kt)(b2o,(0,p.Z)({},Z2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}N2o.isMDXComponent=!0;const A2o={toc:[]},z2o="wrapper";function W2o(t){let{components:e,...n}=t;return(0,s.kt)(z2o,(0,p.Z)({},A2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}W2o.isMDXComponent=!0;const I2o={toc:[]},R2o="wrapper";function S2o(t){let{components:e,...n}=t;return(0,s.kt)(R2o,(0,p.Z)({},I2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}S2o.isMDXComponent=!0;const P2o={toc:[]},E2o="wrapper";function O2o(t){let{components:e,...n}=t;return(0,s.kt)(E2o,(0,p.Z)({},P2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}O2o.isMDXComponent=!0;const G2o={toc:[]},F2o="wrapper";function B2o(t){let{components:e,...n}=t;return(0,s.kt)(F2o,(0,p.Z)({},G2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}B2o.isMDXComponent=!0;const U2o={toc:[]},V2o="wrapper";function q2o(t){let{components:e,...n}=t;return(0,s.kt)(V2o,(0,p.Z)({},U2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}q2o.isMDXComponent=!0;const j2o={toc:[]},Y2o="wrapper";function H2o(t){let{components:e,...n}=t;return(0,s.kt)(Y2o,(0,p.Z)({},j2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}H2o.isMDXComponent=!0;const Q2o={toc:[]},$2o="wrapper";function J2o(t){let{components:e,...n}=t;return(0,s.kt)($2o,(0,p.Z)({},Q2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}J2o.isMDXComponent=!0;const K2o={toc:[]},t6o="wrapper";function e6o(t){let{components:e,...n}=t;return(0,s.kt)(t6o,(0,p.Z)({},K2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}e6o.isMDXComponent=!0;const n6o={toc:[]},o6o="wrapper";function p6o(t){let{components:e,...n}=t;return(0,s.kt)(o6o,(0,p.Z)({},n6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(t){let{components:e,...n}=t;return(0,s.kt)(s6o,(0,p.Z)({},r6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c6o.isMDXComponent=!0;const i6o={toc:[]},a6o="wrapper";function l6o(t){let{components:e,...n}=t;return(0,s.kt)(a6o,(0,p.Z)({},i6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function d6o(t){let{components:e,...n}=t;return(0,s.kt)(m6o,(0,p.Z)({},u6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d6o.isMDXComponent=!0;const h6o={toc:[]},f6o="wrapper";function k6o(t){let{components:e,...n}=t;return(0,s.kt)(f6o,(0,p.Z)({},h6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}k6o.isMDXComponent=!0;const y6o={toc:[]},D6o="wrapper";function M6o(t){let{components:e,...n}=t;return(0,s.kt)(D6o,(0,p.Z)({},y6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(t){let{components:e,...n}=t;return(0,s.kt)(_6o,(0,p.Z)({},X6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}w6o.isMDXComponent=!0;const T6o={toc:[]},g6o="wrapper";function C6o(t){let{components:e,...n}=t;return(0,s.kt)(g6o,(0,p.Z)({},T6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}C6o.isMDXComponent=!0;const x6o={toc:[]},v6o="wrapper";function L6o(t){let{components:e,...n}=t;return(0,s.kt)(v6o,(0,p.Z)({},x6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}L6o.isMDXComponent=!0;const Z6o={toc:[]},b6o="wrapper";function N6o(t){let{components:e,...n}=t;return(0,s.kt)(b6o,(0,p.Z)({},Z6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}N6o.isMDXComponent=!0;const A6o={toc:[]},z6o="wrapper";function W6o(t){let{components:e,...n}=t;return(0,s.kt)(z6o,(0,p.Z)({},A6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}W6o.isMDXComponent=!0;const I6o={toc:[]},R6o="wrapper";function S6o(t){let{components:e,...n}=t;return(0,s.kt)(R6o,(0,p.Z)({},I6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}S6o.isMDXComponent=!0;const P6o={toc:[]},E6o="wrapper";function O6o(t){let{components:e,...n}=t;return(0,s.kt)(E6o,(0,p.Z)({},P6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}O6o.isMDXComponent=!0;const G6o={toc:[]},F6o="wrapper";function B6o(t){let{components:e,...n}=t;return(0,s.kt)(F6o,(0,p.Z)({},G6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}B6o.isMDXComponent=!0;const U6o={toc:[]},V6o="wrapper";function q6o(t){let{components:e,...n}=t;return(0,s.kt)(V6o,(0,p.Z)({},U6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q6o.isMDXComponent=!0;const j6o={toc:[]},Y6o="wrapper";function H6o(t){let{components:e,...n}=t;return(0,s.kt)(Y6o,(0,p.Z)({},j6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}H6o.isMDXComponent=!0;const Q6o={toc:[]},$6o="wrapper";function J6o(t){let{components:e,...n}=t;return(0,s.kt)($6o,(0,p.Z)({},Q6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}J6o.isMDXComponent=!0;const K6o={toc:[]},t3o="wrapper";function e3o(t){let{components:e,...n}=t;return(0,s.kt)(t3o,(0,p.Z)({},K6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}e3o.isMDXComponent=!0;const n3o={toc:[]},o3o="wrapper";function p3o(t){let{components:e,...n}=t;return(0,s.kt)(o3o,(0,p.Z)({},n3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(t){let{components:e,...n}=t;return(0,s.kt)(s3o,(0,p.Z)({},r3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}c3o.isMDXComponent=!0;const i3o={toc:[]},a3o="wrapper";function l3o(t){let{components:e,...n}=t;return(0,s.kt)(a3o,(0,p.Z)({},i3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function d3o(t){let{components:e,...n}=t;return(0,s.kt)(m3o,(0,p.Z)({},u3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d3o.isMDXComponent=!0;const h3o={toc:[]},f3o="wrapper";function k3o(t){let{components:e,...n}=t;return(0,s.kt)(f3o,(0,p.Z)({},h3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}k3o.isMDXComponent=!0;const y3o={toc:[]},D3o="wrapper";function M3o(t){let{components:e,...n}=t;return(0,s.kt)(D3o,(0,p.Z)({},y3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(t){let{components:e,...n}=t;return(0,s.kt)(_3o,(0,p.Z)({},X3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}w3o.isMDXComponent=!0;const T3o={toc:[]},g3o="wrapper";function C3o(t){let{components:e,...n}=t;return(0,s.kt)(g3o,(0,p.Z)({},T3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}C3o.isMDXComponent=!0;const x3o={toc:[]},v3o="wrapper";function L3o(t){let{components:e,...n}=t;return(0,s.kt)(v3o,(0,p.Z)({},x3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L3o.isMDXComponent=!0;const Z3o={toc:[]},b3o="wrapper";function N3o(t){let{components:e,...n}=t;return(0,s.kt)(b3o,(0,p.Z)({},Z3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}N3o.isMDXComponent=!0;const A3o={toc:[]},z3o="wrapper";function W3o(t){let{components:e,...n}=t;return(0,s.kt)(z3o,(0,p.Z)({},A3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}W3o.isMDXComponent=!0;const I3o={toc:[]},R3o="wrapper";function S3o(t){let{components:e,...n}=t;return(0,s.kt)(R3o,(0,p.Z)({},I3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}S3o.isMDXComponent=!0;const P3o={toc:[]},E3o="wrapper";function O3o(t){let{components:e,...n}=t;return(0,s.kt)(E3o,(0,p.Z)({},P3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}O3o.isMDXComponent=!0;const G3o={toc:[]},F3o="wrapper";function B3o(t){let{components:e,...n}=t;return(0,s.kt)(F3o,(0,p.Z)({},G3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}B3o.isMDXComponent=!0;const U3o={toc:[]},V3o="wrapper";function q3o(t){let{components:e,...n}=t;return(0,s.kt)(V3o,(0,p.Z)({},U3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}q3o.isMDXComponent=!0;const j3o={toc:[]},Y3o="wrapper";function H3o(t){let{components:e,...n}=t;return(0,s.kt)(Y3o,(0,p.Z)({},j3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}H3o.isMDXComponent=!0;const Q3o={toc:[]},$3o="wrapper";function J3o(t){let{components:e,...n}=t;return(0,s.kt)($3o,(0,p.Z)({},Q3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}J3o.isMDXComponent=!0;const K3o={toc:[]},t5o="wrapper";function e5o(t){let{components:e,...n}=t;return(0,s.kt)(t5o,(0,p.Z)({},K3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}e5o.isMDXComponent=!0;const n5o={toc:[]},o5o="wrapper";function p5o(t){let{components:e,...n}=t;return(0,s.kt)(o5o,(0,p.Z)({},n5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(t){let{components:e,...n}=t;return(0,s.kt)(s5o,(0,p.Z)({},r5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}c5o.isMDXComponent=!0;const i5o={toc:[]},a5o="wrapper";function l5o(t){let{components:e,...n}=t;return(0,s.kt)(a5o,(0,p.Z)({},i5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function d5o(t){let{components:e,...n}=t;return(0,s.kt)(m5o,(0,p.Z)({},u5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}d5o.isMDXComponent=!0;const h5o={toc:[]},f5o="wrapper";function k5o(t){let{components:e,...n}=t;return(0,s.kt)(f5o,(0,p.Z)({},h5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}k5o.isMDXComponent=!0;const y5o={toc:[]},D5o="wrapper";function M5o(t){let{components:e,...n}=t;return(0,s.kt)(D5o,(0,p.Z)({},y5o,n,{components:e,mdxType:"MDXLayout"}))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(t){let{components:e,...n}=t;return(0,s.kt)(_5o,(0,p.Z)({},X5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}w5o.isMDXComponent=!0;const T5o={toc:[]},g5o="wrapper";function C5o(t){let{components:e,...n}=t;return(0,s.kt)(g5o,(0,p.Z)({},T5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}C5o.isMDXComponent=!0;const x5o={toc:[]},v5o="wrapper";function L5o(t){let{components:e,...n}=t;return(0,s.kt)(v5o,(0,p.Z)({},x5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}L5o.isMDXComponent=!0;const Z5o={toc:[]},b5o="wrapper";function N5o(t){let{components:e,...n}=t;return(0,s.kt)(b5o,(0,p.Z)({},Z5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}N5o.isMDXComponent=!0;const A5o={toc:[]},z5o="wrapper";function W5o(t){let{components:e,...n}=t;return(0,s.kt)(z5o,(0,p.Z)({},A5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W5o.isMDXComponent=!0;const I5o={toc:[]},R5o="wrapper";function S5o(t){let{components:e,...n}=t;return(0,s.kt)(R5o,(0,p.Z)({},I5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S5o.isMDXComponent=!0;const P5o={toc:[]},E5o="wrapper";function O5o(t){let{components:e,...n}=t;return(0,s.kt)(E5o,(0,p.Z)({},P5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}O5o.isMDXComponent=!0;const G5o={toc:[]},F5o="wrapper";function B5o(t){let{components:e,...n}=t;return(0,s.kt)(F5o,(0,p.Z)({},G5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B5o.isMDXComponent=!0;const U5o={toc:[]},V5o="wrapper";function q5o(t){let{components:e,...n}=t;return(0,s.kt)(V5o,(0,p.Z)({},U5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q5o.isMDXComponent=!0;const j5o={toc:[]},Y5o="wrapper";function H5o(t){let{components:e,...n}=t;return(0,s.kt)(Y5o,(0,p.Z)({},j5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H5o.isMDXComponent=!0;const Q5o={toc:[]},$5o="wrapper";function J5o(t){let{components:e,...n}=t;return(0,s.kt)($5o,(0,p.Z)({},Q5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}J5o.isMDXComponent=!0;const K5o={toc:[]},t1o="wrapper";function e1o(t){let{components:e,...n}=t;return(0,s.kt)(t1o,(0,p.Z)({},K5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}e1o.isMDXComponent=!0;const n1o={toc:[]},o1o="wrapper";function p1o(t){let{components:e,...n}=t;return(0,s.kt)(o1o,(0,p.Z)({},n1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(t){let{components:e,...n}=t;return(0,s.kt)(s1o,(0,p.Z)({},r1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c1o.isMDXComponent=!0;const i1o={toc:[]},a1o="wrapper";function l1o(t){let{components:e,...n}=t;return(0,s.kt)(a1o,(0,p.Z)({},i1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function d1o(t){let{components:e,...n}=t;return(0,s.kt)(m1o,(0,p.Z)({},u1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}d1o.isMDXComponent=!0;const h1o={toc:[]},f1o="wrapper";function k1o(t){let{components:e,...n}=t;return(0,s.kt)(f1o,(0,p.Z)({},h1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k1o.isMDXComponent=!0;const y1o={toc:[]},D1o="wrapper";function M1o(t){let{components:e,...n}=t;return(0,s.kt)(D1o,(0,p.Z)({},y1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(t){let{components:e,...n}=t;return(0,s.kt)(_1o,(0,p.Z)({},X1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w1o.isMDXComponent=!0;const T1o={toc:[]},g1o="wrapper";function C1o(t){let{components:e,...n}=t;return(0,s.kt)(g1o,(0,p.Z)({},T1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}C1o.isMDXComponent=!0;const x1o={toc:[]},v1o="wrapper";function L1o(t){let{components:e,...n}=t;return(0,s.kt)(v1o,(0,p.Z)({},x1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L1o.isMDXComponent=!0;const Z1o={toc:[]},b1o="wrapper";function N1o(t){let{components:e,...n}=t;return(0,s.kt)(b1o,(0,p.Z)({},Z1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N1o.isMDXComponent=!0;const A1o={toc:[]},z1o="wrapper";function W1o(t){let{components:e,...n}=t;return(0,s.kt)(z1o,(0,p.Z)({},A1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}W1o.isMDXComponent=!0;const I1o={toc:[]},R1o="wrapper";function S1o(t){let{components:e,...n}=t;return(0,s.kt)(R1o,(0,p.Z)({},I1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}S1o.isMDXComponent=!0;const P1o={toc:[]},E1o="wrapper";function O1o(t){let{components:e,...n}=t;return(0,s.kt)(E1o,(0,p.Z)({},P1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}O1o.isMDXComponent=!0;const G1o={toc:[]},F1o="wrapper";function B1o(t){let{components:e,...n}=t;return(0,s.kt)(F1o,(0,p.Z)({},G1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}B1o.isMDXComponent=!0;const U1o={toc:[]},V1o="wrapper";function q1o(t){let{components:e,...n}=t;return(0,s.kt)(V1o,(0,p.Z)({},U1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q1o.isMDXComponent=!0;const j1o={toc:[]},Y1o="wrapper";function H1o(t){let{components:e,...n}=t;return(0,s.kt)(Y1o,(0,p.Z)({},j1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}H1o.isMDXComponent=!0;const Q1o={toc:[]},$1o="wrapper";function J1o(t){let{components:e,...n}=t;return(0,s.kt)($1o,(0,p.Z)({},Q1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}J1o.isMDXComponent=!0;const K1o={toc:[]},t4o="wrapper";function e4o(t){let{components:e,...n}=t;return(0,s.kt)(t4o,(0,p.Z)({},K1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}e4o.isMDXComponent=!0;const n4o={toc:[]},o4o="wrapper";function p4o(t){let{components:e,...n}=t;return(0,s.kt)(o4o,(0,p.Z)({},n4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(t){let{components:e,...n}=t;return(0,s.kt)(s4o,(0,p.Z)({},r4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c4o.isMDXComponent=!0;const i4o={toc:[]},a4o="wrapper";function l4o(t){let{components:e,...n}=t;return(0,s.kt)(a4o,(0,p.Z)({},i4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function d4o(t){let{components:e,...n}=t;return(0,s.kt)(m4o,(0,p.Z)({},u4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}d4o.isMDXComponent=!0;const h4o={toc:[]},f4o="wrapper";function k4o(t){let{components:e,...n}=t;return(0,s.kt)(f4o,(0,p.Z)({},h4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k4o.isMDXComponent=!0;const y4o={toc:[]},D4o="wrapper";function M4o(t){let{components:e,...n}=t;return(0,s.kt)(D4o,(0,p.Z)({},y4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(t){let{components:e,...n}=t;return(0,s.kt)(_4o,(0,p.Z)({},X4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}w4o.isMDXComponent=!0;const T4o={toc:[]},g4o="wrapper";function C4o(t){let{components:e,...n}=t;return(0,s.kt)(g4o,(0,p.Z)({},T4o,n,{components:e,mdxType:"MDXLayout"}))}C4o.isMDXComponent=!0;const x4o={toc:[]},v4o="wrapper";function L4o(t){let{components:e,...n}=t;return(0,s.kt)(v4o,(0,p.Z)({},x4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L4o.isMDXComponent=!0;const Z4o={toc:[]},b4o="wrapper";function N4o(t){let{components:e,...n}=t;return(0,s.kt)(b4o,(0,p.Z)({},Z4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}N4o.isMDXComponent=!0;const A4o={toc:[]},z4o="wrapper";function W4o(t){let{components:e,...n}=t;return(0,s.kt)(z4o,(0,p.Z)({},A4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W4o.isMDXComponent=!0;const I4o={toc:[]},R4o="wrapper";function S4o(t){let{components:e,...n}=t;return(0,s.kt)(R4o,(0,p.Z)({},I4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S4o.isMDXComponent=!0;const P4o={toc:[]},E4o="wrapper";function O4o(t){let{components:e,...n}=t;return(0,s.kt)(E4o,(0,p.Z)({},P4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}O4o.isMDXComponent=!0;const G4o={toc:[]},F4o="wrapper";function B4o(t){let{components:e,...n}=t;return(0,s.kt)(F4o,(0,p.Z)({},G4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B4o.isMDXComponent=!0;const U4o={toc:[]},V4o="wrapper";function q4o(t){let{components:e,...n}=t;return(0,s.kt)(V4o,(0,p.Z)({},U4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q4o.isMDXComponent=!0;const j4o={toc:[]},Y4o="wrapper";function H4o(t){let{components:e,...n}=t;return(0,s.kt)(Y4o,(0,p.Z)({},j4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H4o.isMDXComponent=!0;const Q4o={toc:[]},$4o="wrapper";function J4o(t){let{components:e,...n}=t;return(0,s.kt)($4o,(0,p.Z)({},Q4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}J4o.isMDXComponent=!0;const K4o={toc:[]},t8o="wrapper";function e8o(t){let{components:e,...n}=t;return(0,s.kt)(t8o,(0,p.Z)({},K4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}e8o.isMDXComponent=!0;const n8o={toc:[]},o8o="wrapper";function p8o(t){let{components:e,...n}=t;return(0,s.kt)(o8o,(0,p.Z)({},n8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(t){let{components:e,...n}=t;return(0,s.kt)(s8o,(0,p.Z)({},r8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c8o.isMDXComponent=!0;const i8o={toc:[]},a8o="wrapper";function l8o(t){let{components:e,...n}=t;return(0,s.kt)(a8o,(0,p.Z)({},i8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function d8o(t){let{components:e,...n}=t;return(0,s.kt)(m8o,(0,p.Z)({},u8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}d8o.isMDXComponent=!0;const h8o={toc:[]},f8o="wrapper";function k8o(t){let{components:e,...n}=t;return(0,s.kt)(f8o,(0,p.Z)({},h8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k8o.isMDXComponent=!0;const y8o={toc:[]},D8o="wrapper";function M8o(t){let{components:e,...n}=t;return(0,s.kt)(D8o,(0,p.Z)({},y8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(t){let{components:e,...n}=t;return(0,s.kt)(_8o,(0,p.Z)({},X8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w8o.isMDXComponent=!0;const T8o={toc:[]},g8o="wrapper";function C8o(t){let{components:e,...n}=t;return(0,s.kt)(g8o,(0,p.Z)({},T8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}C8o.isMDXComponent=!0;const x8o={toc:[]},v8o="wrapper";function L8o(t){let{components:e,...n}=t;return(0,s.kt)(v8o,(0,p.Z)({},x8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L8o.isMDXComponent=!0;const Z8o={toc:[]},b8o="wrapper";function N8o(t){let{components:e,...n}=t;return(0,s.kt)(b8o,(0,p.Z)({},Z8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N8o.isMDXComponent=!0;const A8o={toc:[]},z8o="wrapper";function W8o(t){let{components:e,...n}=t;return(0,s.kt)(z8o,(0,p.Z)({},A8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}W8o.isMDXComponent=!0;const I8o={toc:[]},R8o="wrapper";function S8o(t){let{components:e,...n}=t;return(0,s.kt)(R8o,(0,p.Z)({},I8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}S8o.isMDXComponent=!0;const P8o={toc:[]},E8o="wrapper";function O8o(t){let{components:e,...n}=t;return(0,s.kt)(E8o,(0,p.Z)({},P8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}O8o.isMDXComponent=!0;const G8o={toc:[]},F8o="wrapper";function B8o(t){let{components:e,...n}=t;return(0,s.kt)(F8o,(0,p.Z)({},G8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}B8o.isMDXComponent=!0;const U8o={toc:[]},V8o="wrapper";function q8o(t){let{components:e,...n}=t;return(0,s.kt)(V8o,(0,p.Z)({},U8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q8o.isMDXComponent=!0;const j8o={toc:[]},Y8o="wrapper";function H8o(t){let{components:e,...n}=t;return(0,s.kt)(Y8o,(0,p.Z)({},j8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}H8o.isMDXComponent=!0;const Q8o={toc:[]},$8o="wrapper";function J8o(t){let{components:e,...n}=t;return(0,s.kt)($8o,(0,p.Z)({},Q8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}J8o.isMDXComponent=!0;const K8o={toc:[]},t7o="wrapper";function e7o(t){let{components:e,...n}=t;return(0,s.kt)(t7o,(0,p.Z)({},K8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}e7o.isMDXComponent=!0;const n7o={toc:[]},o7o="wrapper";function p7o(t){let{components:e,...n}=t;return(0,s.kt)(o7o,(0,p.Z)({},n7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(t){let{components:e,...n}=t;return(0,s.kt)(s7o,(0,p.Z)({},r7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c7o.isMDXComponent=!0;const i7o={toc:[]},a7o="wrapper";function l7o(t){let{components:e,...n}=t;return(0,s.kt)(a7o,(0,p.Z)({},i7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function d7o(t){let{components:e,...n}=t;return(0,s.kt)(m7o,(0,p.Z)({},u7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}d7o.isMDXComponent=!0;const h7o={toc:[]},f7o="wrapper";function k7o(t){let{components:e,...n}=t;return(0,s.kt)(f7o,(0,p.Z)({},h7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k7o.isMDXComponent=!0;const y7o={toc:[]},D7o="wrapper";function M7o(t){let{components:e,...n}=t;return(0,s.kt)(D7o,(0,p.Z)({},y7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(t){let{components:e,...n}=t;return(0,s.kt)(_7o,(0,p.Z)({},X7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}w7o.isMDXComponent=!0;const T7o={toc:[]},g7o="wrapper";function C7o(t){let{components:e,...n}=t;return(0,s.kt)(g7o,(0,p.Z)({},T7o,n,{components:e,mdxType:"MDXLayout"}))}C7o.isMDXComponent=!0;const x7o={toc:[]},v7o="wrapper";function L7o(t){let{components:e,...n}=t;return(0,s.kt)(v7o,(0,p.Z)({},x7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L7o.isMDXComponent=!0;const Z7o={toc:[]},b7o="wrapper";function N7o(t){let{components:e,...n}=t;return(0,s.kt)(b7o,(0,p.Z)({},Z7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}N7o.isMDXComponent=!0;const A7o={toc:[]},z7o="wrapper";function W7o(t){let{components:e,...n}=t;return(0,s.kt)(z7o,(0,p.Z)({},A7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W7o.isMDXComponent=!0;const I7o={toc:[]},R7o="wrapper";function S7o(t){let{components:e,...n}=t;return(0,s.kt)(R7o,(0,p.Z)({},I7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S7o.isMDXComponent=!0;const P7o={toc:[]},E7o="wrapper";function O7o(t){let{components:e,...n}=t;return(0,s.kt)(E7o,(0,p.Z)({},P7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}O7o.isMDXComponent=!0;const G7o={toc:[]},F7o="wrapper";function B7o(t){let{components:e,...n}=t;return(0,s.kt)(F7o,(0,p.Z)({},G7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B7o.isMDXComponent=!0;const U7o={toc:[]},V7o="wrapper";function q7o(t){let{components:e,...n}=t;return(0,s.kt)(V7o,(0,p.Z)({},U7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q7o.isMDXComponent=!0;const j7o={toc:[]},Y7o="wrapper";function H7o(t){let{components:e,...n}=t;return(0,s.kt)(Y7o,(0,p.Z)({},j7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H7o.isMDXComponent=!0;const Q7o={toc:[]},$7o="wrapper";function J7o(t){let{components:e,...n}=t;return(0,s.kt)($7o,(0,p.Z)({},Q7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}J7o.isMDXComponent=!0;const K7o={toc:[]},t9o="wrapper";function e9o(t){let{components:e,...n}=t;return(0,s.kt)(t9o,(0,p.Z)({},K7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}e9o.isMDXComponent=!0;const n9o={toc:[]},o9o="wrapper";function p9o(t){let{components:e,...n}=t;return(0,s.kt)(o9o,(0,p.Z)({},n9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(t){let{components:e,...n}=t;return(0,s.kt)(s9o,(0,p.Z)({},r9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c9o.isMDXComponent=!0;const i9o={toc:[]},a9o="wrapper";function l9o(t){let{components:e,...n}=t;return(0,s.kt)(a9o,(0,p.Z)({},i9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function d9o(t){let{components:e,...n}=t;return(0,s.kt)(m9o,(0,p.Z)({},u9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}d9o.isMDXComponent=!0;const h9o={toc:[]},f9o="wrapper";function k9o(t){let{components:e,...n}=t;return(0,s.kt)(f9o,(0,p.Z)({},h9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k9o.isMDXComponent=!0;const y9o={toc:[]},D9o="wrapper";function M9o(t){let{components:e,...n}=t;return(0,s.kt)(D9o,(0,p.Z)({},y9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(t){let{components:e,...n}=t;return(0,s.kt)(_9o,(0,p.Z)({},X9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w9o.isMDXComponent=!0;const T9o={toc:[]},g9o="wrapper";function C9o(t){let{components:e,...n}=t;return(0,s.kt)(g9o,(0,p.Z)({},T9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}C9o.isMDXComponent=!0;const x9o={toc:[]},v9o="wrapper";function L9o(t){let{components:e,...n}=t;return(0,s.kt)(v9o,(0,p.Z)({},x9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}L9o.isMDXComponent=!0;const Z9o={toc:[]},b9o="wrapper";function N9o(t){let{components:e,...n}=t;return(0,s.kt)(b9o,(0,p.Z)({},Z9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}N9o.isMDXComponent=!0;const A9o={toc:[]},z9o="wrapper";function W9o(t){let{components:e,...n}=t;return(0,s.kt)(z9o,(0,p.Z)({},A9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W9o.isMDXComponent=!0;const I9o={toc:[]},R9o="wrapper";function S9o(t){let{components:e,...n}=t;return(0,s.kt)(R9o,(0,p.Z)({},I9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}S9o.isMDXComponent=!0;const P9o={toc:[]},E9o="wrapper";function O9o(t){let{components:e,...n}=t;return(0,s.kt)(E9o,(0,p.Z)({},P9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}O9o.isMDXComponent=!0;const G9o={toc:[]},F9o="wrapper";function B9o(t){let{components:e,...n}=t;return(0,s.kt)(F9o,(0,p.Z)({},G9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}B9o.isMDXComponent=!0;const U9o={toc:[]},V9o="wrapper";function q9o(t){let{components:e,...n}=t;return(0,s.kt)(V9o,(0,p.Z)({},U9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q9o.isMDXComponent=!0;const j9o={toc:[]},Y9o="wrapper";function H9o(t){let{components:e,...n}=t;return(0,s.kt)(Y9o,(0,p.Z)({},j9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}H9o.isMDXComponent=!0;const Q9o={toc:[]},$9o="wrapper";function J9o(t){let{components:e,...n}=t;return(0,s.kt)($9o,(0,p.Z)({},Q9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}J9o.isMDXComponent=!0;const K9o={toc:[]},ttp="wrapper";function etp(t){let{components:e,...n}=t;return(0,s.kt)(ttp,(0,p.Z)({},K9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}etp.isMDXComponent=!0;const ntp={toc:[]},otp="wrapper";function ptp(t){let{components:e,...n}=t;return(0,s.kt)(otp,(0,p.Z)({},ntp,n,{components:e,mdxType:"MDXLayout"}))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(t){let{components:e,...n}=t;return(0,s.kt)(stp,(0,p.Z)({},rtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}ctp.isMDXComponent=!0;const itp={toc:[]},atp="wrapper";function ltp(t){let{components:e,...n}=t;return(0,s.kt)(atp,(0,p.Z)({},itp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function dtp(t){let{components:e,...n}=t;return(0,s.kt)(mtp,(0,p.Z)({},utp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dtp.isMDXComponent=!0;const htp={toc:[]},ftp="wrapper";function ktp(t){let{components:e,...n}=t;return(0,s.kt)(ftp,(0,p.Z)({},htp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ktp.isMDXComponent=!0;const ytp={toc:[]},Dtp="wrapper";function Mtp(t){let{components:e,...n}=t;return(0,s.kt)(Dtp,(0,p.Z)({},ytp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(t){let{components:e,...n}=t;return(0,s.kt)(_tp,(0,p.Z)({},Xtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},gtp="wrapper";function Ctp(t){let{components:e,...n}=t;return(0,s.kt)(gtp,(0,p.Z)({},Ttp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ctp.isMDXComponent=!0;const xtp={toc:[]},vtp="wrapper";function Ltp(t){let{components:e,...n}=t;return(0,s.kt)(vtp,(0,p.Z)({},xtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ltp.isMDXComponent=!0;const Ztp={toc:[]},btp="wrapper";function Ntp(t){let{components:e,...n}=t;return(0,s.kt)(btp,(0,p.Z)({},Ztp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Ntp.isMDXComponent=!0;const Atp={toc:[]},ztp="wrapper";function Wtp(t){let{components:e,...n}=t;return(0,s.kt)(ztp,(0,p.Z)({},Atp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Wtp.isMDXComponent=!0;const Itp={toc:[]},Rtp="wrapper";function Stp(t){let{components:e,...n}=t;return(0,s.kt)(Rtp,(0,p.Z)({},Itp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Stp.isMDXComponent=!0;const Ptp={toc:[]},Etp="wrapper";function Otp(t){let{components:e,...n}=t;return(0,s.kt)(Etp,(0,p.Z)({},Ptp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Otp.isMDXComponent=!0;const Gtp={toc:[]},Ftp="wrapper";function Btp(t){let{components:e,...n}=t;return(0,s.kt)(Ftp,(0,p.Z)({},Gtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Btp.isMDXComponent=!0;const Utp={toc:[]},Vtp="wrapper";function qtp(t){let{components:e,...n}=t;return(0,s.kt)(Vtp,(0,p.Z)({},Utp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qtp.isMDXComponent=!0;const jtp={toc:[]},Ytp="wrapper";function Htp(t){let{components:e,...n}=t;return(0,s.kt)(Ytp,(0,p.Z)({},jtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Htp.isMDXComponent=!0;const Qtp={toc:[]},$tp="wrapper";function Jtp(t){let{components:e,...n}=t;return(0,s.kt)($tp,(0,p.Z)({},Qtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Jtp.isMDXComponent=!0;const Ktp={toc:[]},tep="wrapper";function eep(t){let{components:e,...n}=t;return(0,s.kt)(tep,(0,p.Z)({},Ktp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eep.isMDXComponent=!0;const nep={toc:[]},oep="wrapper";function pep(t){let{components:e,...n}=t;return(0,s.kt)(oep,(0,p.Z)({},nep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(t){let{components:e,...n}=t;return(0,s.kt)(sep,(0,p.Z)({},rep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cep.isMDXComponent=!0;const iep={toc:[]},aep="wrapper";function lep(t){let{components:e,...n}=t;return(0,s.kt)(aep,(0,p.Z)({},iep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function dep(t){let{components:e,...n}=t;return(0,s.kt)(mep,(0,p.Z)({},uep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}dep.isMDXComponent=!0;const hep={toc:[]},fep="wrapper";function kep(t){let{components:e,...n}=t;return(0,s.kt)(fep,(0,p.Z)({},hep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}kep.isMDXComponent=!0;const yep={toc:[]},Dep="wrapper";function Mep(t){let{components:e,...n}=t;return(0,s.kt)(Dep,(0,p.Z)({},yep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(t){let{components:e,...n}=t;return(0,s.kt)(_ep,(0,p.Z)({},Xep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wep.isMDXComponent=!0;const Tep={toc:[]},gep="wrapper";function Cep(t){let{components:e,...n}=t;return(0,s.kt)(gep,(0,p.Z)({},Tep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Cep.isMDXComponent=!0;const xep={toc:[]},vep="wrapper";function Lep(t){let{components:e,...n}=t;return(0,s.kt)(vep,(0,p.Z)({},xep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Lep.isMDXComponent=!0;const Zep={toc:[]},bep="wrapper";function Nep(t){let{components:e,...n}=t;return(0,s.kt)(bep,(0,p.Z)({},Zep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Nep.isMDXComponent=!0;const Aep={toc:[]},zep="wrapper";function Wep(t){let{components:e,...n}=t;return(0,s.kt)(zep,(0,p.Z)({},Aep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Wep.isMDXComponent=!0;const Iep={toc:[]},Rep="wrapper";function Sep(t){let{components:e,...n}=t;return(0,s.kt)(Rep,(0,p.Z)({},Iep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Sep.isMDXComponent=!0;const Pep={toc:[]},Eep="wrapper";function Oep(t){let{components:e,...n}=t;return(0,s.kt)(Eep,(0,p.Z)({},Pep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Oep.isMDXComponent=!0;const Gep={toc:[]},Fep="wrapper";function Bep(t){let{components:e,...n}=t;return(0,s.kt)(Fep,(0,p.Z)({},Gep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Bep.isMDXComponent=!0;const Uep={toc:[]},Vep="wrapper";function qep(t){let{components:e,...n}=t;return(0,s.kt)(Vep,(0,p.Z)({},Uep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}qep.isMDXComponent=!0;const jep={toc:[]},Yep="wrapper";function Hep(t){let{components:e,...n}=t;return(0,s.kt)(Yep,(0,p.Z)({},jep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hep.isMDXComponent=!0;const Qep={toc:[]},$ep="wrapper";function Jep(t){let{components:e,...n}=t;return(0,s.kt)($ep,(0,p.Z)({},Qep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Jep.isMDXComponent=!0;const Kep={toc:[]},tnp="wrapper";function enp(t){let{components:e,...n}=t;return(0,s.kt)(tnp,(0,p.Z)({},Kep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}enp.isMDXComponent=!0;const nnp={toc:[]},onp="wrapper";function pnp(t){let{components:e,...n}=t;return(0,s.kt)(onp,(0,p.Z)({},nnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(t){let{components:e,...n}=t;return(0,s.kt)(snp,(0,p.Z)({},rnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}cnp.isMDXComponent=!0;const inp={toc:[]},anp="wrapper";function lnp(t){let{components:e,...n}=t;return(0,s.kt)(anp,(0,p.Z)({},inp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function dnp(t){let{components:e,...n}=t;return(0,s.kt)(mnp,(0,p.Z)({},unp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dnp.isMDXComponent=!0;const hnp={toc:[]},fnp="wrapper";function knp(t){let{components:e,...n}=t;return(0,s.kt)(fnp,(0,p.Z)({},hnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}knp.isMDXComponent=!0;const ynp={toc:[]},Dnp="wrapper";function Mnp(t){let{components:e,...n}=t;return(0,s.kt)(Dnp,(0,p.Z)({},ynp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(t){let{components:e,...n}=t;return(0,s.kt)(_np,(0,p.Z)({},Xnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},gnp="wrapper";function Cnp(t){let{components:e,...n}=t;return(0,s.kt)(gnp,(0,p.Z)({},Tnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Cnp.isMDXComponent=!0;const xnp={toc:[]},vnp="wrapper";function Lnp(t){let{components:e,...n}=t;return(0,s.kt)(vnp,(0,p.Z)({},xnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Lnp.isMDXComponent=!0;const Znp={toc:[]},bnp="wrapper";function Nnp(t){let{components:e,...n}=t;return(0,s.kt)(bnp,(0,p.Z)({},Znp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nnp.isMDXComponent=!0;const Anp={toc:[]},znp="wrapper";function Wnp(t){let{components:e,...n}=t;return(0,s.kt)(znp,(0,p.Z)({},Anp,n,{components:e,mdxType:"MDXLayout"}))}Wnp.isMDXComponent=!0;const Inp={toc:[]},Rnp="wrapper";function Snp(t){let{components:e,...n}=t;return(0,s.kt)(Rnp,(0,p.Z)({},Inp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Snp.isMDXComponent=!0;const Pnp={toc:[]},Enp="wrapper";function Onp(t){let{components:e,...n}=t;return(0,s.kt)(Enp,(0,p.Z)({},Pnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Onp.isMDXComponent=!0;const Gnp={toc:[]},Fnp="wrapper";function Bnp(t){let{components:e,...n}=t;return(0,s.kt)(Fnp,(0,p.Z)({},Gnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bnp.isMDXComponent=!0;const Unp={toc:[]},Vnp="wrapper";function qnp(t){let{components:e,...n}=t;return(0,s.kt)(Vnp,(0,p.Z)({},Unp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qnp.isMDXComponent=!0;const jnp={toc:[]},Ynp="wrapper";function Hnp(t){let{components:e,...n}=t;return(0,s.kt)(Ynp,(0,p.Z)({},jnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Hnp.isMDXComponent=!0;const Qnp={toc:[]},$np="wrapper";function Jnp(t){let{components:e,...n}=t;return(0,s.kt)($np,(0,p.Z)({},Qnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Jnp.isMDXComponent=!0;const Knp={toc:[]},top="wrapper";function eop(t){let{components:e,...n}=t;return(0,s.kt)(top,(0,p.Z)({},Knp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}eop.isMDXComponent=!0;const nop={toc:[]},oop="wrapper";function pop(t){let{components:e,...n}=t;return(0,s.kt)(oop,(0,p.Z)({},nop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(t){let{components:e,...n}=t;return(0,s.kt)(sop,(0,p.Z)({},rop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cop.isMDXComponent=!0;const iop={toc:[]},aop="wrapper";function lop(t){let{components:e,...n}=t;return(0,s.kt)(aop,(0,p.Z)({},iop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function dop(t){let{components:e,...n}=t;return(0,s.kt)(mop,(0,p.Z)({},uop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dop.isMDXComponent=!0;const hop={toc:[]},fop="wrapper";function kop(t){let{components:e,...n}=t;return(0,s.kt)(fop,(0,p.Z)({},hop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kop.isMDXComponent=!0;const yop={toc:[]},Dop="wrapper";function Mop(t){let{components:e,...n}=t;return(0,s.kt)(Dop,(0,p.Z)({},yop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(t){let{components:e,...n}=t;return(0,s.kt)(_op,(0,p.Z)({},Xop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}wop.isMDXComponent=!0;const Top={toc:[]},gop="wrapper";function Cop(t){let{components:e,...n}=t;return(0,s.kt)(gop,(0,p.Z)({},Top,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Cop.isMDXComponent=!0;const xop={toc:[]},vop="wrapper";function Lop(t){let{components:e,...n}=t;return(0,s.kt)(vop,(0,p.Z)({},xop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lop.isMDXComponent=!0;const Zop={toc:[]},bop="wrapper";function Nop(t){let{components:e,...n}=t;return(0,s.kt)(bop,(0,p.Z)({},Zop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Nop.isMDXComponent=!0;const Aop={toc:[]},zop="wrapper";function Wop(t){let{components:e,...n}=t;return(0,s.kt)(zop,(0,p.Z)({},Aop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wop.isMDXComponent=!0;const Iop={toc:[]},Rop="wrapper";function Sop(t){let{components:e,...n}=t;return(0,s.kt)(Rop,(0,p.Z)({},Iop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Sop.isMDXComponent=!0;const Pop={toc:[]},Eop="wrapper";function Oop(t){let{components:e,...n}=t;return(0,s.kt)(Eop,(0,p.Z)({},Pop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oop.isMDXComponent=!0;const Gop={toc:[]},Fop="wrapper";function Bop(t){let{components:e,...n}=t;return(0,s.kt)(Fop,(0,p.Z)({},Gop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Bop.isMDXComponent=!0;const Uop={toc:[]},Vop="wrapper";function qop(t){let{components:e,...n}=t;return(0,s.kt)(Vop,(0,p.Z)({},Uop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qop.isMDXComponent=!0;const jop={toc:[]},Yop="wrapper";function Hop(t){let{components:e,...n}=t;return(0,s.kt)(Yop,(0,p.Z)({},jop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Hop.isMDXComponent=!0;const Qop={toc:[]},$op="wrapper";function Jop(t){let{components:e,...n}=t;return(0,s.kt)($op,(0,p.Z)({},Qop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Jop.isMDXComponent=!0;const Kop={toc:[]},tpp="wrapper";function epp(t){let{components:e,...n}=t;return(0,s.kt)(tpp,(0,p.Z)({},Kop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}epp.isMDXComponent=!0;const npp={toc:[]},opp="wrapper";function ppp(t){let{components:e,...n}=t;return(0,s.kt)(opp,(0,p.Z)({},npp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(t){let{components:e,...n}=t;return(0,s.kt)(spp,(0,p.Z)({},rpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}cpp.isMDXComponent=!0;const ipp={toc:[]},app="wrapper";function lpp(t){let{components:e,...n}=t;return(0,s.kt)(app,(0,p.Z)({},ipp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function dpp(t){let{components:e,...n}=t;return(0,s.kt)(mpp,(0,p.Z)({},upp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dpp.isMDXComponent=!0;const hpp={toc:[]},fpp="wrapper";function kpp(t){let{components:e,...n}=t;return(0,s.kt)(fpp,(0,p.Z)({},hpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kpp.isMDXComponent=!0;const ypp={toc:[]},Dpp="wrapper";function Mpp(t){let{components:e,...n}=t;return(0,s.kt)(Dpp,(0,p.Z)({},ypp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(t){let{components:e,...n}=t;return(0,s.kt)(_pp,(0,p.Z)({},Xpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},gpp="wrapper";function Cpp(t){let{components:e,...n}=t;return(0,s.kt)(gpp,(0,p.Z)({},Tpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Cpp.isMDXComponent=!0;const xpp={toc:[]},vpp="wrapper";function Lpp(t){let{components:e,...n}=t;return(0,s.kt)(vpp,(0,p.Z)({},xpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lpp.isMDXComponent=!0;const Zpp={toc:[]},bpp="wrapper";function Npp(t){let{components:e,...n}=t;return(0,s.kt)(bpp,(0,p.Z)({},Zpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Npp.isMDXComponent=!0;const App={toc:[]},zpp="wrapper";function Wpp(t){let{components:e,...n}=t;return(0,s.kt)(zpp,(0,p.Z)({},App,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Wpp.isMDXComponent=!0;const Ipp={toc:[]},Rpp="wrapper";function Spp(t){let{components:e,...n}=t;return(0,s.kt)(Rpp,(0,p.Z)({},Ipp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Spp.isMDXComponent=!0;const Ppp={toc:[]},Epp="wrapper";function Opp(t){let{components:e,...n}=t;return(0,s.kt)(Epp,(0,p.Z)({},Ppp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Opp.isMDXComponent=!0;const Gpp={toc:[]},Fpp="wrapper";function Bpp(t){let{components:e,...n}=t;return(0,s.kt)(Fpp,(0,p.Z)({},Gpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bpp.isMDXComponent=!0;const Upp={toc:[]},Vpp="wrapper";function qpp(t){let{components:e,...n}=t;return(0,s.kt)(Vpp,(0,p.Z)({},Upp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qpp.isMDXComponent=!0;const jpp={toc:[]},Ypp="wrapper";function Hpp(t){let{components:e,...n}=t;return(0,s.kt)(Ypp,(0,p.Z)({},jpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hpp.isMDXComponent=!0;const Qpp={toc:[]},$pp="wrapper";function Jpp(t){let{components:e,...n}=t;return(0,s.kt)($pp,(0,p.Z)({},Qpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Jpp.isMDXComponent=!0;const Kpp={toc:[]},trp="wrapper";function erp(t){let{components:e,...n}=t;return(0,s.kt)(trp,(0,p.Z)({},Kpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}erp.isMDXComponent=!0;const nrp={toc:[]},orp="wrapper";function prp(t){let{components:e,...n}=t;return(0,s.kt)(orp,(0,p.Z)({},nrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(t){let{components:e,...n}=t;return(0,s.kt)(srp,(0,p.Z)({},rrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}crp.isMDXComponent=!0;const irp={toc:[]},arp="wrapper";function lrp(t){let{components:e,...n}=t;return(0,s.kt)(arp,(0,p.Z)({},irp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function drp(t){let{components:e,...n}=t;return(0,s.kt)(mrp,(0,p.Z)({},urp,n,{components:e,mdxType:"MDXLayout"}))}drp.isMDXComponent=!0;const hrp={toc:[]},frp="wrapper";function krp(t){let{components:e,...n}=t;return(0,s.kt)(frp,(0,p.Z)({},hrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}krp.isMDXComponent=!0;const yrp={toc:[]},Drp="wrapper";function Mrp(t){let{components:e,...n}=t;return(0,s.kt)(Drp,(0,p.Z)({},yrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(t){let{components:e,...n}=t;return(0,s.kt)(_rp,(0,p.Z)({},Xrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wrp.isMDXComponent=!0;const Trp={toc:[]},grp="wrapper";function Crp(t){let{components:e,...n}=t;return(0,s.kt)(grp,(0,p.Z)({},Trp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Crp.isMDXComponent=!0;const xrp={toc:[]},vrp="wrapper";function Lrp(t){let{components:e,...n}=t;return(0,s.kt)(vrp,(0,p.Z)({},xrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lrp.isMDXComponent=!0;const Zrp={toc:[]},brp="wrapper";function Nrp(t){let{components:e,...n}=t;return(0,s.kt)(brp,(0,p.Z)({},Zrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Nrp.isMDXComponent=!0;const Arp={toc:[]},zrp="wrapper";function Wrp(t){let{components:e,...n}=t;return(0,s.kt)(zrp,(0,p.Z)({},Arp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Wrp.isMDXComponent=!0;const Irp={toc:[]},Rrp="wrapper";function Srp(t){let{components:e,...n}=t;return(0,s.kt)(Rrp,(0,p.Z)({},Irp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Srp.isMDXComponent=!0;const Prp={toc:[]},Erp="wrapper";function Orp(t){let{components:e,...n}=t;return(0,s.kt)(Erp,(0,p.Z)({},Prp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Orp.isMDXComponent=!0;const Grp={toc:[]},Frp="wrapper";function Brp(t){let{components:e,...n}=t;return(0,s.kt)(Frp,(0,p.Z)({},Grp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Brp.isMDXComponent=!0;const Urp={toc:[]},Vrp="wrapper";function qrp(t){let{components:e,...n}=t;return(0,s.kt)(Vrp,(0,p.Z)({},Urp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qrp.isMDXComponent=!0;const jrp={toc:[]},Yrp="wrapper";function Hrp(t){let{components:e,...n}=t;return(0,s.kt)(Yrp,(0,p.Z)({},jrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hrp.isMDXComponent=!0;const Qrp={toc:[]},$rp="wrapper";function Jrp(t){let{components:e,...n}=t;return(0,s.kt)($rp,(0,p.Z)({},Qrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Jrp.isMDXComponent=!0;const Krp={toc:[]},tsp="wrapper";function esp(t){let{components:e,...n}=t;return(0,s.kt)(tsp,(0,p.Z)({},Krp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}esp.isMDXComponent=!0;const nsp={toc:[]},osp="wrapper";function psp(t){let{components:e,...n}=t;return(0,s.kt)(osp,(0,p.Z)({},nsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(t){let{components:e,...n}=t;return(0,s.kt)(ssp,(0,p.Z)({},rsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}csp.isMDXComponent=!0;const isp={toc:[]},asp="wrapper";function lsp(t){let{components:e,...n}=t;return(0,s.kt)(asp,(0,p.Z)({},isp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function dsp(t){let{components:e,...n}=t;return(0,s.kt)(msp,(0,p.Z)({},usp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dsp.isMDXComponent=!0;const hsp={toc:[]},fsp="wrapper";function ksp(t){let{components:e,...n}=t;return(0,s.kt)(fsp,(0,p.Z)({},hsp,n,{components:e,mdxType:"MDXLayout"}))}ksp.isMDXComponent=!0;const ysp={toc:[]},Dsp="wrapper";function Msp(t){let{components:e,...n}=t;return(0,s.kt)(Dsp,(0,p.Z)({},ysp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(t){let{components:e,...n}=t;return(0,s.kt)(_sp,(0,p.Z)({},Xsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},gsp="wrapper";function Csp(t){let{components:e,...n}=t;return(0,s.kt)(gsp,(0,p.Z)({},Tsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Csp.isMDXComponent=!0;const xsp={toc:[]},vsp="wrapper";function Lsp(t){let{components:e,...n}=t;return(0,s.kt)(vsp,(0,p.Z)({},xsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lsp.isMDXComponent=!0;const Zsp={toc:[]},bsp="wrapper";function Nsp(t){let{components:e,...n}=t;return(0,s.kt)(bsp,(0,p.Z)({},Zsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nsp.isMDXComponent=!0;const Asp={toc:[]},zsp="wrapper";function Wsp(t){let{components:e,...n}=t;return(0,s.kt)(zsp,(0,p.Z)({},Asp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Wsp.isMDXComponent=!0;const Isp={toc:[]},Rsp="wrapper";function Ssp(t){let{components:e,...n}=t;return(0,s.kt)(Rsp,(0,p.Z)({},Isp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ssp.isMDXComponent=!0;const Psp={toc:[]},Esp="wrapper";function Osp(t){let{components:e,...n}=t;return(0,s.kt)(Esp,(0,p.Z)({},Psp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Osp.isMDXComponent=!0;const Gsp={toc:[]},Fsp="wrapper";function Bsp(t){let{components:e,...n}=t;return(0,s.kt)(Fsp,(0,p.Z)({},Gsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bsp.isMDXComponent=!0;const Usp={toc:[]},Vsp="wrapper";function qsp(t){let{components:e,...n}=t;return(0,s.kt)(Vsp,(0,p.Z)({},Usp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qsp.isMDXComponent=!0;const jsp={toc:[]},Ysp="wrapper";function Hsp(t){let{components:e,...n}=t;return(0,s.kt)(Ysp,(0,p.Z)({},jsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hsp.isMDXComponent=!0;const Qsp={toc:[]},$sp="wrapper";function Jsp(t){let{components:e,...n}=t;return(0,s.kt)($sp,(0,p.Z)({},Qsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Jsp.isMDXComponent=!0;const Ksp={toc:[]},tcp="wrapper";function ecp(t){let{components:e,...n}=t;return(0,s.kt)(tcp,(0,p.Z)({},Ksp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ecp.isMDXComponent=!0;const ncp={toc:[]},ocp="wrapper";function pcp(t){let{components:e,...n}=t;return(0,s.kt)(ocp,(0,p.Z)({},ncp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(t){let{components:e,...n}=t;return(0,s.kt)(scp,(0,p.Z)({},rcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ccp.isMDXComponent=!0;const icp={toc:[]},acp="wrapper";function lcp(t){let{components:e,...n}=t;return(0,s.kt)(acp,(0,p.Z)({},icp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function dcp(t){let{components:e,...n}=t;return(0,s.kt)(mcp,(0,p.Z)({},ucp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dcp.isMDXComponent=!0;const hcp={toc:[]},fcp="wrapper";function kcp(t){let{components:e,...n}=t;return(0,s.kt)(fcp,(0,p.Z)({},hcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kcp.isMDXComponent=!0;const ycp={toc:[]},Dcp="wrapper";function Mcp(t){let{components:e,...n}=t;return(0,s.kt)(Dcp,(0,p.Z)({},ycp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(t){let{components:e,...n}=t;return(0,s.kt)(_cp,(0,p.Z)({},Xcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},gcp="wrapper";function Ccp(t){let{components:e,...n}=t;return(0,s.kt)(gcp,(0,p.Z)({},Tcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ccp.isMDXComponent=!0;const xcp={toc:[]},vcp="wrapper";function Lcp(t){let{components:e,...n}=t;return(0,s.kt)(vcp,(0,p.Z)({},xcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lcp.isMDXComponent=!0;const Zcp={toc:[]},bcp="wrapper";function Ncp(t){let{components:e,...n}=t;return(0,s.kt)(bcp,(0,p.Z)({},Zcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ncp.isMDXComponent=!0;const Acp={toc:[]},zcp="wrapper";function Wcp(t){let{components:e,...n}=t;return(0,s.kt)(zcp,(0,p.Z)({},Acp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wcp.isMDXComponent=!0;const Icp={toc:[]},Rcp="wrapper";function Scp(t){let{components:e,...n}=t;return(0,s.kt)(Rcp,(0,p.Z)({},Icp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Scp.isMDXComponent=!0;const Pcp={toc:[]},Ecp="wrapper";function Ocp(t){let{components:e,...n}=t;return(0,s.kt)(Ecp,(0,p.Z)({},Pcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ocp.isMDXComponent=!0;const Gcp={toc:[]},Fcp="wrapper";function Bcp(t){let{components:e,...n}=t;return(0,s.kt)(Fcp,(0,p.Z)({},Gcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Bcp.isMDXComponent=!0;const Ucp={toc:[]},Vcp="wrapper";function qcp(t){let{components:e,...n}=t;return(0,s.kt)(Vcp,(0,p.Z)({},Ucp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}qcp.isMDXComponent=!0;const jcp={toc:[]},Ycp="wrapper";function Hcp(t){let{components:e,...n}=t;return(0,s.kt)(Ycp,(0,p.Z)({},jcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hcp.isMDXComponent=!0;const Qcp={toc:[]},$cp="wrapper";function Jcp(t){let{components:e,...n}=t;return(0,s.kt)($cp,(0,p.Z)({},Qcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Jcp.isMDXComponent=!0;const Kcp={toc:[]},tip="wrapper";function eip(t){let{components:e,...n}=t;return(0,s.kt)(tip,(0,p.Z)({},Kcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}eip.isMDXComponent=!0;const nip={toc:[]},oip="wrapper";function pip(t){let{components:e,...n}=t;return(0,s.kt)(oip,(0,p.Z)({},nip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(t){let{components:e,...n}=t;return(0,s.kt)(sip,(0,p.Z)({},rip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}cip.isMDXComponent=!0;const iip={toc:[]},aip="wrapper";function lip(t){let{components:e,...n}=t;return(0,s.kt)(aip,(0,p.Z)({},iip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function dip(t){let{components:e,...n}=t;return(0,s.kt)(mip,(0,p.Z)({},uip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dip.isMDXComponent=!0;const hip={toc:[]},fip="wrapper";function kip(t){let{components:e,...n}=t;return(0,s.kt)(fip,(0,p.Z)({},hip,n,{components:e,mdxType:"MDXLayout"}))}kip.isMDXComponent=!0;const yip={toc:[]},Dip="wrapper";function Mip(t){let{components:e,...n}=t;return(0,s.kt)(Dip,(0,p.Z)({},yip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(t){let{components:e,...n}=t;return(0,s.kt)(_ip,(0,p.Z)({},Xip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wip.isMDXComponent=!0;const Tip={toc:[]},gip="wrapper";function Cip(t){let{components:e,...n}=t;return(0,s.kt)(gip,(0,p.Z)({},Tip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Cip.isMDXComponent=!0;const xip={toc:[]},vip="wrapper";function Lip(t){let{components:e,...n}=t;return(0,s.kt)(vip,(0,p.Z)({},xip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lip.isMDXComponent=!0;const Zip={toc:[]},bip="wrapper";function Nip(t){let{components:e,...n}=t;return(0,s.kt)(bip,(0,p.Z)({},Zip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nip.isMDXComponent=!0;const Aip={toc:[]},zip="wrapper";function Wip(t){let{components:e,...n}=t;return(0,s.kt)(zip,(0,p.Z)({},Aip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Wip.isMDXComponent=!0;const Iip={toc:[]},Rip="wrapper";function Sip(t){let{components:e,...n}=t;return(0,s.kt)(Rip,(0,p.Z)({},Iip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Sip.isMDXComponent=!0;const Pip={toc:[]},Eip="wrapper";function Oip(t){let{components:e,...n}=t;return(0,s.kt)(Eip,(0,p.Z)({},Pip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oip.isMDXComponent=!0;const Gip={toc:[]},Fip="wrapper";function Bip(t){let{components:e,...n}=t;return(0,s.kt)(Fip,(0,p.Z)({},Gip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bip.isMDXComponent=!0;const Uip={toc:[]},Vip="wrapper";function qip(t){let{components:e,...n}=t;return(0,s.kt)(Vip,(0,p.Z)({},Uip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qip.isMDXComponent=!0;const jip={toc:[]},Yip="wrapper";function Hip(t){let{components:e,...n}=t;return(0,s.kt)(Yip,(0,p.Z)({},jip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Hip.isMDXComponent=!0;const Qip={toc:[]},$ip="wrapper";function Jip(t){let{components:e,...n}=t;return(0,s.kt)($ip,(0,p.Z)({},Qip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Jip.isMDXComponent=!0;const Kip={toc:[]},tap="wrapper";function eap(t){let{components:e,...n}=t;return(0,s.kt)(tap,(0,p.Z)({},Kip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eap.isMDXComponent=!0;const nap={toc:[]},oap="wrapper";function pap(t){let{components:e,...n}=t;return(0,s.kt)(oap,(0,p.Z)({},nap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(t){let{components:e,...n}=t;return(0,s.kt)(sap,(0,p.Z)({},rap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cap.isMDXComponent=!0;const iap={toc:[]},aap="wrapper";function lap(t){let{components:e,...n}=t;return(0,s.kt)(aap,(0,p.Z)({},iap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function dap(t){let{components:e,...n}=t;return(0,s.kt)(map,(0,p.Z)({},uap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}dap.isMDXComponent=!0;const hap={toc:[]},fap="wrapper";function kap(t){let{components:e,...n}=t;return(0,s.kt)(fap,(0,p.Z)({},hap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kap.isMDXComponent=!0;const yap={toc:[]},Dap="wrapper";function Map(t){let{components:e,...n}=t;return(0,s.kt)(Dap,(0,p.Z)({},yap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(t){let{components:e,...n}=t;return(0,s.kt)(_ap,(0,p.Z)({},Xap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wap.isMDXComponent=!0;const Tap={toc:[]},gap="wrapper";function Cap(t){let{components:e,...n}=t;return(0,s.kt)(gap,(0,p.Z)({},Tap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Cap.isMDXComponent=!0;const xap={toc:[]},vap="wrapper";function Lap(t){let{components:e,...n}=t;return(0,s.kt)(vap,(0,p.Z)({},xap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Lap.isMDXComponent=!0;const Zap={toc:[]},bap="wrapper";function Nap(t){let{components:e,...n}=t;return(0,s.kt)(bap,(0,p.Z)({},Zap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Nap.isMDXComponent=!0;const Aap={toc:[]},zap="wrapper";function Wap(t){let{components:e,...n}=t;return(0,s.kt)(zap,(0,p.Z)({},Aap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wap.isMDXComponent=!0;const Iap={toc:[]},Rap="wrapper";function Sap(t){let{components:e,...n}=t;return(0,s.kt)(Rap,(0,p.Z)({},Iap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Sap.isMDXComponent=!0;const Pap={toc:[]},Eap="wrapper";function Oap(t){let{components:e,...n}=t;return(0,s.kt)(Eap,(0,p.Z)({},Pap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Oap.isMDXComponent=!0;const Gap={toc:[]},Fap="wrapper";function Bap(t){let{components:e,...n}=t;return(0,s.kt)(Fap,(0,p.Z)({},Gap,n,{components:e,mdxType:"MDXLayout"}))}Bap.isMDXComponent=!0;const Uap={toc:[]},Vap="wrapper";function qap(t){let{components:e,...n}=t;return(0,s.kt)(Vap,(0,p.Z)({},Uap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qap.isMDXComponent=!0;const jap={toc:[]},Yap="wrapper";function Hap(t){let{components:e,...n}=t;return(0,s.kt)(Yap,(0,p.Z)({},jap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Hap.isMDXComponent=!0;const Qap={toc:[]},$ap="wrapper";function Jap(t){let{components:e,...n}=t;return(0,s.kt)($ap,(0,p.Z)({},Qap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Jap.isMDXComponent=!0;const Kap={toc:[]},tlp="wrapper";function elp(t){let{components:e,...n}=t;return(0,s.kt)(tlp,(0,p.Z)({},Kap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}elp.isMDXComponent=!0;const nlp={toc:[]},olp="wrapper";function plp(t){let{components:e,...n}=t;return(0,s.kt)(olp,(0,p.Z)({},nlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(t){let{components:e,...n}=t;return(0,s.kt)(slp,(0,p.Z)({},rlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}clp.isMDXComponent=!0;const ilp={toc:[]},alp="wrapper";function llp(t){let{components:e,...n}=t;return(0,s.kt)(alp,(0,p.Z)({},ilp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function dlp(t){let{components:e,...n}=t;return(0,s.kt)(mlp,(0,p.Z)({},ulp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dlp.isMDXComponent=!0;const hlp={toc:[]},flp="wrapper";function klp(t){let{components:e,...n}=t;return(0,s.kt)(flp,(0,p.Z)({},hlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}klp.isMDXComponent=!0;const ylp={toc:[]},Dlp="wrapper";function Mlp(t){let{components:e,...n}=t;return(0,s.kt)(Dlp,(0,p.Z)({},ylp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(t){let{components:e,...n}=t;return(0,s.kt)(_lp,(0,p.Z)({},Xlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},glp="wrapper";function Clp(t){let{components:e,...n}=t;return(0,s.kt)(glp,(0,p.Z)({},Tlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Clp.isMDXComponent=!0;const xlp={toc:[]},vlp="wrapper";function Llp(t){let{components:e,...n}=t;return(0,s.kt)(vlp,(0,p.Z)({},xlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Llp.isMDXComponent=!0;const Zlp={toc:[]},blp="wrapper";function Nlp(t){let{components:e,...n}=t;return(0,s.kt)(blp,(0,p.Z)({},Zlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Nlp.isMDXComponent=!0;const Alp={toc:[]},zlp="wrapper";function Wlp(t){let{components:e,...n}=t;return(0,s.kt)(zlp,(0,p.Z)({},Alp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Wlp.isMDXComponent=!0;const Ilp={toc:[]},Rlp="wrapper";function Slp(t){let{components:e,...n}=t;return(0,s.kt)(Rlp,(0,p.Z)({},Ilp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Slp.isMDXComponent=!0;const Plp={toc:[]},Elp="wrapper";function Olp(t){let{components:e,...n}=t;return(0,s.kt)(Elp,(0,p.Z)({},Plp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Olp.isMDXComponent=!0;const Glp={toc:[]},Flp="wrapper";function Blp(t){let{components:e,...n}=t;return(0,s.kt)(Flp,(0,p.Z)({},Glp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Blp.isMDXComponent=!0;const Ulp={toc:[]},Vlp="wrapper";function qlp(t){let{components:e,...n}=t;return(0,s.kt)(Vlp,(0,p.Z)({},Ulp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qlp.isMDXComponent=!0;const jlp={toc:[]},Ylp="wrapper";function Hlp(t){let{components:e,...n}=t;return(0,s.kt)(Ylp,(0,p.Z)({},jlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Hlp.isMDXComponent=!0;const Qlp={toc:[]},$lp="wrapper";function Jlp(t){let{components:e,...n}=t;return(0,s.kt)($lp,(0,p.Z)({},Qlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Jlp.isMDXComponent=!0;const Klp={toc:[]},tup="wrapper";function eup(t){let{components:e,...n}=t;return(0,s.kt)(tup,(0,p.Z)({},Klp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eup.isMDXComponent=!0;const nup={toc:[]},oup="wrapper";function pup(t){let{components:e,...n}=t;return(0,s.kt)(oup,(0,p.Z)({},nup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(t){let{components:e,...n}=t;return(0,s.kt)(sup,(0,p.Z)({},rup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cup.isMDXComponent=!0;const iup={toc:[]},aup="wrapper";function lup(t){let{components:e,...n}=t;return(0,s.kt)(aup,(0,p.Z)({},iup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function dup(t){let{components:e,...n}=t;return(0,s.kt)(mup,(0,p.Z)({},uup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dup.isMDXComponent=!0;const hup={toc:[]},fup="wrapper";function kup(t){let{components:e,...n}=t;return(0,s.kt)(fup,(0,p.Z)({},hup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}kup.isMDXComponent=!0;const yup={toc:[]},Dup="wrapper";function Mup(t){let{components:e,...n}=t;return(0,s.kt)(Dup,(0,p.Z)({},yup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(t){let{components:e,...n}=t;return(0,s.kt)(_up,(0,p.Z)({},Xup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}wup.isMDXComponent=!0;const Tup={toc:[]},gup="wrapper";function Cup(t){let{components:e,...n}=t;return(0,s.kt)(gup,(0,p.Z)({},Tup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cup.isMDXComponent=!0;const xup={toc:[]},vup="wrapper";function Lup(t){let{components:e,...n}=t;return(0,s.kt)(vup,(0,p.Z)({},xup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Lup.isMDXComponent=!0;const Zup={toc:[]},bup="wrapper";function Nup(t){let{components:e,...n}=t;return(0,s.kt)(bup,(0,p.Z)({},Zup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nup.isMDXComponent=!0;const Aup={toc:[]},zup="wrapper";function Wup(t){let{components:e,...n}=t;return(0,s.kt)(zup,(0,p.Z)({},Aup,n,{components:e,mdxType:"MDXLayout"}))}Wup.isMDXComponent=!0;const Iup={toc:[]},Rup="wrapper";function Sup(t){let{components:e,...n}=t;return(0,s.kt)(Rup,(0,p.Z)({},Iup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sup.isMDXComponent=!0;const Pup={toc:[]},Eup="wrapper";function Oup(t){let{components:e,...n}=t;return(0,s.kt)(Eup,(0,p.Z)({},Pup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Oup.isMDXComponent=!0;const Gup={toc:[]},Fup="wrapper";function Bup(t){let{components:e,...n}=t;return(0,s.kt)(Fup,(0,p.Z)({},Gup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Bup.isMDXComponent=!0;const Uup={toc:[]},Vup="wrapper";function qup(t){let{components:e,...n}=t;return(0,s.kt)(Vup,(0,p.Z)({},Uup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qup.isMDXComponent=!0;const jup={toc:[]},Yup="wrapper";function Hup(t){let{components:e,...n}=t;return(0,s.kt)(Yup,(0,p.Z)({},jup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Hup.isMDXComponent=!0;const Qup={toc:[]},$up="wrapper";function Jup(t){let{components:e,...n}=t;return(0,s.kt)($up,(0,p.Z)({},Qup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Jup.isMDXComponent=!0;const Kup={toc:[]},tmp="wrapper";function emp(t){let{components:e,...n}=t;return(0,s.kt)(tmp,(0,p.Z)({},Kup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}emp.isMDXComponent=!0;const nmp={toc:[]},omp="wrapper";function pmp(t){let{components:e,...n}=t;return(0,s.kt)(omp,(0,p.Z)({},nmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(t){let{components:e,...n}=t;return(0,s.kt)(smp,(0,p.Z)({},rmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cmp.isMDXComponent=!0;const imp={toc:[]},amp="wrapper";function lmp(t){let{components:e,...n}=t;return(0,s.kt)(amp,(0,p.Z)({},imp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function dmp(t){let{components:e,...n}=t;return(0,s.kt)(mmp,(0,p.Z)({},ump,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dmp.isMDXComponent=!0;const hmp={toc:[]},fmp="wrapper";function kmp(t){let{components:e,...n}=t;return(0,s.kt)(fmp,(0,p.Z)({},hmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kmp.isMDXComponent=!0;const ymp={toc:[]},Dmp="wrapper";function Mmp(t){let{components:e,...n}=t;return(0,s.kt)(Dmp,(0,p.Z)({},ymp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(t){let{components:e,...n}=t;return(0,s.kt)(_mp,(0,p.Z)({},Xmp,n,{components:e,mdxType:"MDXLayout"}))}wmp.isMDXComponent=!0;const Tmp={toc:[]},gmp="wrapper";function Cmp(t){let{components:e,...n}=t;return(0,s.kt)(gmp,(0,p.Z)({},Tmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cmp.isMDXComponent=!0;const xmp={toc:[]},vmp="wrapper";function Lmp(t){let{components:e,...n}=t;return(0,s.kt)(vmp,(0,p.Z)({},xmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lmp.isMDXComponent=!0;const Zmp={toc:[]},bmp="wrapper";function Nmp(t){let{components:e,...n}=t;return(0,s.kt)(bmp,(0,p.Z)({},Zmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nmp.isMDXComponent=!0;const Amp={toc:[]},zmp="wrapper";function Wmp(t){let{components:e,...n}=t;return(0,s.kt)(zmp,(0,p.Z)({},Amp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wmp.isMDXComponent=!0;const Imp={toc:[]},Rmp="wrapper";function Smp(t){let{components:e,...n}=t;return(0,s.kt)(Rmp,(0,p.Z)({},Imp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Smp.isMDXComponent=!0;const Pmp={toc:[]},Emp="wrapper";function Omp(t){let{components:e,...n}=t;return(0,s.kt)(Emp,(0,p.Z)({},Pmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Omp.isMDXComponent=!0;const Gmp={toc:[]},Fmp="wrapper";function Bmp(t){let{components:e,...n}=t;return(0,s.kt)(Fmp,(0,p.Z)({},Gmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bmp.isMDXComponent=!0;const Ump={toc:[]},Vmp="wrapper";function qmp(t){let{components:e,...n}=t;return(0,s.kt)(Vmp,(0,p.Z)({},Ump,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qmp.isMDXComponent=!0;const jmp={toc:[]},Ymp="wrapper";function Hmp(t){let{components:e,...n}=t;return(0,s.kt)(Ymp,(0,p.Z)({},jmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Hmp.isMDXComponent=!0;const Qmp={toc:[]},$mp="wrapper";function Jmp(t){let{components:e,...n}=t;return(0,s.kt)($mp,(0,p.Z)({},Qmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Jmp.isMDXComponent=!0;const Kmp={toc:[]},tdp="wrapper";function edp(t){let{components:e,...n}=t;return(0,s.kt)(tdp,(0,p.Z)({},Kmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}edp.isMDXComponent=!0;const ndp={toc:[]},odp="wrapper";function pdp(t){let{components:e,...n}=t;return(0,s.kt)(odp,(0,p.Z)({},ndp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(t){let{components:e,...n}=t;return(0,s.kt)(sdp,(0,p.Z)({},rdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cdp.isMDXComponent=!0;const idp={toc:[]},adp="wrapper";function ldp(t){let{components:e,...n}=t;return(0,s.kt)(adp,(0,p.Z)({},idp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ddp(t){let{components:e,...n}=t;return(0,s.kt)(mdp,(0,p.Z)({},udp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ddp.isMDXComponent=!0;const hdp={toc:[]},fdp="wrapper";function kdp(t){let{components:e,...n}=t;return(0,s.kt)(fdp,(0,p.Z)({},hdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kdp.isMDXComponent=!0;const ydp={toc:[]},Ddp="wrapper";function Mdp(t){let{components:e,...n}=t;return(0,s.kt)(Ddp,(0,p.Z)({},ydp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(t){let{components:e,...n}=t;return(0,s.kt)(_dp,(0,p.Z)({},Xdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},gdp="wrapper";function Cdp(t){let{components:e,...n}=t;return(0,s.kt)(gdp,(0,p.Z)({},Tdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Cdp.isMDXComponent=!0;const xdp={toc:[]},vdp="wrapper";function Ldp(t){let{components:e,...n}=t;return(0,s.kt)(vdp,(0,p.Z)({},xdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ldp.isMDXComponent=!0;const Zdp={toc:[]},bdp="wrapper";function Ndp(t){let{components:e,...n}=t;return(0,s.kt)(bdp,(0,p.Z)({},Zdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ndp.isMDXComponent=!0;const Adp={toc:[]},zdp="wrapper";function Wdp(t){let{components:e,...n}=t;return(0,s.kt)(zdp,(0,p.Z)({},Adp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wdp.isMDXComponent=!0;const Idp={toc:[]},Rdp="wrapper";function Sdp(t){let{components:e,...n}=t;return(0,s.kt)(Rdp,(0,p.Z)({},Idp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Sdp.isMDXComponent=!0;const Pdp={toc:[]},Edp="wrapper";function Odp(t){let{components:e,...n}=t;return(0,s.kt)(Edp,(0,p.Z)({},Pdp,n,{components:e,mdxType:"MDXLayout"}))}Odp.isMDXComponent=!0;const Gdp={toc:[]},Fdp="wrapper";function Bdp(t){let{components:e,...n}=t;return(0,s.kt)(Fdp,(0,p.Z)({},Gdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Bdp.isMDXComponent=!0;const Udp={toc:[]},Vdp="wrapper";function qdp(t){let{components:e,...n}=t;return(0,s.kt)(Vdp,(0,p.Z)({},Udp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qdp.isMDXComponent=!0;const jdp={toc:[]},Ydp="wrapper";function Hdp(t){let{components:e,...n}=t;return(0,s.kt)(Ydp,(0,p.Z)({},jdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hdp.isMDXComponent=!0;const Qdp={toc:[]},$dp="wrapper";function Jdp(t){let{components:e,...n}=t;return(0,s.kt)($dp,(0,p.Z)({},Qdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Jdp.isMDXComponent=!0;const Kdp={toc:[]},thp="wrapper";function ehp(t){let{components:e,...n}=t;return(0,s.kt)(thp,(0,p.Z)({},Kdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ehp.isMDXComponent=!0;const nhp={toc:[]},ohp="wrapper";function php(t){let{components:e,...n}=t;return(0,s.kt)(ohp,(0,p.Z)({},nhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(t){let{components:e,...n}=t;return(0,s.kt)(shp,(0,p.Z)({},rhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}chp.isMDXComponent=!0;const ihp={toc:[]},ahp="wrapper";function lhp(t){let{components:e,...n}=t;return(0,s.kt)(ahp,(0,p.Z)({},ihp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function dhp(t){let{components:e,...n}=t;return(0,s.kt)(mhp,(0,p.Z)({},uhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dhp.isMDXComponent=!0;const hhp={toc:[]},fhp="wrapper";function khp(t){let{components:e,...n}=t;return(0,s.kt)(fhp,(0,p.Z)({},hhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}khp.isMDXComponent=!0;const yhp={toc:[]},Dhp="wrapper";function Mhp(t){let{components:e,...n}=t;return(0,s.kt)(Dhp,(0,p.Z)({},yhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(t){let{components:e,...n}=t;return(0,s.kt)(_hp,(0,p.Z)({},Xhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}whp.isMDXComponent=!0;const Thp={toc:[]},ghp="wrapper";function Chp(t){let{components:e,...n}=t;return(0,s.kt)(ghp,(0,p.Z)({},Thp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Chp.isMDXComponent=!0;const xhp={toc:[]},vhp="wrapper";function Lhp(t){let{components:e,...n}=t;return(0,s.kt)(vhp,(0,p.Z)({},xhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lhp.isMDXComponent=!0;const Zhp={toc:[]},bhp="wrapper";function Nhp(t){let{components:e,...n}=t;return(0,s.kt)(bhp,(0,p.Z)({},Zhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nhp.isMDXComponent=!0;const Ahp={toc:[]},zhp="wrapper";function Whp(t){let{components:e,...n}=t;return(0,s.kt)(zhp,(0,p.Z)({},Ahp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Whp.isMDXComponent=!0;const Ihp={toc:[]},Rhp="wrapper";function Shp(t){let{components:e,...n}=t;return(0,s.kt)(Rhp,(0,p.Z)({},Ihp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Shp.isMDXComponent=!0;const Php={toc:[]},Ehp="wrapper";function Ohp(t){let{components:e,...n}=t;return(0,s.kt)(Ehp,(0,p.Z)({},Php,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ohp.isMDXComponent=!0;const Ghp={toc:[]},Fhp="wrapper";function Bhp(t){let{components:e,...n}=t;return(0,s.kt)(Fhp,(0,p.Z)({},Ghp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhp.isMDXComponent=!0;const Uhp={toc:[]},Vhp="wrapper";function qhp(t){let{components:e,...n}=t;return(0,s.kt)(Vhp,(0,p.Z)({},Uhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qhp.isMDXComponent=!0;const jhp={toc:[]},Yhp="wrapper";function Hhp(t){let{components:e,...n}=t;return(0,s.kt)(Yhp,(0,p.Z)({},jhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Hhp.isMDXComponent=!0;const Qhp={toc:[]},$hp="wrapper";function Jhp(t){let{components:e,...n}=t;return(0,s.kt)($hp,(0,p.Z)({},Qhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Jhp.isMDXComponent=!0;const Khp={toc:[]},tfp="wrapper";function efp(t){let{components:e,...n}=t;return(0,s.kt)(tfp,(0,p.Z)({},Khp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}efp.isMDXComponent=!0;const nfp={toc:[]},ofp="wrapper";function pfp(t){let{components:e,...n}=t;return(0,s.kt)(ofp,(0,p.Z)({},nfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(t){let{components:e,...n}=t;return(0,s.kt)(sfp,(0,p.Z)({},rfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}cfp.isMDXComponent=!0;const ifp={toc:[]},afp="wrapper";function lfp(t){let{components:e,...n}=t;return(0,s.kt)(afp,(0,p.Z)({},ifp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function dfp(t){let{components:e,...n}=t;return(0,s.kt)(mfp,(0,p.Z)({},ufp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dfp.isMDXComponent=!0;const hfp={toc:[]},ffp="wrapper";function kfp(t){let{components:e,...n}=t;return(0,s.kt)(ffp,(0,p.Z)({},hfp,n,{components:e,mdxType:"MDXLayout"}))}kfp.isMDXComponent=!0;const yfp={toc:[]},Dfp="wrapper";function Mfp(t){let{components:e,...n}=t;return(0,s.kt)(Dfp,(0,p.Z)({},yfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(t){let{components:e,...n}=t;return(0,s.kt)(_fp,(0,p.Z)({},Xfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},gfp="wrapper";function Cfp(t){let{components:e,...n}=t;return(0,s.kt)(gfp,(0,p.Z)({},Tfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cfp.isMDXComponent=!0;const xfp={toc:[]},vfp="wrapper";function Lfp(t){let{components:e,...n}=t;return(0,s.kt)(vfp,(0,p.Z)({},xfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lfp.isMDXComponent=!0;const Zfp={toc:[]},bfp="wrapper";function Nfp(t){let{components:e,...n}=t;return(0,s.kt)(bfp,(0,p.Z)({},Zfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nfp.isMDXComponent=!0;const Afp={toc:[]},zfp="wrapper";function Wfp(t){let{components:e,...n}=t;return(0,s.kt)(zfp,(0,p.Z)({},Afp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Wfp.isMDXComponent=!0;const Ifp={toc:[]},Rfp="wrapper";function Sfp(t){let{components:e,...n}=t;return(0,s.kt)(Rfp,(0,p.Z)({},Ifp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Sfp.isMDXComponent=!0;const Pfp={toc:[]},Efp="wrapper";function Ofp(t){let{components:e,...n}=t;return(0,s.kt)(Efp,(0,p.Z)({},Pfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ofp.isMDXComponent=!0;const Gfp={toc:[]},Ffp="wrapper";function Bfp(t){let{components:e,...n}=t;return(0,s.kt)(Ffp,(0,p.Z)({},Gfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bfp.isMDXComponent=!0;const Ufp={toc:[]},Vfp="wrapper";function qfp(t){let{components:e,...n}=t;return(0,s.kt)(Vfp,(0,p.Z)({},Ufp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qfp.isMDXComponent=!0;const jfp={toc:[]},Yfp="wrapper";function Hfp(t){let{components:e,...n}=t;return(0,s.kt)(Yfp,(0,p.Z)({},jfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hfp.isMDXComponent=!0;const Qfp={toc:[]},$fp="wrapper";function Jfp(t){let{components:e,...n}=t;return(0,s.kt)($fp,(0,p.Z)({},Qfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Jfp.isMDXComponent=!0;const Kfp={toc:[]},tkp="wrapper";function ekp(t){let{components:e,...n}=t;return(0,s.kt)(tkp,(0,p.Z)({},Kfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ekp.isMDXComponent=!0;const nkp={toc:[]},okp="wrapper";function pkp(t){let{components:e,...n}=t;return(0,s.kt)(okp,(0,p.Z)({},nkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(t){let{components:e,...n}=t;return(0,s.kt)(skp,(0,p.Z)({},rkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ckp.isMDXComponent=!0;const ikp={toc:[]},akp="wrapper";function lkp(t){let{components:e,...n}=t;return(0,s.kt)(akp,(0,p.Z)({},ikp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function dkp(t){let{components:e,...n}=t;return(0,s.kt)(mkp,(0,p.Z)({},ukp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dkp.isMDXComponent=!0;const hkp={toc:[]},fkp="wrapper";function kkp(t){let{components:e,...n}=t;return(0,s.kt)(fkp,(0,p.Z)({},hkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kkp.isMDXComponent=!0;const ykp={toc:[]},Dkp="wrapper";function Mkp(t){let{components:e,...n}=t;return(0,s.kt)(Dkp,(0,p.Z)({},ykp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(t){let{components:e,...n}=t;return(0,s.kt)(_kp,(0,p.Z)({},Xkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},gkp="wrapper";function Ckp(t){let{components:e,...n}=t;return(0,s.kt)(gkp,(0,p.Z)({},Tkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ckp.isMDXComponent=!0;const xkp={toc:[]},vkp="wrapper";function Lkp(t){let{components:e,...n}=t;return(0,s.kt)(vkp,(0,p.Z)({},xkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lkp.isMDXComponent=!0;const Zkp={toc:[]},bkp="wrapper";function Nkp(t){let{components:e,...n}=t;return(0,s.kt)(bkp,(0,p.Z)({},Zkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nkp.isMDXComponent=!0;const Akp={toc:[]},zkp="wrapper";function Wkp(t){let{components:e,...n}=t;return(0,s.kt)(zkp,(0,p.Z)({},Akp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wkp.isMDXComponent=!0;const Ikp={toc:[]},Rkp="wrapper";function Skp(t){let{components:e,...n}=t;return(0,s.kt)(Rkp,(0,p.Z)({},Ikp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Skp.isMDXComponent=!0;const Pkp={toc:[]},Ekp="wrapper";function Okp(t){let{components:e,...n}=t;return(0,s.kt)(Ekp,(0,p.Z)({},Pkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Okp.isMDXComponent=!0;const Gkp={toc:[]},Fkp="wrapper";function Bkp(t){let{components:e,...n}=t;return(0,s.kt)(Fkp,(0,p.Z)({},Gkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bkp.isMDXComponent=!0;const Ukp={toc:[]},Vkp="wrapper";function qkp(t){let{components:e,...n}=t;return(0,s.kt)(Vkp,(0,p.Z)({},Ukp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qkp.isMDXComponent=!0;const jkp={toc:[]},Ykp="wrapper";function Hkp(t){let{components:e,...n}=t;return(0,s.kt)(Ykp,(0,p.Z)({},jkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Hkp.isMDXComponent=!0;const Qkp={toc:[]},$kp="wrapper";function Jkp(t){let{components:e,...n}=t;return(0,s.kt)($kp,(0,p.Z)({},Qkp,n,{components:e,mdxType:"MDXLayout"}))}Jkp.isMDXComponent=!0;const Kkp={toc:[]},typ="wrapper";function eyp(t){let{components:e,...n}=t;return(0,s.kt)(typ,(0,p.Z)({},Kkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eyp.isMDXComponent=!0;const nyp={toc:[]},oyp="wrapper";function pyp(t){let{components:e,...n}=t;return(0,s.kt)(oyp,(0,p.Z)({},nyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(t){let{components:e,...n}=t;return(0,s.kt)(syp,(0,p.Z)({},ryp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cyp.isMDXComponent=!0;const iyp={toc:[]},ayp="wrapper";function lyp(t){let{components:e,...n}=t;return(0,s.kt)(ayp,(0,p.Z)({},iyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function dyp(t){let{components:e,...n}=t;return(0,s.kt)(myp,(0,p.Z)({},uyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}dyp.isMDXComponent=!0;const hyp={toc:[]},fyp="wrapper";function kyp(t){let{components:e,...n}=t;return(0,s.kt)(fyp,(0,p.Z)({},hyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}kyp.isMDXComponent=!0;const yyp={toc:[]},Dyp="wrapper";function Myp(t){let{components:e,...n}=t;return(0,s.kt)(Dyp,(0,p.Z)({},yyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(t){let{components:e,...n}=t;return(0,s.kt)(_yp,(0,p.Z)({},Xyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wyp.isMDXComponent=!0;const Typ={toc:[]},gyp="wrapper";function Cyp(t){let{components:e,...n}=t;return(0,s.kt)(gyp,(0,p.Z)({},Typ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cyp.isMDXComponent=!0;const xyp={toc:[]},vyp="wrapper";function Lyp(t){let{components:e,...n}=t;return(0,s.kt)(vyp,(0,p.Z)({},xyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lyp.isMDXComponent=!0;const Zyp={toc:[]},byp="wrapper";function Nyp(t){let{components:e,...n}=t;return(0,s.kt)(byp,(0,p.Z)({},Zyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nyp.isMDXComponent=!0;const Ayp={toc:[]},zyp="wrapper";function Wyp(t){let{components:e,...n}=t;return(0,s.kt)(zyp,(0,p.Z)({},Ayp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Wyp.isMDXComponent=!0;const Iyp={toc:[]},Ryp="wrapper";function Syp(t){let{components:e,...n}=t;return(0,s.kt)(Ryp,(0,p.Z)({},Iyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Syp.isMDXComponent=!0;const Pyp={toc:[]},Eyp="wrapper";function Oyp(t){let{components:e,...n}=t;return(0,s.kt)(Eyp,(0,p.Z)({},Pyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Oyp.isMDXComponent=!0;const Gyp={toc:[]},Fyp="wrapper";function Byp(t){let{components:e,...n}=t;return(0,s.kt)(Fyp,(0,p.Z)({},Gyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Byp.isMDXComponent=!0;const Uyp={toc:[]},Vyp="wrapper";function qyp(t){let{components:e,...n}=t;return(0,s.kt)(Vyp,(0,p.Z)({},Uyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qyp.isMDXComponent=!0;const jyp={toc:[]},Yyp="wrapper";function Hyp(t){let{components:e,...n}=t;return(0,s.kt)(Yyp,(0,p.Z)({},jyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hyp.isMDXComponent=!0;const Qyp={toc:[]},$yp="wrapper";function Jyp(t){let{components:e,...n}=t;return(0,s.kt)($yp,(0,p.Z)({},Qyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Jyp.isMDXComponent=!0;const Kyp={toc:[]},tDp="wrapper";function eDp(t){let{components:e,...n}=t;return(0,s.kt)(tDp,(0,p.Z)({},Kyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eDp.isMDXComponent=!0;const nDp={toc:[]},oDp="wrapper";function pDp(t){let{components:e,...n}=t;return(0,s.kt)(oDp,(0,p.Z)({},nDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(t){let{components:e,...n}=t;return(0,s.kt)(sDp,(0,p.Z)({},rDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cDp.isMDXComponent=!0;const iDp={toc:[]},aDp="wrapper";function lDp(t){let{components:e,...n}=t;return(0,s.kt)(aDp,(0,p.Z)({},iDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function dDp(t){let{components:e,...n}=t;return(0,s.kt)(mDp,(0,p.Z)({},uDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dDp.isMDXComponent=!0;const hDp={toc:[]},fDp="wrapper";function kDp(t){let{components:e,...n}=t;return(0,s.kt)(fDp,(0,p.Z)({},hDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kDp.isMDXComponent=!0;const yDp={toc:[]},DDp="wrapper";function MDp(t){let{components:e,...n}=t;return(0,s.kt)(DDp,(0,p.Z)({},yDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(t){let{components:e,...n}=t;return(0,s.kt)(_Dp,(0,p.Z)({},XDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wDp.isMDXComponent=!0;const TDp={toc:[]},gDp="wrapper";function CDp(t){let{components:e,...n}=t;return(0,s.kt)(gDp,(0,p.Z)({},TDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}CDp.isMDXComponent=!0;const xDp={toc:[]},vDp="wrapper";function LDp(t){let{components:e,...n}=t;return(0,s.kt)(vDp,(0,p.Z)({},xDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}LDp.isMDXComponent=!0;const ZDp={toc:[]},bDp="wrapper";function NDp(t){let{components:e,...n}=t;return(0,s.kt)(bDp,(0,p.Z)({},ZDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}NDp.isMDXComponent=!0;const ADp={toc:[]},zDp="wrapper";function WDp(t){let{components:e,...n}=t;return(0,s.kt)(zDp,(0,p.Z)({},ADp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WDp.isMDXComponent=!0;const IDp={toc:[]},RDp="wrapper";function SDp(t){let{components:e,...n}=t;return(0,s.kt)(RDp,(0,p.Z)({},IDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}SDp.isMDXComponent=!0;const PDp={toc:[]},EDp="wrapper";function ODp(t){let{components:e,...n}=t;return(0,s.kt)(EDp,(0,p.Z)({},PDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}ODp.isMDXComponent=!0;const GDp={toc:[]},FDp="wrapper";function BDp(t){let{components:e,...n}=t;return(0,s.kt)(FDp,(0,p.Z)({},GDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BDp.isMDXComponent=!0;const UDp={toc:[]},VDp="wrapper";function qDp(t){let{components:e,...n}=t;return(0,s.kt)(VDp,(0,p.Z)({},UDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qDp.isMDXComponent=!0;const jDp={toc:[]},YDp="wrapper";function HDp(t){let{components:e,...n}=t;return(0,s.kt)(YDp,(0,p.Z)({},jDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}HDp.isMDXComponent=!0;const QDp={toc:[]},$Dp="wrapper";function JDp(t){let{components:e,...n}=t;return(0,s.kt)($Dp,(0,p.Z)({},QDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}JDp.isMDXComponent=!0;const KDp={toc:[]},tMp="wrapper";function eMp(t){let{components:e,...n}=t;return(0,s.kt)(tMp,(0,p.Z)({},KDp,n,{components:e,mdxType:"MDXLayout"}))}eMp.isMDXComponent=!0;const nMp={toc:[]},oMp="wrapper";function pMp(t){let{components:e,...n}=t;return(0,s.kt)(oMp,(0,p.Z)({},nMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(t){let{components:e,...n}=t;return(0,s.kt)(sMp,(0,p.Z)({},rMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cMp.isMDXComponent=!0;const iMp={toc:[]},aMp="wrapper";function lMp(t){let{components:e,...n}=t;return(0,s.kt)(aMp,(0,p.Z)({},iMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function dMp(t){let{components:e,...n}=t;return(0,s.kt)(mMp,(0,p.Z)({},uMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dMp.isMDXComponent=!0;const hMp={toc:[]},fMp="wrapper";function kMp(t){let{components:e,...n}=t;return(0,s.kt)(fMp,(0,p.Z)({},hMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kMp.isMDXComponent=!0;const yMp={toc:[]},DMp="wrapper";function MMp(t){let{components:e,...n}=t;return(0,s.kt)(DMp,(0,p.Z)({},yMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(t){let{components:e,...n}=t;return(0,s.kt)(_Mp,(0,p.Z)({},XMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}wMp.isMDXComponent=!0;const TMp={toc:[]},gMp="wrapper";function CMp(t){let{components:e,...n}=t;return(0,s.kt)(gMp,(0,p.Z)({},TMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CMp.isMDXComponent=!0;const xMp={toc:[]},vMp="wrapper";function LMp(t){let{components:e,...n}=t;return(0,s.kt)(vMp,(0,p.Z)({},xMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LMp.isMDXComponent=!0;const ZMp={toc:[]},bMp="wrapper";function NMp(t){let{components:e,...n}=t;return(0,s.kt)(bMp,(0,p.Z)({},ZMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NMp.isMDXComponent=!0;const AMp={toc:[]},zMp="wrapper";function WMp(t){let{components:e,...n}=t;return(0,s.kt)(zMp,(0,p.Z)({},AMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WMp.isMDXComponent=!0;const IMp={toc:[]},RMp="wrapper";function SMp(t){let{components:e,...n}=t;return(0,s.kt)(RMp,(0,p.Z)({},IMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SMp.isMDXComponent=!0;const PMp={toc:[]},EMp="wrapper";function OMp(t){let{components:e,...n}=t;return(0,s.kt)(EMp,(0,p.Z)({},PMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}OMp.isMDXComponent=!0;const GMp={toc:[]},FMp="wrapper";function BMp(t){let{components:e,...n}=t;return(0,s.kt)(FMp,(0,p.Z)({},GMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}BMp.isMDXComponent=!0;const UMp={toc:[]},VMp="wrapper";function qMp(t){let{components:e,...n}=t;return(0,s.kt)(VMp,(0,p.Z)({},UMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qMp.isMDXComponent=!0;const jMp={toc:[]},YMp="wrapper";function HMp(t){let{components:e,...n}=t;return(0,s.kt)(YMp,(0,p.Z)({},jMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HMp.isMDXComponent=!0;const QMp={toc:[]},$Mp="wrapper";function JMp(t){let{components:e,...n}=t;return(0,s.kt)($Mp,(0,p.Z)({},QMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}JMp.isMDXComponent=!0;const KMp={toc:[]},tXp="wrapper";function eXp(t){let{components:e,...n}=t;return(0,s.kt)(tXp,(0,p.Z)({},KMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eXp.isMDXComponent=!0;const nXp={toc:[]},oXp="wrapper";function pXp(t){let{components:e,...n}=t;return(0,s.kt)(oXp,(0,p.Z)({},nXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(t){let{components:e,...n}=t;return(0,s.kt)(sXp,(0,p.Z)({},rXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cXp.isMDXComponent=!0;const iXp={toc:[]},aXp="wrapper";function lXp(t){let{components:e,...n}=t;return(0,s.kt)(aXp,(0,p.Z)({},iXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function dXp(t){let{components:e,...n}=t;return(0,s.kt)(mXp,(0,p.Z)({},uXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dXp.isMDXComponent=!0;const hXp={toc:[]},fXp="wrapper";function kXp(t){let{components:e,...n}=t;return(0,s.kt)(fXp,(0,p.Z)({},hXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kXp.isMDXComponent=!0;const yXp={toc:[]},DXp="wrapper";function MXp(t){let{components:e,...n}=t;return(0,s.kt)(DXp,(0,p.Z)({},yXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(t){let{components:e,...n}=t;return(0,s.kt)(_Xp,(0,p.Z)({},XXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wXp.isMDXComponent=!0;const TXp={toc:[]},gXp="wrapper";function CXp(t){let{components:e,...n}=t;return(0,s.kt)(gXp,(0,p.Z)({},TXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CXp.isMDXComponent=!0;const xXp={toc:[]},vXp="wrapper";function LXp(t){let{components:e,...n}=t;return(0,s.kt)(vXp,(0,p.Z)({},xXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LXp.isMDXComponent=!0;const ZXp={toc:[]},bXp="wrapper";function NXp(t){let{components:e,...n}=t;return(0,s.kt)(bXp,(0,p.Z)({},ZXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NXp.isMDXComponent=!0;const AXp={toc:[]},zXp="wrapper";function WXp(t){let{components:e,...n}=t;return(0,s.kt)(zXp,(0,p.Z)({},AXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WXp.isMDXComponent=!0;const IXp={toc:[]},RXp="wrapper";function SXp(t){let{components:e,...n}=t;return(0,s.kt)(RXp,(0,p.Z)({},IXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}SXp.isMDXComponent=!0;const PXp={toc:[]},EXp="wrapper";function OXp(t){let{components:e,...n}=t;return(0,s.kt)(EXp,(0,p.Z)({},PXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OXp.isMDXComponent=!0;const GXp={toc:[]},FXp="wrapper";function BXp(t){let{components:e,...n}=t;return(0,s.kt)(FXp,(0,p.Z)({},GXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BXp.isMDXComponent=!0;const UXp={toc:[]},VXp="wrapper";function qXp(t){let{components:e,...n}=t;return(0,s.kt)(VXp,(0,p.Z)({},UXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qXp.isMDXComponent=!0;const jXp={toc:[]},YXp="wrapper";function HXp(t){let{components:e,...n}=t;return(0,s.kt)(YXp,(0,p.Z)({},jXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}HXp.isMDXComponent=!0;const QXp={toc:[]},$Xp="wrapper";function JXp(t){let{components:e,...n}=t;return(0,s.kt)($Xp,(0,p.Z)({},QXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}JXp.isMDXComponent=!0;const KXp={toc:[]},t_p="wrapper";function e_p(t){let{components:e,...n}=t;return(0,s.kt)(t_p,(0,p.Z)({},KXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}e_p.isMDXComponent=!0;const n_p={toc:[]},o_p="wrapper";function p_p(t){let{components:e,...n}=t;return(0,s.kt)(o_p,(0,p.Z)({},n_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(t){let{components:e,...n}=t;return(0,s.kt)(s_p,(0,p.Z)({},r_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}c_p.isMDXComponent=!0;const i_p={toc:[]},a_p="wrapper";function l_p(t){let{components:e,...n}=t;return(0,s.kt)(a_p,(0,p.Z)({},i_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function d_p(t){let{components:e,...n}=t;return(0,s.kt)(m_p,(0,p.Z)({},u_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}d_p.isMDXComponent=!0;const h_p={toc:[]},f_p="wrapper";function k_p(t){let{components:e,...n}=t;return(0,s.kt)(f_p,(0,p.Z)({},h_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}k_p.isMDXComponent=!0;const y_p={toc:[]},D_p="wrapper";function M_p(t){let{components:e,...n}=t;return(0,s.kt)(D_p,(0,p.Z)({},y_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(t){let{components:e,...n}=t;return(0,s.kt)(__p,(0,p.Z)({},X_p,n,{components:e,mdxType:"MDXLayout"}))}w_p.isMDXComponent=!0;const T_p={toc:[]},g_p="wrapper";function C_p(t){let{components:e,...n}=t;return(0,s.kt)(g_p,(0,p.Z)({},T_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}C_p.isMDXComponent=!0;const x_p={toc:[]},v_p="wrapper";function L_p(t){let{components:e,...n}=t;return(0,s.kt)(v_p,(0,p.Z)({},x_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}L_p.isMDXComponent=!0;const Z_p={toc:[]},b_p="wrapper";function N_p(t){let{components:e,...n}=t;return(0,s.kt)(b_p,(0,p.Z)({},Z_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}N_p.isMDXComponent=!0;const A_p={toc:[]},z_p="wrapper";function W_p(t){let{components:e,...n}=t;return(0,s.kt)(z_p,(0,p.Z)({},A_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}W_p.isMDXComponent=!0;const I_p={toc:[]},R_p="wrapper";function S_p(t){let{components:e,...n}=t;return(0,s.kt)(R_p,(0,p.Z)({},I_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}S_p.isMDXComponent=!0;const P_p={toc:[]},E_p="wrapper";function O_p(t){let{components:e,...n}=t;return(0,s.kt)(E_p,(0,p.Z)({},P_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}O_p.isMDXComponent=!0;const G_p={toc:[]},F_p="wrapper";function B_p(t){let{components:e,...n}=t;return(0,s.kt)(F_p,(0,p.Z)({},G_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}B_p.isMDXComponent=!0;const U_p={toc:[]},V_p="wrapper";function q_p(t){let{components:e,...n}=t;return(0,s.kt)(V_p,(0,p.Z)({},U_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}q_p.isMDXComponent=!0;const j_p={toc:[]},Y_p="wrapper";function H_p(t){let{components:e,...n}=t;return(0,s.kt)(Y_p,(0,p.Z)({},j_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}H_p.isMDXComponent=!0;const Q_p={toc:[]},$_p="wrapper";function J_p(t){let{components:e,...n}=t;return(0,s.kt)($_p,(0,p.Z)({},Q_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}J_p.isMDXComponent=!0;const K_p={toc:[]},twp="wrapper";function ewp(t){let{components:e,...n}=t;return(0,s.kt)(twp,(0,p.Z)({},K_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ewp.isMDXComponent=!0;const nwp={toc:[]},owp="wrapper";function pwp(t){let{components:e,...n}=t;return(0,s.kt)(owp,(0,p.Z)({},nwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(t){let{components:e,...n}=t;return(0,s.kt)(swp,(0,p.Z)({},rwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}cwp.isMDXComponent=!0;const iwp={toc:[]},awp="wrapper";function lwp(t){let{components:e,...n}=t;return(0,s.kt)(awp,(0,p.Z)({},iwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function dwp(t){let{components:e,...n}=t;return(0,s.kt)(mwp,(0,p.Z)({},uwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dwp.isMDXComponent=!0;const hwp={toc:[]},fwp="wrapper";function kwp(t){let{components:e,...n}=t;return(0,s.kt)(fwp,(0,p.Z)({},hwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kwp.isMDXComponent=!0;const ywp={toc:[]},Dwp="wrapper";function Mwp(t){let{components:e,...n}=t;return(0,s.kt)(Dwp,(0,p.Z)({},ywp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(t){let{components:e,...n}=t;return(0,s.kt)(_wp,(0,p.Z)({},Xwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wwp.isMDXComponent=!0;const Twp={toc:[]},gwp="wrapper";function Cwp(t){let{components:e,...n}=t;return(0,s.kt)(gwp,(0,p.Z)({},Twp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cwp.isMDXComponent=!0;const xwp={toc:[]},vwp="wrapper";function Lwp(t){let{components:e,...n}=t;return(0,s.kt)(vwp,(0,p.Z)({},xwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lwp.isMDXComponent=!0;const Zwp={toc:[]},bwp="wrapper";function Nwp(t){let{components:e,...n}=t;return(0,s.kt)(bwp,(0,p.Z)({},Zwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nwp.isMDXComponent=!0;const Awp={toc:[]},zwp="wrapper";function Wwp(t){let{components:e,...n}=t;return(0,s.kt)(zwp,(0,p.Z)({},Awp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wwp.isMDXComponent=!0;const Iwp={toc:[]},Rwp="wrapper";function Swp(t){let{components:e,...n}=t;return(0,s.kt)(Rwp,(0,p.Z)({},Iwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Swp.isMDXComponent=!0;const Pwp={toc:[]},Ewp="wrapper";function Owp(t){let{components:e,...n}=t;return(0,s.kt)(Ewp,(0,p.Z)({},Pwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Owp.isMDXComponent=!0;const Gwp={toc:[]},Fwp="wrapper";function Bwp(t){let{components:e,...n}=t;return(0,s.kt)(Fwp,(0,p.Z)({},Gwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bwp.isMDXComponent=!0;const Uwp={toc:[]},Vwp="wrapper";function qwp(t){let{components:e,...n}=t;return(0,s.kt)(Vwp,(0,p.Z)({},Uwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qwp.isMDXComponent=!0;const jwp={toc:[]},Ywp="wrapper";function Hwp(t){let{components:e,...n}=t;return(0,s.kt)(Ywp,(0,p.Z)({},jwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Hwp.isMDXComponent=!0;const Qwp={toc:[]},$wp="wrapper";function Jwp(t){let{components:e,...n}=t;return(0,s.kt)($wp,(0,p.Z)({},Qwp,n,{components:e,mdxType:"MDXLayout"}))}Jwp.isMDXComponent=!0;const Kwp={toc:[]},tTp="wrapper";function eTp(t){let{components:e,...n}=t;return(0,s.kt)(tTp,(0,p.Z)({},Kwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eTp.isMDXComponent=!0;const nTp={toc:[]},oTp="wrapper";function pTp(t){let{components:e,...n}=t;return(0,s.kt)(oTp,(0,p.Z)({},nTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(t){let{components:e,...n}=t;return(0,s.kt)(sTp,(0,p.Z)({},rTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cTp.isMDXComponent=!0;const iTp={toc:[]},aTp="wrapper";function lTp(t){let{components:e,...n}=t;return(0,s.kt)(aTp,(0,p.Z)({},iTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function dTp(t){let{components:e,...n}=t;return(0,s.kt)(mTp,(0,p.Z)({},uTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dTp.isMDXComponent=!0;const hTp={toc:[]},fTp="wrapper";function kTp(t){let{components:e,...n}=t;return(0,s.kt)(fTp,(0,p.Z)({},hTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kTp.isMDXComponent=!0;const yTp={toc:[]},DTp="wrapper";function MTp(t){let{components:e,...n}=t;return(0,s.kt)(DTp,(0,p.Z)({},yTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(t){let{components:e,...n}=t;return(0,s.kt)(_Tp,(0,p.Z)({},XTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}wTp.isMDXComponent=!0;const TTp={toc:[]},gTp="wrapper";function CTp(t){let{components:e,...n}=t;return(0,s.kt)(gTp,(0,p.Z)({},TTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CTp.isMDXComponent=!0;const xTp={toc:[]},vTp="wrapper";function LTp(t){let{components:e,...n}=t;return(0,s.kt)(vTp,(0,p.Z)({},xTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LTp.isMDXComponent=!0;const ZTp={toc:[]},bTp="wrapper";function NTp(t){let{components:e,...n}=t;return(0,s.kt)(bTp,(0,p.Z)({},ZTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NTp.isMDXComponent=!0;const ATp={toc:[]},zTp="wrapper";function WTp(t){let{components:e,...n}=t;return(0,s.kt)(zTp,(0,p.Z)({},ATp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WTp.isMDXComponent=!0;const ITp={toc:[]},RTp="wrapper";function STp(t){let{components:e,...n}=t;return(0,s.kt)(RTp,(0,p.Z)({},ITp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}STp.isMDXComponent=!0;const PTp={toc:[]},ETp="wrapper";function OTp(t){let{components:e,...n}=t;return(0,s.kt)(ETp,(0,p.Z)({},PTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}OTp.isMDXComponent=!0;const GTp={toc:[]},FTp="wrapper";function BTp(t){let{components:e,...n}=t;return(0,s.kt)(FTp,(0,p.Z)({},GTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BTp.isMDXComponent=!0;const UTp={toc:[]},VTp="wrapper";function qTp(t){let{components:e,...n}=t;return(0,s.kt)(VTp,(0,p.Z)({},UTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qTp.isMDXComponent=!0;const jTp={toc:[]},YTp="wrapper";function HTp(t){let{components:e,...n}=t;return(0,s.kt)(YTp,(0,p.Z)({},jTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}HTp.isMDXComponent=!0;const QTp={toc:[]},$Tp="wrapper";function JTp(t){let{components:e,...n}=t;return(0,s.kt)($Tp,(0,p.Z)({},QTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}JTp.isMDXComponent=!0;const KTp={toc:[]},tgp="wrapper";function egp(t){let{components:e,...n}=t;return(0,s.kt)(tgp,(0,p.Z)({},KTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}egp.isMDXComponent=!0;const ngp={toc:[]},ogp="wrapper";function pgp(t){let{components:e,...n}=t;return(0,s.kt)(ogp,(0,p.Z)({},ngp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(t){let{components:e,...n}=t;return(0,s.kt)(sgp,(0,p.Z)({},rgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cgp.isMDXComponent=!0;const igp={toc:[]},agp="wrapper";function lgp(t){let{components:e,...n}=t;return(0,s.kt)(agp,(0,p.Z)({},igp,n,{components:e,mdxType:"MDXLayout"}))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function dgp(t){let{components:e,...n}=t;return(0,s.kt)(mgp,(0,p.Z)({},ugp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dgp.isMDXComponent=!0;const hgp={toc:[]},fgp="wrapper";function kgp(t){let{components:e,...n}=t;return(0,s.kt)(fgp,(0,p.Z)({},hgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kgp.isMDXComponent=!0;const ygp={toc:[]},Dgp="wrapper";function Mgp(t){let{components:e,...n}=t;return(0,s.kt)(Dgp,(0,p.Z)({},ygp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(t){let{components:e,...n}=t;return(0,s.kt)(_gp,(0,p.Z)({},Xgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},ggp="wrapper";function Cgp(t){let{components:e,...n}=t;return(0,s.kt)(ggp,(0,p.Z)({},Tgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cgp.isMDXComponent=!0;const xgp={toc:[]},vgp="wrapper";function Lgp(t){let{components:e,...n}=t;return(0,s.kt)(vgp,(0,p.Z)({},xgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lgp.isMDXComponent=!0;const Zgp={toc:[]},bgp="wrapper";function Ngp(t){let{components:e,...n}=t;return(0,s.kt)(bgp,(0,p.Z)({},Zgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ngp.isMDXComponent=!0;const Agp={toc:[]},zgp="wrapper";function Wgp(t){let{components:e,...n}=t;return(0,s.kt)(zgp,(0,p.Z)({},Agp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Wgp.isMDXComponent=!0;const Igp={toc:[]},Rgp="wrapper";function Sgp(t){let{components:e,...n}=t;return(0,s.kt)(Rgp,(0,p.Z)({},Igp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sgp.isMDXComponent=!0;const Pgp={toc:[]},Egp="wrapper";function Ogp(t){let{components:e,...n}=t;return(0,s.kt)(Egp,(0,p.Z)({},Pgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ogp.isMDXComponent=!0;const Ggp={toc:[]},Fgp="wrapper";function Bgp(t){let{components:e,...n}=t;return(0,s.kt)(Fgp,(0,p.Z)({},Ggp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bgp.isMDXComponent=!0;const Ugp={toc:[]},Vgp="wrapper";function qgp(t){let{components:e,...n}=t;return(0,s.kt)(Vgp,(0,p.Z)({},Ugp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qgp.isMDXComponent=!0;const jgp={toc:[]},Ygp="wrapper";function Hgp(t){let{components:e,...n}=t;return(0,s.kt)(Ygp,(0,p.Z)({},jgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hgp.isMDXComponent=!0;const Qgp={toc:[]},$gp="wrapper";function Jgp(t){let{components:e,...n}=t;return(0,s.kt)($gp,(0,p.Z)({},Qgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Jgp.isMDXComponent=!0;const Kgp={toc:[]},tCp="wrapper";function eCp(t){let{components:e,...n}=t;return(0,s.kt)(tCp,(0,p.Z)({},Kgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}eCp.isMDXComponent=!0;const nCp={toc:[]},oCp="wrapper";function pCp(t){let{components:e,...n}=t;return(0,s.kt)(oCp,(0,p.Z)({},nCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(t){let{components:e,...n}=t;return(0,s.kt)(sCp,(0,p.Z)({},rCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cCp.isMDXComponent=!0;const iCp={toc:[]},aCp="wrapper";function lCp(t){let{components:e,...n}=t;return(0,s.kt)(aCp,(0,p.Z)({},iCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function dCp(t){let{components:e,...n}=t;return(0,s.kt)(mCp,(0,p.Z)({},uCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dCp.isMDXComponent=!0;const hCp={toc:[]},fCp="wrapper";function kCp(t){let{components:e,...n}=t;return(0,s.kt)(fCp,(0,p.Z)({},hCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}kCp.isMDXComponent=!0;const yCp={toc:[]},DCp="wrapper";function MCp(t){let{components:e,...n}=t;return(0,s.kt)(DCp,(0,p.Z)({},yCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(t){let{components:e,...n}=t;return(0,s.kt)(_Cp,(0,p.Z)({},XCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wCp.isMDXComponent=!0;const TCp={toc:[]},gCp="wrapper";function CCp(t){let{components:e,...n}=t;return(0,s.kt)(gCp,(0,p.Z)({},TCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CCp.isMDXComponent=!0;const xCp={toc:[]},vCp="wrapper";function LCp(t){let{components:e,...n}=t;return(0,s.kt)(vCp,(0,p.Z)({},xCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LCp.isMDXComponent=!0;const ZCp={toc:[]},bCp="wrapper";function NCp(t){let{components:e,...n}=t;return(0,s.kt)(bCp,(0,p.Z)({},ZCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}NCp.isMDXComponent=!0;const ACp={toc:[]},zCp="wrapper";function WCp(t){let{components:e,...n}=t;return(0,s.kt)(zCp,(0,p.Z)({},ACp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}WCp.isMDXComponent=!0;const ICp={toc:[]},RCp="wrapper";function SCp(t){let{components:e,...n}=t;return(0,s.kt)(RCp,(0,p.Z)({},ICp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}SCp.isMDXComponent=!0;const PCp={toc:[]},ECp="wrapper";function OCp(t){let{components:e,...n}=t;return(0,s.kt)(ECp,(0,p.Z)({},PCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OCp.isMDXComponent=!0;const GCp={toc:[]},FCp="wrapper";function BCp(t){let{components:e,...n}=t;return(0,s.kt)(FCp,(0,p.Z)({},GCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BCp.isMDXComponent=!0;const UCp={toc:[]},VCp="wrapper";function qCp(t){let{components:e,...n}=t;return(0,s.kt)(VCp,(0,p.Z)({},UCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}qCp.isMDXComponent=!0;const jCp={toc:[]},YCp="wrapper";function HCp(t){let{components:e,...n}=t;return(0,s.kt)(YCp,(0,p.Z)({},jCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}HCp.isMDXComponent=!0;const QCp={toc:[]},$Cp="wrapper";function JCp(t){let{components:e,...n}=t;return(0,s.kt)($Cp,(0,p.Z)({},QCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}JCp.isMDXComponent=!0;const KCp={toc:[]},txp="wrapper";function exp(t){let{components:e,...n}=t;return(0,s.kt)(txp,(0,p.Z)({},KCp,n,{components:e,mdxType:"MDXLayout"}))}exp.isMDXComponent=!0;const nxp={toc:[]},oxp="wrapper";function pxp(t){let{components:e,...n}=t;return(0,s.kt)(oxp,(0,p.Z)({},nxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(t){let{components:e,...n}=t;return(0,s.kt)(sxp,(0,p.Z)({},rxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cxp.isMDXComponent=!0;const ixp={toc:[]},axp="wrapper";function lxp(t){let{components:e,...n}=t;return(0,s.kt)(axp,(0,p.Z)({},ixp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function dxp(t){let{components:e,...n}=t;return(0,s.kt)(mxp,(0,p.Z)({},uxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dxp.isMDXComponent=!0;const hxp={toc:[]},fxp="wrapper";function kxp(t){let{components:e,...n}=t;return(0,s.kt)(fxp,(0,p.Z)({},hxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kxp.isMDXComponent=!0;const yxp={toc:[]},Dxp="wrapper";function Mxp(t){let{components:e,...n}=t;return(0,s.kt)(Dxp,(0,p.Z)({},yxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(t){let{components:e,...n}=t;return(0,s.kt)(_xp,(0,p.Z)({},Xxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wxp.isMDXComponent=!0;const Txp={toc:[]},gxp="wrapper";function Cxp(t){let{components:e,...n}=t;return(0,s.kt)(gxp,(0,p.Z)({},Txp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cxp.isMDXComponent=!0;const xxp={toc:[]},vxp="wrapper";function Lxp(t){let{components:e,...n}=t;return(0,s.kt)(vxp,(0,p.Z)({},xxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lxp.isMDXComponent=!0;const Zxp={toc:[]},bxp="wrapper";function Nxp(t){let{components:e,...n}=t;return(0,s.kt)(bxp,(0,p.Z)({},Zxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nxp.isMDXComponent=!0;const Axp={toc:[]},zxp="wrapper";function Wxp(t){let{components:e,...n}=t;return(0,s.kt)(zxp,(0,p.Z)({},Axp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wxp.isMDXComponent=!0;const Ixp={toc:[]},Rxp="wrapper";function Sxp(t){let{components:e,...n}=t;return(0,s.kt)(Rxp,(0,p.Z)({},Ixp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sxp.isMDXComponent=!0;const Pxp={toc:[]},Exp="wrapper";function Oxp(t){let{components:e,...n}=t;return(0,s.kt)(Exp,(0,p.Z)({},Pxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oxp.isMDXComponent=!0;const Gxp={toc:[]},Fxp="wrapper";function Bxp(t){let{components:e,...n}=t;return(0,s.kt)(Fxp,(0,p.Z)({},Gxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bxp.isMDXComponent=!0;const Uxp={toc:[]},Vxp="wrapper";function qxp(t){let{components:e,...n}=t;return(0,s.kt)(Vxp,(0,p.Z)({},Uxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qxp.isMDXComponent=!0;const jxp={toc:[]},Yxp="wrapper";function Hxp(t){let{components:e,...n}=t;return(0,s.kt)(Yxp,(0,p.Z)({},jxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Hxp.isMDXComponent=!0;const Qxp={toc:[]},$xp="wrapper";function Jxp(t){let{components:e,...n}=t;return(0,s.kt)($xp,(0,p.Z)({},Qxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Jxp.isMDXComponent=!0;const Kxp={toc:[]},tvp="wrapper";function evp(t){let{components:e,...n}=t;return(0,s.kt)(tvp,(0,p.Z)({},Kxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}evp.isMDXComponent=!0;const nvp={toc:[]},ovp="wrapper";function pvp(t){let{components:e,...n}=t;return(0,s.kt)(ovp,(0,p.Z)({},nvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(t){let{components:e,...n}=t;return(0,s.kt)(svp,(0,p.Z)({},rvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cvp.isMDXComponent=!0;const ivp={toc:[]},avp="wrapper";function lvp(t){let{components:e,...n}=t;return(0,s.kt)(avp,(0,p.Z)({},ivp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function dvp(t){let{components:e,...n}=t;return(0,s.kt)(mvp,(0,p.Z)({},uvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dvp.isMDXComponent=!0;const hvp={toc:[]},fvp="wrapper";function kvp(t){let{components:e,...n}=t;return(0,s.kt)(fvp,(0,p.Z)({},hvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kvp.isMDXComponent=!0;const yvp={toc:[]},Dvp="wrapper";function Mvp(t){let{components:e,...n}=t;return(0,s.kt)(Dvp,(0,p.Z)({},yvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(t){let{components:e,...n}=t;return(0,s.kt)(_vp,(0,p.Z)({},Xvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},gvp="wrapper";function Cvp(t){let{components:e,...n}=t;return(0,s.kt)(gvp,(0,p.Z)({},Tvp,n,{components:e,mdxType:"MDXLayout"}))}Cvp.isMDXComponent=!0;const xvp={toc:[]},vvp="wrapper";function Lvp(t){let{components:e,...n}=t;return(0,s.kt)(vvp,(0,p.Z)({},xvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lvp.isMDXComponent=!0;const Zvp={toc:[]},bvp="wrapper";function Nvp(t){let{components:e,...n}=t;return(0,s.kt)(bvp,(0,p.Z)({},Zvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Nvp.isMDXComponent=!0;const Avp={toc:[]},zvp="wrapper";function Wvp(t){let{components:e,...n}=t;return(0,s.kt)(zvp,(0,p.Z)({},Avp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wvp.isMDXComponent=!0;const Ivp={toc:[]},Rvp="wrapper";function Svp(t){let{components:e,...n}=t;return(0,s.kt)(Rvp,(0,p.Z)({},Ivp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Svp.isMDXComponent=!0;const Pvp={toc:[]},Evp="wrapper";function Ovp(t){let{components:e,...n}=t;return(0,s.kt)(Evp,(0,p.Z)({},Pvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ovp.isMDXComponent=!0;const Gvp={toc:[]},Fvp="wrapper";function Bvp(t){let{components:e,...n}=t;return(0,s.kt)(Fvp,(0,p.Z)({},Gvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Bvp.isMDXComponent=!0;const Uvp={toc:[]},Vvp="wrapper";function qvp(t){let{components:e,...n}=t;return(0,s.kt)(Vvp,(0,p.Z)({},Uvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}qvp.isMDXComponent=!0;const jvp={toc:[]},Yvp="wrapper";function Hvp(t){let{components:e,...n}=t;return(0,s.kt)(Yvp,(0,p.Z)({},jvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Hvp.isMDXComponent=!0;const Qvp={toc:[]},$vp="wrapper";function Jvp(t){let{components:e,...n}=t;return(0,s.kt)($vp,(0,p.Z)({},Qvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Jvp.isMDXComponent=!0;const Kvp={toc:[]},tLp="wrapper";function eLp(t){let{components:e,...n}=t;return(0,s.kt)(tLp,(0,p.Z)({},Kvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}eLp.isMDXComponent=!0;const nLp={toc:[]},oLp="wrapper";function pLp(t){let{components:e,...n}=t;return(0,s.kt)(oLp,(0,p.Z)({},nLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(t){let{components:e,...n}=t;return(0,s.kt)(sLp,(0,p.Z)({},rLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cLp.isMDXComponent=!0;const iLp={toc:[]},aLp="wrapper";function lLp(t){let{components:e,...n}=t;return(0,s.kt)(aLp,(0,p.Z)({},iLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function dLp(t){let{components:e,...n}=t;return(0,s.kt)(mLp,(0,p.Z)({},uLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}dLp.isMDXComponent=!0;const hLp={toc:[]},fLp="wrapper";function kLp(t){let{components:e,...n}=t;return(0,s.kt)(fLp,(0,p.Z)({},hLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kLp.isMDXComponent=!0;const yLp={toc:[]},DLp="wrapper";function MLp(t){let{components:e,...n}=t;return(0,s.kt)(DLp,(0,p.Z)({},yLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(t){let{components:e,...n}=t;return(0,s.kt)(_Lp,(0,p.Z)({},XLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}wLp.isMDXComponent=!0;const TLp={toc:[]},gLp="wrapper";function CLp(t){let{components:e,...n}=t;return(0,s.kt)(gLp,(0,p.Z)({},TLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}CLp.isMDXComponent=!0;const xLp={toc:[]},vLp="wrapper";function LLp(t){let{components:e,...n}=t;return(0,s.kt)(vLp,(0,p.Z)({},xLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}LLp.isMDXComponent=!0;const ZLp={toc:[]},bLp="wrapper";function NLp(t){let{components:e,...n}=t;return(0,s.kt)(bLp,(0,p.Z)({},ZLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}NLp.isMDXComponent=!0;const ALp={toc:[]},zLp="wrapper";function WLp(t){let{components:e,...n}=t;return(0,s.kt)(zLp,(0,p.Z)({},ALp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WLp.isMDXComponent=!0;const ILp={toc:[]},RLp="wrapper";function SLp(t){let{components:e,...n}=t;return(0,s.kt)(RLp,(0,p.Z)({},ILp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}SLp.isMDXComponent=!0;const PLp={toc:[]},ELp="wrapper";function OLp(t){let{components:e,...n}=t;return(0,s.kt)(ELp,(0,p.Z)({},PLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}OLp.isMDXComponent=!0;const GLp={toc:[]},FLp="wrapper";function BLp(t){let{components:e,...n}=t;return(0,s.kt)(FLp,(0,p.Z)({},GLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}BLp.isMDXComponent=!0;const ULp={toc:[]},VLp="wrapper";function qLp(t){let{components:e,...n}=t;return(0,s.kt)(VLp,(0,p.Z)({},ULp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qLp.isMDXComponent=!0;const jLp={toc:[]},YLp="wrapper";function HLp(t){let{components:e,...n}=t;return(0,s.kt)(YLp,(0,p.Z)({},jLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}HLp.isMDXComponent=!0;const QLp={toc:[]},$Lp="wrapper";function JLp(t){let{components:e,...n}=t;return(0,s.kt)($Lp,(0,p.Z)({},QLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}JLp.isMDXComponent=!0;const KLp={toc:[]},tZp="wrapper";function eZp(t){let{components:e,...n}=t;return(0,s.kt)(tZp,(0,p.Z)({},KLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}eZp.isMDXComponent=!0;const nZp={toc:[]},oZp="wrapper";function pZp(t){let{components:e,...n}=t;return(0,s.kt)(oZp,(0,p.Z)({},nZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(t){let{components:e,...n}=t;return(0,s.kt)(sZp,(0,p.Z)({},rZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}cZp.isMDXComponent=!0;const iZp={toc:[]},aZp="wrapper";function lZp(t){let{components:e,...n}=t;return(0,s.kt)(aZp,(0,p.Z)({},iZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function dZp(t){let{components:e,...n}=t;return(0,s.kt)(mZp,(0,p.Z)({},uZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}dZp.isMDXComponent=!0;const hZp={toc:[]},fZp="wrapper";function kZp(t){let{components:e,...n}=t;return(0,s.kt)(fZp,(0,p.Z)({},hZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}kZp.isMDXComponent=!0;const yZp={toc:[]},DZp="wrapper";function MZp(t){let{components:e,...n}=t;return(0,s.kt)(DZp,(0,p.Z)({},yZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(t){let{components:e,...n}=t;return(0,s.kt)(_Zp,(0,p.Z)({},XZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wZp.isMDXComponent=!0;const TZp={toc:[]},gZp="wrapper";function CZp(t){let{components:e,...n}=t;return(0,s.kt)(gZp,(0,p.Z)({},TZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}CZp.isMDXComponent=!0;const xZp={toc:[]},vZp="wrapper";function LZp(t){let{components:e,...n}=t;return(0,s.kt)(vZp,(0,p.Z)({},xZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}LZp.isMDXComponent=!0;const ZZp={toc:[]},bZp="wrapper";function NZp(t){let{components:e,...n}=t;return(0,s.kt)(bZp,(0,p.Z)({},ZZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}NZp.isMDXComponent=!0;const AZp={toc:[]},zZp="wrapper";function WZp(t){let{components:e,...n}=t;return(0,s.kt)(zZp,(0,p.Z)({},AZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}WZp.isMDXComponent=!0;const IZp={toc:[]},RZp="wrapper";function SZp(t){let{components:e,...n}=t;return(0,s.kt)(RZp,(0,p.Z)({},IZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}SZp.isMDXComponent=!0;const PZp={toc:[]},EZp="wrapper";function OZp(t){let{components:e,...n}=t;return(0,s.kt)(EZp,(0,p.Z)({},PZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}OZp.isMDXComponent=!0;const GZp={toc:[]},FZp="wrapper";function BZp(t){let{components:e,...n}=t;return(0,s.kt)(FZp,(0,p.Z)({},GZp,n,{components:e,mdxType:"MDXLayout"}))}BZp.isMDXComponent=!0;const UZp={toc:[]},VZp="wrapper";function qZp(t){let{components:e,...n}=t;return(0,s.kt)(VZp,(0,p.Z)({},UZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}qZp.isMDXComponent=!0;const jZp={toc:[]},YZp="wrapper";function HZp(t){let{components:e,...n}=t;return(0,s.kt)(YZp,(0,p.Z)({},jZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}HZp.isMDXComponent=!0;const QZp={toc:[]},$Zp="wrapper";function JZp(t){let{components:e,...n}=t;return(0,s.kt)($Zp,(0,p.Z)({},QZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}JZp.isMDXComponent=!0;const KZp={toc:[]},tbp="wrapper";function ebp(t){let{components:e,...n}=t;return(0,s.kt)(tbp,(0,p.Z)({},KZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ebp.isMDXComponent=!0;const nbp={toc:[]},obp="wrapper";function pbp(t){let{components:e,...n}=t;return(0,s.kt)(obp,(0,p.Z)({},nbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(t){let{components:e,...n}=t;return(0,s.kt)(sbp,(0,p.Z)({},rbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cbp.isMDXComponent=!0;const ibp={toc:[]},abp="wrapper";function lbp(t){let{components:e,...n}=t;return(0,s.kt)(abp,(0,p.Z)({},ibp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function dbp(t){let{components:e,...n}=t;return(0,s.kt)(mbp,(0,p.Z)({},ubp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}dbp.isMDXComponent=!0;const hbp={toc:[]},fbp="wrapper";function kbp(t){let{components:e,...n}=t;return(0,s.kt)(fbp,(0,p.Z)({},hbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kbp.isMDXComponent=!0;const ybp={toc:[]},Dbp="wrapper";function Mbp(t){let{components:e,...n}=t;return(0,s.kt)(Dbp,(0,p.Z)({},ybp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(t){let{components:e,...n}=t;return(0,s.kt)(_bp,(0,p.Z)({},Xbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},gbp="wrapper";function Cbp(t){let{components:e,...n}=t;return(0,s.kt)(gbp,(0,p.Z)({},Tbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Cbp.isMDXComponent=!0;const xbp={toc:[]},vbp="wrapper";function Lbp(t){let{components:e,...n}=t;return(0,s.kt)(vbp,(0,p.Z)({},xbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lbp.isMDXComponent=!0;const Zbp={toc:[]},bbp="wrapper";function Nbp(t){let{components:e,...n}=t;return(0,s.kt)(bbp,(0,p.Z)({},Zbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Nbp.isMDXComponent=!0;const Abp={toc:[]},zbp="wrapper";function Wbp(t){let{components:e,...n}=t;return(0,s.kt)(zbp,(0,p.Z)({},Abp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wbp.isMDXComponent=!0;const Ibp={toc:[]},Rbp="wrapper";function Sbp(t){let{components:e,...n}=t;return(0,s.kt)(Rbp,(0,p.Z)({},Ibp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Sbp.isMDXComponent=!0;const Pbp={toc:[]},Ebp="wrapper";function Obp(t){let{components:e,...n}=t;return(0,s.kt)(Ebp,(0,p.Z)({},Pbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Obp.isMDXComponent=!0;const Gbp={toc:[]},Fbp="wrapper";function Bbp(t){let{components:e,...n}=t;return(0,s.kt)(Fbp,(0,p.Z)({},Gbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bbp.isMDXComponent=!0;const Ubp={toc:[]},Vbp="wrapper";function qbp(t){let{components:e,...n}=t;return(0,s.kt)(Vbp,(0,p.Z)({},Ubp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qbp.isMDXComponent=!0;const jbp={toc:[]},Ybp="wrapper";function Hbp(t){let{components:e,...n}=t;return(0,s.kt)(Ybp,(0,p.Z)({},jbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Hbp.isMDXComponent=!0;const Qbp={toc:[]},$bp="wrapper";function Jbp(t){let{components:e,...n}=t;return(0,s.kt)($bp,(0,p.Z)({},Qbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Jbp.isMDXComponent=!0;const Kbp={toc:[]},tNp="wrapper";function eNp(t){let{components:e,...n}=t;return(0,s.kt)(tNp,(0,p.Z)({},Kbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eNp.isMDXComponent=!0;const nNp={toc:[]},oNp="wrapper";function pNp(t){let{components:e,...n}=t;return(0,s.kt)(oNp,(0,p.Z)({},nNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(t){let{components:e,...n}=t;return(0,s.kt)(sNp,(0,p.Z)({},rNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}cNp.isMDXComponent=!0;const iNp={toc:[]},aNp="wrapper";function lNp(t){let{components:e,...n}=t;return(0,s.kt)(aNp,(0,p.Z)({},iNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function dNp(t){let{components:e,...n}=t;return(0,s.kt)(mNp,(0,p.Z)({},uNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}dNp.isMDXComponent=!0;const hNp={toc:[]},fNp="wrapper";function kNp(t){let{components:e,...n}=t;return(0,s.kt)(fNp,(0,p.Z)({},hNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kNp.isMDXComponent=!0;const yNp={toc:[]},DNp="wrapper";function MNp(t){let{components:e,...n}=t;return(0,s.kt)(DNp,(0,p.Z)({},yNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(t){let{components:e,...n}=t;return(0,s.kt)(_Np,(0,p.Z)({},XNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wNp.isMDXComponent=!0;const TNp={toc:[]},gNp="wrapper";function CNp(t){let{components:e,...n}=t;return(0,s.kt)(gNp,(0,p.Z)({},TNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}CNp.isMDXComponent=!0;const xNp={toc:[]},vNp="wrapper";function LNp(t){let{components:e,...n}=t;return(0,s.kt)(vNp,(0,p.Z)({},xNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LNp.isMDXComponent=!0;const ZNp={toc:[]},bNp="wrapper";function NNp(t){let{components:e,...n}=t;return(0,s.kt)(bNp,(0,p.Z)({},ZNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}NNp.isMDXComponent=!0;const ANp={toc:[]},zNp="wrapper";function WNp(t){let{components:e,...n}=t;return(0,s.kt)(zNp,(0,p.Z)({},ANp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WNp.isMDXComponent=!0;const INp={toc:[]},RNp="wrapper";function SNp(t){let{components:e,...n}=t;return(0,s.kt)(RNp,(0,p.Z)({},INp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}SNp.isMDXComponent=!0;const PNp={toc:[]},ENp="wrapper";function ONp(t){let{components:e,...n}=t;return(0,s.kt)(ENp,(0,p.Z)({},PNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}ONp.isMDXComponent=!0;const GNp={toc:[]},FNp="wrapper";function BNp(t){let{components:e,...n}=t;return(0,s.kt)(FNp,(0,p.Z)({},GNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BNp.isMDXComponent=!0;const UNp={toc:[]},VNp="wrapper";function qNp(t){let{components:e,...n}=t;return(0,s.kt)(VNp,(0,p.Z)({},UNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}qNp.isMDXComponent=!0;const jNp={toc:[]},YNp="wrapper";function HNp(t){let{components:e,...n}=t;return(0,s.kt)(YNp,(0,p.Z)({},jNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}HNp.isMDXComponent=!0;const QNp={toc:[]},$Np="wrapper";function JNp(t){let{components:e,...n}=t;return(0,s.kt)($Np,(0,p.Z)({},QNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}JNp.isMDXComponent=!0;const KNp={toc:[]},tAp="wrapper";function eAp(t){let{components:e,...n}=t;return(0,s.kt)(tAp,(0,p.Z)({},KNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}eAp.isMDXComponent=!0;const nAp={toc:[]},oAp="wrapper";function pAp(t){let{components:e,...n}=t;return(0,s.kt)(oAp,(0,p.Z)({},nAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(t){let{components:e,...n}=t;return(0,s.kt)(sAp,(0,p.Z)({},rAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}cAp.isMDXComponent=!0;const iAp={toc:[]},aAp="wrapper";function lAp(t){let{components:e,...n}=t;return(0,s.kt)(aAp,(0,p.Z)({},iAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function dAp(t){let{components:e,...n}=t;return(0,s.kt)(mAp,(0,p.Z)({},uAp,n,{components:e,mdxType:"MDXLayout"}))}dAp.isMDXComponent=!0;const hAp={toc:[]},fAp="wrapper";function kAp(t){let{components:e,...n}=t;return(0,s.kt)(fAp,(0,p.Z)({},hAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kAp.isMDXComponent=!0;const yAp={toc:[]},DAp="wrapper";function MAp(t){let{components:e,...n}=t;return(0,s.kt)(DAp,(0,p.Z)({},yAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(t){let{components:e,...n}=t;return(0,s.kt)(_Ap,(0,p.Z)({},XAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wAp.isMDXComponent=!0;const TAp={toc:[]},gAp="wrapper";function CAp(t){let{components:e,...n}=t;return(0,s.kt)(gAp,(0,p.Z)({},TAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}CAp.isMDXComponent=!0;const xAp={toc:[]},vAp="wrapper";function LAp(t){let{components:e,...n}=t;return(0,s.kt)(vAp,(0,p.Z)({},xAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LAp.isMDXComponent=!0;const ZAp={toc:[]},bAp="wrapper";function NAp(t){let{components:e,...n}=t;return(0,s.kt)(bAp,(0,p.Z)({},ZAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}NAp.isMDXComponent=!0;const AAp={toc:[]},zAp="wrapper";function WAp(t){let{components:e,...n}=t;return(0,s.kt)(zAp,(0,p.Z)({},AAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WAp.isMDXComponent=!0;const IAp={toc:[]},RAp="wrapper";function SAp(t){let{components:e,...n}=t;return(0,s.kt)(RAp,(0,p.Z)({},IAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SAp.isMDXComponent=!0;const PAp={toc:[]},EAp="wrapper";function OAp(t){let{components:e,...n}=t;return(0,s.kt)(EAp,(0,p.Z)({},PAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OAp.isMDXComponent=!0;const GAp={toc:[]},FAp="wrapper";function BAp(t){let{components:e,...n}=t;return(0,s.kt)(FAp,(0,p.Z)({},GAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BAp.isMDXComponent=!0;const UAp={toc:[]},VAp="wrapper";function qAp(t){let{components:e,...n}=t;return(0,s.kt)(VAp,(0,p.Z)({},UAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qAp.isMDXComponent=!0;const jAp={toc:[]},YAp="wrapper";function HAp(t){let{components:e,...n}=t;return(0,s.kt)(YAp,(0,p.Z)({},jAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HAp.isMDXComponent=!0;const QAp={toc:[]},$Ap="wrapper";function JAp(t){let{components:e,...n}=t;return(0,s.kt)($Ap,(0,p.Z)({},QAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}JAp.isMDXComponent=!0;const KAp={toc:[]},tzp="wrapper";function ezp(t){let{components:e,...n}=t;return(0,s.kt)(tzp,(0,p.Z)({},KAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}ezp.isMDXComponent=!0;const nzp={toc:[]},ozp="wrapper";function pzp(t){let{components:e,...n}=t;return(0,s.kt)(ozp,(0,p.Z)({},nzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(t){let{components:e,...n}=t;return(0,s.kt)(szp,(0,p.Z)({},rzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}czp.isMDXComponent=!0;const izp={toc:[]},azp="wrapper";function lzp(t){let{components:e,...n}=t;return(0,s.kt)(azp,(0,p.Z)({},izp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function dzp(t){let{components:e,...n}=t;return(0,s.kt)(mzp,(0,p.Z)({},uzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}dzp.isMDXComponent=!0;const hzp={toc:[]},fzp="wrapper";function kzp(t){let{components:e,...n}=t;return(0,s.kt)(fzp,(0,p.Z)({},hzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}kzp.isMDXComponent=!0;const yzp={toc:[]},Dzp="wrapper";function Mzp(t){let{components:e,...n}=t;return(0,s.kt)(Dzp,(0,p.Z)({},yzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(t){let{components:e,...n}=t;return(0,s.kt)(_zp,(0,p.Z)({},Xzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}wzp.isMDXComponent=!0;const Tzp={toc:[]},gzp="wrapper";function Czp(t){let{components:e,...n}=t;return(0,s.kt)(gzp,(0,p.Z)({},Tzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Czp.isMDXComponent=!0;const xzp={toc:[]},vzp="wrapper";function Lzp(t){let{components:e,...n}=t;return(0,s.kt)(vzp,(0,p.Z)({},xzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Lzp.isMDXComponent=!0;const Zzp={toc:[]},bzp="wrapper";function Nzp(t){let{components:e,...n}=t;return(0,s.kt)(bzp,(0,p.Z)({},Zzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Nzp.isMDXComponent=!0;const Azp={toc:[]},zzp="wrapper";function Wzp(t){let{components:e,...n}=t;return(0,s.kt)(zzp,(0,p.Z)({},Azp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Wzp.isMDXComponent=!0;const Izp={toc:[]},Rzp="wrapper";function Szp(t){let{components:e,...n}=t;return(0,s.kt)(Rzp,(0,p.Z)({},Izp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Szp.isMDXComponent=!0;const Pzp={toc:[]},Ezp="wrapper";function Ozp(t){let{components:e,...n}=t;return(0,s.kt)(Ezp,(0,p.Z)({},Pzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Ozp.isMDXComponent=!0;const Gzp={toc:[]},Fzp="wrapper";function Bzp(t){let{components:e,...n}=t;return(0,s.kt)(Fzp,(0,p.Z)({},Gzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Bzp.isMDXComponent=!0;const Uzp={toc:[]},Vzp="wrapper";function qzp(t){let{components:e,...n}=t;return(0,s.kt)(Vzp,(0,p.Z)({},Uzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}qzp.isMDXComponent=!0;const jzp={toc:[]},Yzp="wrapper";function Hzp(t){let{components:e,...n}=t;return(0,s.kt)(Yzp,(0,p.Z)({},jzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}Hzp.isMDXComponent=!0;const Qzp={toc:[]},$zp="wrapper";function Jzp(t){let{components:e,...n}=t;return(0,s.kt)($zp,(0,p.Z)({},Qzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}Jzp.isMDXComponent=!0;const Kzp={toc:[]},tWp="wrapper";function eWp(t){let{components:e,...n}=t;return(0,s.kt)(tWp,(0,p.Z)({},Kzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}eWp.isMDXComponent=!0;const nWp={toc:[]},oWp="wrapper";function pWp(t){let{components:e,...n}=t;return(0,s.kt)(oWp,(0,p.Z)({},nWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(t){let{components:e,...n}=t;return(0,s.kt)(sWp,(0,p.Z)({},rWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}cWp.isMDXComponent=!0;const iWp={toc:[]},aWp="wrapper";function lWp(t){let{components:e,...n}=t;return(0,s.kt)(aWp,(0,p.Z)({},iWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function dWp(t){let{components:e,...n}=t;return(0,s.kt)(mWp,(0,p.Z)({},uWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}dWp.isMDXComponent=!0;const hWp={toc:[]},fWp="wrapper";function kWp(t){let{components:e,...n}=t;return(0,s.kt)(fWp,(0,p.Z)({},hWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}kWp.isMDXComponent=!0;const yWp={toc:[]},DWp="wrapper";function MWp(t){let{components:e,...n}=t;return(0,s.kt)(DWp,(0,p.Z)({},yWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(t){let{components:e,...n}=t;return(0,s.kt)(_Wp,(0,p.Z)({},XWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}wWp.isMDXComponent=!0;const TWp={toc:[]},gWp="wrapper";function CWp(t){let{components:e,...n}=t;return(0,s.kt)(gWp,(0,p.Z)({},TWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}CWp.isMDXComponent=!0;const xWp={toc:[]},vWp="wrapper";function LWp(t){let{components:e,...n}=t;return(0,s.kt)(vWp,(0,p.Z)({},xWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}LWp.isMDXComponent=!0;const ZWp={toc:[]},bWp="wrapper";function NWp(t){let{components:e,...n}=t;return(0,s.kt)(bWp,(0,p.Z)({},ZWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}NWp.isMDXComponent=!0;const AWp={toc:[]},zWp="wrapper";function WWp(t){let{components:e,...n}=t;return(0,s.kt)(zWp,(0,p.Z)({},AWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}WWp.isMDXComponent=!0;const IWp={toc:[]},RWp="wrapper";function SWp(t){let{components:e,...n}=t;return(0,s.kt)(RWp,(0,p.Z)({},IWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}SWp.isMDXComponent=!0;const PWp={toc:[]},EWp="wrapper";function OWp(t){let{components:e,...n}=t;return(0,s.kt)(EWp,(0,p.Z)({},PWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}OWp.isMDXComponent=!0;const GWp={toc:[]},FWp="wrapper";function BWp(t){let{components:e,...n}=t;return(0,s.kt)(FWp,(0,p.Z)({},GWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}BWp.isMDXComponent=!0;const UWp={toc:[]},VWp="wrapper";function qWp(t){let{components:e,...n}=t;return(0,s.kt)(VWp,(0,p.Z)({},UWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}qWp.isMDXComponent=!0;const jWp={toc:[]},YWp="wrapper";function HWp(t){let{components:e,...n}=t;return(0,s.kt)(YWp,(0,p.Z)({},jWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}HWp.isMDXComponent=!0;const QWp={toc:[]},$Wp="wrapper";function JWp(t){let{components:e,...n}=t;return(0,s.kt)($Wp,(0,p.Z)({},QWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}JWp.isMDXComponent=!0;const KWp={toc:[]},tIp="wrapper";function eIp(t){let{components:e,...n}=t;return(0,s.kt)(tIp,(0,p.Z)({},KWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}eIp.isMDXComponent=!0;const nIp={toc:[]},oIp="wrapper";function pIp(t){let{components:e,...n}=t;return(0,s.kt)(oIp,(0,p.Z)({},nIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(t){let{components:e,...n}=t;return(0,s.kt)(sIp,(0,p.Z)({},rIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}cIp.isMDXComponent=!0;const iIp={toc:[]},aIp="wrapper";function lIp(t){let{components:e,...n}=t;return(0,s.kt)(aIp,(0,p.Z)({},iIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function dIp(t){let{components:e,...n}=t;return(0,s.kt)(mIp,(0,p.Z)({},uIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}dIp.isMDXComponent=!0;const hIp={toc:[]},fIp="wrapper";function kIp(t){let{components:e,...n}=t;return(0,s.kt)(fIp,(0,p.Z)({},hIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}kIp.isMDXComponent=!0;const yIp={toc:[]},DIp="wrapper";function MIp(t){let{components:e,...n}=t;return(0,s.kt)(DIp,(0,p.Z)({},yIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(t){let{components:e,...n}=t;return(0,s.kt)(_Ip,(0,p.Z)({},XIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}wIp.isMDXComponent=!0;const TIp={toc:[]},gIp="wrapper";function CIp(t){let{components:e,...n}=t;return(0,s.kt)(gIp,(0,p.Z)({},TIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}CIp.isMDXComponent=!0;const xIp={toc:[]},vIp="wrapper";function LIp(t){let{components:e,...n}=t;return(0,s.kt)(vIp,(0,p.Z)({},xIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}LIp.isMDXComponent=!0;const ZIp={toc:[]},bIp="wrapper";function NIp(t){let{components:e,...n}=t;return(0,s.kt)(bIp,(0,p.Z)({},ZIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}NIp.isMDXComponent=!0;const AIp={toc:[]},zIp="wrapper";function WIp(t){let{components:e,...n}=t;return(0,s.kt)(zIp,(0,p.Z)({},AIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}WIp.isMDXComponent=!0;const IIp={toc:[]},RIp="wrapper";function SIp(t){let{components:e,...n}=t;return(0,s.kt)(RIp,(0,p.Z)({},IIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}SIp.isMDXComponent=!0;const PIp={toc:[]},EIp="wrapper";function OIp(t){let{components:e,...n}=t;return(0,s.kt)(EIp,(0,p.Z)({},PIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}OIp.isMDXComponent=!0;const GIp={toc:[]},FIp="wrapper";function BIp(t){let{components:e,...n}=t;return(0,s.kt)(FIp,(0,p.Z)({},GIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}BIp.isMDXComponent=!0;const UIp={toc:[]},VIp="wrapper";function qIp(t){let{components:e,...n}=t;return(0,s.kt)(VIp,(0,p.Z)({},UIp,n,{components:e,mdxType:"MDXLayout"}))}qIp.isMDXComponent=!0;const jIp={toc:[]},YIp="wrapper";function HIp(t){let{components:e,...n}=t;return(0,s.kt)(YIp,(0,p.Z)({},jIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}HIp.isMDXComponent=!0;const QIp={toc:[]},$Ip="wrapper";function JIp(t){let{components:e,...n}=t;return(0,s.kt)($Ip,(0,p.Z)({},QIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}JIp.isMDXComponent=!0;const KIp={toc:[]},tRp="wrapper";function eRp(t){let{components:e,...n}=t;return(0,s.kt)(tRp,(0,p.Z)({},KIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}eRp.isMDXComponent=!0;const nRp={toc:[]},oRp="wrapper";function pRp(t){let{components:e,...n}=t;return(0,s.kt)(oRp,(0,p.Z)({},nRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(t){let{components:e,...n}=t;return(0,s.kt)(sRp,(0,p.Z)({},rRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}cRp.isMDXComponent=!0;const iRp={toc:[]},aRp="wrapper";function lRp(t){let{components:e,...n}=t;return(0,s.kt)(aRp,(0,p.Z)({},iRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function dRp(t){let{components:e,...n}=t;return(0,s.kt)(mRp,(0,p.Z)({},uRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}dRp.isMDXComponent=!0;const hRp={toc:[]},fRp="wrapper";function kRp(t){let{components:e,...n}=t;return(0,s.kt)(fRp,(0,p.Z)({},hRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}kRp.isMDXComponent=!0;const yRp={toc:[]},DRp="wrapper";function MRp(t){let{components:e,...n}=t;return(0,s.kt)(DRp,(0,p.Z)({},yRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(t){let{components:e,...n}=t;return(0,s.kt)(_Rp,(0,p.Z)({},XRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}wRp.isMDXComponent=!0;const TRp={toc:[]},gRp="wrapper";function CRp(t){let{components:e,...n}=t;return(0,s.kt)(gRp,(0,p.Z)({},TRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}CRp.isMDXComponent=!0;const xRp={toc:[]},vRp="wrapper";function LRp(t){let{components:e,...n}=t;return(0,s.kt)(vRp,(0,p.Z)({},xRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}LRp.isMDXComponent=!0;const ZRp={toc:[]},bRp="wrapper";function NRp(t){let{components:e,...n}=t;return(0,s.kt)(bRp,(0,p.Z)({},ZRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}NRp.isMDXComponent=!0;const ARp={toc:[]},zRp="wrapper";function WRp(t){let{components:e,...n}=t;return(0,s.kt)(zRp,(0,p.Z)({},ARp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WRp.isMDXComponent=!0;const IRp={toc:[]},RRp="wrapper";function SRp(t){let{components:e,...n}=t;return(0,s.kt)(RRp,(0,p.Z)({},IRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}SRp.isMDXComponent=!0;const PRp={toc:[]},ERp="wrapper";function ORp(t){let{components:e,...n}=t;return(0,s.kt)(ERp,(0,p.Z)({},PRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}ORp.isMDXComponent=!0;const GRp={toc:[]},FRp="wrapper";function BRp(t){let{components:e,...n}=t;return(0,s.kt)(FRp,(0,p.Z)({},GRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BRp.isMDXComponent=!0;const URp={toc:[]},VRp="wrapper";function qRp(t){let{components:e,...n}=t;return(0,s.kt)(VRp,(0,p.Z)({},URp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}qRp.isMDXComponent=!0;const jRp={toc:[]},YRp="wrapper";function HRp(t){let{components:e,...n}=t;return(0,s.kt)(YRp,(0,p.Z)({},jRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}HRp.isMDXComponent=!0;const QRp={toc:[]},$Rp="wrapper";function JRp(t){let{components:e,...n}=t;return(0,s.kt)($Rp,(0,p.Z)({},QRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}JRp.isMDXComponent=!0;const KRp={toc:[]},tSp="wrapper";function eSp(t){let{components:e,...n}=t;return(0,s.kt)(tSp,(0,p.Z)({},KRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}eSp.isMDXComponent=!0;const nSp={toc:[]},oSp="wrapper";function pSp(t){let{components:e,...n}=t;return(0,s.kt)(oSp,(0,p.Z)({},nSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(t){let{components:e,...n}=t;return(0,s.kt)(sSp,(0,p.Z)({},rSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}cSp.isMDXComponent=!0;const iSp={toc:[]},aSp="wrapper";function lSp(t){let{components:e,...n}=t;return(0,s.kt)(aSp,(0,p.Z)({},iSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function dSp(t){let{components:e,...n}=t;return(0,s.kt)(mSp,(0,p.Z)({},uSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}dSp.isMDXComponent=!0;const hSp={toc:[]},fSp="wrapper";function kSp(t){let{components:e,...n}=t;return(0,s.kt)(fSp,(0,p.Z)({},hSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}kSp.isMDXComponent=!0;const ySp={toc:[]},DSp="wrapper";function MSp(t){let{components:e,...n}=t;return(0,s.kt)(DSp,(0,p.Z)({},ySp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(t){let{components:e,...n}=t;return(0,s.kt)(_Sp,(0,p.Z)({},XSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}wSp.isMDXComponent=!0;const TSp={toc:[]},gSp="wrapper";function CSp(t){let{components:e,...n}=t;return(0,s.kt)(gSp,(0,p.Z)({},TSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}CSp.isMDXComponent=!0;const xSp={toc:[]},vSp="wrapper";function LSp(t){let{components:e,...n}=t;return(0,s.kt)(vSp,(0,p.Z)({},xSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}LSp.isMDXComponent=!0;const ZSp={toc:[]},bSp="wrapper";function NSp(t){let{components:e,...n}=t;return(0,s.kt)(bSp,(0,p.Z)({},ZSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}NSp.isMDXComponent=!0;const ASp={toc:[]},zSp="wrapper";function WSp(t){let{components:e,...n}=t;return(0,s.kt)(zSp,(0,p.Z)({},ASp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}WSp.isMDXComponent=!0;const ISp={toc:[]},RSp="wrapper";function SSp(t){let{components:e,...n}=t;return(0,s.kt)(RSp,(0,p.Z)({},ISp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}SSp.isMDXComponent=!0;const PSp={toc:[]},ESp="wrapper";function OSp(t){let{components:e,...n}=t;return(0,s.kt)(ESp,(0,p.Z)({},PSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}OSp.isMDXComponent=!0;const GSp={toc:[]},FSp="wrapper";function BSp(t){let{components:e,...n}=t;return(0,s.kt)(FSp,(0,p.Z)({},GSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BSp.isMDXComponent=!0;const USp={toc:[]},VSp="wrapper";function qSp(t){let{components:e,...n}=t;return(0,s.kt)(VSp,(0,p.Z)({},USp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}qSp.isMDXComponent=!0;const jSp={toc:[]},YSp="wrapper";function HSp(t){let{components:e,...n}=t;return(0,s.kt)(YSp,(0,p.Z)({},jSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}HSp.isMDXComponent=!0;const QSp={toc:[]},$Sp="wrapper";function JSp(t){let{components:e,...n}=t;return(0,s.kt)($Sp,(0,p.Z)({},QSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}JSp.isMDXComponent=!0;const KSp={toc:[]},tPp="wrapper";function ePp(t){let{components:e,...n}=t;return(0,s.kt)(tPp,(0,p.Z)({},KSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ePp.isMDXComponent=!0;const nPp={toc:[]},oPp="wrapper";function pPp(t){let{components:e,...n}=t;return(0,s.kt)(oPp,(0,p.Z)({},nPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(t){let{components:e,...n}=t;return(0,s.kt)(sPp,(0,p.Z)({},rPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}cPp.isMDXComponent=!0;const iPp={toc:[]},aPp="wrapper";function lPp(t){let{components:e,...n}=t;return(0,s.kt)(aPp,(0,p.Z)({},iPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function dPp(t){let{components:e,...n}=t;return(0,s.kt)(mPp,(0,p.Z)({},uPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}dPp.isMDXComponent=!0;const hPp={toc:[]},fPp="wrapper";function kPp(t){let{components:e,...n}=t;return(0,s.kt)(fPp,(0,p.Z)({},hPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}kPp.isMDXComponent=!0;const yPp={toc:[]},DPp="wrapper";function MPp(t){let{components:e,...n}=t;return(0,s.kt)(DPp,(0,p.Z)({},yPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(t){let{components:e,...n}=t;return(0,s.kt)(_Pp,(0,p.Z)({},XPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wPp.isMDXComponent=!0;const TPp={toc:[]},gPp="wrapper";function CPp(t){let{components:e,...n}=t;return(0,s.kt)(gPp,(0,p.Z)({},TPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}CPp.isMDXComponent=!0;const xPp={toc:[]},vPp="wrapper";function LPp(t){let{components:e,...n}=t;return(0,s.kt)(vPp,(0,p.Z)({},xPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}LPp.isMDXComponent=!0;const ZPp={toc:[]},bPp="wrapper";function NPp(t){let{components:e,...n}=t;return(0,s.kt)(bPp,(0,p.Z)({},ZPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}NPp.isMDXComponent=!0;const APp={toc:[]},zPp="wrapper";function WPp(t){let{components:e,...n}=t;return(0,s.kt)(zPp,(0,p.Z)({},APp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}WPp.isMDXComponent=!0;const IPp={toc:[]},RPp="wrapper";function SPp(t){let{components:e,...n}=t;return(0,s.kt)(RPp,(0,p.Z)({},IPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}SPp.isMDXComponent=!0;const PPp={toc:[]},EPp="wrapper";function OPp(t){let{components:e,...n}=t;return(0,s.kt)(EPp,(0,p.Z)({},PPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}OPp.isMDXComponent=!0;const GPp={toc:[]},FPp="wrapper";function BPp(t){let{components:e,...n}=t;return(0,s.kt)(FPp,(0,p.Z)({},GPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}BPp.isMDXComponent=!0;const UPp={toc:[]},VPp="wrapper";function qPp(t){let{components:e,...n}=t;return(0,s.kt)(VPp,(0,p.Z)({},UPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}qPp.isMDXComponent=!0;const jPp={toc:[]},YPp="wrapper";function HPp(t){let{components:e,...n}=t;return(0,s.kt)(YPp,(0,p.Z)({},jPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}HPp.isMDXComponent=!0;const QPp={toc:[]},$Pp="wrapper";function JPp(t){let{components:e,...n}=t;return(0,s.kt)($Pp,(0,p.Z)({},QPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}JPp.isMDXComponent=!0;const KPp={toc:[]},tEp="wrapper";function eEp(t){let{components:e,...n}=t;return(0,s.kt)(tEp,(0,p.Z)({},KPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}eEp.isMDXComponent=!0;const nEp={toc:[]},oEp="wrapper";function pEp(t){let{components:e,...n}=t;return(0,s.kt)(oEp,(0,p.Z)({},nEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(t){let{components:e,...n}=t;return(0,s.kt)(sEp,(0,p.Z)({},rEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}cEp.isMDXComponent=!0;const iEp={toc:[]},aEp="wrapper";function lEp(t){let{components:e,...n}=t;return(0,s.kt)(aEp,(0,p.Z)({},iEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function dEp(t){let{components:e,...n}=t;return(0,s.kt)(mEp,(0,p.Z)({},uEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}dEp.isMDXComponent=!0;const hEp={toc:[]},fEp="wrapper";function kEp(t){let{components:e,...n}=t;return(0,s.kt)(fEp,(0,p.Z)({},hEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}kEp.isMDXComponent=!0;const yEp={toc:[]},DEp="wrapper";function MEp(t){let{components:e,...n}=t;return(0,s.kt)(DEp,(0,p.Z)({},yEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(t){let{components:e,...n}=t;return(0,s.kt)(_Ep,(0,p.Z)({},XEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}wEp.isMDXComponent=!0;const TEp={toc:[]},gEp="wrapper";function CEp(t){let{components:e,...n}=t;return(0,s.kt)(gEp,(0,p.Z)({},TEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}CEp.isMDXComponent=!0;const xEp={toc:[]},vEp="wrapper";function LEp(t){let{components:e,...n}=t;return(0,s.kt)(vEp,(0,p.Z)({},xEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}LEp.isMDXComponent=!0;const ZEp={toc:[]},bEp="wrapper";function NEp(t){let{components:e,...n}=t;return(0,s.kt)(bEp,(0,p.Z)({},ZEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}NEp.isMDXComponent=!0;const AEp={toc:[]},zEp="wrapper";function WEp(t){let{components:e,...n}=t;return(0,s.kt)(zEp,(0,p.Z)({},AEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}WEp.isMDXComponent=!0;const IEp={toc:[]},REp="wrapper";function SEp(t){let{components:e,...n}=t;return(0,s.kt)(REp,(0,p.Z)({},IEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}SEp.isMDXComponent=!0;const PEp={toc:[]},EEp="wrapper";function OEp(t){let{components:e,...n}=t;return(0,s.kt)(EEp,(0,p.Z)({},PEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}OEp.isMDXComponent=!0;const GEp={toc:[]},FEp="wrapper";function BEp(t){let{components:e,...n}=t;return(0,s.kt)(FEp,(0,p.Z)({},GEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}BEp.isMDXComponent=!0;const UEp={toc:[]},VEp="wrapper";function qEp(t){let{components:e,...n}=t;return(0,s.kt)(VEp,(0,p.Z)({},UEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}qEp.isMDXComponent=!0;const jEp={toc:[]},YEp="wrapper";function HEp(t){let{components:e,...n}=t;return(0,s.kt)(YEp,(0,p.Z)({},jEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}HEp.isMDXComponent=!0;const QEp={toc:[]},$Ep="wrapper";function JEp(t){let{components:e,...n}=t;return(0,s.kt)($Ep,(0,p.Z)({},QEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}JEp.isMDXComponent=!0;const KEp={toc:[]},tOp="wrapper";function eOp(t){let{components:e,...n}=t;return(0,s.kt)(tOp,(0,p.Z)({},KEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}eOp.isMDXComponent=!0;const nOp={toc:[]},oOp="wrapper";function pOp(t){let{components:e,...n}=t;return(0,s.kt)(oOp,(0,p.Z)({},nOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(t){let{components:e,...n}=t;return(0,s.kt)(sOp,(0,p.Z)({},rOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class to check against."))}function iOp(t){let{id:e}=t;const n=o[e]??r.Fragment;return r.createElement(n,null)}cOp.isMDXComponent=!0},9322:(t,e,n)=>{"use strict";n.d(e,{Z:()=>a});var o=n(8698),p=n(4237),r=n(8770),s=n(6277),c=n(2784);const i={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function a(t){let{comment:e,full:n=!0}=t;const o=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@remarks"===e}))),[e]);return c.createElement(c.Fragment,null,n&&c.createElement(l,{comment:e}),c.createElement(p.Z,{id:e?.summaryId}),c.createElement(p.Z,{id:o?.contentId}),n&&c.createElement(u,{comment:e}))}function l(t){let{comment:e}=t;return(0,c.useMemo)((()=>e?.modifierTags?.includes("@experimental")),[e])?c.createElement(r.Z,null):null}function u(t){let{comment:e}=t;const[n,r]=(0,c.useState)(!0),a=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@preview"===e}))),[e]),l=(0,c.useMemo)((()=>e?.blockTags?.filter((t=>{let{tag:e}=t;return"@example"===e}))??[]),[e]),u=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))),[e]),m=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@deprecated"===e}))),[e]),d=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@see"===e}))),[e]);return c.createElement(c.Fragment,null,c.createElement(p.Z,{id:a?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.Z)(i.toggle,n&&i.collapsed),onClick:t=>{t.preventDefault(),r(!n)},href:"#"},"Examples")),c.createElement(o.z,{lazy:!0,as:"div",collapsed:n},c.createElement("div",{className:i.collapse},l.map((t=>c.createElement(p.Z,{key:t.contentId,id:t.contentId})))),c.createElement("div",{className:i.clearFix})),c.createElement("div",{className:(0,s.Z)(i.clearFix,i.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((t=>t.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.Z,{id:m.contentId})),d&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.Z,{id:d.contentId})))}},2830:(t,e,n)=>{"use strict";n.d(e,{Z:()=>wt});var o=n(8569),p=n(6835),r=n(7896),s=n(2784);function c(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var a=n(68),l=n(6277);function u(t){let{children:e,highlight:n,onClick:r,link:u}=t;const m=(0,p.F)(),d=(0,a.s2)();return s.createElement("div",{className:(0,l.Z)(o.Z.codeBlockContent,i.codeBlock,n&&i.highlight,r&&i.pointer)},s.createElement("pre",{onClick:r,onKeyDown:t=>{"Enter"===t.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.Z)(o.Z.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.Z.codeBlockLines,style:d},e)),u&&s.createElement("div",{className:o.Z.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=n(9318);function d(t){let{children:e}=t;return s.createElement(m.Z,{as:"div",className:(0,l.Z)(i.codeBlockContainer,"language-typescript")},e)}function h(t){let{children:e}=t;const n=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${i.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(i.wrap)}})),s.createElement(s.Fragment,null,e&&s.createElement("span",{ref:n,className:(0,l.Z)(i.line,"token-line")},e),s.createElement("br",null))}var f=n(9322),k=n(7390);function y(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=n(7708);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const t=(0,s.useRef)(null),[e,n]=(0,s.useState)(!1),[o,p]=(0,D.mN)();return(0,s.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),s.createElement(s.Fragment,null,s.createElement("div",{ref:t,className:(0,l.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",s.createElement(y,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.Z)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:t=>{p({...o,private:t.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.Z)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:t=>{p({...o,inherited:t.target.checked})}}),"Inherited members")))))}function _(t){let{children:e,kind:n}=t;return n===k.W.Class||n===k.W.Interface?s.createElement("div",{className:(0,l.Z)("row",M.header)},s.createElement("div",{className:(0,l.Z)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},e)):s.createElement(s.Fragment,null,e)}var w=n(3181),T=n(9817);function g(t){let{children:e,type:n,to:o,id:p,tooltip:c}=t;const i=(0,a.Ld)(n);return o?s.createElement(T.Z,(0,r.Z)({id:p,to:o,"data-tooltip":c},i),e):s.createElement("span",(0,r.Z)({id:p},i),e)}let C=function(t){return t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses",t}({}),x=function(t){return t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & ",t}({});const v={[C.None]:i.none,[C.Angle]:i.angle,[C.Curly]:i.curly,[C.Square]:i.square,[C.Parentheses]:i.parentheses};function L(t){let{children:e,type:n,separator:o=x.Comma}=t;return s.createElement("span",{className:(0,l.Z)(i.list,v[n??C.None])},s.createElement("span",{className:(0,l.Z)(i.elements,o!==x.Comma&&i.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>s.createElement("span",{"data-separator":o,key:e,className:i.element},t)))))}function Z(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.elementType}),"[]")}function b(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.checkType}),s.createElement(g,{type:"keyword"}," extends "),s.createElement(ot,{type:e.extendsType})," ? ",s.createElement(ot,{type:e.trueType})," : ",s.createElement(ot,{type:e.falseType}))}function N(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.objectType}),"[",s.createElement(ot,{type:e.indexType}),"]")}function A(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"infer "),s.createElement(g,{type:"constant"},e.name))}function z(t){let{type:e}=t;return s.createElement(L,{type:C.Parentheses,separator:x.Ampersand},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function W(t){let{type:e}=t;return s.createElement(g,{type:"keyword"},e.name)}function I(t){let{type:e}=t;const[n,o]=(0,s.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return s.createElement(g,{type:o},n)}function R(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(L,{type:C.Curly},s.createElement(s.Fragment,null,"[",s.createElement(g,{type:"class"},e.parameter),s.createElement(g,{type:"keyword"}," in "),s.createElement(ot,{type:e.parameterType}),"]: ",s.createElement(ot,{type:e.templateType}))))}function S(t){let{type:e}=t;return s.createElement(s.Fragment,null,e.name,": ",s.createElement(ot,{type:e.element}))}function P(t){let{type:e}=t;return e.asserts?s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"asserts "),s.createElement(g,null,e.name," ")):s.createElement(s.Fragment,null,s.createElement(g,null,e.name," "),s.createElement(g,{type:"keyword"},"is "),s.createElement(ot,{type:e.targetType}))}function E(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"typeof "),s.createElement(ot,{type:e.queryType}))}function O(t){let{flags:e,explicitAccessModifier:n}=t;const o=[];return e?.isAbstract&&o.push("abstract"),e?.isStatic&&o.push("static"),e?.isConst&&o.push("const"),e?.isReadonly&&o.push("readonly"),e?.isPrivate&&o.push("private"),e?.isProtected&&o.push("protected"),(e?.isPublic||n&&!e?.isProtected&&!e?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((t=>s.createElement(g,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(O,{flags:e.flags}),e.varianceModifier&&s.createElement(g,{type:"keyword"},e.varianceModifier," "),s.createElement(g,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&s.createElement(s.Fragment,null," extends ",s.createElement(ot,{type:e.type})),e.default&&s.createElement(s.Fragment,null," = ",s.createElement(ot,{type:e.default})))}var F=n(8617);const B={[k.W.Namespace]:"namespace",[k.W.Enum]:"enum",[k.W.Class]:"class",[k.W.Interface]:"interface"};function U(t){let{reflection:e}=t;const n=(0,F.in)();return s.createElement(s.Fragment,null,s.createElement(O,{flags:e.flags}),s.createElement(g,{type:"keyword"},B[e.kind]," "),s.createElement(g,{type:"class-name"},e.name),!!e.typeParameters?.length&&s.createElement(L,{type:C.Angle},e.typeParameters.map((t=>s.createElement(G,{key:t.id,reflection:n(t)}))))," ",!!e.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"extends "),s.createElement(L,null,e.extendedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))),!!e.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"implements "),s.createElement(L,null,e.implementedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return s.createElement(s.Fragment,null,s.createElement(O,{flags:e.flags}),e.flags.isRest&&"...",s.createElement(g,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&s.createElement(ot,{type:e.type}),e.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(g,{type:"plain"},e.defaultValue)))}function q(t){let{reflection:e,flags:n}=t;const o=(0,F.in)(),p="__type"===e.name;return s.createElement(s.Fragment,null,s.createElement(O,{flags:n??e.flags,explicitAccessModifier:!p}),e.kind===k.W.GetSignature&&s.createElement(g,{type:"keyword"},"get "),e.kind===k.W.SetSignature&&s.createElement(g,{type:"keyword"},"set "),e.overwrites&&s.createElement(s.Fragment,null,s.createElement(g,{to:e.overwrites.externalUrl??(0,F.Gr)(o(e.overwrites.id)),type:"keyword"},"override")," "),e.kind===k.W.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(g,{to:"#",type:"keyword"},"new")," ",s.createElement(g,{type:"plain"},e.type.name)):p?"":s.createElement(g,{type:"function"},e.name),!!e.typeParameter?.length&&s.createElement(L,{type:C.Angle},e.typeParameter.map((t=>s.createElement(G,{key:t.id,reflection:o(t)})))),e.parameters?.length?s.createElement(L,{type:C.Parentheses},e.parameters.map((t=>s.createElement(V,{key:t,reflection:o(t)})))):"()",e.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(ot,{type:e.type})))}function j(t){let{reflection:e}=t;const n=e.signatures?.[0]??e.getSignature??e.setSignature??e.indexSignature;return s.createElement(q,{reflection:n})}function Y(t){let{reflection:e}=t;return s.createElement(V,{reflection:e})}function H(t){let{reflection:e}=t;const n=(0,F.in)();return s.createElement(s.Fragment,null,s.createElement(O,{flags:e.flags}),s.createElement(g,{type:"keyword"},"type "),s.createElement(g,{type:"class-name"},e.name),e.typeParameters&&s.createElement(L,{type:C.Angle},e.typeParameters.map((t=>s.createElement(G,{key:t.id,reflection:n(t)}))))," = ",s.createElement(ot,{type:e.type}))}function Q(t){let{reflection:e}=t;const n=(0,F.in)();return e.signatures?s.createElement(q,{reflection:e.signatures[0]}):e.children?s.createElement(L,{type:C.Curly},e.children.map((t=>s.createElement($,{key:t.id,reflection:n(t)})))):s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},"unknown"))}function $(t){let{reflection:e}=t;const n=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:case k.W.Module:case k.W.EnumMember:case k.W.Variable:case k.W.Function:break;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return U;case k.W.Constructor:return q;case k.W.Property:return Y;case k.W.Method:return j;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:break;case k.W.TypeLiteral:return Q;case k.W.TypeParameter:return G;case k.W.Accessor:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return H;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return s.createElement(n,{reflection:e})}function J(t){let{type:e}=t;const n=(0,F.in)();return s.createElement($,{reflection:n(e.declaration)})}function K(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(g,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,o]=t;return s.createElement(s.Fragment,null,"${",s.createElement(ot,{key:e,type:n}),"}",s.createElement(g,{type:"string"},o))})),s.createElement(g,{type:"string"},"`"))}function tt(t){let{type:e}=t;return e.elements?s.createElement(L,{type:C.Square},e.elements.map(((t,e)=>s.createElement(ot,{key:e,type:t})))):s.createElement(s.Fragment,null,"[]")}function et(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(g,{type:"keyword"},e.operator," "),s.createElement(ot,{type:e.target}))}function nt(t){let{type:e}=t;return s.createElement(L,{type:C.Parentheses,separator:x.Pipe},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function ot(t){const e=(0,s.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return et;case"conditional":return b;case"reflection":return J;case"query":return E;case"named-tuple-member":return S;case"union":return nt;case"intrinsic":return W;case"literal":return I;case"reference":return pt;case"predicate":return P;case"tuple":return tt;case"array":return Z;case"intersection":return z;case"inferred":return A;case"mapped":return R;case"template-literal":return K;case"indexedAccess":return N}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return s.createElement(e,t)}function pt(t){let{type:e}=t;const n=(0,F.RU)(e.project),o=n?.[e.id],p=e.externalUrl??(0,F.Gr)(o);return s.createElement(s.Fragment,null,s.createElement(g,{to:p,type:p?"class-name":"constant",tooltip:!0},e.name),!!e.typeArguments?.length&&s.createElement(L,{type:C.Angle},e.typeArguments.map(((t,e)=>s.createElement(ot,{key:e,type:t})))))}function rt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?s.createElement(wt,{reflection:e.nested[0]}):s.createElement(s.Fragment,null,e.external.length>0&&s.createElement("ul",null,e.external.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>s.createElement(s.Fragment,{key:t.id},e>0&&s.createElement("hr",null),s.createElement(wt,{reflection:t})))))}var st=n(3851),ct=n(2009),it=n(7336);function at(t){let{group:e,project:n}=t;const o=(0,w.TH)(),p=(0,F.RU)(n),r=o.hash.split("-")[0].slice(1),[c]=(0,D.mN)(),i=(0,s.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,D.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,p,c))).filter((t=>!!t))),[e,p,c]);return(0,s.useEffect)((()=>{if(1===i.length)return;const t=o.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[o.hash,i]),0===i.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h2",id:e.title},e.title),i.length>1?s.createElement(it.Z,{groupId:e.title},i.map((t=>s.createElement(ct.Z,{default:t.anchors.includes(r),value:t.title,label:t.title,className:"margin-top--lg"},s.createElement(rt,{group:t}))))):s.createElement(rt,{group:i[0]}))}var lt=n(4237);function ut(t){let{parameters:e}=t;const n=(0,F.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(V,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function mt(t){let{parameters:e}=t;const n=(0,F.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(G,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function dt(t){let{signatures:e,flags:n,source:o}=t;const p=(0,F.in)(),r=(0,s.useMemo)((()=>e.map(p)),[e]),[c,i]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(d,null,r.map((t=>s.createElement(u,{link:o?.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},s.createElement(h,null,s.createElement(q,{reflection:t,flags:n})))))),s.createElement(f.Z,{comment:c.comment}),s.createElement(mt,{parameters:c.typeParameter}),s.createElement(ut,{parameters:c.parameters}))}function ht(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:e})))),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),s.createElement(mt,{parameters:e.typeParameters}),e.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,e.implementedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,e.extendedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(at,{group:t,key:t.title,project:e.project}))))}function ft(t){let{reflection:e,headless:n}=t;const o=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(dt,{signatures:o,flags:e.flags,source:e.sources?.[0]}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))),e.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pt,{type:e.overwrites}))))}var kt=n(6109);function yt(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(kt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),e.groups?.map((t=>s.createElement(at,{group:t,key:t.title,project:e.project}))))}const Dt={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Mt(t){let{reflection:e}=t;const n=(0,F.RU)(e.project),o=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.Z)("row")},o.map((t=>s.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.Z,{href:t.href,className:(0,l.Z)("card padding--lg",Dt.cardContainer)},s.createElement("h2",{className:(0,l.Z)("text--truncate",Dt.cardTitle)},s.createElement("code",null,t.name)),s.createElement("div",{className:(0,l.Z)("text--truncate",Dt.cardDescription)},t.comment?.summaryText??"\xa0")))))))}function Xt(t){let{reflection:e,headless:n}=t;return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement(Y,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))))}function _t(t){let{reflection:e}=t;const n=(0,F.RU)(e.project);return s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name)),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),s.createElement(mt,{parameters:e.typeParameters}),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(s.Fragment,{key:t.title},s.createElement("h2",null,t.title),t.children.map((t=>n[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>s.createElement(wt,{key:t.id,reflection:t})))))))}function wt(t){let{reflection:e,headless:n=!1}=t;const o=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:return Mt;case k.W.Module:return yt;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return ht;case k.W.Function:case k.W.Accessor:case k.W.Constructor:case k.W.Method:return ft;case k.W.Variable:case k.W.Property:case k.W.EnumMember:return Xt;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:case k.W.TypeLiteral:case k.W.TypeParameter:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return _t;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return s.createElement(o,{reflection:e,headless:n})}},7390:(t,e,n)=>{"use strict";n.d(e,{W:()=>o});let o=function(t){return t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference",t}({})},8770:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(9817),p=n(6047),r=n(2784);function s(){return r.createElement(p.Z,{type:"experimental"},"This is an ",r.createElement(o.Z,{to:"/docs/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},4974:(t,e,n)=>{"use strict";n.d(e,{Z:()=>tt});var o=n(3947),p=n(9387),r=n(7120),s=n(1727),c=n(5565),i=n(1263),a=n(3181),l=n(9573),u=n(2784);function m(){return u.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},u.createElement("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}))}function d(){return u.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},u.createElement("path",{d:"M8 5v14l11-7z"}))}function h(){return u.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},u.createElement("path",{d:"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"}))}function f(){return u.createElement("svg",{width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor"},u.createElement("path",{d:"M6 6h2v12H6zm3.5 6l8.5 6V6z"}))}var k=n(700),y=n(8015),D=n(6277);function M(t){let{options:e,value:n,className:o,onChange:p}=t;const r=(0,u.useRef)(),s=(0,u.useRef)(),[c,i]=(0,u.useState)(!1);return(0,u.useEffect)((()=>{const t=t=>{r.current&&!r.current.contains(t.target)&&i(!1)};return document.addEventListener("mousedown",t),document.addEventListener("touchstart",t),()=>{document.removeEventListener("mousedown",t),document.removeEventListener("touchstart",t)}}),[r]),u.createElement("div",{ref:r,className:(0,D.Z)("dropdown dropdown--right",c&&"dropdown--show",o)},u.createElement("a",{ref:s,className:"navbar__link",href:"#",onClick:t=>{t.preventDefault(),i(!c)}},e.find((t=>t.value===n))?.name??n),u.createElement("ul",{className:"dropdown__menu"},e.map(((t,o)=>u.createElement("li",{key:t.value},u.createElement("a",{href:"#",className:(0,D.Z)("dropdown__link",n===t.value&&"dropdown__link--active"),onClick:e=>{e.preventDefault(),p(t.value),i(!1),s.current.focus()},onKeyDown:t=>{o!==e.length-1||"Tab"!==t.key||t.shiftKey||(t.preventDefault(),i(!1),s.current.focus())}},t.name))))))}let X=null,_=null,w=null,T=null,g=null,C=null,x=1,v=null;async function L(t,e,n,o){if(t!==g){if(T&&C&&T.finalBuffer.parentElement===C&&C?.removeChild(T.finalBuffer),g?.(null),g=t,C=e,v=o,!X){const{Logger:t,Player:e,ProjectMetadata:n,Stage:o,ValueDispatcher:p,DefaultPlugin:r}=await import("@motion-canvas/core"),{makeScene2D:s}=await import("@motion-canvas/2d");_=s((function*(){yield})),_.onReplaced=new p(_),X={name:"fiddle",logger:new t,plugins:[r()],scenes:[_]},X.meta=new n(X),X.meta.shared.size.set(960),w=new e(X,{size:X.meta.shared.size.get()}),T=new o,T.configure({size:X.meta.shared.size.get()}),w.onRender.subscribe((async()=>{await T.render(w.playback.currentScene,w.playback.previousScene)})),w.onRecalculated.subscribe((()=>{T.finalBuffer.parentElement!==C&&(C?.append(T.finalBuffer),g(w))})),X.logger.onLogged.subscribe((t=>{"error"===t.level&&v?.(`Runtime error: ${t.message}`)}))}return x!==n&&(X.meta.shared.size.set([960,Math.floor(960/n)]),_.onReplaced.current={..._.onReplaced.current,size:X.meta.shared.size.get()},T.configure({size:X.meta.shared.size.get()}),x=n),w.activate(),w.requestReset(),w}}const Z=[];function b(t){Object.entries(t).forEach((t=>{let[e,n]=t;var o;Z.push({label:e,type:"function"==typeof n?(o=n,o.prototype&&o.prototype.constructor.name?"class":"function"):"variable"})}))}i.Z.canUseDOM&&(import("@motion-canvas/core").then(b).catch(),import("@motion-canvas/2d").then(b).catch());const N=s.Py.define(),A=s.Py.define({map:(t,e)=>{let{from:n,to:o,tooltip:p}=t;return{from:e.mapPos(n),to:e.mapPos(o),tooltip:p}}}),z=c.p.mark({class:"cm-underline"}),W=c.tk.baseTheme({".cm-underline":{textDecoration:"var(--ifm-color-danger-dark) wavy underline"}}),I=s.QQ.define({create:()=>c.p.none,update:(t,e)=>{t=t.map(e.changes);for(const n of e.effects){if(n.is(N)){t=t.update({filter:()=>!1});break}n.is(A)&&(t=t.update({add:[z.range(n.value.from,n.value.to)]}))}return t},provide:t=>c.tk.decorations.from(t)});class R extends s.uU{constructor(t){super(),this.tooltip=t}}const S=s.QQ.define({create:()=>s.Xs.empty,update:(t,e)=>{t=t.map(e.changes);for(const n of e.effects){if(n.is(N)){t=t.update({filter:()=>!1});break}n.is(A)&&(t=t.update({add:[new R(n.value.tooltip).range(n.value.from,n.value.to)]}))}return t},provide:t=>(0,c.bF)(((e,n)=>{let o;return e.state.field(t,!1).between(n,n,((t,e,n)=>(o={pos:t,end:e,create:()=>{const t=document.createElement("div");return t.textContent=n.tooltip,{dom:t}}},!1))),o}))});function P(t,e,n){const o=e.map((e=>(e.from===e.to&&(e=function(t,e){const n=(0,r.qz)(t).resolveInner(e,1);return{from:n.from,to:n.to}}(t.state,e.from)),A.of({tooltip:n,...e}))));return t.dispatch({effects:o}),!0}const E=7;function O(t,e){let n=(0,r.qz)(t).topNode.firstChild,o=null;for(;n;){if(n.type.is("ImportDeclaration")){o=n;break}n=n.nextSibling}if(!o)return null;if(e){const n=t.doc.lineAt(o.from);if(n.from>e.to||n.to<e.from)return null}let p=o;for(;p;){const t=p.nextSibling;if(!t.type.is("ImportDeclaration"))break;p=t}return{from:o.from+E,to:p.to}}function G(t){const{state:e}=t,n=O(e);n&&t.dispatch({effects:[r.SW.of(n)]})}const F=/ *\/\/ ?(\S+) ?(.*)/,B=["highlight-next-line","highlight-start","highlight-end","prettier-ignore"];var U=n(6253);const V=r.Qf.define([{tag:U.pJ.comment,color:"var(--hl-comment)"},{tag:U.pJ.docComment,color:"var(--hl-comment)"},{tag:U.pJ.blockComment,color:"var(--hl-comment)"},{tag:U.pJ.keyword,color:"var(--hl-keyword)"},{tag:U.pJ.number,color:"var(--hl-number)"},{tag:U.pJ.inserted,color:"var(--hl-number)"},{tag:U.pJ.constant(U.pJ.propertyName),color:"var(--hl-constant)"},{tag:U.pJ.attributeName,color:"var(--hl-variable)"},{tag:U.pJ.variableName,color:"var(--hl-variable)"},{tag:U.pJ.propertyName,color:"var(--hl-variable)"},{tag:U.pJ.deleted,color:"var(--hl-string)"},{tag:U.pJ.string,color:"var(--hl-string)"},{tag:U.pJ.attributeValue,color:"var(--hl-string)"},{tag:U.pJ.tagName,color:"var(--hl-tag)"},{tag:U.pJ.typeName,color:"var(--hl-tag)"},{tag:U.pJ.punctuation,color:"var(--hl-punctuation)"},{tag:U.pJ.operator,color:"var(--hl-punctuation)"},{tag:U.pJ.function(U.pJ.variableName),color:"var(--hl-function)"},{tag:U.pJ.function(U.pJ.propertyName),color:"var(--hl-function)"},{tag:U.pJ.className,color:"var(--hl-class)"},{tag:U.pJ.character,color:"var(--hl-char)"}]),q=c.tk.theme({"&":{fontSize:"var(--ifm-code-font-size)",lineHeight:"21.04px",fontFamily:"var(--ifm-font-family-monospace)",color:"var(--hl-color)",backgroundColor:"var(--hl-background)"},"&.cm-focused .cm-cursor":{borderLeftColor:"var(--hl-color)"},"&.cm-focused":{outline:"none"},".cm-gutters":{backgroundColor:"var(--hl-background)",color:"var(--ifm-color-secondary-darkest)",borderRight:"1px solid var(--ifm-background-color)"},"& .cm-lineNumbers .cm-gutterElement":{paddingLeft:"var(--ifm-pre-padding)"},".cm-activeLineGutter":{backgroundColor:"var(--ifm-code-active-color)"},".cm-scroller":{fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",paddingTop:"var(--ifm-pre-padding)",paddingBottom:"var(--ifm-pre-padding)"},".cm-content":{padding:"0"},"& .cm-line":{paddingRight:"var(--ifm-pre-padding)"},"& .cm-selectionBackground, &.cm-focused .cm-selectionBackground, ::selection":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-activeLine":{backgroundColor:"var(--ifm-code-active-color)"},".cm-selectionMatch":{backgroundColor:"var(--ifm-code-selection-color)"},".cm-foldPlaceholder":{backgroundColor:"var(--ifm-code-selection-color)",borderColor:"var(--ifm-color-emphasis-300)"},".cm-tooltip":{backgroundColor:"var(--ifm-background-surface-color)"}});var j=n(7243);class Y extends Error{constructor(t,e){super(t),this.errors=e}}function H(t,e){const n=`${e}.tsx`,o=new Set,p=[];let r,s=null;try{r=j.transform(t,{filename:n,presets:["typescript",["react",{runtime:"automatic",importSource:"@motion-canvas/2d"}]],plugins:[t=>{let{types:e}=t;return{visitor:{ImportDeclaration(t){t.node.source.value.startsWith("@motion-canvas/core")&&(t.node.source.value="@motion-canvas/core"),t.node.source.value.startsWith("@motion-canvas/2d")&&(t.node.source.value="@motion-canvas/2d")},ReferencedIdentifier(t){const{node:n,scope:r}=t;e.isIdentifier(n)&&!r.hasBinding(n.name)&&(o.add(n.name),p.push({from:n.start,to:n.end,tooltip:`Cannot find name '${n.name}'.`}))}}}}]})}catch(c){const t=/(.*) \(\d+:\d+\)/.exec(c.message.slice(n.length+1));s=t?t[1]:c.message,c.loc&&p.push({from:c.pos,to:c.pos,tooltip:s})}if(p.length>0)throw new Y(s??`Cannot find names: ${Array.from(o).join(", ")}\nDid you forget to import them?`,p);return r.code}function Q(t){const[e,n]=(0,u.useState)(t?.current);return(0,u.useEffect)((()=>t&&t.subscribe(n)),[t]),e}var $=n(6109),J=n(8888);const K={root:"root_icgl",layoutControl:"layoutControl_X__N",icon:"icon_brRG",active:"active_qxTr",progress:"progress_HsLC",controls:"controls_R4ai",previewOnly:"previewOnly_FFUw",section:"section_UscS",disabled:"disabled_egkt",error:"error_N64d",editor:"editor_xQGp",source:"source_Dq6N",preview:"preview_C9cZ",button:"button_ESGX",picker:"picker_Whdf",codeOnly:"codeOnly_lee0"};function tt(t){let{children:e,className:n,mode:x="editor",ratio:v="4"}=t;const[b,A]=(0,u.useState)(null),z=(0,u.useRef)(null),R=(0,u.useRef)(),E=(0,u.useRef)(),[U,j]=(0,u.useState)(x),{pathname:tt}=(0,a.TH)(),[et,nt]=(0,u.useState)(null),ot=Q(b?.onDurationChanged),pt=Q(b?.onFrameChanged),rt=Q(b?.onStateChanged),[st,ct]=(0,u.useState)(null),[it,at]=(0,u.useState)(null),lt=(0,u.useMemo)((()=>{if(v.includes("/")){const t=v.split("/"),e=parseFloat(t[0])/parseFloat(t[1]);if(!isNaN(e))return e}const t=parseFloat(v);return isNaN(t)?4:t}),[v]),ut=async function(t,e){void 0===e&&(e=!0),await L(A,E.current,lt,nt);try{const p=await async function(t,e){const n=H(t,e);return(await import(URL.createObjectURL(new Blob([n],{type:"text/javascript"})))).default}(t.sliceString(0),tt);return o=p,_&&(_.onReplaced.current=o),at(t),e&&!it?.eq(t)&&E.current.animate((void 0===n&&(n=4),[{boxShadow:"0 0 0px 0 #ccc inset",easing:"cubic-bezier(0.33, 1, 0.68, 1)"},{boxShadow:`0 0 0px ${n}px #ccc inset`,easing:"cubic-bezier(0.32, 0, 0.67, 0)"},{boxShadow:"0 0 0px 0 #ccc inset"}]),{duration:300}),!0}catch(p){return p instanceof Y&&P(z.current,p.errors,p.message),nt(p.message),b?.togglePlayback(!1),!1}var n,o},mt=async t=>{ht(t);const e=function(t){const e=O(t);let n=!1;return t.field(r.iQ,!1).between(e.from,e.to,(()=>(n=!0,!1))),n}(z.current.state);z.current.setState(ft[t].state),await ut(ft[t].state.doc),e&&G(z.current)},[dt,ht]=(0,u.useState)(0),ft=(0,u.useMemo)((()=>function(t){let e={name:"Default",lines:[]};const n=[e];for(const o of t.split("\n")){const t=F.exec(o);if(!t){e.lines.push(o);continue}const[,p,r]=t;B.includes(p)||("snippet"===p?e.lines.length>0?(e={name:r,lines:[]},n.push(e)):e.name=r:e.lines.push(o))}return n}(e).map((t=>({name:t.name,state:s.yy.create({doc:s.xv.of(t.lines),extensions:[J.Xy,c.$f.of([o.oc,{key:"Mod-s",preventDefault:!0,run:t=>(ut(t.state.doc),!0)}]),c.tk.updateListener.of((t=>{ct(t.state.doc),t.docChanged&&(nt(null),z.current.dispatch({effects:[N.of(null)]}))})),p.Lz.data.of({autocomplete:t=>{if("String"===(0,r.qz)(t.state).resolveInner(t.pos,-1).name)return;const e=t.matchBefore(/\w*/);return e.from!==e.to||t.explicit?{from:e.from,options:Z}:null}}),r.rs.of(((t,e,n)=>O(t,{from:e,to:n}))),[I,S,W],(0,p.eJ)({jsx:!0,typescript:!0}),(0,r.nF)(V),q]})})))),[e]);i.Z.canUseDOM||ft.forEach((t=>{H(t.state.doc.sliceString(0),tt)})),(0,u.useEffect)((()=>(z.current=new c.tk({parent:R.current,state:ft[dt].state}),G(z.current),async function(t,e,n,o){return g?null:L(t,e,n,o)}(A,E.current,lt,nt).then((async t=>{if(t){await ut(ft[dt].state.doc,!1)&&"code"!==U&&t.togglePlayback(!0)}})),()=>{g===A&&X&&(w.deactivate(),g=null,C=null,T.finalBuffer.remove()),z.current.destroy()})),[]);const kt=(0,u.useMemo)((()=>{const t=ft[0].state,e=O(t);let n=t.doc;return e&&(n=n.replace(e.from,e.to,s.xv.of(["..."]))),n.toString()+"\n"}),[ft]),yt=it&&st&&!st.eq(it),Dt=st&&!st.eq(ft[dt].state.doc)||yt;return u.createElement("div",{className:(0,D.Z)(K.root,n,{[K.codeOnly]:"code"===U,[K.previewOnly]:"preview"===U})},u.createElement("div",{className:K.layoutControl},u.createElement("button",{className:(0,D.Z)(K.icon,"code"===U&&K.active),onClick:()=>{j("code"),b?.togglePlayback(!1)},title:"Source code"},u.createElement(y.Z,null)),u.createElement("button",{className:(0,D.Z)(K.icon,"editor"===U&&K.active),onClick:()=>j("editor"),title:"Editor with preview"},u.createElement(k.Z,null)),u.createElement("button",{className:(0,D.Z)(K.icon,"preview"===U&&K.active),onClick:()=>j("preview"),title:"Preview"},u.createElement(l.Z,null))),u.createElement("div",{className:K.preview,style:{aspectRatio:v},ref:E},!b&&u.createElement("div",null,"Press play to preview the animation")),ot>0&&u.createElement("div",{className:K.progress,style:{width:b?pt/ot*100+"%":0}}),u.createElement("div",{className:K.controls},u.createElement("div",{className:K.section},yt&&u.createElement("button",{onClick:()=>ut(z.current.state.doc),className:K.button},u.createElement("kbd",null,"CTRL"),u.createElement("kbd",null,"S"),u.createElement("small",null,"Update preview"))),u.createElement("div",{className:(0,D.Z)(K.section,0===ot&&b&&K.disabled)},u.createElement("button",{className:K.icon,onClick:()=>b?.requestPreviousFrame()},u.createElement(f,null)),u.createElement("button",{className:K.icon,onClick:async()=>{if(b){let t=!0;it||(t=await ut(z.current.state.doc)),t&&b.togglePlayback()}else{const t=await L(A,E.current,lt,nt);await ut(z.current.state.doc)&&t.togglePlayback(!0)}}},!b||(rt?.paused??1)?u.createElement(d,null):u.createElement(m,null)),u.createElement("button",{className:K.icon,onClick:()=>b?.requestNextFrame()},u.createElement(h,null))),u.createElement("div",{className:K.section},1===ft.length&&Dt&&u.createElement("button",{className:K.button,onClick:()=>mt(0)},u.createElement("small",null,"Reset example")),ft.length>1&&u.createElement(M,{className:K.picker,value:Dt?-1:dt,onChange:mt,options:ft.map(((t,e)=>({value:e,name:t.name}))).concat(Dt?{value:-1,name:"Custom"}:[])}))),et&&u.createElement("pre",{className:K.error},et),u.createElement("div",{className:K.editor,ref:R},u.createElement($.Z,{className:K.source,language:"tsx"},"code"===U?ft[dt].state.doc.toString():kt)))}},532:(t,e,n)=>{"use strict";n.d(e,{Z:()=>l});var o=n(9741),p=n(9322),r=n(8617),s=n(6277),c=n(2784);const i={tooltipContainer:"tooltipContainer_vf9D",tooltip:"tooltip_lI6R",active:"active_DOSD"},a=496;function l(t){let{children:e}=t;const n=(0,o.Z)(),l=(0,r.rG)(),[u,m]=(0,c.useState)(!1),[d,h]=(0,c.useState)(null),f=(0,c.useRef)(),k=(0,c.useRef)(),y=(0,c.useRef)(),D=(0,c.useCallback)((()=>{if(!k.current||!y.current)return;const t=k.current.getBoundingClientRect();let e=window.innerWidth-t.left-a;e<0&&(e=0),y.current.style.right=`${e}px`,y.current.style.top=`${t.bottom}px`}),[]);return(0,c.useEffect)((()=>{if(!n)return;const t=t=>{if(!t.target.href||!f.current?.contains(t.target)||y.current?.contains(t.target))return;const e=new URL(t.target.href,document.baseURI);if(e.pathname===window.location.pathname)return;const n=l(e.pathname+e.hash);n?.comment?.summary&&(k.current=t.target,m(!0),h(n.comment),D())},e=t=>{t.target===k.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",D),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",D)}}),[n]),(0,c.useEffect)((()=>{D()})),c.createElement("div",{ref:f},e,c.createElement("div",{ref:y,className:(0,s.Z)(i.tooltip,"padding--md margin-horiz--md",u&&i.active)},d&&c.createElement(p.Z,{comment:d,full:!1})))}},8617:(t,e,n)=>{"use strict";n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof e?.project)return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{const o=t[n];return o?e[o.projectId]?.[o.id]??null:null}}function a(t){if(t)return t.href}},68:(t,e,n)=>{"use strict";n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(822),p=n(2784);const r=p.createContext(null);function s(t){let{children:e}=t;const n=(0,o.p)(),s=(0,p.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return p.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{"use strict";n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(1263),p=n(9741),r=n(2784);const s="api-filters",c=o.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=r.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,o]=(0,r.useState)(i),c=(0,p.Z)();return r.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),o(t)}]},e)}function u(){return(0,r.useContext)(a)}function m(t,e){const n=e.flags?.isPrivate||e.flags?.isProtected;if(!t.private&&n)return!1;const o=!!e.inheritedFrom;return!(!t.inherited&&o)}},6047:(t,e,n)=>{"use strict";n.d(e,{Z:()=>m});var o=n(7896),p=n(8046),r=n(2784);function s(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function i(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function a(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=n(9055);const u={icon:"icon_Fw4I"};function m(t){let{title:e,type:n,...m}=t;const d=(0,r.useMemo)((()=>{switch(n){case"tip":return i;case"caution":return a;case"danger":return s;case"experimental":return p.Z;default:return c}}),[n]);return"experimental"===n&&(e??="Experimental",n="caution"),r.createElement(r.Fragment,null,r.createElement(l.Z,(0,o.Z)({icon:r.createElement(d,{className:u.icon}),title:e,type:n},m)))}},4141:(t,e,n)=>{"use strict";n.d(e,{Z:()=>c});var o=n(7896),p=n(6277),r=n(2784);const s={iconEdit:"iconEdit_N_05"};function c(t){let{className:e,...n}=t;return r.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,p.Z)(s.iconEdit,e),"aria-hidden":"true"},n),r.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},4648:(t,e,n)=>{"use strict";n.d(e,{Z:()=>r});var o=n(7896),p=n(2784);function r(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),p.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}},9459:(t,e,n)=>{"use strict";n.d(e,{Z:()=>s});var o=n(4974),p=n(6109),r=n(2784);const s={...n(2203).Z,pre:function(t){return(0,r.isValidElement)(t.children)&&t.children.props?.editor?r.createElement(o.Z,t.children.props):r.createElement(p.Z,(0,r.isValidElement)(t.children)&&"code"===t.children.props?.originalType?t.children.props:{...t})}}},7733:(t,e,n)=>{"use strict";n.d(e,{Z:()=>c});var o=n(7896),p=n(7287),r=n(2784);const s={root:"root_ZAv1"};function c(t){const e=r.Children.toArray(t.children),n=e.find((t=>r.isValidElement(t)&&"summary"===t.props?.mdxType)),c=r.createElement(r.Fragment,null,e.filter((t=>t!==n)));return r.createElement(r.Fragment,null,r.createElement(p.P,(0,o.Z)({},t,{summary:n,className:s.root}),c))}},6155:(t,e,n)=>{var o={"./locale":9394,"./locale.js":9394};function p(t){var e=r(t);return n(e)}function r(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}p.keys=function(){return Object.keys(o)},p.resolve=r,t.exports=p,p.id=6155}}]);