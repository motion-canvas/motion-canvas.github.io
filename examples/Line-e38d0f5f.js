import{I as b,g as c,J as _,K as A,S as N,O as V,i as d,s as u,q as T,u as E,P as W,L as F,Q as H,T as J,U as K,W as Q}from"./makeScene2D-1b5f4133.js";class I{}class U extends I{constructor(t,s,e,n,i){super(),this.center=t,this.radius=s,this.from=e,this.to=n,this.counter=i,this.angle=Math.acos(b(-1,1,e.dot(n))),this.length=Math.abs(this.angle*s);const a=new c(1,1).scale(s);this.points=[t.sub(a),t.add(a)]}get arcLength(){return this.length}draw(t,s,e){const n=this.counter?-1:1,i=this.from.radians+s*this.angle*n,a=this.to.radians-(1-e)*this.angle*n;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,i,a,this.counter);const o=c.fromRadians(i),l=c.fromRadians(a);return[{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped},{position:this.center.add(l.scale(this.radius)),tangent:this.counter?l.flipped:l,normal:this.counter?l.flipped:l}]}getPoint(t){const s=this.counter?-1:1,e=this.from.radians+t*this.angle*s,n=c.fromRadians(e);return{position:this.center.add(n.scale(this.radius)),tangent:this.counter?n:n.flipped,normal:this.counter?n:n.flipped}}}function q(r,t){const s=b(0,r.arcLength,t);let e=0;for(const n of r.segments){const i=e;if(e+=n.arcLength,e>=s){const a=(s-i)/n.arcLength;return n.getPoint(b(0,1,a))}}return{position:c.zero,tangent:c.up,normal:c.up}}class k extends I{constructor(t,s){super(),this.from=t,this.to=s,this.vector=s.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe,this.points=[t,s]}get arcLength(){return this.length}draw(t,s=0,e=1,n=!1){const i=this.from.add(this.vector.scale(s)),a=this.from.add(this.vector.scale(e));return n&&_(t,i),A(t,a),[{position:i,tangent:this.normal.flipped,normal:this.normal},{position:a,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}function $(r,t,s){const e={arcLength:0,segments:[],minSin:1};if(r.length===0)return e;if(s){const a=r[0].add(r[r.length-1]).scale(.5);r.unshift(a),r.push(a)}let n=r[0];for(let a=2;a<r.length;a++){const o=r[a-2],l=r[a-1],g=r[a],L=o.sub(l),m=g.sub(l),P=L.normalized.safe,h=m.normalized.safe,v=Math.acos(b(-1,1,P.dot(h))),w=Math.tan(v/2),y=Math.sin(v/2),j=Math.min(t,w*L.magnitude*(a===2?1:.5),w*m.magnitude*(a===r.length-1?1:.5)),z=y===0?0:j/y,S=w===0?0:j/w,B=P.add(h).scale(1/2).normalized.safe.scale(z).add(l),C=P.perpendicular.dot(h)<0,M=new k(n,l.add(P.scale(S))),R=new U(B,j,P.perpendicular.scale(C?1:-1),h.perpendicular.scale(C?-1:1),C);e.segments.push(M),e.segments.push(R),e.arcLength+=M.arcLength,e.arcLength+=R.arcLength,e.minSin=Math.min(e.minSin,Math.abs(y)),n=l.add(h.scale(S))}const i=new k(n,r[r.length-1]);return e.segments.push(i),e.arcLength+=i.arcLength,e}var f=globalThis&&globalThis.__decorate||function(r,t,s,e){var n=arguments.length,i=n<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,s):e,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,t,s,e);else for(var o=r.length-1;o>=0;o--)(a=r[o])&&(i=(n<3?a(i):n>3?a(t,s,i):a(t,s))||i);return n>3&&i&&Object.defineProperty(t,s,i),i};class p extends N{desiredSize(){return this.childrenBBox().size}constructor(t){super(t),this.canHaveSubpath=!1}percentageToDistance(t){return b(0,this.baseArcLength(),this.startOffset()+this.offsetArcLength()*t)}distanceToPercentage(t){return(t-this.startOffset())/this.offsetArcLength()}baseArcLength(){return this.profile().arcLength}offsetArcLength(){const t=this.startOffset(),s=this.endOffset(),e=this.baseArcLength();return b(0,e,e-t-s)}arcLength(){return this.offsetArcLength()*Math.abs(this.start()-this.end())}completion(){return Math.abs(this.start()-this.end())}processSubpath(t,s,e){}curveDrawingInfo(){const t=new Path2D;let s=new Path2D;const e=this.profile();let n=this.percentageToDistance(this.start()),i=this.percentageToDistance(this.end());n>i&&([n,i]=[i,n]);const a=i-n,o=Math.min(a/2,this.arrowSize());this.startArrow()&&(n+=o/2),this.endArrow()&&(i-=o/2);let l=0,g=null,L=null,m=null,P=null;for(const h of e.segments){const v=l;if(l+=h.arcLength,l<n)continue;const w=(n-v)/h.arcLength,y=(i-v)/h.arcLength,j=b(0,1,w),z=b(0,1,y);this.canHaveSubpath&&m&&!h.getPoint(0).position.equals(m)&&(t.addPath(s),this.processSubpath(s,g,m),s=new Path2D,g=null);const[S,B]=h.draw(s,j,z,g===null);if(g===null&&(g=S.position,L=S.normal.flipped.perpendicular),m=B.position,P=B.normal.flipped.perpendicular,l>i)break}return this.end()===1&&this.closed()&&s.closePath(),this.processSubpath(s,g,m),t.addPath(s),{startPoint:g??c.zero,startTangent:L??c.right,endPoint:m??c.zero,endTangent:P??c.right,arrowSize:o,path:t,startOffset:n}}getPointAtDistance(t){return q(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return q(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:s}=this.profile();t.lineDashOffset-=s/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),s=this.arrowSize(),e=this.lineWidth(),n=this.lineWidthCoefficient();return t.expand(Math.max(0,s,e*n))}lineWidthCoefficient(){return this.lineCap()==="square"?.5*1.4143:.5}drawShape(t){super.drawShape(t);const{startPoint:s,startTangent:e,endPoint:n,endTangent:i,arrowSize:a}=this.curveDrawingInfo();a<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,n,i.flipped,a),this.startArrow()&&this.drawArrow(t,s,e,a),t.fillStyle=V(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,s,e,n){const i=e.perpendicular,a=s.add(e.scale(-n/2));_(t,a),A(t,a.add(e.add(i).scale(n))),A(t,a.add(e.sub(i).scale(n))),A(t,a),t.closePath()}}f([d(!1),u()],p.prototype,"closed",void 0);f([d(0),u()],p.prototype,"start",void 0);f([d(0),u()],p.prototype,"startOffset",void 0);f([d(!1),u()],p.prototype,"startArrow",void 0);f([d(1),u()],p.prototype,"end",void 0);f([d(0),u()],p.prototype,"endOffset",void 0);f([d(!1),u()],p.prototype,"endArrow",void 0);f([d(24),u()],p.prototype,"arrowSize",void 0);f([T()],p.prototype,"arcLength",null);f([T()],p.prototype,"curveDrawingInfo",null);var O=globalThis&&globalThis.__decorate||function(r,t,s,e){var n=arguments.length,i=n<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,s):e,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,t,s,e);else for(var o=r.length-1;o>=0;o--)(a=r[o])&&(i=(n<3?a(i):n>3?a(t,s,i):a(t,s))||i);return n>3&&i&&Object.defineProperty(t,s,i),i};class D extends p{constructor(t){super(t),t.children===void 0&&t.points===void 0&&E().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre>
<p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre>
<p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>
`,inspect:this.key})}childrenBBox(){const t=this.points(),s=t?t.map(e=>new c(W(e))):this.children().filter(e=>!(e instanceof F)||e.isLayoutRoot()).map(e=>e.position());return H.fromPoints(...s)}parsedPoints(){const t=this.points();return t?t.map(s=>new c(W(s))):this.children().map(s=>s.position())}profile(){return $(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),s=this.lineJoin();let e=super.lineWidthCoefficient();if(t===0&&s==="miter"){const{minSin:n}=this.profile();n>0&&(e=Math.max(e,.5/n))}return e}drawOverlay(t,s){const e=this.childrenBBox().transformCorners(s),i=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(s);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const a=new Path2D,o=this.parsedPoints().map(l=>l.transformAsPoint(s));if(o.length>0){_(a,o[0]);for(const l of o)A(a,l),t.beginPath(),J(t,l,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(a),t.beginPath(),K(t,i),t.stroke(),t.beginPath(),Q(t,e),t.closePath(),t.stroke()}}O([d(0),u()],D.prototype,"radius",void 0);O([d(null),u()],D.prototype,"points",void 0);O([T()],D.prototype,"childrenBBox",null);O([T()],D.prototype,"parsedPoints",null);O([T()],D.prototype,"profile",null);export{D as L};
