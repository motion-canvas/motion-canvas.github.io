"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1276],{876:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var o=n(2784);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){p(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,o,p=function(t,e){if(null==t)return{};var n,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(p[n]=t[n]);return p}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(p[n]=t[n])}return p}var i=o.createContext({}),a=function(t){var e=o.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=a(t.components);return o.createElement(i.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(n),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,s(s({ref:e},l),{},{components:n})):o.createElement(h,s({ref:e},l))}));function h(t,e){var n=arguments,p=e&&e.mdxType;if("string"==typeof t||p){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=n[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3851:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),p=n(2784),r=n(6277),s=n(1077),c=n(7683),i=n(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:e,id:n,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===e||!n)return p.createElement(e,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:n});return p.createElement(e,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:n}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${n}`,"aria-label":d,title:d},"\u200b"))}},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),p=n(8617),r=n(1930);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return o.createElement(r.Z,{reflection:n,headless:!0})}},3328:(t,e,n)=>{n.d(e,{Z:()=>NGe});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>te,content_0_1000:()=>Ey,content_0_1002:()=>Gy,content_0_1004:()=>Uy,content_0_1006:()=>qy,content_0_1008:()=>jy,content_0_1010:()=>Qy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>eM,content_0_1018:()=>oM,content_0_102:()=>ne,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>kM,content_0_1032:()=>yM,content_0_1034:()=>DM,content_0_1036:()=>_M,content_0_1038:()=>gM,content_0_104:()=>pe,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>SM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>UM,content_0_106:()=>se,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>QM,content_0_1066:()=>$M,content_0_1068:()=>JM,content_0_1070:()=>eD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>ie,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>kD,content_0_1086:()=>yD,content_0_1088:()=>DD,content_0_1090:()=>_D,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>le,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>SD,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>UD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_1118:()=>QD,content_0_112:()=>me,content_0_1120:()=>$D,content_0_1122:()=>JD,content_0_1124:()=>ew,content_0_1126:()=>ow,content_0_1128:()=>rw,content_0_1130:()=>cw,content_0_1132:()=>aw,content_0_1134:()=>uw,content_0_1136:()=>dw,content_0_1138:()=>kw,content_0_114:()=>he,content_0_1140:()=>yw,content_0_1142:()=>Dw,content_0_1144:()=>_w,content_0_1146:()=>gw,content_0_1148:()=>xw,content_0_1150:()=>vw,content_0_1152:()=>Zw,content_0_1154:()=>Nw,content_0_1156:()=>Aw,content_0_1158:()=>Rw,content_0_116:()=>fe,content_0_1160:()=>Sw,content_0_1162:()=>Ew,content_0_1164:()=>Gw,content_0_1166:()=>Uw,content_0_1168:()=>qw,content_0_1170:()=>jw,content_0_1172:()=>Qw,content_0_1174:()=>$w,content_0_1176:()=>Jw,content_0_1178:()=>e_,content_0_118:()=>Me,content_0_1180:()=>o_,content_0_1182:()=>r_,content_0_1184:()=>c_,content_0_1186:()=>a_,content_0_1188:()=>u_,content_0_1190:()=>d_,content_0_1192:()=>k_,content_0_1194:()=>y_,content_0_1196:()=>D_,content_0_1198:()=>__,content_0_12:()=>w,content_0_120:()=>we,content_0_1200:()=>g_,content_0_1202:()=>x_,content_0_1204:()=>v_,content_0_1206:()=>Z_,content_0_1208:()=>N_,content_0_1210:()=>A_,content_0_1212:()=>R_,content_0_1214:()=>S_,content_0_1216:()=>E_,content_0_1218:()=>G_,content_0_122:()=>Xe,content_0_1220:()=>U_,content_0_1222:()=>q_,content_0_1224:()=>j_,content_0_1226:()=>Q_,content_0_1228:()=>$_,content_0_1230:()=>J_,content_0_1232:()=>eX,content_0_1234:()=>oX,content_0_1236:()=>rX,content_0_1238:()=>cX,content_0_124:()=>Te,content_0_1240:()=>aX,content_0_1242:()=>uX,content_0_1244:()=>dX,content_0_1246:()=>kX,content_0_1248:()=>yX,content_0_1250:()=>DX,content_0_1252:()=>_X,content_0_1254:()=>gX,content_0_1256:()=>xX,content_0_1258:()=>vX,content_0_126:()=>Ce,content_0_1260:()=>ZX,content_0_1262:()=>NX,content_0_1264:()=>AX,content_0_1266:()=>RX,content_0_1268:()=>SX,content_0_1270:()=>EX,content_0_1272:()=>GX,content_0_1274:()=>UX,content_0_1276:()=>qX,content_0_1278:()=>jX,content_0_128:()=>Le,content_0_1280:()=>QX,content_0_1282:()=>$X,content_0_1284:()=>JX,content_0_1286:()=>eg,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>be,content_0_1300:()=>kg,content_0_1302:()=>yg,content_0_1304:()=>Dg,content_0_1306:()=>_g,content_0_1308:()=>gg,content_0_1310:()=>xg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>ze,content_0_1320:()=>Rg,content_0_1322:()=>Sg,content_0_1324:()=>Eg,content_0_1326:()=>Gg,content_0_1328:()=>Ug,content_0_1330:()=>qg,content_0_1332:()=>jg,content_0_1334:()=>Qg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>We,content_0_1340:()=>eT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>kT,content_0_1356:()=>yT,content_0_1358:()=>DT,content_0_136:()=>Ie,content_0_1360:()=>_T,content_0_1362:()=>gT,content_0_1364:()=>xT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>RT,content_0_1376:()=>ST,content_0_1378:()=>ET,content_0_138:()=>Pe,content_0_1380:()=>GT,content_0_1382:()=>UT,content_0_1384:()=>qT,content_0_1386:()=>jT,content_0_1388:()=>QT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>ex,content_0_1396:()=>ox,content_0_1398:()=>rx,content_0_14:()=>X,content_0_140:()=>Be,content_0_1400:()=>cx,content_0_1402:()=>ax,content_0_1404:()=>ux,content_0_1406:()=>dx,content_0_1408:()=>kx,content_0_1410:()=>yx,content_0_1412:()=>Dx,content_0_1414:()=>_x,content_0_1416:()=>gx,content_0_1418:()=>xx,content_0_142:()=>Oe,content_0_1420:()=>vx,content_0_1422:()=>Zx,content_0_1424:()=>Nx,content_0_1426:()=>Ax,content_0_1428:()=>Rx,content_0_1430:()=>Sx,content_0_1432:()=>Ex,content_0_1434:()=>Gx,content_0_1436:()=>Ux,content_0_1438:()=>qx,content_0_144:()=>Fe,content_0_1440:()=>jx,content_0_1442:()=>Qx,content_0_1444:()=>$x,content_0_1446:()=>Jx,content_0_1448:()=>eC,content_0_1450:()=>oC,content_0_1452:()=>rC,content_0_1454:()=>cC,content_0_1456:()=>aC,content_0_1458:()=>uC,content_0_146:()=>Ve,content_0_1460:()=>dC,content_0_1462:()=>kC,content_0_1464:()=>yC,content_0_1466:()=>DC,content_0_1468:()=>_C,content_0_1470:()=>gC,content_0_1472:()=>xC,content_0_1474:()=>vC,content_0_1476:()=>ZC,content_0_1478:()=>NC,content_0_148:()=>He,content_0_1480:()=>AC,content_0_1482:()=>RC,content_0_1484:()=>SC,content_0_1486:()=>EC,content_0_1488:()=>GC,content_0_1490:()=>UC,content_0_1492:()=>qC,content_0_1494:()=>jC,content_0_1496:()=>QC,content_0_1498:()=>$C,content_0_150:()=>Ye,content_0_1500:()=>JC,content_0_1502:()=>ev,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>kv,content_0_1518:()=>yv,content_0_152:()=>Ke,content_0_1520:()=>Dv,content_0_1522:()=>_v,content_0_1524:()=>gv,content_0_1526:()=>xv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Rv,content_0_1538:()=>Sv,content_0_154:()=>tn,content_0_1540:()=>Ev,content_0_1542:()=>Gv,content_0_1544:()=>Uv,content_0_1546:()=>qv,content_0_1548:()=>jv,content_0_1550:()=>Qv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>eL,content_0_1558:()=>oL,content_0_156:()=>nn,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>kL,content_0_1572:()=>yL,content_0_1574:()=>DL,content_0_1576:()=>_L,content_0_1578:()=>gL,content_0_158:()=>pn,content_0_1580:()=>xL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>RL,content_0_1592:()=>SL,content_0_1594:()=>EL,content_0_1596:()=>GL,content_0_1598:()=>UL,content_0_16:()=>T,content_0_160:()=>sn,content_0_1600:()=>qL,content_0_1602:()=>jL,content_0_1604:()=>QL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>eZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_1616:()=>cZ,content_0_1618:()=>aZ,content_0_162:()=>an,content_0_1620:()=>uZ,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>kn,content_0_170:()=>yn,content_0_172:()=>Dn,content_0_174:()=>_n,content_0_176:()=>gn,content_0_178:()=>xn,content_0_18:()=>C,content_0_180:()=>vn,content_0_182:()=>Zn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>Rn,content_0_190:()=>Sn,content_0_192:()=>En,content_0_194:()=>Gn,content_0_196:()=>Un,content_0_198:()=>qn,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>jn,content_0_202:()=>Qn,content_0_204:()=>$n,content_0_206:()=>Jn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>fo,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>Po,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Fo,content_0_252:()=>Vo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>np,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>fp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Fp,content_0_306:()=>Vp,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>fr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Pr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Fr,content_0_36:()=>F,content_0_360:()=>Vr,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>ns,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>fs,content_0_386:()=>Ms,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ps,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Fs,content_0_414:()=>Vs,content_0_416:()=>Hs,content_0_418:()=>Ys,content_0_42:()=>Y,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>nc,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>fc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Pc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Fc,content_0_468:()=>Vc,content_0_470:()=>Hc,content_0_472:()=>Yc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ni,content_0_48:()=>nt,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>fi,content_0_494:()=>Mi,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Pi,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Fi,content_0_522:()=>Vi,content_0_524:()=>Hi,content_0_526:()=>Yi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>fa,content_0_548:()=>Ma,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Pa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Fa,content_0_576:()=>Va,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Ya,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>fl,content_0_602:()=>Ml,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>ft,content_0_620:()=>Il,content_0_622:()=>Pl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Fl,content_0_630:()=>Vl,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>nu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>fu,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Pu,content_0_678:()=>Bu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>Fu,content_0_684:()=>Vu,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>fm,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Pm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Fm,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>fd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Pd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Fd,content_0_792:()=>Vd,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>f,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>fh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Fh,content_0_846:()=>Vh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>nk,content_0_858:()=>pk,content_0_86:()=>Bt,content_0_860:()=>sk,content_0_862:()=>ik,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>fk,content_0_872:()=>Mk,content_0_874:()=>wk,content_0_876:()=>Xk,content_0_878:()=>Tk,content_0_88:()=>Ot,content_0_880:()=>Ck,content_0_882:()=>Lk,content_0_884:()=>bk,content_0_886:()=>zk,content_0_888:()=>Wk,content_0_890:()=>Ik,content_0_892:()=>Pk,content_0_894:()=>Bk,content_0_896:()=>Ok,content_0_898:()=>Fk,content_0_90:()=>Ft,content_0_900:()=>Vk,content_0_902:()=>Hk,content_0_904:()=>Yk,content_0_906:()=>Kk,content_0_908:()=>tf,content_0_910:()=>nf,content_0_912:()=>pf,content_0_914:()=>sf,content_0_916:()=>af,content_0_918:()=>uf,content_0_92:()=>Vt,content_0_920:()=>df,content_0_922:()=>kf,content_0_924:()=>yf,content_0_926:()=>Df,content_0_928:()=>_f,content_0_930:()=>gf,content_0_932:()=>xf,content_0_934:()=>vf,content_0_936:()=>Zf,content_0_938:()=>Nf,content_0_94:()=>Ht,content_0_940:()=>Af,content_0_942:()=>Rf,content_0_944:()=>Sf,content_0_946:()=>Ef,content_0_948:()=>Gf,content_0_950:()=>Uf,content_0_952:()=>qf,content_0_954:()=>jf,content_0_956:()=>Qf,content_0_958:()=>$f,content_0_96:()=>Yt,content_0_960:()=>Jf,content_0_962:()=>ey,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>ky,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>Dy,content_0_982:()=>_y,content_0_984:()=>gy,content_0_986:()=>xy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Ry,content_0_998:()=>Sy,content_3504_0:()=>dZ,content_3504_10:()=>gZ,content_3504_100:()=>rN,content_3504_1000:()=>Gj,content_3504_1002:()=>Uj,content_3504_1004:()=>qj,content_3504_1006:()=>jj,content_3504_1008:()=>Qj,content_3504_1010:()=>$j,content_3504_1012:()=>Jj,content_3504_1014:()=>eH,content_3504_1016:()=>oH,content_3504_1018:()=>rH,content_3504_102:()=>cN,content_3504_1020:()=>cH,content_3504_1022:()=>aH,content_3504_1024:()=>uH,content_3504_1026:()=>dH,content_3504_1028:()=>kH,content_3504_1030:()=>yH,content_3504_1032:()=>DH,content_3504_1034:()=>_H,content_3504_1036:()=>gH,content_3504_1038:()=>xH,content_3504_104:()=>aN,content_3504_1040:()=>vH,content_3504_1042:()=>ZH,content_3504_1044:()=>NH,content_3504_1046:()=>AH,content_3504_1048:()=>RH,content_3504_1050:()=>SH,content_3504_1052:()=>EH,content_3504_1054:()=>GH,content_3504_1056:()=>UH,content_3504_1058:()=>qH,content_3504_106:()=>uN,content_3504_1060:()=>jH,content_3504_1062:()=>QH,content_3504_1064:()=>$H,content_3504_1066:()=>JH,content_3504_1068:()=>eQ,content_3504_1070:()=>oQ,content_3504_1072:()=>rQ,content_3504_1074:()=>cQ,content_3504_1076:()=>aQ,content_3504_1078:()=>uQ,content_3504_108:()=>dN,content_3504_1080:()=>dQ,content_3504_1082:()=>kQ,content_3504_1084:()=>yQ,content_3504_1086:()=>DQ,content_3504_1088:()=>_Q,content_3504_1090:()=>gQ,content_3504_1092:()=>xQ,content_3504_1094:()=>vQ,content_3504_1096:()=>ZQ,content_3504_1098:()=>NQ,content_3504_110:()=>kN,content_3504_1100:()=>AQ,content_3504_1102:()=>RQ,content_3504_1104:()=>SQ,content_3504_1106:()=>EQ,content_3504_1108:()=>GQ,content_3504_1110:()=>UQ,content_3504_1112:()=>qQ,content_3504_1114:()=>jQ,content_3504_1116:()=>QQ,content_3504_1118:()=>$Q,content_3504_112:()=>yN,content_3504_1120:()=>JQ,content_3504_1122:()=>eY,content_3504_1124:()=>oY,content_3504_1126:()=>rY,content_3504_1128:()=>cY,content_3504_1130:()=>aY,content_3504_1132:()=>uY,content_3504_1134:()=>dY,content_3504_1136:()=>kY,content_3504_1138:()=>yY,content_3504_114:()=>DN,content_3504_1140:()=>DY,content_3504_1142:()=>_Y,content_3504_1144:()=>gY,content_3504_1146:()=>xY,content_3504_1148:()=>vY,content_3504_1150:()=>ZY,content_3504_1152:()=>NY,content_3504_1154:()=>AY,content_3504_1156:()=>RY,content_3504_1158:()=>SY,content_3504_116:()=>_N,content_3504_1160:()=>EY,content_3504_1162:()=>GY,content_3504_1164:()=>UY,content_3504_1166:()=>qY,content_3504_1168:()=>jY,content_3504_1170:()=>QY,content_3504_1172:()=>$Y,content_3504_1174:()=>JY,content_3504_1176:()=>e$,content_3504_1178:()=>o$,content_3504_118:()=>gN,content_3504_1180:()=>r$,content_3504_1182:()=>c$,content_3504_1184:()=>a$,content_3504_1186:()=>u$,content_3504_1188:()=>d$,content_3504_1190:()=>k$,content_3504_1192:()=>y$,content_3504_1194:()=>D$,content_3504_1196:()=>_$,content_3504_1198:()=>g$,content_3504_12:()=>xZ,content_3504_120:()=>xN,content_3504_1200:()=>x$,content_3504_1202:()=>v$,content_3504_1204:()=>Z$,content_3504_1206:()=>N$,content_3504_1208:()=>A$,content_3504_1210:()=>R$,content_3504_1212:()=>S$,content_3504_1214:()=>E$,content_3504_1216:()=>G$,content_3504_1218:()=>U$,content_3504_122:()=>vN,content_3504_1220:()=>q$,content_3504_1222:()=>j$,content_3504_1224:()=>Q$,content_3504_1226:()=>$$,content_3504_1228:()=>J$,content_3504_1230:()=>eK,content_3504_1232:()=>oK,content_3504_1234:()=>rK,content_3504_1236:()=>cK,content_3504_1238:()=>aK,content_3504_124:()=>ZN,content_3504_1240:()=>uK,content_3504_1242:()=>dK,content_3504_1244:()=>kK,content_3504_1246:()=>yK,content_3504_1248:()=>DK,content_3504_1250:()=>_K,content_3504_1252:()=>gK,content_3504_1254:()=>xK,content_3504_1256:()=>vK,content_3504_1258:()=>ZK,content_3504_126:()=>NN,content_3504_1260:()=>NK,content_3504_1262:()=>AK,content_3504_1264:()=>RK,content_3504_1266:()=>SK,content_3504_1268:()=>EK,content_3504_1270:()=>GK,content_3504_1272:()=>UK,content_3504_1274:()=>qK,content_3504_1276:()=>jK,content_3504_1278:()=>QK,content_3504_128:()=>AN,content_3504_1280:()=>$K,content_3504_1282:()=>JK,content_3504_1284:()=>eJ,content_3504_1286:()=>oJ,content_3504_1288:()=>rJ,content_3504_1290:()=>cJ,content_3504_1292:()=>aJ,content_3504_1294:()=>uJ,content_3504_1296:()=>dJ,content_3504_1298:()=>kJ,content_3504_130:()=>RN,content_3504_1300:()=>yJ,content_3504_1302:()=>DJ,content_3504_1304:()=>_J,content_3504_1306:()=>gJ,content_3504_1308:()=>xJ,content_3504_1310:()=>vJ,content_3504_1312:()=>ZJ,content_3504_1314:()=>NJ,content_3504_1316:()=>AJ,content_3504_1318:()=>RJ,content_3504_132:()=>SN,content_3504_1320:()=>SJ,content_3504_1322:()=>EJ,content_3504_1324:()=>GJ,content_3504_1326:()=>UJ,content_3504_1328:()=>qJ,content_3504_1330:()=>jJ,content_3504_1332:()=>QJ,content_3504_1334:()=>$J,content_3504_1336:()=>JJ,content_3504_1338:()=>e0,content_3504_134:()=>EN,content_3504_1340:()=>o0,content_3504_1342:()=>r0,content_3504_1344:()=>c0,content_3504_1346:()=>a0,content_3504_1348:()=>u0,content_3504_1350:()=>d0,content_3504_1352:()=>k0,content_3504_1354:()=>y0,content_3504_1356:()=>D0,content_3504_1358:()=>_0,content_3504_136:()=>GN,content_3504_1360:()=>g0,content_3504_1362:()=>x0,content_3504_1364:()=>v0,content_3504_1366:()=>Z0,content_3504_1368:()=>N0,content_3504_1370:()=>A0,content_3504_1372:()=>R0,content_3504_1374:()=>S0,content_3504_1376:()=>E0,content_3504_1378:()=>G0,content_3504_138:()=>UN,content_3504_1380:()=>U0,content_3504_1382:()=>q0,content_3504_1384:()=>j0,content_3504_1386:()=>Q0,content_3504_1388:()=>$0,content_3504_1390:()=>J0,content_3504_1392:()=>e4,content_3504_1394:()=>o4,content_3504_1396:()=>r4,content_3504_1398:()=>c4,content_3504_14:()=>vZ,content_3504_140:()=>qN,content_3504_1400:()=>a4,content_3504_1402:()=>u4,content_3504_1404:()=>d4,content_3504_1406:()=>k4,content_3504_1408:()=>y4,content_3504_1410:()=>D4,content_3504_1412:()=>_4,content_3504_1414:()=>g4,content_3504_1416:()=>x4,content_3504_1418:()=>v4,content_3504_142:()=>jN,content_3504_1420:()=>Z4,content_3504_1422:()=>N4,content_3504_1424:()=>A4,content_3504_1426:()=>R4,content_3504_1428:()=>S4,content_3504_1430:()=>E4,content_3504_1432:()=>G4,content_3504_1434:()=>U4,content_3504_1436:()=>q4,content_3504_1438:()=>j4,content_3504_144:()=>QN,content_3504_1440:()=>Q4,content_3504_1442:()=>$4,content_3504_1444:()=>J4,content_3504_1446:()=>e3,content_3504_1448:()=>o3,content_3504_1450:()=>r3,content_3504_1452:()=>c3,content_3504_1454:()=>a3,content_3504_1456:()=>u3,content_3504_1458:()=>d3,content_3504_146:()=>$N,content_3504_1460:()=>k3,content_3504_1462:()=>y3,content_3504_1464:()=>D3,content_3504_1466:()=>_3,content_3504_1468:()=>g3,content_3504_1470:()=>x3,content_3504_1472:()=>v3,content_3504_1474:()=>Z3,content_3504_1476:()=>N3,content_3504_1478:()=>A3,content_3504_148:()=>JN,content_3504_1480:()=>R3,content_3504_1482:()=>S3,content_3504_1484:()=>E3,content_3504_1486:()=>G3,content_3504_1488:()=>U3,content_3504_1490:()=>q3,content_3504_1492:()=>j3,content_3504_1494:()=>Q3,content_3504_1496:()=>$3,content_3504_1498:()=>J3,content_3504_150:()=>ez,content_3504_1500:()=>e5,content_3504_1502:()=>o5,content_3504_1504:()=>r5,content_3504_1506:()=>c5,content_3504_1508:()=>a5,content_3504_1510:()=>u5,content_3504_1512:()=>d5,content_3504_1514:()=>k5,content_3504_1516:()=>y5,content_3504_1518:()=>D5,content_3504_152:()=>oz,content_3504_1520:()=>_5,content_3504_1522:()=>g5,content_3504_1524:()=>x5,content_3504_1526:()=>v5,content_3504_1528:()=>Z5,content_3504_1530:()=>N5,content_3504_1532:()=>A5,content_3504_1534:()=>R5,content_3504_1536:()=>S5,content_3504_1538:()=>E5,content_3504_154:()=>rz,content_3504_1540:()=>G5,content_3504_1542:()=>U5,content_3504_1544:()=>q5,content_3504_1546:()=>j5,content_3504_1548:()=>Q5,content_3504_1550:()=>$5,content_3504_1552:()=>J5,content_3504_1554:()=>e2,content_3504_1556:()=>o2,content_3504_1558:()=>r2,content_3504_156:()=>cz,content_3504_1560:()=>c2,content_3504_1562:()=>a2,content_3504_1564:()=>u2,content_3504_1566:()=>d2,content_3504_1568:()=>k2,content_3504_1570:()=>y2,content_3504_1572:()=>D2,content_3504_1574:()=>_2,content_3504_1576:()=>g2,content_3504_1578:()=>x2,content_3504_158:()=>az,content_3504_1580:()=>v2,content_3504_1582:()=>Z2,content_3504_1584:()=>N2,content_3504_1586:()=>A2,content_3504_1588:()=>R2,content_3504_1590:()=>S2,content_3504_1592:()=>E2,content_3504_1594:()=>G2,content_3504_1596:()=>U2,content_3504_1598:()=>q2,content_3504_16:()=>ZZ,content_3504_160:()=>uz,content_3504_1600:()=>j2,content_3504_1602:()=>Q2,content_3504_1604:()=>$2,content_3504_1606:()=>J2,content_3504_1608:()=>e1,content_3504_1610:()=>o1,content_3504_1612:()=>r1,content_3504_1614:()=>c1,content_3504_1616:()=>a1,content_3504_1618:()=>u1,content_3504_162:()=>dz,content_3504_1620:()=>d1,content_3504_1622:()=>k1,content_3504_1624:()=>y1,content_3504_1626:()=>D1,content_3504_1628:()=>_1,content_3504_1630:()=>g1,content_3504_1632:()=>x1,content_3504_1634:()=>v1,content_3504_1636:()=>Z1,content_3504_1638:()=>N1,content_3504_164:()=>kz,content_3504_1640:()=>A1,content_3504_1642:()=>R1,content_3504_1644:()=>S1,content_3504_1646:()=>E1,content_3504_1648:()=>G1,content_3504_1650:()=>U1,content_3504_1652:()=>q1,content_3504_1654:()=>j1,content_3504_1656:()=>Q1,content_3504_1658:()=>$1,content_3504_166:()=>yz,content_3504_1660:()=>J1,content_3504_1662:()=>e6,content_3504_1664:()=>o6,content_3504_1666:()=>r6,content_3504_1668:()=>c6,content_3504_1670:()=>a6,content_3504_1672:()=>u6,content_3504_1674:()=>d6,content_3504_1676:()=>k6,content_3504_1678:()=>y6,content_3504_168:()=>Dz,content_3504_1680:()=>D6,content_3504_1682:()=>_6,content_3504_1684:()=>g6,content_3504_1686:()=>x6,content_3504_1688:()=>v6,content_3504_1690:()=>Z6,content_3504_1692:()=>N6,content_3504_1694:()=>A6,content_3504_1696:()=>R6,content_3504_1698:()=>S6,content_3504_170:()=>_z,content_3504_1700:()=>E6,content_3504_1702:()=>G6,content_3504_1704:()=>U6,content_3504_1706:()=>q6,content_3504_1708:()=>j6,content_3504_1710:()=>Q6,content_3504_1712:()=>$6,content_3504_1714:()=>J6,content_3504_1716:()=>e8,content_3504_1718:()=>o8,content_3504_172:()=>gz,content_3504_1720:()=>r8,content_3504_1722:()=>c8,content_3504_1724:()=>a8,content_3504_1726:()=>u8,content_3504_1728:()=>d8,content_3504_1730:()=>k8,content_3504_1732:()=>y8,content_3504_1734:()=>D8,content_3504_1736:()=>_8,content_3504_1738:()=>g8,content_3504_174:()=>xz,content_3504_1740:()=>x8,content_3504_1742:()=>v8,content_3504_1744:()=>Z8,content_3504_1746:()=>N8,content_3504_1748:()=>A8,content_3504_1750:()=>R8,content_3504_1752:()=>S8,content_3504_1754:()=>E8,content_3504_1756:()=>G8,content_3504_1758:()=>U8,content_3504_176:()=>vz,content_3504_1760:()=>q8,content_3504_1762:()=>j8,content_3504_1764:()=>Q8,content_3504_1766:()=>$8,content_3504_1768:()=>J8,content_3504_1770:()=>e7,content_3504_1772:()=>o7,content_3504_1774:()=>r7,content_3504_1776:()=>c7,content_3504_1778:()=>a7,content_3504_178:()=>Zz,content_3504_1780:()=>u7,content_3504_1782:()=>d7,content_3504_1784:()=>k7,content_3504_1786:()=>y7,content_3504_1788:()=>D7,content_3504_1790:()=>_7,content_3504_1792:()=>g7,content_3504_1794:()=>x7,content_3504_1796:()=>v7,content_3504_1798:()=>Z7,content_3504_18:()=>NZ,content_3504_180:()=>Nz,content_3504_1800:()=>N7,content_3504_1802:()=>A7,content_3504_1804:()=>R7,content_3504_1806:()=>S7,content_3504_1808:()=>E7,content_3504_1810:()=>G7,content_3504_1812:()=>U7,content_3504_1814:()=>q7,content_3504_1816:()=>j7,content_3504_1818:()=>Q7,content_3504_182:()=>Az,content_3504_1820:()=>$7,content_3504_1822:()=>J7,content_3504_1824:()=>e9,content_3504_1826:()=>o9,content_3504_1828:()=>r9,content_3504_1830:()=>c9,content_3504_1832:()=>a9,content_3504_1834:()=>u9,content_3504_1836:()=>d9,content_3504_1838:()=>k9,content_3504_184:()=>Rz,content_3504_1840:()=>y9,content_3504_1842:()=>D9,content_3504_1844:()=>_9,content_3504_1846:()=>g9,content_3504_1848:()=>x9,content_3504_1850:()=>v9,content_3504_1852:()=>Z9,content_3504_1854:()=>N9,content_3504_1856:()=>A9,content_3504_1858:()=>R9,content_3504_186:()=>Sz,content_3504_1860:()=>S9,content_3504_1862:()=>E9,content_3504_1864:()=>G9,content_3504_1866:()=>U9,content_3504_1868:()=>q9,content_3504_1870:()=>j9,content_3504_1872:()=>Q9,content_3504_1874:()=>$9,content_3504_1876:()=>J9,content_3504_1878:()=>ett,content_3504_188:()=>Ez,content_3504_1880:()=>ott,content_3504_1882:()=>rtt,content_3504_1884:()=>ctt,content_3504_1886:()=>att,content_3504_1888:()=>utt,content_3504_1890:()=>dtt,content_3504_1892:()=>ktt,content_3504_1894:()=>ytt,content_3504_1896:()=>Dtt,content_3504_1898:()=>_tt,content_3504_190:()=>Gz,content_3504_1900:()=>gtt,content_3504_1902:()=>xtt,content_3504_1904:()=>vtt,content_3504_1906:()=>Ztt,content_3504_1908:()=>Ntt,content_3504_1910:()=>Att,content_3504_1912:()=>Rtt,content_3504_1914:()=>Stt,content_3504_1916:()=>Ett,content_3504_1918:()=>Gtt,content_3504_192:()=>Uz,content_3504_1920:()=>Utt,content_3504_1922:()=>qtt,content_3504_1924:()=>jtt,content_3504_1926:()=>Qtt,content_3504_1928:()=>$tt,content_3504_1930:()=>Jtt,content_3504_1932:()=>eet,content_3504_1934:()=>oet,content_3504_1936:()=>ret,content_3504_1938:()=>cet,content_3504_194:()=>qz,content_3504_1940:()=>aet,content_3504_1942:()=>met,content_3504_1944:()=>het,content_3504_1946:()=>fet,content_3504_1948:()=>Met,content_3504_1950:()=>wet,content_3504_1952:()=>Xet,content_3504_1954:()=>Tet,content_3504_1956:()=>Cet,content_3504_1958:()=>Let,content_3504_196:()=>jz,content_3504_1960:()=>bet,content_3504_1962:()=>zet,content_3504_1964:()=>Wet,content_3504_1966:()=>Iet,content_3504_1968:()=>Pet,content_3504_1970:()=>Bet,content_3504_1972:()=>Oet,content_3504_1974:()=>Fet,content_3504_1976:()=>Vet,content_3504_1978:()=>Het,content_3504_198:()=>Qz,content_3504_1980:()=>Yet,content_3504_1982:()=>Ket,content_3504_1984:()=>tnt,content_3504_1986:()=>nnt,content_3504_1988:()=>pnt,content_3504_1990:()=>snt,content_3504_1992:()=>int,content_3504_1994:()=>lnt,content_3504_1996:()=>mnt,content_3504_1998:()=>hnt,content_3504_2:()=>kZ,content_3504_20:()=>AZ,content_3504_200:()=>$z,content_3504_2000:()=>fnt,content_3504_2002:()=>Mnt,content_3504_2004:()=>wnt,content_3504_2006:()=>Xnt,content_3504_2008:()=>Tnt,content_3504_2010:()=>Cnt,content_3504_2012:()=>Lnt,content_3504_2014:()=>bnt,content_3504_2016:()=>znt,content_3504_2018:()=>Wnt,content_3504_202:()=>Jz,content_3504_2020:()=>Int,content_3504_2022:()=>Pnt,content_3504_2024:()=>Bnt,content_3504_2026:()=>Ont,content_3504_2028:()=>Fnt,content_3504_2030:()=>Vnt,content_3504_2032:()=>Hnt,content_3504_2034:()=>Ynt,content_3504_2036:()=>Knt,content_3504_2038:()=>tot,content_3504_204:()=>eA,content_3504_2040:()=>not,content_3504_2042:()=>pot,content_3504_2044:()=>sot,content_3504_2046:()=>iot,content_3504_2048:()=>lot,content_3504_2050:()=>mot,content_3504_2052:()=>hot,content_3504_2054:()=>fot,content_3504_2056:()=>Mot,content_3504_2058:()=>wot,content_3504_206:()=>oA,content_3504_2060:()=>Xot,content_3504_2062:()=>Tot,content_3504_2064:()=>Cot,content_3504_2066:()=>Lot,content_3504_2068:()=>bot,content_3504_2070:()=>zot,content_3504_2072:()=>Wot,content_3504_2074:()=>Iot,content_3504_2076:()=>Pot,content_3504_2078:()=>Bot,content_3504_208:()=>rA,content_3504_2080:()=>Oot,content_3504_2082:()=>Fot,content_3504_2084:()=>Vot,content_3504_2086:()=>Hot,content_3504_2088:()=>Yot,content_3504_2090:()=>Kot,content_3504_2092:()=>tpt,content_3504_2094:()=>npt,content_3504_2096:()=>ppt,content_3504_2098:()=>spt,content_3504_210:()=>cA,content_3504_2100:()=>ipt,content_3504_2102:()=>lpt,content_3504_2104:()=>mpt,content_3504_2106:()=>hpt,content_3504_2108:()=>fpt,content_3504_2110:()=>Mpt,content_3504_2112:()=>wpt,content_3504_2114:()=>Xpt,content_3504_2116:()=>Tpt,content_3504_2118:()=>Cpt,content_3504_212:()=>aA,content_3504_2120:()=>Lpt,content_3504_2122:()=>bpt,content_3504_2124:()=>zpt,content_3504_2126:()=>Wpt,content_3504_2128:()=>Ipt,content_3504_2130:()=>Ppt,content_3504_2132:()=>Bpt,content_3504_2134:()=>Opt,content_3504_2136:()=>Fpt,content_3504_2138:()=>Vpt,content_3504_214:()=>uA,content_3504_2140:()=>Hpt,content_3504_2142:()=>Ypt,content_3504_2144:()=>Kpt,content_3504_2146:()=>trt,content_3504_2148:()=>nrt,content_3504_2150:()=>prt,content_3504_2152:()=>srt,content_3504_2154:()=>irt,content_3504_2156:()=>lrt,content_3504_2158:()=>mrt,content_3504_216:()=>dA,content_3504_2160:()=>hrt,content_3504_2162:()=>frt,content_3504_2164:()=>Mrt,content_3504_2166:()=>wrt,content_3504_2168:()=>Xrt,content_3504_2170:()=>Trt,content_3504_2172:()=>Crt,content_3504_2174:()=>Lrt,content_3504_2176:()=>brt,content_3504_2178:()=>zrt,content_3504_218:()=>kA,content_3504_2180:()=>Wrt,content_3504_2182:()=>Irt,content_3504_2184:()=>Prt,content_3504_2186:()=>Brt,content_3504_2188:()=>Ort,content_3504_2190:()=>Frt,content_3504_2192:()=>Vrt,content_3504_2194:()=>Hrt,content_3504_2196:()=>Yrt,content_3504_2198:()=>Krt,content_3504_22:()=>RZ,content_3504_220:()=>yA,content_3504_2200:()=>tst,content_3504_2202:()=>nst,content_3504_2204:()=>pst,content_3504_2206:()=>sst,content_3504_2208:()=>ist,content_3504_2210:()=>lst,content_3504_2212:()=>mst,content_3504_2214:()=>hst,content_3504_2216:()=>fst,content_3504_2218:()=>Mst,content_3504_222:()=>DA,content_3504_2220:()=>wst,content_3504_2222:()=>Xst,content_3504_2224:()=>Tst,content_3504_2226:()=>Cst,content_3504_2228:()=>Lst,content_3504_2230:()=>bst,content_3504_2232:()=>zst,content_3504_2234:()=>Wst,content_3504_2236:()=>Ist,content_3504_2238:()=>Pst,content_3504_224:()=>_A,content_3504_2240:()=>Bst,content_3504_2242:()=>Ost,content_3504_2244:()=>Fst,content_3504_2246:()=>Vst,content_3504_2248:()=>Hst,content_3504_2250:()=>Yst,content_3504_2252:()=>Kst,content_3504_2254:()=>tct,content_3504_2256:()=>nct,content_3504_2258:()=>pct,content_3504_226:()=>gA,content_3504_2260:()=>sct,content_3504_2262:()=>ict,content_3504_2264:()=>lct,content_3504_2266:()=>mct,content_3504_2268:()=>hct,content_3504_2270:()=>fct,content_3504_2272:()=>Mct,content_3504_2274:()=>wct,content_3504_2276:()=>Xct,content_3504_2278:()=>Tct,content_3504_228:()=>xA,content_3504_2280:()=>Cct,content_3504_2282:()=>Lct,content_3504_2284:()=>bct,content_3504_2286:()=>zct,content_3504_2288:()=>Wct,content_3504_2290:()=>Ict,content_3504_2292:()=>Pct,content_3504_2294:()=>Bct,content_3504_2296:()=>Oct,content_3504_2298:()=>Fct,content_3504_230:()=>vA,content_3504_2300:()=>Vct,content_3504_2302:()=>Hct,content_3504_2304:()=>Yct,content_3504_2306:()=>Kct,content_3504_2308:()=>tit,content_3504_2310:()=>nit,content_3504_2312:()=>pit,content_3504_2314:()=>sit,content_3504_2316:()=>iit,content_3504_2318:()=>lit,content_3504_232:()=>ZA,content_3504_2320:()=>mit,content_3504_2322:()=>hit,content_3504_2324:()=>fit,content_3504_2326:()=>Mit,content_3504_2328:()=>wit,content_3504_2330:()=>Xit,content_3504_2332:()=>Tit,content_3504_2334:()=>Cit,content_3504_2336:()=>Lit,content_3504_2338:()=>bit,content_3504_234:()=>NA,content_3504_2340:()=>zit,content_3504_2342:()=>Wit,content_3504_2344:()=>Iit,content_3504_2346:()=>Pit,content_3504_2348:()=>Bit,content_3504_2350:()=>Oit,content_3504_2352:()=>Fit,content_3504_2354:()=>Vit,content_3504_2356:()=>Hit,content_3504_2358:()=>Yit,content_3504_236:()=>AA,content_3504_2360:()=>Kit,content_3504_2362:()=>tat,content_3504_2364:()=>nat,content_3504_2366:()=>pat,content_3504_2368:()=>sat,content_3504_2370:()=>iat,content_3504_2372:()=>lat,content_3504_2374:()=>mat,content_3504_2376:()=>hat,content_3504_2378:()=>fat,content_3504_238:()=>RA,content_3504_2380:()=>Mat,content_3504_2382:()=>wat,content_3504_2384:()=>Xat,content_3504_2386:()=>Tat,content_3504_2388:()=>Cat,content_3504_2390:()=>Lat,content_3504_2392:()=>bat,content_3504_2394:()=>zat,content_3504_2396:()=>Wat,content_3504_2398:()=>Iat,content_3504_24:()=>SZ,content_3504_240:()=>SA,content_3504_2400:()=>Pat,content_3504_2402:()=>Bat,content_3504_2404:()=>Oat,content_3504_2406:()=>Fat,content_3504_2408:()=>Vat,content_3504_2410:()=>Hat,content_3504_2412:()=>Yat,content_3504_2414:()=>Kat,content_3504_2416:()=>tlt,content_3504_2418:()=>nlt,content_3504_242:()=>EA,content_3504_2420:()=>plt,content_3504_2422:()=>slt,content_3504_2424:()=>ilt,content_3504_2426:()=>llt,content_3504_2428:()=>mlt,content_3504_2430:()=>hlt,content_3504_2432:()=>flt,content_3504_2434:()=>Mlt,content_3504_2436:()=>wlt,content_3504_2438:()=>Xlt,content_3504_244:()=>GA,content_3504_2440:()=>Tlt,content_3504_2442:()=>Clt,content_3504_2444:()=>Llt,content_3504_2446:()=>blt,content_3504_2448:()=>zlt,content_3504_2450:()=>Wlt,content_3504_2452:()=>Ilt,content_3504_2454:()=>Plt,content_3504_2456:()=>Blt,content_3504_2458:()=>Olt,content_3504_246:()=>UA,content_3504_2460:()=>Flt,content_3504_2462:()=>Vlt,content_3504_2464:()=>Hlt,content_3504_2466:()=>Ylt,content_3504_2468:()=>Klt,content_3504_2470:()=>tut,content_3504_2472:()=>nut,content_3504_2474:()=>put,content_3504_2476:()=>sut,content_3504_2478:()=>iut,content_3504_248:()=>qA,content_3504_2480:()=>lut,content_3504_2482:()=>mut,content_3504_2484:()=>hut,content_3504_2486:()=>fut,content_3504_2488:()=>Mut,content_3504_2490:()=>wut,content_3504_2492:()=>Xut,content_3504_2494:()=>Tut,content_3504_2496:()=>Cut,content_3504_2498:()=>Lut,content_3504_250:()=>jA,content_3504_2500:()=>but,content_3504_2502:()=>zut,content_3504_2504:()=>Wut,content_3504_2506:()=>Iut,content_3504_2508:()=>Put,content_3504_2510:()=>But,content_3504_2512:()=>Out,content_3504_2514:()=>Fut,content_3504_2516:()=>Vut,content_3504_2518:()=>Hut,content_3504_252:()=>QA,content_3504_2520:()=>Yut,content_3504_2522:()=>Kut,content_3504_2524:()=>tmt,content_3504_2526:()=>nmt,content_3504_2528:()=>pmt,content_3504_2530:()=>smt,content_3504_2532:()=>imt,content_3504_2534:()=>lmt,content_3504_2536:()=>mmt,content_3504_2538:()=>hmt,content_3504_254:()=>$A,content_3504_2540:()=>fmt,content_3504_2542:()=>Mmt,content_3504_2544:()=>wmt,content_3504_2546:()=>Xmt,content_3504_2548:()=>Tmt,content_3504_2550:()=>Cmt,content_3504_2552:()=>Lmt,content_3504_2554:()=>bmt,content_3504_2556:()=>zmt,content_3504_2558:()=>Wmt,content_3504_256:()=>JA,content_3504_2560:()=>Imt,content_3504_2562:()=>Pmt,content_3504_2564:()=>Bmt,content_3504_2566:()=>Omt,content_3504_2568:()=>Fmt,content_3504_2570:()=>Vmt,content_3504_2572:()=>Hmt,content_3504_2574:()=>Ymt,content_3504_2576:()=>Kmt,content_3504_2578:()=>tdt,content_3504_258:()=>eW,content_3504_2580:()=>ndt,content_3504_2582:()=>pdt,content_3504_2584:()=>sdt,content_3504_2586:()=>idt,content_3504_2588:()=>ldt,content_3504_2590:()=>mdt,content_3504_2592:()=>hdt,content_3504_2594:()=>fdt,content_3504_2596:()=>Mdt,content_3504_2598:()=>wdt,content_3504_26:()=>EZ,content_3504_260:()=>oW,content_3504_2600:()=>Xdt,content_3504_2602:()=>Tdt,content_3504_2604:()=>Cdt,content_3504_2606:()=>Ldt,content_3504_2608:()=>bdt,content_3504_2610:()=>zdt,content_3504_2612:()=>Wdt,content_3504_2614:()=>Idt,content_3504_2616:()=>Pdt,content_3504_2618:()=>Bdt,content_3504_262:()=>rW,content_3504_2620:()=>Odt,content_3504_2622:()=>Fdt,content_3504_2624:()=>Vdt,content_3504_2626:()=>Hdt,content_3504_2628:()=>Ydt,content_3504_2630:()=>Kdt,content_3504_2632:()=>tht,content_3504_2634:()=>nht,content_3504_2636:()=>pht,content_3504_2638:()=>sht,content_3504_264:()=>cW,content_3504_2640:()=>iht,content_3504_2642:()=>lht,content_3504_2644:()=>mht,content_3504_2646:()=>hht,content_3504_2648:()=>fht,content_3504_2650:()=>Mht,content_3504_2652:()=>wht,content_3504_2654:()=>Xht,content_3504_2656:()=>Tht,content_3504_2658:()=>Cht,content_3504_266:()=>aW,content_3504_2660:()=>Lht,content_3504_2662:()=>bht,content_3504_2664:()=>zht,content_3504_2666:()=>Wht,content_3504_2668:()=>Iht,content_3504_2670:()=>Pht,content_3504_2672:()=>Bht,content_3504_2674:()=>Oht,content_3504_2676:()=>Fht,content_3504_2678:()=>Vht,content_3504_268:()=>uW,content_3504_2680:()=>Hht,content_3504_2682:()=>Yht,content_3504_2684:()=>Kht,content_3504_2686:()=>tkt,content_3504_2688:()=>nkt,content_3504_2690:()=>pkt,content_3504_2692:()=>skt,content_3504_2694:()=>ikt,content_3504_2696:()=>lkt,content_3504_2698:()=>mkt,content_3504_270:()=>dW,content_3504_2700:()=>hkt,content_3504_2702:()=>fkt,content_3504_2704:()=>Mkt,content_3504_2706:()=>wkt,content_3504_2708:()=>Xkt,content_3504_2710:()=>Tkt,content_3504_2712:()=>Ckt,content_3504_2714:()=>Lkt,content_3504_2716:()=>bkt,content_3504_2718:()=>zkt,content_3504_272:()=>kW,content_3504_2720:()=>Wkt,content_3504_2722:()=>Ikt,content_3504_2724:()=>Pkt,content_3504_2726:()=>Bkt,content_3504_2728:()=>Okt,content_3504_2730:()=>Fkt,content_3504_2732:()=>Vkt,content_3504_2734:()=>Hkt,content_3504_2736:()=>Ykt,content_3504_2738:()=>Kkt,content_3504_274:()=>yW,content_3504_2740:()=>tft,content_3504_2742:()=>nft,content_3504_2744:()=>pft,content_3504_2746:()=>sft,content_3504_2748:()=>ift,content_3504_2750:()=>lft,content_3504_2752:()=>mft,content_3504_2754:()=>hft,content_3504_2756:()=>fft,content_3504_2758:()=>Mft,content_3504_276:()=>DW,content_3504_2760:()=>wft,content_3504_2762:()=>Xft,content_3504_2764:()=>Tft,content_3504_2766:()=>Cft,content_3504_2768:()=>Lft,content_3504_2770:()=>bft,content_3504_2772:()=>zft,content_3504_2774:()=>Wft,content_3504_2776:()=>Ift,content_3504_2778:()=>Pft,content_3504_278:()=>_W,content_3504_2780:()=>Bft,content_3504_2782:()=>Oft,content_3504_2784:()=>Fft,content_3504_2786:()=>Vft,content_3504_2788:()=>Hft,content_3504_2790:()=>Yft,content_3504_2792:()=>Kft,content_3504_2794:()=>tyt,content_3504_2796:()=>nyt,content_3504_2798:()=>pyt,content_3504_28:()=>GZ,content_3504_280:()=>gW,content_3504_2800:()=>syt,content_3504_2802:()=>iyt,content_3504_2804:()=>lyt,content_3504_2806:()=>myt,content_3504_2808:()=>hyt,content_3504_2810:()=>fyt,content_3504_2812:()=>Myt,content_3504_2814:()=>wyt,content_3504_2816:()=>Xyt,content_3504_2818:()=>Tyt,content_3504_282:()=>xW,content_3504_2820:()=>Cyt,content_3504_2822:()=>Lyt,content_3504_2824:()=>byt,content_3504_2826:()=>zyt,content_3504_2828:()=>Wyt,content_3504_2830:()=>Iyt,content_3504_2832:()=>Pyt,content_3504_2834:()=>Byt,content_3504_2836:()=>Oyt,content_3504_2838:()=>Fyt,content_3504_284:()=>vW,content_3504_2840:()=>Vyt,content_3504_2842:()=>Hyt,content_3504_2844:()=>Yyt,content_3504_2846:()=>Kyt,content_3504_2848:()=>tMt,content_3504_2850:()=>nMt,content_3504_2852:()=>pMt,content_3504_2854:()=>sMt,content_3504_2856:()=>iMt,content_3504_2858:()=>lMt,content_3504_286:()=>ZW,content_3504_2860:()=>mMt,content_3504_2862:()=>hMt,content_3504_2864:()=>fMt,content_3504_2866:()=>MMt,content_3504_2868:()=>wMt,content_3504_2870:()=>XMt,content_3504_2872:()=>TMt,content_3504_2874:()=>CMt,content_3504_2876:()=>LMt,content_3504_2878:()=>bMt,content_3504_288:()=>NW,content_3504_2880:()=>zMt,content_3504_2882:()=>WMt,content_3504_2884:()=>IMt,content_3504_2886:()=>PMt,content_3504_2888:()=>BMt,content_3504_2890:()=>OMt,content_3504_2892:()=>FMt,content_3504_2894:()=>VMt,content_3504_2896:()=>HMt,content_3504_2898:()=>YMt,content_3504_290:()=>AW,content_3504_2900:()=>KMt,content_3504_2902:()=>tDt,content_3504_2904:()=>nDt,content_3504_2906:()=>pDt,content_3504_2908:()=>sDt,content_3504_2910:()=>iDt,content_3504_2912:()=>lDt,content_3504_2914:()=>mDt,content_3504_2916:()=>hDt,content_3504_2918:()=>fDt,content_3504_292:()=>RW,content_3504_2920:()=>MDt,content_3504_2922:()=>wDt,content_3504_2924:()=>XDt,content_3504_2926:()=>TDt,content_3504_2928:()=>CDt,content_3504_2930:()=>LDt,content_3504_2932:()=>bDt,content_3504_2934:()=>zDt,content_3504_2936:()=>WDt,content_3504_2938:()=>IDt,content_3504_294:()=>SW,content_3504_2940:()=>PDt,content_3504_2942:()=>BDt,content_3504_2944:()=>ODt,content_3504_2946:()=>FDt,content_3504_2948:()=>VDt,content_3504_2950:()=>HDt,content_3504_2952:()=>YDt,content_3504_2954:()=>KDt,content_3504_2956:()=>twt,content_3504_2958:()=>nwt,content_3504_296:()=>EW,content_3504_2960:()=>pwt,content_3504_2962:()=>swt,content_3504_2964:()=>iwt,content_3504_2966:()=>lwt,content_3504_2968:()=>mwt,content_3504_2970:()=>hwt,content_3504_2972:()=>fwt,content_3504_2974:()=>Mwt,content_3504_2976:()=>wwt,content_3504_2978:()=>Xwt,content_3504_298:()=>GW,content_3504_2980:()=>Twt,content_3504_2982:()=>Cwt,content_3504_2984:()=>Lwt,content_3504_2986:()=>bwt,content_3504_2988:()=>zwt,content_3504_2990:()=>Wwt,content_3504_2992:()=>Iwt,content_3504_2994:()=>Pwt,content_3504_2996:()=>Bwt,content_3504_2998:()=>Owt,content_3504_30:()=>UZ,content_3504_300:()=>UW,content_3504_3000:()=>Fwt,content_3504_3002:()=>Vwt,content_3504_3004:()=>Hwt,content_3504_3006:()=>Ywt,content_3504_3008:()=>Kwt,content_3504_3010:()=>t_t,content_3504_3012:()=>n_t,content_3504_3014:()=>p_t,content_3504_3016:()=>s_t,content_3504_3018:()=>i_t,content_3504_302:()=>qW,content_3504_3020:()=>l_t,content_3504_3022:()=>m_t,content_3504_3024:()=>h_t,content_3504_3026:()=>f_t,content_3504_3028:()=>M_t,content_3504_3030:()=>w_t,content_3504_3032:()=>X_t,content_3504_3034:()=>T_t,content_3504_3036:()=>C_t,content_3504_3038:()=>L_t,content_3504_304:()=>jW,content_3504_3040:()=>b_t,content_3504_3042:()=>z_t,content_3504_3044:()=>W_t,content_3504_3046:()=>I_t,content_3504_3048:()=>P_t,content_3504_3050:()=>B_t,content_3504_3052:()=>O_t,content_3504_3054:()=>F_t,content_3504_3056:()=>V_t,content_3504_3058:()=>H_t,content_3504_306:()=>QW,content_3504_3060:()=>Y_t,content_3504_3062:()=>K_t,content_3504_3064:()=>tXt,content_3504_3066:()=>nXt,content_3504_3068:()=>pXt,content_3504_3070:()=>sXt,content_3504_3072:()=>iXt,content_3504_3074:()=>lXt,content_3504_3076:()=>mXt,content_3504_3078:()=>hXt,content_3504_308:()=>$W,content_3504_3080:()=>fXt,content_3504_3082:()=>MXt,content_3504_3084:()=>wXt,content_3504_3086:()=>XXt,content_3504_3088:()=>TXt,content_3504_3090:()=>CXt,content_3504_3092:()=>LXt,content_3504_3094:()=>bXt,content_3504_3096:()=>zXt,content_3504_3098:()=>WXt,content_3504_310:()=>JW,content_3504_3100:()=>IXt,content_3504_3102:()=>PXt,content_3504_3104:()=>BXt,content_3504_3106:()=>OXt,content_3504_3108:()=>FXt,content_3504_3110:()=>VXt,content_3504_3112:()=>HXt,content_3504_3114:()=>YXt,content_3504_3116:()=>KXt,content_3504_3118:()=>tgt,content_3504_312:()=>eR,content_3504_3120:()=>ngt,content_3504_3122:()=>pgt,content_3504_3124:()=>sgt,content_3504_3126:()=>igt,content_3504_3128:()=>lgt,content_3504_3130:()=>mgt,content_3504_3132:()=>hgt,content_3504_3134:()=>fgt,content_3504_3136:()=>Mgt,content_3504_3138:()=>wgt,content_3504_314:()=>oR,content_3504_3140:()=>Xgt,content_3504_3142:()=>Tgt,content_3504_3144:()=>Cgt,content_3504_3146:()=>Lgt,content_3504_3148:()=>bgt,content_3504_3150:()=>zgt,content_3504_3152:()=>Wgt,content_3504_3154:()=>Igt,content_3504_3156:()=>Pgt,content_3504_3158:()=>Bgt,content_3504_316:()=>rR,content_3504_3160:()=>Ogt,content_3504_3162:()=>Fgt,content_3504_3164:()=>Vgt,content_3504_3166:()=>Hgt,content_3504_3168:()=>Ygt,content_3504_3170:()=>Kgt,content_3504_3172:()=>tTt,content_3504_3174:()=>nTt,content_3504_3176:()=>pTt,content_3504_3178:()=>sTt,content_3504_318:()=>cR,content_3504_3180:()=>iTt,content_3504_3182:()=>lTt,content_3504_3184:()=>mTt,content_3504_3186:()=>hTt,content_3504_3188:()=>fTt,content_3504_3190:()=>MTt,content_3504_3192:()=>wTt,content_3504_3194:()=>XTt,content_3504_3196:()=>TTt,content_3504_3198:()=>CTt,content_3504_32:()=>qZ,content_3504_320:()=>aR,content_3504_3200:()=>LTt,content_3504_3202:()=>bTt,content_3504_3204:()=>zTt,content_3504_3206:()=>WTt,content_3504_3208:()=>ITt,content_3504_3210:()=>PTt,content_3504_3212:()=>BTt,content_3504_3214:()=>OTt,content_3504_3216:()=>FTt,content_3504_3218:()=>VTt,content_3504_322:()=>uR,content_3504_3220:()=>HTt,content_3504_3222:()=>YTt,content_3504_3224:()=>KTt,content_3504_3226:()=>txt,content_3504_3228:()=>nxt,content_3504_3230:()=>pxt,content_3504_3232:()=>sxt,content_3504_3234:()=>ixt,content_3504_3236:()=>lxt,content_3504_3238:()=>mxt,content_3504_324:()=>dR,content_3504_3240:()=>hxt,content_3504_3242:()=>fxt,content_3504_3244:()=>Mxt,content_3504_3246:()=>wxt,content_3504_3248:()=>Xxt,content_3504_3250:()=>Txt,content_3504_3252:()=>Cxt,content_3504_3254:()=>Lxt,content_3504_3256:()=>bxt,content_3504_3258:()=>zxt,content_3504_326:()=>kR,content_3504_3260:()=>Wxt,content_3504_3262:()=>Ixt,content_3504_3264:()=>Pxt,content_3504_3266:()=>Bxt,content_3504_3268:()=>Oxt,content_3504_3270:()=>Fxt,content_3504_3272:()=>Vxt,content_3504_3274:()=>Hxt,content_3504_3276:()=>Yxt,content_3504_3278:()=>Kxt,content_3504_328:()=>yR,content_3504_3280:()=>tCt,content_3504_3282:()=>nCt,content_3504_3284:()=>pCt,content_3504_3286:()=>sCt,content_3504_3288:()=>iCt,content_3504_3290:()=>lCt,content_3504_3292:()=>mCt,content_3504_3294:()=>hCt,content_3504_3296:()=>fCt,content_3504_3298:()=>MCt,content_3504_330:()=>DR,content_3504_3300:()=>wCt,content_3504_3302:()=>XCt,content_3504_3304:()=>TCt,content_3504_3306:()=>CCt,content_3504_3308:()=>LCt,content_3504_3310:()=>bCt,content_3504_3312:()=>zCt,content_3504_3314:()=>WCt,content_3504_3316:()=>ICt,content_3504_3318:()=>PCt,content_3504_332:()=>_R,content_3504_3320:()=>BCt,content_3504_3322:()=>OCt,content_3504_3324:()=>FCt,content_3504_3326:()=>VCt,content_3504_3328:()=>HCt,content_3504_3330:()=>YCt,content_3504_3332:()=>KCt,content_3504_3334:()=>tvt,content_3504_3336:()=>nvt,content_3504_3338:()=>pvt,content_3504_334:()=>gR,content_3504_3340:()=>svt,content_3504_3342:()=>ivt,content_3504_3344:()=>lvt,content_3504_3346:()=>mvt,content_3504_3348:()=>hvt,content_3504_3350:()=>fvt,content_3504_3352:()=>Mvt,content_3504_3354:()=>wvt,content_3504_3356:()=>Xvt,content_3504_3358:()=>Tvt,content_3504_336:()=>xR,content_3504_3360:()=>Cvt,content_3504_3362:()=>Lvt,content_3504_3364:()=>bvt,content_3504_3366:()=>zvt,content_3504_3368:()=>Wvt,content_3504_3370:()=>Ivt,content_3504_3372:()=>Pvt,content_3504_3374:()=>Bvt,content_3504_3376:()=>Ovt,content_3504_3378:()=>Fvt,content_3504_338:()=>vR,content_3504_3380:()=>Vvt,content_3504_3382:()=>Hvt,content_3504_3384:()=>Yvt,content_3504_3386:()=>Kvt,content_3504_3388:()=>tLt,content_3504_3390:()=>nLt,content_3504_3392:()=>pLt,content_3504_3394:()=>sLt,content_3504_3396:()=>iLt,content_3504_3398:()=>lLt,content_3504_34:()=>jZ,content_3504_340:()=>ZR,content_3504_3400:()=>mLt,content_3504_3402:()=>hLt,content_3504_3404:()=>fLt,content_3504_3406:()=>MLt,content_3504_3408:()=>wLt,content_3504_3410:()=>XLt,content_3504_3412:()=>TLt,content_3504_3414:()=>CLt,content_3504_3416:()=>LLt,content_3504_3418:()=>bLt,content_3504_342:()=>NR,content_3504_3420:()=>zLt,content_3504_3422:()=>WLt,content_3504_3424:()=>ILt,content_3504_3426:()=>PLt,content_3504_3428:()=>BLt,content_3504_3430:()=>OLt,content_3504_3432:()=>FLt,content_3504_3434:()=>VLt,content_3504_3436:()=>HLt,content_3504_3438:()=>YLt,content_3504_344:()=>AR,content_3504_3440:()=>KLt,content_3504_3442:()=>tZt,content_3504_3444:()=>nZt,content_3504_3446:()=>pZt,content_3504_3448:()=>sZt,content_3504_3450:()=>iZt,content_3504_3452:()=>lZt,content_3504_3454:()=>mZt,content_3504_3456:()=>hZt,content_3504_3458:()=>fZt,content_3504_346:()=>RR,content_3504_3460:()=>MZt,content_3504_3462:()=>wZt,content_3504_3464:()=>XZt,content_3504_3466:()=>TZt,content_3504_3468:()=>CZt,content_3504_3470:()=>LZt,content_3504_3472:()=>bZt,content_3504_3474:()=>zZt,content_3504_3476:()=>WZt,content_3504_3478:()=>IZt,content_3504_348:()=>SR,content_3504_3480:()=>PZt,content_3504_3482:()=>BZt,content_3504_3484:()=>OZt,content_3504_3486:()=>FZt,content_3504_3488:()=>VZt,content_3504_3490:()=>HZt,content_3504_3492:()=>YZt,content_3504_3494:()=>KZt,content_3504_3496:()=>tbt,content_3504_3498:()=>nbt,content_3504_350:()=>ER,content_3504_3500:()=>pbt,content_3504_3502:()=>sbt,content_3504_3504:()=>ibt,content_3504_3506:()=>lbt,content_3504_3508:()=>mbt,content_3504_3510:()=>hbt,content_3504_3512:()=>fbt,content_3504_3514:()=>Mbt,content_3504_3516:()=>wbt,content_3504_3518:()=>Xbt,content_3504_352:()=>GR,content_3504_3520:()=>Tbt,content_3504_3522:()=>Cbt,content_3504_3524:()=>Lbt,content_3504_3526:()=>bbt,content_3504_3528:()=>zbt,content_3504_3530:()=>Wbt,content_3504_3532:()=>Ibt,content_3504_3534:()=>Pbt,content_3504_3536:()=>Bbt,content_3504_3538:()=>Obt,content_3504_354:()=>UR,content_3504_3540:()=>Fbt,content_3504_3542:()=>Vbt,content_3504_3544:()=>Hbt,content_3504_3546:()=>Ybt,content_3504_3548:()=>Kbt,content_3504_3550:()=>tNt,content_3504_3552:()=>nNt,content_3504_3554:()=>pNt,content_3504_3556:()=>sNt,content_3504_3558:()=>iNt,content_3504_356:()=>qR,content_3504_3560:()=>lNt,content_3504_3562:()=>mNt,content_3504_3564:()=>hNt,content_3504_3566:()=>fNt,content_3504_3568:()=>MNt,content_3504_3570:()=>wNt,content_3504_3572:()=>XNt,content_3504_3574:()=>TNt,content_3504_3576:()=>CNt,content_3504_3578:()=>LNt,content_3504_358:()=>jR,content_3504_3580:()=>bNt,content_3504_3582:()=>zNt,content_3504_3584:()=>WNt,content_3504_3586:()=>INt,content_3504_3588:()=>PNt,content_3504_3590:()=>BNt,content_3504_3592:()=>ONt,content_3504_3594:()=>FNt,content_3504_3596:()=>VNt,content_3504_3598:()=>HNt,content_3504_36:()=>QZ,content_3504_360:()=>QR,content_3504_3600:()=>YNt,content_3504_3602:()=>KNt,content_3504_3604:()=>tzt,content_3504_3606:()=>nzt,content_3504_3608:()=>pzt,content_3504_3610:()=>szt,content_3504_3612:()=>izt,content_3504_3614:()=>lzt,content_3504_3616:()=>mzt,content_3504_3618:()=>hzt,content_3504_362:()=>$R,content_3504_3620:()=>fzt,content_3504_3622:()=>Mzt,content_3504_3624:()=>wzt,content_3504_3626:()=>Xzt,content_3504_3628:()=>Tzt,content_3504_3630:()=>Czt,content_3504_3632:()=>Lzt,content_3504_3634:()=>bzt,content_3504_3636:()=>zzt,content_3504_3638:()=>Wzt,content_3504_364:()=>JR,content_3504_3640:()=>Izt,content_3504_3642:()=>Pzt,content_3504_3644:()=>Bzt,content_3504_3646:()=>Ozt,content_3504_3648:()=>Fzt,content_3504_3650:()=>Vzt,content_3504_3652:()=>Hzt,content_3504_3654:()=>Yzt,content_3504_3656:()=>Kzt,content_3504_3658:()=>tAt,content_3504_366:()=>eI,content_3504_3660:()=>nAt,content_3504_3662:()=>pAt,content_3504_3664:()=>sAt,content_3504_3666:()=>iAt,content_3504_3668:()=>lAt,content_3504_3670:()=>mAt,content_3504_3672:()=>hAt,content_3504_3674:()=>fAt,content_3504_3676:()=>MAt,content_3504_3678:()=>wAt,content_3504_368:()=>oI,content_3504_3680:()=>XAt,content_3504_3682:()=>TAt,content_3504_3684:()=>CAt,content_3504_3686:()=>LAt,content_3504_3688:()=>bAt,content_3504_3690:()=>zAt,content_3504_3692:()=>WAt,content_3504_3694:()=>IAt,content_3504_3696:()=>PAt,content_3504_3698:()=>BAt,content_3504_370:()=>rI,content_3504_3700:()=>OAt,content_3504_3702:()=>FAt,content_3504_3704:()=>VAt,content_3504_3706:()=>HAt,content_3504_3708:()=>YAt,content_3504_3710:()=>KAt,content_3504_3712:()=>tWt,content_3504_3714:()=>nWt,content_3504_3716:()=>pWt,content_3504_3718:()=>sWt,content_3504_372:()=>cI,content_3504_3720:()=>iWt,content_3504_3722:()=>lWt,content_3504_3724:()=>mWt,content_3504_3726:()=>hWt,content_3504_3728:()=>fWt,content_3504_3730:()=>MWt,content_3504_3732:()=>wWt,content_3504_3734:()=>XWt,content_3504_3736:()=>TWt,content_3504_3738:()=>CWt,content_3504_374:()=>aI,content_3504_3740:()=>LWt,content_3504_3742:()=>bWt,content_3504_3744:()=>zWt,content_3504_3746:()=>WWt,content_3504_3748:()=>IWt,content_3504_3750:()=>PWt,content_3504_3752:()=>BWt,content_3504_3754:()=>OWt,content_3504_3756:()=>FWt,content_3504_3758:()=>VWt,content_3504_376:()=>uI,content_3504_3760:()=>HWt,content_3504_3762:()=>YWt,content_3504_3764:()=>KWt,content_3504_3766:()=>tRt,content_3504_3768:()=>nRt,content_3504_3770:()=>pRt,content_3504_3772:()=>sRt,content_3504_3774:()=>iRt,content_3504_3776:()=>lRt,content_3504_3778:()=>mRt,content_3504_378:()=>dI,content_3504_3780:()=>hRt,content_3504_3782:()=>fRt,content_3504_3784:()=>MRt,content_3504_3786:()=>wRt,content_3504_3788:()=>XRt,content_3504_3790:()=>TRt,content_3504_3792:()=>CRt,content_3504_3794:()=>LRt,content_3504_3796:()=>bRt,content_3504_3798:()=>zRt,content_3504_38:()=>$Z,content_3504_380:()=>kI,content_3504_3800:()=>WRt,content_3504_3802:()=>IRt,content_3504_3804:()=>PRt,content_3504_3806:()=>BRt,content_3504_3808:()=>ORt,content_3504_3810:()=>FRt,content_3504_3812:()=>VRt,content_3504_3814:()=>HRt,content_3504_3816:()=>YRt,content_3504_3818:()=>KRt,content_3504_382:()=>yI,content_3504_3820:()=>tIt,content_3504_3822:()=>nIt,content_3504_3824:()=>pIt,content_3504_3826:()=>sIt,content_3504_3828:()=>iIt,content_3504_3830:()=>lIt,content_3504_3832:()=>mIt,content_3504_3834:()=>hIt,content_3504_3836:()=>fIt,content_3504_3838:()=>MIt,content_3504_384:()=>DI,content_3504_3840:()=>wIt,content_3504_3842:()=>XIt,content_3504_3844:()=>TIt,content_3504_3846:()=>CIt,content_3504_3848:()=>LIt,content_3504_3850:()=>bIt,content_3504_3852:()=>zIt,content_3504_3854:()=>WIt,content_3504_3856:()=>IIt,content_3504_3858:()=>PIt,content_3504_386:()=>_I,content_3504_3860:()=>BIt,content_3504_3862:()=>OIt,content_3504_3864:()=>FIt,content_3504_3866:()=>VIt,content_3504_3868:()=>HIt,content_3504_3870:()=>YIt,content_3504_3872:()=>KIt,content_3504_3874:()=>tSt,content_3504_3876:()=>nSt,content_3504_3878:()=>pSt,content_3504_388:()=>gI,content_3504_3880:()=>sSt,content_3504_3882:()=>iSt,content_3504_3884:()=>lSt,content_3504_3886:()=>mSt,content_3504_3888:()=>hSt,content_3504_3890:()=>fSt,content_3504_3892:()=>MSt,content_3504_3894:()=>wSt,content_3504_3896:()=>XSt,content_3504_3898:()=>TSt,content_3504_390:()=>xI,content_3504_3900:()=>CSt,content_3504_3902:()=>LSt,content_3504_3904:()=>bSt,content_3504_3906:()=>zSt,content_3504_3908:()=>WSt,content_3504_3910:()=>ISt,content_3504_3912:()=>PSt,content_3504_3914:()=>BSt,content_3504_3916:()=>OSt,content_3504_3918:()=>FSt,content_3504_392:()=>vI,content_3504_3920:()=>VSt,content_3504_3922:()=>HSt,content_3504_3924:()=>YSt,content_3504_3926:()=>KSt,content_3504_3928:()=>tPt,content_3504_3930:()=>nPt,content_3504_3932:()=>pPt,content_3504_3934:()=>sPt,content_3504_3936:()=>iPt,content_3504_3938:()=>lPt,content_3504_394:()=>ZI,content_3504_3940:()=>mPt,content_3504_3942:()=>hPt,content_3504_3944:()=>fPt,content_3504_3946:()=>MPt,content_3504_3948:()=>wPt,content_3504_3950:()=>XPt,content_3504_3952:()=>TPt,content_3504_3954:()=>CPt,content_3504_3956:()=>LPt,content_3504_3958:()=>bPt,content_3504_396:()=>NI,content_3504_3960:()=>zPt,content_3504_3962:()=>WPt,content_3504_3964:()=>IPt,content_3504_3966:()=>PPt,content_3504_3968:()=>BPt,content_3504_3970:()=>OPt,content_3504_3972:()=>FPt,content_3504_3974:()=>VPt,content_3504_3976:()=>HPt,content_3504_3978:()=>YPt,content_3504_398:()=>AI,content_3504_3980:()=>KPt,content_3504_3982:()=>tEt,content_3504_3984:()=>nEt,content_3504_3986:()=>pEt,content_3504_3988:()=>sEt,content_3504_3990:()=>iEt,content_3504_3992:()=>lEt,content_3504_3994:()=>mEt,content_3504_3996:()=>hEt,content_3504_3998:()=>fEt,content_3504_4:()=>yZ,content_3504_40:()=>JZ,content_3504_400:()=>RI,content_3504_4000:()=>MEt,content_3504_4002:()=>wEt,content_3504_4004:()=>XEt,content_3504_4006:()=>TEt,content_3504_4008:()=>CEt,content_3504_4010:()=>LEt,content_3504_4012:()=>bEt,content_3504_4014:()=>zEt,content_3504_4016:()=>WEt,content_3504_4018:()=>IEt,content_3504_402:()=>SI,content_3504_4020:()=>PEt,content_3504_4022:()=>BEt,content_3504_4024:()=>OEt,content_3504_4026:()=>FEt,content_3504_4028:()=>VEt,content_3504_4030:()=>HEt,content_3504_4032:()=>YEt,content_3504_4034:()=>KEt,content_3504_4036:()=>tBt,content_3504_4038:()=>nBt,content_3504_404:()=>EI,content_3504_4040:()=>pBt,content_3504_4042:()=>sBt,content_3504_4044:()=>iBt,content_3504_4046:()=>lBt,content_3504_4048:()=>mBt,content_3504_4050:()=>hBt,content_3504_4052:()=>fBt,content_3504_4054:()=>MBt,content_3504_4056:()=>wBt,content_3504_4058:()=>XBt,content_3504_406:()=>GI,content_3504_4060:()=>TBt,content_3504_4062:()=>CBt,content_3504_4064:()=>LBt,content_3504_4066:()=>bBt,content_3504_4068:()=>zBt,content_3504_4070:()=>WBt,content_3504_4072:()=>IBt,content_3504_4074:()=>PBt,content_3504_4076:()=>BBt,content_3504_4078:()=>OBt,content_3504_408:()=>UI,content_3504_4080:()=>FBt,content_3504_4082:()=>VBt,content_3504_4084:()=>HBt,content_3504_4086:()=>YBt,content_3504_4088:()=>KBt,content_3504_4090:()=>tGt,content_3504_4092:()=>nGt,content_3504_4094:()=>pGt,content_3504_4096:()=>sGt,content_3504_4098:()=>iGt,content_3504_410:()=>qI,content_3504_4100:()=>lGt,content_3504_4102:()=>mGt,content_3504_4104:()=>hGt,content_3504_4106:()=>fGt,content_3504_4108:()=>MGt,content_3504_4110:()=>wGt,content_3504_4112:()=>XGt,content_3504_4114:()=>TGt,content_3504_4116:()=>CGt,content_3504_4118:()=>LGt,content_3504_412:()=>jI,content_3504_4120:()=>bGt,content_3504_4122:()=>zGt,content_3504_4124:()=>WGt,content_3504_4126:()=>IGt,content_3504_4128:()=>PGt,content_3504_4130:()=>BGt,content_3504_4132:()=>OGt,content_3504_4134:()=>FGt,content_3504_4136:()=>VGt,content_3504_4138:()=>HGt,content_3504_414:()=>QI,content_3504_4140:()=>YGt,content_3504_4142:()=>KGt,content_3504_4144:()=>tOt,content_3504_4146:()=>nOt,content_3504_4148:()=>pOt,content_3504_4150:()=>sOt,content_3504_4152:()=>iOt,content_3504_4154:()=>lOt,content_3504_4156:()=>mOt,content_3504_4158:()=>hOt,content_3504_416:()=>$I,content_3504_4160:()=>fOt,content_3504_4162:()=>MOt,content_3504_4164:()=>wOt,content_3504_4166:()=>XOt,content_3504_4168:()=>TOt,content_3504_4170:()=>COt,content_3504_4172:()=>LOt,content_3504_4174:()=>bOt,content_3504_4176:()=>zOt,content_3504_4178:()=>WOt,content_3504_418:()=>JI,content_3504_4180:()=>IOt,content_3504_4182:()=>POt,content_3504_4184:()=>BOt,content_3504_4186:()=>OOt,content_3504_4188:()=>FOt,content_3504_4190:()=>VOt,content_3504_4192:()=>HOt,content_3504_4194:()=>YOt,content_3504_4196:()=>KOt,content_3504_4198:()=>tUt,content_3504_42:()=>eb,content_3504_420:()=>eS,content_3504_4200:()=>nUt,content_3504_4202:()=>pUt,content_3504_4204:()=>sUt,content_3504_4206:()=>iUt,content_3504_4208:()=>lUt,content_3504_4210:()=>mUt,content_3504_4212:()=>hUt,content_3504_4214:()=>fUt,content_3504_4216:()=>MUt,content_3504_4218:()=>wUt,content_3504_422:()=>oS,content_3504_4220:()=>XUt,content_3504_4222:()=>TUt,content_3504_4224:()=>CUt,content_3504_4226:()=>LUt,content_3504_4228:()=>bUt,content_3504_4230:()=>zUt,content_3504_4232:()=>WUt,content_3504_4234:()=>IUt,content_3504_4236:()=>PUt,content_3504_4238:()=>BUt,content_3504_424:()=>rS,content_3504_4240:()=>OUt,content_3504_4242:()=>FUt,content_3504_4244:()=>VUt,content_3504_4246:()=>HUt,content_3504_4248:()=>YUt,content_3504_4250:()=>KUt,content_3504_4252:()=>tFt,content_3504_4254:()=>nFt,content_3504_4256:()=>pFt,content_3504_4258:()=>sFt,content_3504_426:()=>cS,content_3504_4260:()=>iFt,content_3504_4262:()=>lFt,content_3504_4264:()=>mFt,content_3504_4266:()=>hFt,content_3504_4268:()=>fFt,content_3504_4270:()=>MFt,content_3504_4272:()=>wFt,content_3504_4274:()=>XFt,content_3504_4276:()=>TFt,content_3504_4278:()=>CFt,content_3504_428:()=>aS,content_3504_4280:()=>LFt,content_3504_4282:()=>bFt,content_3504_4284:()=>zFt,content_3504_4286:()=>WFt,content_3504_4288:()=>IFt,content_3504_4290:()=>PFt,content_3504_4292:()=>BFt,content_3504_4294:()=>OFt,content_3504_4296:()=>FFt,content_3504_4298:()=>VFt,content_3504_430:()=>uS,content_3504_4300:()=>HFt,content_3504_4302:()=>YFt,content_3504_4304:()=>KFt,content_3504_4306:()=>tqt,content_3504_4308:()=>nqt,content_3504_4310:()=>pqt,content_3504_4312:()=>sqt,content_3504_4314:()=>iqt,content_3504_4316:()=>lqt,content_3504_4318:()=>mqt,content_3504_432:()=>dS,content_3504_4320:()=>hqt,content_3504_4322:()=>fqt,content_3504_4324:()=>Mqt,content_3504_4326:()=>wqt,content_3504_4328:()=>Xqt,content_3504_4330:()=>Tqt,content_3504_4332:()=>Cqt,content_3504_4334:()=>Lqt,content_3504_4336:()=>bqt,content_3504_4338:()=>zqt,content_3504_434:()=>kS,content_3504_4340:()=>Wqt,content_3504_4342:()=>Iqt,content_3504_4344:()=>Pqt,content_3504_4346:()=>Bqt,content_3504_4348:()=>Oqt,content_3504_4350:()=>Fqt,content_3504_4352:()=>Vqt,content_3504_4354:()=>Hqt,content_3504_4356:()=>Yqt,content_3504_4358:()=>Kqt,content_3504_436:()=>yS,content_3504_4360:()=>tVt,content_3504_4362:()=>nVt,content_3504_4364:()=>pVt,content_3504_4366:()=>sVt,content_3504_4368:()=>iVt,content_3504_4370:()=>lVt,content_3504_4372:()=>mVt,content_3504_4374:()=>hVt,content_3504_4376:()=>fVt,content_3504_4378:()=>MVt,content_3504_438:()=>DS,content_3504_4380:()=>wVt,content_3504_4382:()=>XVt,content_3504_4384:()=>TVt,content_3504_4386:()=>CVt,content_3504_4388:()=>LVt,content_3504_4390:()=>bVt,content_3504_4392:()=>zVt,content_3504_4394:()=>WVt,content_3504_4396:()=>IVt,content_3504_4398:()=>PVt,content_3504_44:()=>ob,content_3504_440:()=>_S,content_3504_4400:()=>BVt,content_3504_4402:()=>OVt,content_3504_4404:()=>FVt,content_3504_4406:()=>VVt,content_3504_4408:()=>HVt,content_3504_4410:()=>YVt,content_3504_4412:()=>KVt,content_3504_4414:()=>tjt,content_3504_4416:()=>njt,content_3504_4418:()=>pjt,content_3504_442:()=>gS,content_3504_4420:()=>sjt,content_3504_4422:()=>ijt,content_3504_4424:()=>ljt,content_3504_4426:()=>mjt,content_3504_4428:()=>hjt,content_3504_4430:()=>fjt,content_3504_4432:()=>Mjt,content_3504_4434:()=>wjt,content_3504_4436:()=>Xjt,content_3504_4438:()=>Tjt,content_3504_444:()=>xS,content_3504_4440:()=>Cjt,content_3504_4442:()=>Ljt,content_3504_4444:()=>bjt,content_3504_4446:()=>zjt,content_3504_4448:()=>Wjt,content_3504_4450:()=>Ijt,content_3504_4452:()=>Pjt,content_3504_4454:()=>Bjt,content_3504_4456:()=>Ojt,content_3504_4458:()=>Fjt,content_3504_446:()=>vS,content_3504_4460:()=>Vjt,content_3504_4462:()=>Hjt,content_3504_4464:()=>Yjt,content_3504_4466:()=>Kjt,content_3504_4468:()=>tHt,content_3504_4470:()=>nHt,content_3504_4472:()=>pHt,content_3504_4474:()=>sHt,content_3504_4476:()=>iHt,content_3504_4478:()=>lHt,content_3504_448:()=>ZS,content_3504_4480:()=>mHt,content_3504_4482:()=>hHt,content_3504_4484:()=>fHt,content_3504_4486:()=>MHt,content_3504_4488:()=>wHt,content_3504_4490:()=>XHt,content_3504_4492:()=>THt,content_3504_4494:()=>CHt,content_3504_4496:()=>LHt,content_3504_4498:()=>bHt,content_3504_450:()=>NS,content_3504_4500:()=>zHt,content_3504_4502:()=>WHt,content_3504_4504:()=>IHt,content_3504_4506:()=>PHt,content_3504_4508:()=>BHt,content_3504_4510:()=>OHt,content_3504_4512:()=>FHt,content_3504_4514:()=>VHt,content_3504_4516:()=>HHt,content_3504_4518:()=>YHt,content_3504_452:()=>AS,content_3504_4520:()=>KHt,content_3504_4522:()=>tQt,content_3504_4524:()=>nQt,content_3504_4526:()=>pQt,content_3504_4528:()=>sQt,content_3504_4530:()=>iQt,content_3504_4532:()=>lQt,content_3504_4534:()=>mQt,content_3504_4536:()=>hQt,content_3504_4538:()=>fQt,content_3504_454:()=>RS,content_3504_4540:()=>MQt,content_3504_4542:()=>wQt,content_3504_4544:()=>XQt,content_3504_4546:()=>TQt,content_3504_4548:()=>CQt,content_3504_4550:()=>LQt,content_3504_4552:()=>bQt,content_3504_4554:()=>zQt,content_3504_4556:()=>WQt,content_3504_4558:()=>IQt,content_3504_456:()=>SS,content_3504_4560:()=>PQt,content_3504_4562:()=>BQt,content_3504_4564:()=>OQt,content_3504_4566:()=>FQt,content_3504_4568:()=>VQt,content_3504_4570:()=>HQt,content_3504_4572:()=>YQt,content_3504_4574:()=>KQt,content_3504_4576:()=>tYt,content_3504_4578:()=>nYt,content_3504_458:()=>ES,content_3504_4580:()=>pYt,content_3504_4582:()=>sYt,content_3504_4584:()=>iYt,content_3504_4586:()=>lYt,content_3504_4588:()=>mYt,content_3504_4590:()=>hYt,content_3504_4592:()=>fYt,content_3504_4594:()=>MYt,content_3504_4596:()=>wYt,content_3504_4598:()=>XYt,content_3504_46:()=>rb,content_3504_460:()=>GS,content_3504_4600:()=>TYt,content_3504_4602:()=>CYt,content_3504_4604:()=>LYt,content_3504_4606:()=>bYt,content_3504_4608:()=>zYt,content_3504_4610:()=>WYt,content_3504_4612:()=>IYt,content_3504_4614:()=>PYt,content_3504_4616:()=>BYt,content_3504_4618:()=>OYt,content_3504_462:()=>US,content_3504_4620:()=>FYt,content_3504_4622:()=>VYt,content_3504_4624:()=>HYt,content_3504_4626:()=>YYt,content_3504_4628:()=>KYt,content_3504_4630:()=>t$t,content_3504_4632:()=>n$t,content_3504_4634:()=>p$t,content_3504_4636:()=>s$t,content_3504_4638:()=>i$t,content_3504_464:()=>qS,content_3504_4640:()=>l$t,content_3504_4642:()=>m$t,content_3504_4644:()=>h$t,content_3504_4646:()=>f$t,content_3504_4648:()=>M$t,content_3504_4650:()=>w$t,content_3504_4652:()=>X$t,content_3504_4654:()=>T$t,content_3504_4656:()=>C$t,content_3504_4658:()=>L$t,content_3504_466:()=>jS,content_3504_4660:()=>b$t,content_3504_4662:()=>z$t,content_3504_4664:()=>W$t,content_3504_4666:()=>I$t,content_3504_4668:()=>P$t,content_3504_4670:()=>B$t,content_3504_4672:()=>O$t,content_3504_4674:()=>F$t,content_3504_4676:()=>V$t,content_3504_4678:()=>H$t,content_3504_468:()=>QS,content_3504_4680:()=>Y$t,content_3504_4682:()=>K$t,content_3504_4684:()=>tKt,content_3504_4686:()=>nKt,content_3504_4688:()=>pKt,content_3504_4690:()=>sKt,content_3504_4692:()=>iKt,content_3504_4694:()=>lKt,content_3504_4696:()=>mKt,content_3504_4698:()=>hKt,content_3504_470:()=>$S,content_3504_4700:()=>fKt,content_3504_4702:()=>MKt,content_3504_4704:()=>wKt,content_3504_4706:()=>XKt,content_3504_4708:()=>TKt,content_3504_4710:()=>CKt,content_3504_4712:()=>LKt,content_3504_4714:()=>bKt,content_3504_4716:()=>zKt,content_3504_4718:()=>WKt,content_3504_472:()=>JS,content_3504_4720:()=>IKt,content_3504_4722:()=>PKt,content_3504_4724:()=>BKt,content_3504_4726:()=>OKt,content_3504_4728:()=>FKt,content_3504_4730:()=>VKt,content_3504_4732:()=>HKt,content_3504_4734:()=>YKt,content_3504_4736:()=>KKt,content_3504_4738:()=>tJt,content_3504_474:()=>eP,content_3504_4740:()=>nJt,content_3504_4742:()=>pJt,content_3504_4744:()=>sJt,content_3504_4746:()=>iJt,content_3504_4748:()=>lJt,content_3504_4750:()=>mJt,content_3504_4752:()=>hJt,content_3504_4754:()=>fJt,content_3504_4756:()=>MJt,content_3504_4758:()=>wJt,content_3504_476:()=>oP,content_3504_4760:()=>XJt,content_3504_4762:()=>TJt,content_3504_4764:()=>CJt,content_3504_4766:()=>LJt,content_3504_4768:()=>bJt,content_3504_4770:()=>zJt,content_3504_4772:()=>WJt,content_3504_4774:()=>IJt,content_3504_4776:()=>PJt,content_3504_4778:()=>BJt,content_3504_478:()=>rP,content_3504_4780:()=>OJt,content_3504_4782:()=>FJt,content_3504_4784:()=>VJt,content_3504_4786:()=>HJt,content_3504_4788:()=>YJt,content_3504_4790:()=>KJt,content_3504_4792:()=>t0t,content_3504_4794:()=>n0t,content_3504_4796:()=>p0t,content_3504_4798:()=>s0t,content_3504_48:()=>cb,content_3504_480:()=>cP,content_3504_4800:()=>i0t,content_3504_4802:()=>l0t,content_3504_4804:()=>m0t,content_3504_4806:()=>h0t,content_3504_4808:()=>f0t,content_3504_4810:()=>M0t,content_3504_4812:()=>w0t,content_3504_4814:()=>X0t,content_3504_4816:()=>T0t,content_3504_4818:()=>C0t,content_3504_482:()=>aP,content_3504_4820:()=>L0t,content_3504_4822:()=>b0t,content_3504_4824:()=>z0t,content_3504_4826:()=>W0t,content_3504_4828:()=>I0t,content_3504_4830:()=>P0t,content_3504_4832:()=>B0t,content_3504_4834:()=>O0t,content_3504_4836:()=>F0t,content_3504_4838:()=>V0t,content_3504_484:()=>uP,content_3504_4840:()=>H0t,content_3504_4842:()=>Y0t,content_3504_4844:()=>K0t,content_3504_4846:()=>t4t,content_3504_4848:()=>n4t,content_3504_4850:()=>p4t,content_3504_4852:()=>s4t,content_3504_4854:()=>i4t,content_3504_4856:()=>l4t,content_3504_4858:()=>m4t,content_3504_486:()=>dP,content_3504_4860:()=>h4t,content_3504_4862:()=>f4t,content_3504_4864:()=>M4t,content_3504_4866:()=>w4t,content_3504_4868:()=>X4t,content_3504_4870:()=>T4t,content_3504_4872:()=>C4t,content_3504_4874:()=>L4t,content_3504_4876:()=>b4t,content_3504_4878:()=>z4t,content_3504_488:()=>kP,content_3504_4880:()=>W4t,content_3504_4882:()=>I4t,content_3504_4884:()=>P4t,content_3504_4886:()=>B4t,content_3504_4888:()=>O4t,content_3504_4890:()=>F4t,content_3504_4892:()=>V4t,content_3504_4894:()=>H4t,content_3504_4896:()=>Y4t,content_3504_4898:()=>K4t,content_3504_490:()=>yP,content_3504_4900:()=>t3t,content_3504_4902:()=>n3t,content_3504_4904:()=>p3t,content_3504_4906:()=>s3t,content_3504_4908:()=>i3t,content_3504_4910:()=>l3t,content_3504_4912:()=>m3t,content_3504_4914:()=>h3t,content_3504_4916:()=>f3t,content_3504_4918:()=>M3t,content_3504_492:()=>DP,content_3504_4920:()=>w3t,content_3504_4922:()=>X3t,content_3504_4924:()=>T3t,content_3504_4926:()=>C3t,content_3504_4928:()=>L3t,content_3504_4930:()=>b3t,content_3504_4932:()=>z3t,content_3504_4934:()=>W3t,content_3504_4936:()=>I3t,content_3504_4938:()=>P3t,content_3504_494:()=>_P,content_3504_4940:()=>B3t,content_3504_4942:()=>O3t,content_3504_4944:()=>F3t,content_3504_4946:()=>V3t,content_3504_4948:()=>H3t,content_3504_4950:()=>Y3t,content_3504_4952:()=>K3t,content_3504_4954:()=>t5t,content_3504_4956:()=>n5t,content_3504_4958:()=>p5t,content_3504_496:()=>gP,content_3504_4960:()=>s5t,content_3504_4962:()=>i5t,content_3504_4964:()=>l5t,content_3504_4966:()=>m5t,content_3504_4968:()=>h5t,content_3504_4970:()=>f5t,content_3504_4972:()=>M5t,content_3504_4974:()=>w5t,content_3504_4976:()=>X5t,content_3504_4978:()=>T5t,content_3504_498:()=>xP,content_3504_4980:()=>C5t,content_3504_4982:()=>L5t,content_3504_4984:()=>b5t,content_3504_4986:()=>z5t,content_3504_4988:()=>W5t,content_3504_4990:()=>I5t,content_3504_4992:()=>P5t,content_3504_4994:()=>B5t,content_3504_4996:()=>O5t,content_3504_4998:()=>F5t,content_3504_50:()=>ab,content_3504_500:()=>vP,content_3504_5000:()=>V5t,content_3504_5002:()=>H5t,content_3504_5004:()=>Y5t,content_3504_5006:()=>K5t,content_3504_5008:()=>t2t,content_3504_5010:()=>n2t,content_3504_5012:()=>p2t,content_3504_5014:()=>s2t,content_3504_5016:()=>i2t,content_3504_5018:()=>l2t,content_3504_502:()=>ZP,content_3504_5020:()=>m2t,content_3504_5022:()=>h2t,content_3504_5024:()=>f2t,content_3504_5026:()=>M2t,content_3504_5028:()=>w2t,content_3504_5030:()=>X2t,content_3504_5032:()=>T2t,content_3504_5034:()=>C2t,content_3504_5036:()=>L2t,content_3504_5038:()=>b2t,content_3504_504:()=>NP,content_3504_5040:()=>z2t,content_3504_5042:()=>W2t,content_3504_5044:()=>I2t,content_3504_5046:()=>P2t,content_3504_5048:()=>B2t,content_3504_5050:()=>O2t,content_3504_5052:()=>F2t,content_3504_5054:()=>V2t,content_3504_5056:()=>H2t,content_3504_5058:()=>Y2t,content_3504_506:()=>AP,content_3504_5060:()=>K2t,content_3504_5062:()=>t1t,content_3504_5064:()=>n1t,content_3504_5066:()=>p1t,content_3504_5068:()=>s1t,content_3504_5070:()=>i1t,content_3504_5072:()=>l1t,content_3504_5074:()=>m1t,content_3504_5076:()=>h1t,content_3504_5078:()=>f1t,content_3504_508:()=>RP,content_3504_5080:()=>M1t,content_3504_5082:()=>w1t,content_3504_5084:()=>X1t,content_3504_5086:()=>T1t,content_3504_5088:()=>C1t,content_3504_5090:()=>L1t,content_3504_5092:()=>b1t,content_3504_5094:()=>z1t,content_3504_5096:()=>W1t,content_3504_5098:()=>I1t,content_3504_510:()=>SP,content_3504_5100:()=>P1t,content_3504_5102:()=>B1t,content_3504_5104:()=>O1t,content_3504_5106:()=>F1t,content_3504_5108:()=>V1t,content_3504_5110:()=>H1t,content_3504_5112:()=>Y1t,content_3504_5114:()=>K1t,content_3504_5116:()=>t6t,content_3504_5118:()=>n6t,content_3504_512:()=>EP,content_3504_5120:()=>p6t,content_3504_5122:()=>s6t,content_3504_5124:()=>i6t,content_3504_5126:()=>l6t,content_3504_5128:()=>m6t,content_3504_5130:()=>h6t,content_3504_5132:()=>f6t,content_3504_5134:()=>M6t,content_3504_5136:()=>w6t,content_3504_5138:()=>X6t,content_3504_514:()=>GP,content_3504_5140:()=>T6t,content_3504_5142:()=>C6t,content_3504_5144:()=>L6t,content_3504_5146:()=>b6t,content_3504_5148:()=>z6t,content_3504_5150:()=>W6t,content_3504_5152:()=>I6t,content_3504_5154:()=>P6t,content_3504_5156:()=>B6t,content_3504_5158:()=>O6t,content_3504_516:()=>UP,content_3504_5160:()=>F6t,content_3504_5162:()=>V6t,content_3504_5164:()=>H6t,content_3504_5166:()=>Y6t,content_3504_5168:()=>K6t,content_3504_5170:()=>t8t,content_3504_5172:()=>n8t,content_3504_5174:()=>p8t,content_3504_5176:()=>s8t,content_3504_5178:()=>i8t,content_3504_518:()=>qP,content_3504_5180:()=>l8t,content_3504_5182:()=>m8t,content_3504_5184:()=>h8t,content_3504_5186:()=>f8t,content_3504_5188:()=>M8t,content_3504_5190:()=>w8t,content_3504_5192:()=>X8t,content_3504_5194:()=>T8t,content_3504_5196:()=>C8t,content_3504_5198:()=>L8t,content_3504_52:()=>ub,content_3504_520:()=>jP,content_3504_5200:()=>b8t,content_3504_5202:()=>z8t,content_3504_5204:()=>W8t,content_3504_5206:()=>I8t,content_3504_5208:()=>P8t,content_3504_5210:()=>B8t,content_3504_5212:()=>O8t,content_3504_5214:()=>F8t,content_3504_5216:()=>V8t,content_3504_5218:()=>H8t,content_3504_522:()=>QP,content_3504_5220:()=>Y8t,content_3504_5222:()=>K8t,content_3504_5224:()=>t7t,content_3504_5226:()=>n7t,content_3504_5228:()=>p7t,content_3504_5230:()=>s7t,content_3504_5232:()=>i7t,content_3504_5234:()=>l7t,content_3504_5236:()=>m7t,content_3504_5238:()=>h7t,content_3504_524:()=>$P,content_3504_5240:()=>f7t,content_3504_5242:()=>M7t,content_3504_5244:()=>w7t,content_3504_5246:()=>X7t,content_3504_5248:()=>T7t,content_3504_5250:()=>C7t,content_3504_5252:()=>L7t,content_3504_5254:()=>b7t,content_3504_5256:()=>z7t,content_3504_5258:()=>W7t,content_3504_526:()=>JP,content_3504_5260:()=>I7t,content_3504_5262:()=>P7t,content_3504_5264:()=>B7t,content_3504_5266:()=>O7t,content_3504_5268:()=>F7t,content_3504_5270:()=>V7t,content_3504_5272:()=>H7t,content_3504_5274:()=>Y7t,content_3504_5276:()=>K7t,content_3504_5278:()=>t9t,content_3504_528:()=>eE,content_3504_5280:()=>n9t,content_3504_5282:()=>p9t,content_3504_5284:()=>s9t,content_3504_5286:()=>i9t,content_3504_5288:()=>l9t,content_3504_5290:()=>m9t,content_3504_5292:()=>h9t,content_3504_5294:()=>f9t,content_3504_5296:()=>M9t,content_3504_5298:()=>w9t,content_3504_530:()=>oE,content_3504_5300:()=>X9t,content_3504_5302:()=>T9t,content_3504_5304:()=>C9t,content_3504_5306:()=>L9t,content_3504_5308:()=>b9t,content_3504_5310:()=>z9t,content_3504_5312:()=>W9t,content_3504_5314:()=>I9t,content_3504_5316:()=>P9t,content_3504_5318:()=>B9t,content_3504_532:()=>rE,content_3504_5320:()=>O9t,content_3504_5322:()=>F9t,content_3504_5324:()=>V9t,content_3504_5326:()=>H9t,content_3504_5328:()=>Y9t,content_3504_5330:()=>K9t,content_3504_5332:()=>tte,content_3504_5334:()=>nte,content_3504_5336:()=>pte,content_3504_5338:()=>ste,content_3504_534:()=>cE,content_3504_5340:()=>ite,content_3504_5342:()=>lte,content_3504_5344:()=>mte,content_3504_5346:()=>hte,content_3504_5348:()=>fte,content_3504_5350:()=>Mte,content_3504_5352:()=>wte,content_3504_5354:()=>Xte,content_3504_5356:()=>Tte,content_3504_5358:()=>Cte,content_3504_536:()=>aE,content_3504_5360:()=>Lte,content_3504_5362:()=>bte,content_3504_5364:()=>zte,content_3504_5366:()=>Wte,content_3504_5368:()=>Ite,content_3504_5370:()=>Pte,content_3504_5372:()=>Bte,content_3504_5374:()=>Ote,content_3504_5376:()=>Fte,content_3504_5378:()=>Vte,content_3504_538:()=>uE,content_3504_5380:()=>Hte,content_3504_5382:()=>Yte,content_3504_5384:()=>Kte,content_3504_5386:()=>tee,content_3504_5388:()=>nee,content_3504_5390:()=>pee,content_3504_5392:()=>see,content_3504_5394:()=>iee,content_3504_5396:()=>lee,content_3504_5398:()=>mee,content_3504_54:()=>db,content_3504_540:()=>dE,content_3504_5400:()=>hee,content_3504_5402:()=>fee,content_3504_5404:()=>Mee,content_3504_5406:()=>wee,content_3504_5408:()=>Xee,content_3504_5410:()=>Tee,content_3504_5412:()=>Cee,content_3504_5414:()=>Lee,content_3504_5416:()=>bee,content_3504_5418:()=>zee,content_3504_542:()=>kE,content_3504_5420:()=>Wee,content_3504_5422:()=>Iee,content_3504_5424:()=>Pee,content_3504_5426:()=>Bee,content_3504_5428:()=>Oee,content_3504_5430:()=>Fee,content_3504_5432:()=>Vee,content_3504_5434:()=>Hee,content_3504_5436:()=>Yee,content_3504_5438:()=>Kee,content_3504_544:()=>yE,content_3504_5440:()=>tne,content_3504_5442:()=>nne,content_3504_5444:()=>pne,content_3504_5446:()=>sne,content_3504_5448:()=>ine,content_3504_5450:()=>lne,content_3504_5452:()=>mne,content_3504_5454:()=>hne,content_3504_5456:()=>fne,content_3504_5458:()=>Mne,content_3504_546:()=>DE,content_3504_5460:()=>wne,content_3504_5462:()=>Xne,content_3504_5464:()=>Tne,content_3504_5466:()=>Cne,content_3504_5468:()=>Lne,content_3504_5470:()=>bne,content_3504_5472:()=>zne,content_3504_5474:()=>Wne,content_3504_5476:()=>Ine,content_3504_5478:()=>Pne,content_3504_548:()=>_E,content_3504_5480:()=>Bne,content_3504_5482:()=>One,content_3504_5484:()=>Fne,content_3504_5486:()=>Vne,content_3504_5488:()=>Hne,content_3504_5490:()=>Yne,content_3504_5492:()=>Kne,content_3504_5494:()=>toe,content_3504_5496:()=>noe,content_3504_5498:()=>poe,content_3504_550:()=>gE,content_3504_5500:()=>soe,content_3504_5502:()=>ioe,content_3504_5504:()=>loe,content_3504_5506:()=>moe,content_3504_5508:()=>hoe,content_3504_5510:()=>foe,content_3504_5512:()=>Moe,content_3504_5514:()=>woe,content_3504_5516:()=>Xoe,content_3504_5518:()=>Toe,content_3504_552:()=>xE,content_3504_5520:()=>Coe,content_3504_5522:()=>Loe,content_3504_5524:()=>boe,content_3504_5526:()=>zoe,content_3504_5528:()=>Woe,content_3504_5530:()=>Ioe,content_3504_5532:()=>Poe,content_3504_5534:()=>Boe,content_3504_5536:()=>Ooe,content_3504_5538:()=>Foe,content_3504_554:()=>vE,content_3504_5540:()=>Voe,content_3504_5542:()=>Hoe,content_3504_5544:()=>Yoe,content_3504_5546:()=>Koe,content_3504_5548:()=>tpe,content_3504_5550:()=>npe,content_3504_5552:()=>ppe,content_3504_5554:()=>spe,content_3504_5556:()=>ipe,content_3504_5558:()=>lpe,content_3504_556:()=>ZE,content_3504_5560:()=>mpe,content_3504_5562:()=>hpe,content_3504_5564:()=>fpe,content_3504_5566:()=>Mpe,content_3504_5568:()=>wpe,content_3504_5570:()=>Xpe,content_3504_5572:()=>Tpe,content_3504_5574:()=>Cpe,content_3504_5576:()=>Lpe,content_3504_5578:()=>bpe,content_3504_558:()=>NE,content_3504_5580:()=>zpe,content_3504_5582:()=>Wpe,content_3504_5584:()=>Ipe,content_3504_5586:()=>Ppe,content_3504_5588:()=>Bpe,content_3504_5590:()=>Ope,content_3504_5592:()=>Fpe,content_3504_5594:()=>Vpe,content_3504_5596:()=>Hpe,content_3504_5598:()=>Ype,content_3504_56:()=>kb,content_3504_560:()=>AE,content_3504_5600:()=>Kpe,content_3504_5602:()=>tre,content_3504_5604:()=>nre,content_3504_5606:()=>pre,content_3504_5608:()=>sre,content_3504_5610:()=>ire,content_3504_5612:()=>lre,content_3504_5614:()=>mre,content_3504_5616:()=>hre,content_3504_5618:()=>fre,content_3504_562:()=>RE,content_3504_5620:()=>Mre,content_3504_5622:()=>wre,content_3504_5624:()=>Xre,content_3504_5626:()=>Tre,content_3504_5628:()=>Cre,content_3504_5630:()=>Lre,content_3504_5632:()=>bre,content_3504_5634:()=>zre,content_3504_5636:()=>Wre,content_3504_5638:()=>Ire,content_3504_564:()=>SE,content_3504_5640:()=>Pre,content_3504_5642:()=>Bre,content_3504_5644:()=>Ore,content_3504_5646:()=>Fre,content_3504_5648:()=>Vre,content_3504_5650:()=>Hre,content_3504_5652:()=>Yre,content_3504_5654:()=>Kre,content_3504_5656:()=>tse,content_3504_5658:()=>nse,content_3504_566:()=>EE,content_3504_5660:()=>pse,content_3504_5662:()=>sse,content_3504_5664:()=>ise,content_3504_5666:()=>lse,content_3504_5668:()=>mse,content_3504_5670:()=>hse,content_3504_5672:()=>fse,content_3504_5674:()=>Mse,content_3504_5676:()=>wse,content_3504_5678:()=>Xse,content_3504_568:()=>GE,content_3504_5680:()=>Tse,content_3504_5682:()=>Cse,content_3504_5684:()=>Lse,content_3504_5686:()=>bse,content_3504_5688:()=>zse,content_3504_5690:()=>Wse,content_3504_5692:()=>Ise,content_3504_5694:()=>Pse,content_3504_5696:()=>Bse,content_3504_5698:()=>Ose,content_3504_570:()=>UE,content_3504_5700:()=>Fse,content_3504_5702:()=>Vse,content_3504_5704:()=>Hse,content_3504_5706:()=>Yse,content_3504_5708:()=>Kse,content_3504_5710:()=>tce,content_3504_5712:()=>nce,content_3504_5714:()=>pce,content_3504_5716:()=>sce,content_3504_5718:()=>ice,content_3504_572:()=>qE,content_3504_5720:()=>lce,content_3504_5722:()=>mce,content_3504_5724:()=>hce,content_3504_5726:()=>fce,content_3504_5728:()=>Mce,content_3504_5730:()=>wce,content_3504_5732:()=>Xce,content_3504_5734:()=>Tce,content_3504_5736:()=>Cce,content_3504_5738:()=>Lce,content_3504_574:()=>jE,content_3504_5740:()=>bce,content_3504_5742:()=>zce,content_3504_5744:()=>Wce,content_3504_5746:()=>Ice,content_3504_5748:()=>Pce,content_3504_5750:()=>Bce,content_3504_5752:()=>Oce,content_3504_5754:()=>Fce,content_3504_5756:()=>Vce,content_3504_5758:()=>Hce,content_3504_576:()=>QE,content_3504_5760:()=>Yce,content_3504_5762:()=>Kce,content_3504_5764:()=>tie,content_3504_5766:()=>nie,content_3504_5768:()=>pie,content_3504_5770:()=>sie,content_3504_5772:()=>iie,content_3504_5774:()=>lie,content_3504_5776:()=>mie,content_3504_5778:()=>hie,content_3504_578:()=>$E,content_3504_5780:()=>fie,content_3504_5782:()=>Mie,content_3504_5784:()=>wie,content_3504_5786:()=>Xie,content_3504_5788:()=>Tie,content_3504_5790:()=>Cie,content_3504_5792:()=>Lie,content_3504_5794:()=>bie,content_3504_5796:()=>zie,content_3504_5798:()=>Wie,content_3504_58:()=>yb,content_3504_580:()=>JE,content_3504_5800:()=>Iie,content_3504_5802:()=>Pie,content_3504_5804:()=>Bie,content_3504_5806:()=>Oie,content_3504_5808:()=>Fie,content_3504_5810:()=>Vie,content_3504_5812:()=>Hie,content_3504_5814:()=>Yie,content_3504_5816:()=>Kie,content_3504_5818:()=>tae,content_3504_582:()=>eB,content_3504_5820:()=>nae,content_3504_5822:()=>pae,content_3504_5824:()=>sae,content_3504_5826:()=>iae,content_3504_5828:()=>lae,content_3504_5830:()=>mae,content_3504_5832:()=>hae,content_3504_5834:()=>fae,content_3504_5836:()=>Mae,content_3504_5838:()=>wae,content_3504_584:()=>oB,content_3504_5840:()=>Xae,content_3504_5842:()=>Tae,content_3504_5844:()=>Cae,content_3504_5846:()=>Lae,content_3504_5848:()=>bae,content_3504_5850:()=>zae,content_3504_5852:()=>Wae,content_3504_5854:()=>Iae,content_3504_5856:()=>Pae,content_3504_5858:()=>Bae,content_3504_586:()=>rB,content_3504_5860:()=>Oae,content_3504_5862:()=>Fae,content_3504_5864:()=>Vae,content_3504_5866:()=>Hae,content_3504_5868:()=>Yae,content_3504_5870:()=>Kae,content_3504_5872:()=>tle,content_3504_5874:()=>nle,content_3504_5876:()=>ple,content_3504_5878:()=>sle,content_3504_588:()=>cB,content_3504_5880:()=>ile,content_3504_5882:()=>lle,content_3504_5884:()=>mle,content_3504_5886:()=>hle,content_3504_5888:()=>fle,content_3504_5890:()=>Mle,content_3504_5892:()=>wle,content_3504_5894:()=>Xle,content_3504_5896:()=>Tle,content_3504_5898:()=>Cle,content_3504_590:()=>aB,content_3504_5900:()=>Lle,content_3504_5902:()=>ble,content_3504_5904:()=>zle,content_3504_5906:()=>Wle,content_3504_5908:()=>Ile,content_3504_5910:()=>Ple,content_3504_5912:()=>Ble,content_3504_5914:()=>Ole,content_3504_5916:()=>Fle,content_3504_5918:()=>Vle,content_3504_592:()=>uB,content_3504_5920:()=>Hle,content_3504_5922:()=>Yle,content_3504_5924:()=>Kle,content_3504_5926:()=>tue,content_3504_5928:()=>nue,content_3504_5930:()=>pue,content_3504_5932:()=>sue,content_3504_5934:()=>iue,content_3504_5936:()=>lue,content_3504_5938:()=>mue,content_3504_594:()=>dB,content_3504_5940:()=>hue,content_3504_5942:()=>fue,content_3504_5944:()=>Mue,content_3504_5946:()=>wue,content_3504_5948:()=>Xue,content_3504_5950:()=>Tue,content_3504_5952:()=>Cue,content_3504_5954:()=>Lue,content_3504_5956:()=>bue,content_3504_5958:()=>zue,content_3504_596:()=>kB,content_3504_5960:()=>Wue,content_3504_5962:()=>Iue,content_3504_5964:()=>Pue,content_3504_5966:()=>Bue,content_3504_5968:()=>Oue,content_3504_5970:()=>Fue,content_3504_5972:()=>Vue,content_3504_5974:()=>Hue,content_3504_5976:()=>Yue,content_3504_5978:()=>Kue,content_3504_598:()=>yB,content_3504_5980:()=>tme,content_3504_5982:()=>nme,content_3504_5984:()=>pme,content_3504_5986:()=>sme,content_3504_5988:()=>ime,content_3504_5990:()=>lme,content_3504_5992:()=>mme,content_3504_5994:()=>hme,content_3504_5996:()=>fme,content_3504_5998:()=>Mme,content_3504_6:()=>DZ,content_3504_60:()=>Db,content_3504_600:()=>DB,content_3504_6000:()=>wme,content_3504_6002:()=>Xme,content_3504_6004:()=>Tme,content_3504_6006:()=>Cme,content_3504_6008:()=>Lme,content_3504_6010:()=>bme,content_3504_6012:()=>zme,content_3504_6014:()=>Wme,content_3504_6016:()=>Ime,content_3504_6018:()=>Pme,content_3504_602:()=>_B,content_3504_6020:()=>Bme,content_3504_6022:()=>Ome,content_3504_6024:()=>Fme,content_3504_6026:()=>Vme,content_3504_6028:()=>Hme,content_3504_6030:()=>Yme,content_3504_6032:()=>Kme,content_3504_6034:()=>tde,content_3504_6036:()=>nde,content_3504_6038:()=>pde,content_3504_604:()=>gB,content_3504_6040:()=>sde,content_3504_6042:()=>ide,content_3504_6044:()=>lde,content_3504_6046:()=>mde,content_3504_6048:()=>hde,content_3504_6050:()=>fde,content_3504_6052:()=>Mde,content_3504_6054:()=>wde,content_3504_6056:()=>Xde,content_3504_6058:()=>Tde,content_3504_606:()=>xB,content_3504_6060:()=>Cde,content_3504_6062:()=>Lde,content_3504_6064:()=>bde,content_3504_6066:()=>zde,content_3504_6068:()=>Wde,content_3504_6070:()=>Ide,content_3504_6072:()=>Pde,content_3504_6074:()=>Bde,content_3504_6076:()=>Ode,content_3504_6078:()=>Fde,content_3504_608:()=>vB,content_3504_6080:()=>Vde,content_3504_6082:()=>Hde,content_3504_6084:()=>Yde,content_3504_6086:()=>Kde,content_3504_6088:()=>the,content_3504_6090:()=>nhe,content_3504_6092:()=>phe,content_3504_6094:()=>she,content_3504_6096:()=>ihe,content_3504_6098:()=>lhe,content_3504_610:()=>ZB,content_3504_6100:()=>mhe,content_3504_6102:()=>hhe,content_3504_6104:()=>fhe,content_3504_6106:()=>Mhe,content_3504_6108:()=>whe,content_3504_6110:()=>Xhe,content_3504_6112:()=>The,content_3504_6114:()=>Che,content_3504_6116:()=>Lhe,content_3504_6118:()=>bhe,content_3504_612:()=>NB,content_3504_6120:()=>zhe,content_3504_6122:()=>Whe,content_3504_6124:()=>Ihe,content_3504_6126:()=>Phe,content_3504_6128:()=>Bhe,content_3504_6130:()=>Ohe,content_3504_6132:()=>Fhe,content_3504_6134:()=>Vhe,content_3504_6136:()=>Hhe,content_3504_6138:()=>Yhe,content_3504_614:()=>AB,content_3504_6140:()=>Khe,content_3504_6142:()=>tke,content_3504_6144:()=>nke,content_3504_6146:()=>pke,content_3504_6148:()=>ske,content_3504_6150:()=>ike,content_3504_6152:()=>lke,content_3504_6154:()=>mke,content_3504_6156:()=>hke,content_3504_6158:()=>fke,content_3504_616:()=>RB,content_3504_6160:()=>Mke,content_3504_6162:()=>wke,content_3504_6164:()=>Xke,content_3504_6166:()=>Tke,content_3504_6168:()=>Cke,content_3504_6170:()=>Lke,content_3504_6172:()=>bke,content_3504_6174:()=>zke,content_3504_6176:()=>Wke,content_3504_6178:()=>Ike,content_3504_618:()=>SB,content_3504_6180:()=>Pke,content_3504_6182:()=>Bke,content_3504_6184:()=>Oke,content_3504_6186:()=>Fke,content_3504_6188:()=>Vke,content_3504_6190:()=>Hke,content_3504_6192:()=>Yke,content_3504_6194:()=>Kke,content_3504_6196:()=>tfe,content_3504_6198:()=>nfe,content_3504_62:()=>_b,content_3504_620:()=>EB,content_3504_6200:()=>pfe,content_3504_6202:()=>sfe,content_3504_6204:()=>ife,content_3504_6206:()=>lfe,content_3504_6208:()=>mfe,content_3504_6210:()=>hfe,content_3504_6212:()=>ffe,content_3504_6214:()=>Mfe,content_3504_6216:()=>wfe,content_3504_6218:()=>Xfe,content_3504_622:()=>GB,content_3504_6220:()=>Tfe,content_3504_6222:()=>Cfe,content_3504_6224:()=>Lfe,content_3504_6226:()=>bfe,content_3504_6228:()=>zfe,content_3504_6230:()=>Wfe,content_3504_6232:()=>Ife,content_3504_6234:()=>Pfe,content_3504_6236:()=>Bfe,content_3504_6238:()=>Ofe,content_3504_624:()=>UB,content_3504_6240:()=>Ffe,content_3504_6242:()=>Vfe,content_3504_6244:()=>Hfe,content_3504_6246:()=>Yfe,content_3504_6248:()=>Kfe,content_3504_6250:()=>tye,content_3504_6252:()=>nye,content_3504_6254:()=>pye,content_3504_6256:()=>sye,content_3504_6258:()=>iye,content_3504_626:()=>qB,content_3504_6260:()=>lye,content_3504_6262:()=>mye,content_3504_6264:()=>hye,content_3504_6266:()=>fye,content_3504_6268:()=>Mye,content_3504_6270:()=>wye,content_3504_6272:()=>Xye,content_3504_6274:()=>Tye,content_3504_6276:()=>Cye,content_3504_6278:()=>Lye,content_3504_628:()=>jB,content_3504_6280:()=>bye,content_3504_6282:()=>zye,content_3504_6284:()=>Wye,content_3504_6286:()=>Iye,content_3504_6288:()=>Pye,content_3504_6290:()=>Bye,content_3504_6292:()=>Oye,content_3504_6294:()=>Fye,content_3504_6296:()=>Vye,content_3504_6298:()=>Hye,content_3504_630:()=>QB,content_3504_6300:()=>Yye,content_3504_6302:()=>Kye,content_3504_6304:()=>tMe,content_3504_6306:()=>nMe,content_3504_6308:()=>pMe,content_3504_6310:()=>sMe,content_3504_6312:()=>iMe,content_3504_6314:()=>lMe,content_3504_6316:()=>mMe,content_3504_6318:()=>hMe,content_3504_632:()=>$B,content_3504_6320:()=>fMe,content_3504_6322:()=>MMe,content_3504_6324:()=>wMe,content_3504_6326:()=>XMe,content_3504_6328:()=>TMe,content_3504_6330:()=>CMe,content_3504_6332:()=>LMe,content_3504_6334:()=>bMe,content_3504_6336:()=>zMe,content_3504_6338:()=>WMe,content_3504_634:()=>JB,content_3504_6340:()=>IMe,content_3504_6342:()=>PMe,content_3504_6344:()=>BMe,content_3504_6346:()=>OMe,content_3504_6348:()=>FMe,content_3504_6350:()=>VMe,content_3504_6352:()=>HMe,content_3504_6354:()=>YMe,content_3504_6356:()=>KMe,content_3504_6358:()=>tDe,content_3504_636:()=>eG,content_3504_6360:()=>nDe,content_3504_6362:()=>pDe,content_3504_6364:()=>sDe,content_3504_6366:()=>iDe,content_3504_6368:()=>lDe,content_3504_6370:()=>mDe,content_3504_6372:()=>hDe,content_3504_6374:()=>fDe,content_3504_6376:()=>MDe,content_3504_6378:()=>wDe,content_3504_638:()=>oG,content_3504_6380:()=>XDe,content_3504_6382:()=>TDe,content_3504_6384:()=>CDe,content_3504_6386:()=>LDe,content_3504_6388:()=>bDe,content_3504_6390:()=>zDe,content_3504_6392:()=>WDe,content_3504_6394:()=>IDe,content_3504_6396:()=>PDe,content_3504_6398:()=>BDe,content_3504_64:()=>gb,content_3504_640:()=>rG,content_3504_6400:()=>ODe,content_3504_6402:()=>FDe,content_3504_6404:()=>VDe,content_3504_6406:()=>HDe,content_3504_6408:()=>YDe,content_3504_6410:()=>KDe,content_3504_6412:()=>twe,content_3504_6414:()=>nwe,content_3504_6416:()=>pwe,content_3504_6418:()=>swe,content_3504_642:()=>cG,content_3504_6420:()=>iwe,content_3504_6422:()=>lwe,content_3504_6424:()=>mwe,content_3504_6426:()=>hwe,content_3504_6428:()=>fwe,content_3504_6430:()=>Mwe,content_3504_6432:()=>wwe,content_3504_6434:()=>Xwe,content_3504_6436:()=>Twe,content_3504_6438:()=>Cwe,content_3504_644:()=>aG,content_3504_6440:()=>Lwe,content_3504_6442:()=>bwe,content_3504_6444:()=>zwe,content_3504_6446:()=>Wwe,content_3504_6448:()=>Iwe,content_3504_6450:()=>Pwe,content_3504_6452:()=>Bwe,content_3504_6454:()=>Owe,content_3504_6456:()=>Fwe,content_3504_6458:()=>Vwe,content_3504_646:()=>uG,content_3504_6460:()=>Hwe,content_3504_6462:()=>Ywe,content_3504_6464:()=>Kwe,content_3504_6466:()=>t_e,content_3504_6468:()=>n_e,content_3504_6470:()=>p_e,content_3504_6472:()=>s_e,content_3504_6474:()=>i_e,content_3504_6476:()=>l_e,content_3504_6478:()=>m_e,content_3504_648:()=>dG,content_3504_6480:()=>h_e,content_3504_6482:()=>f_e,content_3504_6484:()=>M_e,content_3504_6486:()=>w_e,content_3504_6488:()=>X_e,content_3504_6490:()=>T_e,content_3504_6492:()=>C_e,content_3504_6494:()=>L_e,content_3504_6496:()=>b_e,content_3504_6498:()=>z_e,content_3504_650:()=>kG,content_3504_6500:()=>W_e,content_3504_6502:()=>I_e,content_3504_6504:()=>P_e,content_3504_6506:()=>B_e,content_3504_6508:()=>O_e,content_3504_6510:()=>F_e,content_3504_6512:()=>V_e,content_3504_6514:()=>H_e,content_3504_6516:()=>Y_e,content_3504_6518:()=>K_e,content_3504_652:()=>yG,content_3504_6520:()=>tXe,content_3504_6522:()=>nXe,content_3504_6524:()=>pXe,content_3504_6526:()=>sXe,content_3504_6528:()=>iXe,content_3504_6530:()=>lXe,content_3504_6532:()=>mXe,content_3504_6534:()=>hXe,content_3504_6536:()=>fXe,content_3504_6538:()=>MXe,content_3504_654:()=>DG,content_3504_6540:()=>wXe,content_3504_6542:()=>XXe,content_3504_6544:()=>TXe,content_3504_6546:()=>CXe,content_3504_6548:()=>LXe,content_3504_6550:()=>bXe,content_3504_6552:()=>zXe,content_3504_6554:()=>WXe,content_3504_6556:()=>IXe,content_3504_6558:()=>PXe,content_3504_656:()=>_G,content_3504_6560:()=>BXe,content_3504_6562:()=>OXe,content_3504_6564:()=>FXe,content_3504_6566:()=>VXe,content_3504_6568:()=>HXe,content_3504_6570:()=>YXe,content_3504_6572:()=>KXe,content_3504_6574:()=>tge,content_3504_6576:()=>nge,content_3504_6578:()=>pge,content_3504_658:()=>gG,content_3504_6580:()=>sge,content_3504_6582:()=>ige,content_3504_6584:()=>lge,content_3504_6586:()=>mge,content_3504_6588:()=>hge,content_3504_6590:()=>fge,content_3504_6592:()=>Mge,content_3504_6594:()=>wge,content_3504_6596:()=>Xge,content_3504_6598:()=>Tge,content_3504_66:()=>xb,content_3504_660:()=>xG,content_3504_6600:()=>Cge,content_3504_6602:()=>Lge,content_3504_6604:()=>bge,content_3504_6606:()=>zge,content_3504_6608:()=>Wge,content_3504_6610:()=>Ige,content_3504_6612:()=>Pge,content_3504_6614:()=>Bge,content_3504_6616:()=>Oge,content_3504_6618:()=>Fge,content_3504_662:()=>vG,content_3504_6620:()=>Vge,content_3504_6622:()=>Hge,content_3504_6624:()=>Yge,content_3504_6626:()=>Kge,content_3504_6628:()=>tTe,content_3504_6630:()=>nTe,content_3504_6632:()=>pTe,content_3504_6634:()=>sTe,content_3504_6636:()=>iTe,content_3504_6638:()=>lTe,content_3504_664:()=>ZG,content_3504_6640:()=>mTe,content_3504_6642:()=>hTe,content_3504_6644:()=>fTe,content_3504_6646:()=>MTe,content_3504_6648:()=>wTe,content_3504_6650:()=>XTe,content_3504_6652:()=>TTe,content_3504_6654:()=>CTe,content_3504_6656:()=>LTe,content_3504_6658:()=>bTe,content_3504_666:()=>NG,content_3504_6660:()=>zTe,content_3504_6662:()=>WTe,content_3504_6664:()=>ITe,content_3504_6666:()=>PTe,content_3504_6668:()=>BTe,content_3504_6670:()=>OTe,content_3504_6672:()=>FTe,content_3504_6674:()=>VTe,content_3504_6676:()=>HTe,content_3504_6678:()=>YTe,content_3504_668:()=>AG,content_3504_6680:()=>KTe,content_3504_6682:()=>txe,content_3504_6684:()=>nxe,content_3504_6686:()=>pxe,content_3504_6688:()=>sxe,content_3504_6690:()=>ixe,content_3504_6692:()=>lxe,content_3504_6694:()=>mxe,content_3504_6696:()=>hxe,content_3504_6698:()=>fxe,content_3504_670:()=>RG,content_3504_6700:()=>Mxe,content_3504_6702:()=>wxe,content_3504_6704:()=>Xxe,content_3504_6706:()=>Txe,content_3504_6708:()=>Cxe,content_3504_6710:()=>Lxe,content_3504_6712:()=>bxe,content_3504_6714:()=>zxe,content_3504_6716:()=>Wxe,content_3504_6718:()=>Ixe,content_3504_672:()=>SG,content_3504_6720:()=>Pxe,content_3504_6722:()=>Bxe,content_3504_6724:()=>Oxe,content_3504_6726:()=>Fxe,content_3504_6728:()=>Vxe,content_3504_6730:()=>Hxe,content_3504_6732:()=>Yxe,content_3504_6734:()=>Kxe,content_3504_6736:()=>tCe,content_3504_6738:()=>nCe,content_3504_674:()=>EG,content_3504_6740:()=>pCe,content_3504_6742:()=>sCe,content_3504_6744:()=>iCe,content_3504_6746:()=>lCe,content_3504_6748:()=>mCe,content_3504_6750:()=>hCe,content_3504_6752:()=>fCe,content_3504_6754:()=>MCe,content_3504_6756:()=>wCe,content_3504_6758:()=>XCe,content_3504_676:()=>GG,content_3504_6760:()=>TCe,content_3504_6762:()=>CCe,content_3504_6764:()=>LCe,content_3504_6766:()=>bCe,content_3504_6768:()=>zCe,content_3504_6770:()=>WCe,content_3504_6772:()=>ICe,content_3504_6774:()=>PCe,content_3504_6776:()=>BCe,content_3504_6778:()=>OCe,content_3504_678:()=>UG,content_3504_6780:()=>FCe,content_3504_6782:()=>VCe,content_3504_6784:()=>HCe,content_3504_6786:()=>YCe,content_3504_6788:()=>KCe,content_3504_6790:()=>tve,content_3504_6792:()=>nve,content_3504_6794:()=>pve,content_3504_6796:()=>sve,content_3504_6798:()=>ive,content_3504_68:()=>vb,content_3504_680:()=>qG,content_3504_6800:()=>lve,content_3504_6802:()=>mve,content_3504_6804:()=>hve,content_3504_6806:()=>fve,content_3504_6808:()=>Mve,content_3504_6810:()=>wve,content_3504_6812:()=>Xve,content_3504_6814:()=>Tve,content_3504_6816:()=>Cve,content_3504_6818:()=>Lve,content_3504_682:()=>jG,content_3504_6820:()=>bve,content_3504_6822:()=>zve,content_3504_6824:()=>Wve,content_3504_6826:()=>Ive,content_3504_6828:()=>Pve,content_3504_6830:()=>Bve,content_3504_6832:()=>Ove,content_3504_6834:()=>Fve,content_3504_6836:()=>Vve,content_3504_6838:()=>Hve,content_3504_684:()=>QG,content_3504_6840:()=>Yve,content_3504_6842:()=>Kve,content_3504_6844:()=>tLe,content_3504_6846:()=>nLe,content_3504_6848:()=>pLe,content_3504_6850:()=>sLe,content_3504_6852:()=>iLe,content_3504_6854:()=>lLe,content_3504_6856:()=>mLe,content_3504_6858:()=>hLe,content_3504_686:()=>$G,content_3504_6860:()=>fLe,content_3504_6862:()=>MLe,content_3504_6864:()=>wLe,content_3504_6866:()=>XLe,content_3504_6868:()=>TLe,content_3504_6870:()=>CLe,content_3504_6872:()=>LLe,content_3504_6874:()=>bLe,content_3504_6876:()=>zLe,content_3504_6878:()=>WLe,content_3504_688:()=>JG,content_3504_6880:()=>ILe,content_3504_6882:()=>PLe,content_3504_6884:()=>BLe,content_3504_6886:()=>OLe,content_3504_6888:()=>FLe,content_3504_6890:()=>VLe,content_3504_6892:()=>HLe,content_3504_6894:()=>YLe,content_3504_6896:()=>KLe,content_3504_6898:()=>tZe,content_3504_690:()=>eO,content_3504_6900:()=>nZe,content_3504_6902:()=>pZe,content_3504_6904:()=>sZe,content_3504_6906:()=>iZe,content_3504_6908:()=>lZe,content_3504_6910:()=>mZe,content_3504_6912:()=>hZe,content_3504_6914:()=>fZe,content_3504_6916:()=>MZe,content_3504_6918:()=>wZe,content_3504_692:()=>oO,content_3504_6920:()=>XZe,content_3504_6922:()=>TZe,content_3504_6924:()=>CZe,content_3504_6926:()=>LZe,content_3504_6928:()=>bZe,content_3504_6930:()=>zZe,content_3504_6932:()=>WZe,content_3504_6934:()=>IZe,content_3504_6936:()=>PZe,content_3504_6938:()=>BZe,content_3504_694:()=>rO,content_3504_6940:()=>OZe,content_3504_6942:()=>FZe,content_3504_6944:()=>VZe,content_3504_6946:()=>HZe,content_3504_6948:()=>YZe,content_3504_6950:()=>KZe,content_3504_6952:()=>tbe,content_3504_6954:()=>nbe,content_3504_6956:()=>pbe,content_3504_6958:()=>sbe,content_3504_696:()=>cO,content_3504_6960:()=>ibe,content_3504_6962:()=>lbe,content_3504_6964:()=>mbe,content_3504_6966:()=>hbe,content_3504_6968:()=>fbe,content_3504_6970:()=>Mbe,content_3504_6972:()=>wbe,content_3504_6974:()=>Xbe,content_3504_6976:()=>Tbe,content_3504_6978:()=>Cbe,content_3504_698:()=>aO,content_3504_6980:()=>Lbe,content_3504_6982:()=>bbe,content_3504_6984:()=>zbe,content_3504_6986:()=>Wbe,content_3504_6988:()=>Ibe,content_3504_6990:()=>Pbe,content_3504_6992:()=>Bbe,content_3504_6994:()=>Obe,content_3504_6996:()=>Fbe,content_3504_6998:()=>Vbe,content_3504_70:()=>Zb,content_3504_700:()=>uO,content_3504_7000:()=>Hbe,content_3504_7002:()=>Ybe,content_3504_7004:()=>Kbe,content_3504_7006:()=>tNe,content_3504_7008:()=>nNe,content_3504_7010:()=>pNe,content_3504_7012:()=>sNe,content_3504_7014:()=>iNe,content_3504_7016:()=>lNe,content_3504_7018:()=>mNe,content_3504_702:()=>dO,content_3504_7020:()=>hNe,content_3504_7022:()=>fNe,content_3504_7024:()=>MNe,content_3504_7026:()=>wNe,content_3504_7028:()=>XNe,content_3504_7030:()=>TNe,content_3504_7032:()=>CNe,content_3504_7034:()=>LNe,content_3504_7036:()=>bNe,content_3504_7038:()=>zNe,content_3504_704:()=>kO,content_3504_7040:()=>WNe,content_3504_7042:()=>INe,content_3504_7044:()=>PNe,content_3504_7046:()=>BNe,content_3504_7048:()=>ONe,content_3504_7050:()=>FNe,content_3504_7052:()=>VNe,content_3504_7054:()=>HNe,content_3504_7056:()=>YNe,content_3504_7058:()=>KNe,content_3504_706:()=>yO,content_3504_7060:()=>tze,content_3504_7062:()=>nze,content_3504_7064:()=>pze,content_3504_7066:()=>sze,content_3504_7068:()=>ize,content_3504_7070:()=>lze,content_3504_7072:()=>mze,content_3504_7074:()=>hze,content_3504_7076:()=>fze,content_3504_7078:()=>Mze,content_3504_708:()=>DO,content_3504_7080:()=>wze,content_3504_7082:()=>Xze,content_3504_7084:()=>Tze,content_3504_7086:()=>Cze,content_3504_7088:()=>Lze,content_3504_7090:()=>bze,content_3504_7092:()=>zze,content_3504_7094:()=>Wze,content_3504_7096:()=>Ize,content_3504_7098:()=>Pze,content_3504_710:()=>_O,content_3504_7100:()=>Bze,content_3504_7102:()=>Oze,content_3504_7104:()=>Fze,content_3504_7106:()=>Vze,content_3504_7108:()=>Hze,content_3504_7110:()=>Yze,content_3504_7112:()=>Kze,content_3504_7114:()=>tAe,content_3504_7116:()=>nAe,content_3504_7118:()=>pAe,content_3504_712:()=>gO,content_3504_7120:()=>sAe,content_3504_7122:()=>iAe,content_3504_7124:()=>lAe,content_3504_7126:()=>mAe,content_3504_7128:()=>hAe,content_3504_7130:()=>fAe,content_3504_7132:()=>MAe,content_3504_7134:()=>wAe,content_3504_7136:()=>XAe,content_3504_7138:()=>TAe,content_3504_714:()=>xO,content_3504_7140:()=>CAe,content_3504_7142:()=>LAe,content_3504_7144:()=>bAe,content_3504_7146:()=>zAe,content_3504_7148:()=>WAe,content_3504_7150:()=>IAe,content_3504_7152:()=>PAe,content_3504_7154:()=>BAe,content_3504_7156:()=>OAe,content_3504_7158:()=>FAe,content_3504_716:()=>vO,content_3504_7160:()=>VAe,content_3504_7162:()=>HAe,content_3504_7164:()=>YAe,content_3504_7166:()=>KAe,content_3504_7168:()=>tWe,content_3504_7170:()=>nWe,content_3504_7172:()=>pWe,content_3504_7174:()=>sWe,content_3504_7176:()=>iWe,content_3504_7178:()=>lWe,content_3504_718:()=>ZO,content_3504_7180:()=>mWe,content_3504_7182:()=>hWe,content_3504_7184:()=>fWe,content_3504_7186:()=>MWe,content_3504_7188:()=>wWe,content_3504_7190:()=>XWe,content_3504_7192:()=>TWe,content_3504_7194:()=>CWe,content_3504_7196:()=>LWe,content_3504_7198:()=>bWe,content_3504_72:()=>Nb,content_3504_720:()=>NO,content_3504_7200:()=>zWe,content_3504_7202:()=>WWe,content_3504_7204:()=>IWe,content_3504_7206:()=>PWe,content_3504_7208:()=>BWe,content_3504_7210:()=>OWe,content_3504_7212:()=>FWe,content_3504_7214:()=>VWe,content_3504_7216:()=>HWe,content_3504_7218:()=>YWe,content_3504_722:()=>AO,content_3504_7220:()=>KWe,content_3504_7222:()=>tRe,content_3504_7224:()=>nRe,content_3504_7226:()=>pRe,content_3504_7228:()=>sRe,content_3504_7230:()=>iRe,content_3504_7232:()=>lRe,content_3504_7234:()=>mRe,content_3504_7236:()=>hRe,content_3504_7238:()=>fRe,content_3504_724:()=>RO,content_3504_7240:()=>MRe,content_3504_7242:()=>wRe,content_3504_7244:()=>XRe,content_3504_7246:()=>TRe,content_3504_7248:()=>CRe,content_3504_7250:()=>LRe,content_3504_7252:()=>bRe,content_3504_7254:()=>zRe,content_3504_7256:()=>WRe,content_3504_7258:()=>IRe,content_3504_726:()=>SO,content_3504_7260:()=>PRe,content_3504_7262:()=>BRe,content_3504_7264:()=>ORe,content_3504_7266:()=>FRe,content_3504_7268:()=>VRe,content_3504_7270:()=>HRe,content_3504_7272:()=>YRe,content_3504_7274:()=>KRe,content_3504_7276:()=>tIe,content_3504_7278:()=>nIe,content_3504_728:()=>EO,content_3504_7280:()=>pIe,content_3504_7282:()=>sIe,content_3504_7284:()=>iIe,content_3504_7286:()=>lIe,content_3504_7288:()=>mIe,content_3504_7290:()=>hIe,content_3504_7292:()=>fIe,content_3504_7294:()=>MIe,content_3504_7296:()=>wIe,content_3504_7298:()=>XIe,content_3504_730:()=>GO,content_3504_7300:()=>TIe,content_3504_7302:()=>CIe,content_3504_7304:()=>LIe,content_3504_7306:()=>bIe,content_3504_7308:()=>zIe,content_3504_7310:()=>WIe,content_3504_7312:()=>IIe,content_3504_7314:()=>PIe,content_3504_7316:()=>BIe,content_3504_7318:()=>OIe,content_3504_732:()=>UO,content_3504_7320:()=>FIe,content_3504_7322:()=>VIe,content_3504_7324:()=>HIe,content_3504_7326:()=>YIe,content_3504_7328:()=>KIe,content_3504_7330:()=>tSe,content_3504_7332:()=>nSe,content_3504_7334:()=>pSe,content_3504_7336:()=>sSe,content_3504_7338:()=>iSe,content_3504_734:()=>qO,content_3504_7340:()=>lSe,content_3504_7342:()=>mSe,content_3504_7344:()=>hSe,content_3504_7346:()=>fSe,content_3504_7348:()=>MSe,content_3504_7350:()=>wSe,content_3504_7352:()=>XSe,content_3504_7354:()=>TSe,content_3504_7356:()=>CSe,content_3504_7358:()=>LSe,content_3504_736:()=>jO,content_3504_7360:()=>bSe,content_3504_7362:()=>zSe,content_3504_7364:()=>WSe,content_3504_7366:()=>ISe,content_3504_7368:()=>PSe,content_3504_7370:()=>BSe,content_3504_7372:()=>OSe,content_3504_7374:()=>FSe,content_3504_7376:()=>VSe,content_3504_7378:()=>HSe,content_3504_738:()=>QO,content_3504_7380:()=>YSe,content_3504_7382:()=>KSe,content_3504_7384:()=>tPe,content_3504_7386:()=>nPe,content_3504_7388:()=>pPe,content_3504_7390:()=>sPe,content_3504_7392:()=>iPe,content_3504_7394:()=>lPe,content_3504_7396:()=>mPe,content_3504_7398:()=>hPe,content_3504_74:()=>Ab,content_3504_740:()=>$O,content_3504_7400:()=>fPe,content_3504_7402:()=>MPe,content_3504_7404:()=>wPe,content_3504_7406:()=>XPe,content_3504_7408:()=>TPe,content_3504_7410:()=>CPe,content_3504_7412:()=>LPe,content_3504_7414:()=>bPe,content_3504_7416:()=>zPe,content_3504_7418:()=>WPe,content_3504_742:()=>JO,content_3504_7420:()=>IPe,content_3504_7422:()=>PPe,content_3504_7424:()=>BPe,content_3504_7426:()=>OPe,content_3504_7428:()=>FPe,content_3504_7430:()=>VPe,content_3504_7432:()=>HPe,content_3504_7434:()=>YPe,content_3504_7436:()=>KPe,content_3504_7438:()=>tEe,content_3504_744:()=>eU,content_3504_7440:()=>nEe,content_3504_7442:()=>pEe,content_3504_7444:()=>sEe,content_3504_7446:()=>iEe,content_3504_7448:()=>lEe,content_3504_7450:()=>mEe,content_3504_7452:()=>hEe,content_3504_7454:()=>fEe,content_3504_7456:()=>MEe,content_3504_7458:()=>wEe,content_3504_746:()=>oU,content_3504_7460:()=>XEe,content_3504_7462:()=>TEe,content_3504_7464:()=>CEe,content_3504_7466:()=>LEe,content_3504_7468:()=>bEe,content_3504_7470:()=>zEe,content_3504_7472:()=>WEe,content_3504_7474:()=>IEe,content_3504_7476:()=>PEe,content_3504_7478:()=>BEe,content_3504_748:()=>rU,content_3504_7480:()=>OEe,content_3504_7482:()=>FEe,content_3504_7484:()=>VEe,content_3504_7486:()=>HEe,content_3504_7488:()=>YEe,content_3504_7490:()=>KEe,content_3504_7492:()=>tBe,content_3504_7494:()=>nBe,content_3504_7496:()=>pBe,content_3504_7498:()=>sBe,content_3504_750:()=>cU,content_3504_7500:()=>iBe,content_3504_7502:()=>lBe,content_3504_7504:()=>mBe,content_3504_7506:()=>hBe,content_3504_7508:()=>fBe,content_3504_7510:()=>MBe,content_3504_7512:()=>wBe,content_3504_7514:()=>XBe,content_3504_7516:()=>TBe,content_3504_7518:()=>CBe,content_3504_752:()=>aU,content_3504_7520:()=>LBe,content_3504_7522:()=>bBe,content_3504_7524:()=>zBe,content_3504_7526:()=>WBe,content_3504_7528:()=>IBe,content_3504_7530:()=>PBe,content_3504_7532:()=>BBe,content_3504_7534:()=>OBe,content_3504_7536:()=>FBe,content_3504_7538:()=>VBe,content_3504_754:()=>uU,content_3504_7540:()=>HBe,content_3504_7542:()=>YBe,content_3504_7544:()=>KBe,content_3504_7546:()=>tGe,content_3504_7548:()=>nGe,content_3504_7550:()=>pGe,content_3504_7552:()=>sGe,content_3504_7554:()=>iGe,content_3504_7556:()=>lGe,content_3504_7558:()=>mGe,content_3504_756:()=>dU,content_3504_7560:()=>hGe,content_3504_7562:()=>fGe,content_3504_7564:()=>MGe,content_3504_7566:()=>wGe,content_3504_7568:()=>XGe,content_3504_7570:()=>TGe,content_3504_7572:()=>CGe,content_3504_7574:()=>LGe,content_3504_7576:()=>bGe,content_3504_758:()=>kU,content_3504_76:()=>Rb,content_3504_760:()=>yU,content_3504_762:()=>DU,content_3504_764:()=>_U,content_3504_766:()=>gU,content_3504_768:()=>xU,content_3504_770:()=>vU,content_3504_772:()=>ZU,content_3504_774:()=>NU,content_3504_776:()=>AU,content_3504_778:()=>RU,content_3504_78:()=>Sb,content_3504_780:()=>SU,content_3504_782:()=>EU,content_3504_784:()=>GU,content_3504_786:()=>UU,content_3504_788:()=>qU,content_3504_790:()=>jU,content_3504_792:()=>QU,content_3504_794:()=>$U,content_3504_796:()=>JU,content_3504_798:()=>eF,content_3504_8:()=>_Z,content_3504_80:()=>Eb,content_3504_800:()=>oF,content_3504_802:()=>rF,content_3504_804:()=>cF,content_3504_806:()=>aF,content_3504_808:()=>uF,content_3504_810:()=>dF,content_3504_812:()=>kF,content_3504_814:()=>yF,content_3504_816:()=>DF,content_3504_818:()=>_F,content_3504_82:()=>Gb,content_3504_820:()=>gF,content_3504_822:()=>xF,content_3504_824:()=>vF,content_3504_826:()=>ZF,content_3504_828:()=>NF,content_3504_830:()=>AF,content_3504_832:()=>RF,content_3504_834:()=>SF,content_3504_836:()=>EF,content_3504_838:()=>GF,content_3504_84:()=>Ub,content_3504_840:()=>UF,content_3504_842:()=>qF,content_3504_844:()=>jF,content_3504_846:()=>QF,content_3504_848:()=>$F,content_3504_850:()=>JF,content_3504_852:()=>eq,content_3504_854:()=>oq,content_3504_856:()=>rq,content_3504_858:()=>cq,content_3504_86:()=>qb,content_3504_860:()=>aq,content_3504_862:()=>uq,content_3504_864:()=>dq,content_3504_866:()=>kq,content_3504_868:()=>yq,content_3504_870:()=>Dq,content_3504_872:()=>_q,content_3504_874:()=>gq,content_3504_876:()=>xq,content_3504_878:()=>vq,content_3504_88:()=>jb,content_3504_880:()=>Zq,content_3504_882:()=>Nq,content_3504_884:()=>Aq,content_3504_886:()=>Rq,content_3504_888:()=>Sq,content_3504_890:()=>Eq,content_3504_892:()=>Gq,content_3504_894:()=>Uq,content_3504_896:()=>qq,content_3504_898:()=>jq,content_3504_90:()=>Qb,content_3504_900:()=>Qq,content_3504_902:()=>$q,content_3504_904:()=>Jq,content_3504_906:()=>eV,content_3504_908:()=>oV,content_3504_910:()=>rV,content_3504_912:()=>cV,content_3504_914:()=>aV,content_3504_916:()=>uV,content_3504_918:()=>dV,content_3504_92:()=>$b,content_3504_920:()=>kV,content_3504_922:()=>yV,content_3504_924:()=>DV,content_3504_926:()=>_V,content_3504_928:()=>gV,content_3504_930:()=>xV,content_3504_932:()=>vV,content_3504_934:()=>ZV,content_3504_936:()=>NV,content_3504_938:()=>AV,content_3504_94:()=>Jb,content_3504_940:()=>RV,content_3504_942:()=>SV,content_3504_944:()=>EV,content_3504_946:()=>GV,content_3504_948:()=>UV,content_3504_950:()=>qV,content_3504_952:()=>jV,content_3504_954:()=>QV,content_3504_956:()=>$V,content_3504_958:()=>JV,content_3504_96:()=>eN,content_3504_960:()=>ej,content_3504_962:()=>oj,content_3504_964:()=>rj,content_3504_966:()=>cj,content_3504_968:()=>aj,content_3504_970:()=>uj,content_3504_972:()=>dj,content_3504_974:()=>kj,content_3504_976:()=>yj,content_3504_978:()=>Dj,content_3504_98:()=>oN,content_3504_980:()=>_j,content_3504_982:()=>gj,content_3504_984:()=>xj,content_3504_986:()=>vj,content_3504_988:()=>Zj,content_3504_990:()=>Nj,content_3504_992:()=>Aj,content_3504_994:()=>Rj,content_3504_996:()=>Sj,content_3504_998:()=>Ej});var p=n(2784),r=n(7896),s=n(876);const c={toc:[]};function i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const k={toc:[]};function f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}f.isMDXComponent=!0;const y={toc:[]};function M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}I.isMDXComponent=!0;const S={toc:[]};function P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}P.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}O.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}F.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}V.isMDXComponent=!0;const j={toc:[]};function H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}H.isMDXComponent=!0;const Q={toc:[]};function Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Y.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nt.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const kt={toc:[]};function ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ft.isMDXComponent=!0;const yt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}It.isMDXComponent=!0;const St={toc:[]};function Pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Pt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ot.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ft.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Ht.isMDXComponent=!0;const Qt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Yt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}ne.isMDXComponent=!0;const oe={toc:[]};function pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pe.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}se.isMDXComponent=!0;const ce={toc:[]};function ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}ie.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}he.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}fe.isMDXComponent=!0;const ye={toc:[]};function Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Me.isMDXComponent=!0;const De={toc:[]};function we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}we.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Xe.isMDXComponent=!0;const ge={toc:[]};function Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}Te.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}Ce.isMDXComponent=!0;const ve={toc:[]};function Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}be.isMDXComponent=!0;const Ne={toc:[]};function ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}ze.isMDXComponent=!0;const Ae={toc:[]};function We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}We.isMDXComponent=!0;const Re={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Ie.isMDXComponent=!0;const Se={toc:[]};function Pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Pe.isMDXComponent=!0;const Ee={toc:[]};function Be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Be.isMDXComponent=!0;const Ge={toc:[]};function Oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}))}Oe.isMDXComponent=!0;const Ue={toc:[]};function Fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Fe.isMDXComponent=!0;const qe={toc:[]};function Ve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}Ve.isMDXComponent=!0;const je={toc:[]};function He(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}He.isMDXComponent=!0;const Qe={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Ye.isMDXComponent=!0;const $e={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Ke.isMDXComponent=!0;const Je={toc:[]};function tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}nn.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}kn.isMDXComponent=!0;const fn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}yn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Rn.isMDXComponent=!0;const In={toc:[]};function Sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Sn.isMDXComponent=!0;const Pn={toc:[]};function En(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Gn.isMDXComponent=!0;const On={toc:[]};function Un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Un.isMDXComponent=!0;const Fn={toc:[]};function qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}jn.isMDXComponent=!0;const Hn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Qn.isMDXComponent=!0;const Yn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const ko={toc:[]};function fo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}fo.isMDXComponent=!0;const yo={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Io.isMDXComponent=!0;const So={toc:[]};function Po(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},So,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Po.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Oo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Fo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Ho.isMDXComponent=!0;const Qo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Yo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}np.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const kp={toc:[]};function fp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}fp.isMDXComponent=!0;const yp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ip.isMDXComponent=!0;const Sp={toc:[]};function Pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Pp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Op.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Fp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hp.isMDXComponent=!0;const Qp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Yp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nr.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const kr={toc:[]};function fr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}fr.isMDXComponent=!0;const yr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ir.isMDXComponent=!0;const Sr={toc:[]};function Pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Pr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Or.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Fr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Vr.isMDXComponent=!0;const jr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Hr.isMDXComponent=!0;const Qr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Yr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}ns.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const ks={toc:[]};function fs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ks,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}fs.isMDXComponent=!0;const ys={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Is.isMDXComponent=!0;const Ss={toc:[]};function Ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ss,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ps.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Os.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Fs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Vs.isMDXComponent=!0;const js={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Hs.isMDXComponent=!0;const Qs={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ys.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}nc.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const kc={toc:[]};function fc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}fc.isMDXComponent=!0;const yc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ic.isMDXComponent=!0;const Sc={toc:[]};function Pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Pc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Oc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hc.isMDXComponent=!0;const Qc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ni.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const ki={toc:[]};function fi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ki,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}fi.isMDXComponent=!0;const yi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ii.isMDXComponent=!0;const Si={toc:[]};function Pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Si,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Pi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Oi.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Hi.isMDXComponent=!0;const Qi={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}na.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const ka={toc:[]};function fa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ka,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}fa.isMDXComponent=!0;const ya={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ia.isMDXComponent=!0;const Sa={toc:[]};function Pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Pa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Oa.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Fa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Va.isMDXComponent=!0;const ja={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ha.isMDXComponent=!0;const Qa={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ya.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}nl.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const kl={toc:[]};function fl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}fl.isMDXComponent=!0;const yl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Il.isMDXComponent=!0;const Sl={toc:[]};function Pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Pl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Ol.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hl.isMDXComponent=!0;const Ql={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const ku={toc:[]};function fu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ku,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}fu.isMDXComponent=!0;const yu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Iu.isMDXComponent=!0;const Su={toc:[]};function Pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Su,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Pu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ou.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Fu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Hu.isMDXComponent=!0;const Qu={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Yu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}nm.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const km={toc:[]};function fm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},km,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}fm.isMDXComponent=!0;const ym={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Im.isMDXComponent=!0;const Sm={toc:[]};function Pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Om.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hm.isMDXComponent=!0;const Qm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ym.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nd.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const kd={toc:[]};function fd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}fd.isMDXComponent=!0;const yd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Id.isMDXComponent=!0;const Sd={toc:[]};function Pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Od.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hd.isMDXComponent=!0;const Qd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const kh={toc:[]};function fh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}fh.isMDXComponent=!0;const yh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ih.isMDXComponent=!0;const Sh={toc:[]};function Ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ph.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Oh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Fh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Hh.isMDXComponent=!0;const Qh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Yh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tk.isMDXComponent=!0;const ek={toc:[]};function nk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}nk.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ok,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pk.isMDXComponent=!0;const rk={toc:[]};function sk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sk.isMDXComponent=!0;const ck={toc:[]};function ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}ik.isMDXComponent=!0;const ak={toc:[]};function lk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ak,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}hk.isMDXComponent=!0;const kk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}fk.isMDXComponent=!0;const yk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function wk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}wk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}Xk.isMDXComponent=!0;const gk={toc:[]};function Tk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}Tk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}Ck.isMDXComponent=!0;const vk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}bk.isMDXComponent=!0;const Nk={toc:[]};function zk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}zk.isMDXComponent=!0;const Ak={toc:[]};function Wk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Wk.isMDXComponent=!0;const Rk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Ik.isMDXComponent=!0;const Sk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Pk.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ok.isMDXComponent=!0;const Uk={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Fk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Vk.isMDXComponent=!0;const jk={toc:[]};function Hk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Hk.isMDXComponent=!0;const Qk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Yk.isMDXComponent=!0;const $k={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Kk.isMDXComponent=!0;const Jk={toc:[]};function tf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}nf.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}kf.isMDXComponent=!0;const ff={toc:[]};function yf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ff,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Rf.isMDXComponent=!0;const If={toc:[]};function Sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Sf.isMDXComponent=!0;const Pf={toc:[]};function Ef(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Gf.isMDXComponent=!0;const Of={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ff,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jf.isMDXComponent=!0;const Hf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Qf.isMDXComponent=!0;const Yf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jf.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}ky.isMDXComponent=!0;const fy={toc:[]};function yy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const My={toc:[]};function Dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Dy.isMDXComponent=!0;const wy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}_y.isMDXComponent=!0;const Xy={toc:[]};function gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function xy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}xy.isMDXComponent=!0;const Cy={toc:[]};function vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ry.isMDXComponent=!0;const Iy={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Sy.isMDXComponent=!0;const Py={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Ey.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Uy.isMDXComponent=!0;const Fy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}qy.isMDXComponent=!0;const Vy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Hy={toc:[]};function Qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Qy.isMDXComponent=!0;const Yy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}kM.isMDXComponent=!0;const fM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}RM.isMDXComponent=!0;const IM={toc:[]};function SM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}SM.isMDXComponent=!0;const PM={toc:[]};function EM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}GM.isMDXComponent=!0;const OM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}UM.isMDXComponent=!0;const FM={toc:[]};function qM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jM.isMDXComponent=!0;const HM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}QM.isMDXComponent=!0;const YM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}kD.isMDXComponent=!0;const fD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}yD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}RD.isMDXComponent=!0;const ID={toc:[]};function SD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}SD.isMDXComponent=!0;const PD={toc:[]};function ED(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}GD.isMDXComponent=!0;const OD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}UD.isMDXComponent=!0;const FD={toc:[]};function qD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}jD.isMDXComponent=!0;const HD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}QD.isMDXComponent=!0;const YD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}JD.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}kw.isMDXComponent=!0;const fw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}yw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Sw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Sw.isMDXComponent=!0;const Pw={toc:[]};function Ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}jw.isMDXComponent=!0;const Hw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Qw.isMDXComponent=!0;const Yw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Jw.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}k_.isMDXComponent=!0;const f_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}y_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}R_.isMDXComponent=!0;const I_={toc:[]};function S_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}S_.isMDXComponent=!0;const P_={toc:[]};function E_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}G_.isMDXComponent=!0;const O_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}U_.isMDXComponent=!0;const F_={toc:[]};function q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}j_.isMDXComponent=!0;const H_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Q_.isMDXComponent=!0;const Y_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}J_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}kX.isMDXComponent=!0;const fX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}yX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}RX.isMDXComponent=!0;const IX={toc:[]};function SX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}SX.isMDXComponent=!0;const PX={toc:[]};function EX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}GX.isMDXComponent=!0;const OX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}UX.isMDXComponent=!0;const FX={toc:[]};function qX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}jX.isMDXComponent=!0;const HX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}QX.isMDXComponent=!0;const YX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}JX.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}kg.isMDXComponent=!0;const fg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}yg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Sg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Sg.isMDXComponent=!0;const Pg={toc:[]};function Eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Gg.isMDXComponent=!0;const Og={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}jg.isMDXComponent=!0;const Hg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Qg.isMDXComponent=!0;const Yg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Jg.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}kT.isMDXComponent=!0;const fT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}yT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}RT.isMDXComponent=!0;const IT={toc:[]};function ST(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}ST.isMDXComponent=!0;const PT={toc:[]};function ET(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}GT.isMDXComponent=!0;const OT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}UT.isMDXComponent=!0;const FT={toc:[]};function qT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}jT.isMDXComponent=!0;const HT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}QT.isMDXComponent=!0;const YT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}JT.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}kx.isMDXComponent=!0;const fx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}yx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Sx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Sx.isMDXComponent=!0;const Px={toc:[]};function Ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Ux.isMDXComponent=!0;const Fx={toc:[]};function qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}jx.isMDXComponent=!0;const Hx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}Qx.isMDXComponent=!0;const Yx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}Jx.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}kC.isMDXComponent=!0;const fC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}yC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}RC.isMDXComponent=!0;const IC={toc:[]};function SC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}SC.isMDXComponent=!0;const PC={toc:[]};function EC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}GC.isMDXComponent=!0;const OC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}UC.isMDXComponent=!0;const FC={toc:[]};function qC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}jC.isMDXComponent=!0;const HC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}QC.isMDXComponent=!0;const YC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}JC.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}kv.isMDXComponent=!0;const fv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}yv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Sv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Sv.isMDXComponent=!0;const Pv={toc:[]};function Ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}jv.isMDXComponent=!0;const Hv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}Qv.isMDXComponent=!0;const Yv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}Jv.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}kL.isMDXComponent=!0;const fL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}yL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}RL.isMDXComponent=!0;const IL={toc:[]};function SL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}SL.isMDXComponent=!0;const PL={toc:[]};function EL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}GL.isMDXComponent=!0;const OL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}UL.isMDXComponent=!0;const FL={toc:[]};function qL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}jL.isMDXComponent=!0;const HL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}QL.isMDXComponent=!0;const YL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}JL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kZ.isMDXComponent=!0;const fZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function SZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}SZ.isMDXComponent=!0;const PZ={toc:[]};function EZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GZ.isMDXComponent=!0;const OZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function qZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}jZ.isMDXComponent=!0;const HZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QZ.isMDXComponent=!0;const YZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}JZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kb.isMDXComponent=!0;const fb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}yb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Sb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Sb.isMDXComponent=!0;const Pb={toc:[]};function Eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}jb.isMDXComponent=!0;const Hb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qb.isMDXComponent=!0;const Yb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Jb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kN.isMDXComponent=!0;const fN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}yN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}RN.isMDXComponent=!0;const IN={toc:[]};function SN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}SN.isMDXComponent=!0;const PN={toc:[]};function EN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GN.isMDXComponent=!0;const ON={toc:[]};function UN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UN.isMDXComponent=!0;const FN={toc:[]};function qN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}jN.isMDXComponent=!0;const HN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}QN.isMDXComponent=!0;const YN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}JN.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kz.isMDXComponent=!0;const fz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Sz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Sz.isMDXComponent=!0;const Pz={toc:[]};function Ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Uz.isMDXComponent=!0;const Fz={toc:[]};function qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}jz.isMDXComponent=!0;const Hz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Qz.isMDXComponent=!0;const Yz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Jz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kA.isMDXComponent=!0;const fA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RA.isMDXComponent=!0;const IA={toc:[]};function SA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SA.isMDXComponent=!0;const PA={toc:[]};function EA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GA.isMDXComponent=!0;const OA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}UA.isMDXComponent=!0;const FA={toc:[]};function qA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}jA.isMDXComponent=!0;const HA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QA.isMDXComponent=!0;const YA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}JA.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kW.isMDXComponent=!0;const fW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}RW.isMDXComponent=!0;const IW={toc:[]};function SW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}SW.isMDXComponent=!0;const PW={toc:[]};function EW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}GW.isMDXComponent=!0;const OW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UW.isMDXComponent=!0;const FW={toc:[]};function qW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jW.isMDXComponent=!0;const HW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}QW.isMDXComponent=!0;const YW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}JW.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kR.isMDXComponent=!0;const fR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}yR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RR.isMDXComponent=!0;const IR={toc:[]};function SR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SR.isMDXComponent=!0;const PR={toc:[]};function ER(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}GR.isMDXComponent=!0;const OR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}UR.isMDXComponent=!0;const FR={toc:[]};function qR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}jR.isMDXComponent=!0;const HR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QR.isMDXComponent=!0;const YR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}JR.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kI.isMDXComponent=!0;const fI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}yI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}RI.isMDXComponent=!0;const II={toc:[]};function SI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}SI.isMDXComponent=!0;const PI={toc:[]};function EI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}GI.isMDXComponent=!0;const OI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}UI.isMDXComponent=!0;const FI={toc:[]};function qI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}jI.isMDXComponent=!0;const HI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}QI.isMDXComponent=!0;const YI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}JI.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}kS.isMDXComponent=!0;const fS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}RS.isMDXComponent=!0;const IS={toc:[]};function SS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}SS.isMDXComponent=!0;const PS={toc:[]};function ES(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GS.isMDXComponent=!0;const OS={toc:[]};function US(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}US.isMDXComponent=!0;const FS={toc:[]};function qS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}jS.isMDXComponent=!0;const HS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QS.isMDXComponent=!0;const YS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}JS.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kP.isMDXComponent=!0;const fP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}yP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}RP.isMDXComponent=!0;const IP={toc:[]};function SP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}SP.isMDXComponent=!0;const PP={toc:[]};function EP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GP.isMDXComponent=!0;const OP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}UP.isMDXComponent=!0;const FP={toc:[]};function qP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jP.isMDXComponent=!0;const HP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}QP.isMDXComponent=!0;const YP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JP.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kE.isMDXComponent=!0;const fE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}yE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}RE.isMDXComponent=!0;const IE={toc:[]};function SE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}SE.isMDXComponent=!0;const PE={toc:[]};function EE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}GE.isMDXComponent=!0;const OE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}UE.isMDXComponent=!0;const FE={toc:[]};function qE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}jE.isMDXComponent=!0;const HE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}QE.isMDXComponent=!0;const YE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}JE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kB.isMDXComponent=!0;const fB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}RB.isMDXComponent=!0;const IB={toc:[]};function SB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}SB.isMDXComponent=!0;const PB={toc:[]};function EB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GB.isMDXComponent=!0;const OB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}UB.isMDXComponent=!0;const FB={toc:[]};function qB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}jB.isMDXComponent=!0;const HB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QB.isMDXComponent=!0;const YB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}JB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kG.isMDXComponent=!0;const fG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}yG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RG.isMDXComponent=!0;const IG={toc:[]};function SG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}SG.isMDXComponent=!0;const PG={toc:[]};function EG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}GG.isMDXComponent=!0;const OG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UG.isMDXComponent=!0;const FG={toc:[]};function qG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}jG.isMDXComponent=!0;const HG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QG.isMDXComponent=!0;const YG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}JG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}kO.isMDXComponent=!0;const fO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}RO.isMDXComponent=!0;const IO={toc:[]};function SO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}SO.isMDXComponent=!0;const PO={toc:[]};function EO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}GO.isMDXComponent=!0;const OO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}UO.isMDXComponent=!0;const FO={toc:[]};function qO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}jO.isMDXComponent=!0;const HO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}QO.isMDXComponent=!0;const YO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}JO.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kU.isMDXComponent=!0;const fU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}yU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}RU.isMDXComponent=!0;const IU={toc:[]};function SU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}SU.isMDXComponent=!0;const PU={toc:[]};function EU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GU.isMDXComponent=!0;const OU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}UU.isMDXComponent=!0;const FU={toc:[]};function qU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}jU.isMDXComponent=!0;const HU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}QU.isMDXComponent=!0;const YU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}JU.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kF.isMDXComponent=!0;const fF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}yF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}RF.isMDXComponent=!0;const IF={toc:[]};function SF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}SF.isMDXComponent=!0;const PF={toc:[]};function EF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}GF.isMDXComponent=!0;const OF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}UF.isMDXComponent=!0;const FF={toc:[]};function qF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}jF.isMDXComponent=!0;const HF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}QF.isMDXComponent=!0;const YF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}JF.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kq.isMDXComponent=!0;const fq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}yq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Sq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Sq.isMDXComponent=!0;const Pq={toc:[]};function Eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Uq.isMDXComponent=!0;const Fq={toc:[]};function qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}jq.isMDXComponent=!0;const Hq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Qq.isMDXComponent=!0;const Yq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Jq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kV.isMDXComponent=!0;const fV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}RV.isMDXComponent=!0;const IV={toc:[]};function SV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}SV.isMDXComponent=!0;const PV={toc:[]};function EV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GV.isMDXComponent=!0;const OV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UV.isMDXComponent=!0;const FV={toc:[]};function qV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}jV.isMDXComponent=!0;const HV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QV.isMDXComponent=!0;const YV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JV.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}kj.isMDXComponent=!0;const fj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Sj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Sj.isMDXComponent=!0;const Pj={toc:[]};function Ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Uj.isMDXComponent=!0;const Fj={toc:[]};function qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}jj.isMDXComponent=!0;const Hj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Qj.isMDXComponent=!0;const Yj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jj.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kH.isMDXComponent=!0;const fH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}yH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}RH.isMDXComponent=!0;const IH={toc:[]};function SH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}SH.isMDXComponent=!0;const PH={toc:[]};function EH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GH.isMDXComponent=!0;const OH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}UH.isMDXComponent=!0;const FH={toc:[]};function qH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jH.isMDXComponent=!0;const HH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}QH.isMDXComponent=!0;const YH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}JH.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}kQ.isMDXComponent=!0;const fQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function SQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}SQ.isMDXComponent=!0;const PQ={toc:[]};function EQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UQ.isMDXComponent=!0;const FQ={toc:[]};function qQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jQ.isMDXComponent=!0;const HQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QQ.isMDXComponent=!0;const YQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}JQ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kY.isMDXComponent=!0;const fY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}RY.isMDXComponent=!0;const IY={toc:[]};function SY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}SY.isMDXComponent=!0;const PY={toc:[]};function EY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}GY.isMDXComponent=!0;const OY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}UY.isMDXComponent=!0;const FY={toc:[]};function qY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}jY.isMDXComponent=!0;const HY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QY.isMDXComponent=!0;const YY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}JY.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}k$.isMDXComponent=!0;const f$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}y$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}R$.isMDXComponent=!0;const I$={toc:[]};function S$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}S$.isMDXComponent=!0;const P$={toc:[]};function E$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}G$.isMDXComponent=!0;const O$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}U$.isMDXComponent=!0;const F$={toc:[]};function q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}j$.isMDXComponent=!0;const H$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q$.isMDXComponent=!0;const Y$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}J$.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kK.isMDXComponent=!0;const fK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}yK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}RK.isMDXComponent=!0;const IK={toc:[]};function SK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}SK.isMDXComponent=!0;const PK={toc:[]};function EK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GK.isMDXComponent=!0;const OK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UK.isMDXComponent=!0;const FK={toc:[]};function qK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}jK.isMDXComponent=!0;const HK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QK.isMDXComponent=!0;const YK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}JK.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}kJ.isMDXComponent=!0;const fJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function SJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}SJ.isMDXComponent=!0;const PJ={toc:[]};function EJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GJ.isMDXComponent=!0;const OJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UJ.isMDXComponent=!0;const FJ={toc:[]};function qJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}jJ.isMDXComponent=!0;const HJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}QJ.isMDXComponent=!0;const YJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}JJ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}k0.isMDXComponent=!0;const f0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}y0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}R0.isMDXComponent=!0;const I0={toc:[]};function S0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}S0.isMDXComponent=!0;const P0={toc:[]};function E0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}G0.isMDXComponent=!0;const O0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}U0.isMDXComponent=!0;const F0={toc:[]};function q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}j0.isMDXComponent=!0;const H0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Q0.isMDXComponent=!0;const Y0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}J0.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}k4.isMDXComponent=!0;const f4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}y4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}D4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}R4.isMDXComponent=!0;const I4={toc:[]};function S4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}S4.isMDXComponent=!0;const P4={toc:[]};function E4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}G4.isMDXComponent=!0;const O4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}U4.isMDXComponent=!0;const F4={toc:[]};function q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}j4.isMDXComponent=!0;const H4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Q4.isMDXComponent=!0;const Y4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}J4.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}k3.isMDXComponent=!0;const f3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}y3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R3.isMDXComponent=!0;const I3={toc:[]};function S3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}S3.isMDXComponent=!0;const P3={toc:[]};function E3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}G3.isMDXComponent=!0;const O3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}U3.isMDXComponent=!0;const F3={toc:[]};function q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}j3.isMDXComponent=!0;const H3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Q3.isMDXComponent=!0;const Y3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}J3.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d5.isMDXComponent=!0;const h5={toc:[]};function k5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}k5.isMDXComponent=!0;const f5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}y5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}D5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}R5.isMDXComponent=!0;const I5={toc:[]};function S5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}S5.isMDXComponent=!0;const P5={toc:[]};function E5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}G5.isMDXComponent=!0;const O5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}U5.isMDXComponent=!0;const F5={toc:[]};function q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}j5.isMDXComponent=!0;const H5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Q5.isMDXComponent=!0;const Y5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}J5.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}k2.isMDXComponent=!0;const f2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}y2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}D2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}R2.isMDXComponent=!0;const I2={toc:[]};function S2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}S2.isMDXComponent=!0;const P2={toc:[]};function E2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}G2.isMDXComponent=!0;const O2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}U2.isMDXComponent=!0;const F2={toc:[]};function q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}j2.isMDXComponent=!0;const H2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Q2.isMDXComponent=!0;const Y2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}J2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}k1.isMDXComponent=!0;const f1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}y1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}R1.isMDXComponent=!0;const I1={toc:[]};function S1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}S1.isMDXComponent=!0;const P1={toc:[]};function E1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}G1.isMDXComponent=!0;const O1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}U1.isMDXComponent=!0;const F1={toc:[]};function q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}j1.isMDXComponent=!0;const H1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Q1.isMDXComponent=!0;const Y1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}J1.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}k6.isMDXComponent=!0;const f6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}y6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}D6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}R6.isMDXComponent=!0;const I6={toc:[]};function S6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}S6.isMDXComponent=!0;const P6={toc:[]};function E6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}G6.isMDXComponent=!0;const O6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}U6.isMDXComponent=!0;const F6={toc:[]};function q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}j6.isMDXComponent=!0;const H6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q6.isMDXComponent=!0;const Y6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}J6.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}k8.isMDXComponent=!0;const f8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}D8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}R8.isMDXComponent=!0;const I8={toc:[]};function S8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}S8.isMDXComponent=!0;const P8={toc:[]};function E8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}G8.isMDXComponent=!0;const O8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}U8.isMDXComponent=!0;const F8={toc:[]};function q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}j8.isMDXComponent=!0;const H8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Q8.isMDXComponent=!0;const Y8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}J8.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}k7.isMDXComponent=!0;const f7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}y7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}D7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}R7.isMDXComponent=!0;const I7={toc:[]};function S7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}S7.isMDXComponent=!0;const P7={toc:[]};function E7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}G7.isMDXComponent=!0;const O7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}U7.isMDXComponent=!0;const F7={toc:[]};function q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}j7.isMDXComponent=!0;const H7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Q7.isMDXComponent=!0;const Y7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}J7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}d9.isMDXComponent=!0;const h9={toc:[]};function k9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}k9.isMDXComponent=!0;const f9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}y9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}D9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}R9.isMDXComponent=!0;const I9={toc:[]};function S9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}S9.isMDXComponent=!0;const P9={toc:[]};function E9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}G9.isMDXComponent=!0;const O9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}U9.isMDXComponent=!0;const F9={toc:[]};function q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}j9.isMDXComponent=!0;const H9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Q9.isMDXComponent=!0;const Y9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}J9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}dtt.isMDXComponent=!0;const htt={toc:[]};function ktt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ktt.isMDXComponent=!0;const ftt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ytt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Dtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Stt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Stt.isMDXComponent=!0;const Ptt={toc:[]};function Ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Utt.isMDXComponent=!0;const Ftt={toc:[]};function qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jtt.isMDXComponent=!0;const Htt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qtt.isMDXComponent=!0;const Ytt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Jtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}het.isMDXComponent=!0;const ket={toc:[]};function fet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ket,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}fet.isMDXComponent=!0;const yet={toc:[]};function Met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Met.isMDXComponent=!0;const Det={toc:[]};function wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Iet.isMDXComponent=!0;const Set={toc:[]};function Pet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Oet.isMDXComponent=!0;const Uet={toc:[]};function Fet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Fet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Het.isMDXComponent=!0;const Qet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Yet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nnt.isMDXComponent=!0;const ont={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pnt.isMDXComponent=!0;const rnt={toc:[]};function snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}snt.isMDXComponent=!0;const cnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}int.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hnt.isMDXComponent=!0;const knt={toc:[]};function fnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}fnt.isMDXComponent=!0;const ynt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}wnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Xnt.isMDXComponent=!0;const gnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Tnt.isMDXComponent=!0;const xnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Cnt.isMDXComponent=!0;const vnt={toc:[]};function Lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}bnt.isMDXComponent=!0;const Nnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wnt.isMDXComponent=!0;const Rnt={toc:[]};function Int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Int.isMDXComponent=!0;const Snt={toc:[]};function Pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Pnt.isMDXComponent=!0;const Ent={toc:[]};function Bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bnt.isMDXComponent=!0;const Gnt={toc:[]};function Ont(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Ont.isMDXComponent=!0;const Unt={toc:[]};function Fnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fnt.isMDXComponent=!0;const qnt={toc:[]};function Vnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Vnt.isMDXComponent=!0;const jnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Hnt.isMDXComponent=!0;const Qnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ynt.isMDXComponent=!0;const $nt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Knt.isMDXComponent=!0;const Jnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}not.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hot.isMDXComponent=!0;const kot={toc:[]};function fot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}fot.isMDXComponent=!0;const yot={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Iot.isMDXComponent=!0;const Sot={toc:[]};function Pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Pot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Oot.isMDXComponent=!0;const Uot={toc:[]};function Fot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Fot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Hot.isMDXComponent=!0;const Qot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Yot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}npt.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}hpt.isMDXComponent=!0;const kpt={toc:[]};function fpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}fpt.isMDXComponent=!0;const ypt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ipt.isMDXComponent=!0;const Spt={toc:[]};function Ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Ppt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Opt.isMDXComponent=!0;const Upt={toc:[]};function Fpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Fpt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ypt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}nrt.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hrt.isMDXComponent=!0;const krt={toc:[]};function frt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}frt.isMDXComponent=!0;const yrt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Irt.isMDXComponent=!0;const Srt={toc:[]};function Prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Prt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Ort.isMDXComponent=!0;const Urt={toc:[]};function Frt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Frt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hrt.isMDXComponent=!0;const Qrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Yrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}nst.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hst.isMDXComponent=!0;const kst={toc:[]};function fst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}fst.isMDXComponent=!0;const yst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ist.isMDXComponent=!0;const Sst={toc:[]};function Pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Pst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ost.isMDXComponent=!0;const Ust={toc:[]};function Fst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fst.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Hst.isMDXComponent=!0;const Qst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Yst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}nct.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}hct.isMDXComponent=!0;const kct={toc:[]};function fct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}fct.isMDXComponent=!0;const yct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}Ict.isMDXComponent=!0;const Sct={toc:[]};function Pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Pct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Oct.isMDXComponent=!0;const Uct={toc:[]};function Fct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Fct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Hct.isMDXComponent=!0;const Qct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Yct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}hit.isMDXComponent=!0;const kit={toc:[]};function fit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fit.isMDXComponent=!0;const yit={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Iit.isMDXComponent=!0;const Sit={toc:[]};function Pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Pit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Oit.isMDXComponent=!0;const Uit={toc:[]};function Fit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Fit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Vit.isMDXComponent=!0;const jit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Hit.isMDXComponent=!0;const Qit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Yit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}nat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hat.isMDXComponent=!0;const kat={toc:[]};function fat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fat.isMDXComponent=!0;const yat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Iat.isMDXComponent=!0;const Sat={toc:[]};function Pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Pat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Oat.isMDXComponent=!0;const Uat={toc:[]};function Fat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Fat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Hat.isMDXComponent=!0;const Qat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Yat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}nlt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}hlt.isMDXComponent=!0;const klt={toc:[]};function flt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},klt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}flt.isMDXComponent=!0;const ylt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ilt.isMDXComponent=!0;const Slt={toc:[]};function Plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Slt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Plt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Olt.isMDXComponent=!0;const Ult={toc:[]};function Flt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Flt.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ylt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hut.isMDXComponent=!0;const kut={toc:[]};function fut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}fut.isMDXComponent=!0;const yut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Iut.isMDXComponent=!0;const Sut={toc:[]};function Put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Put.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Out.isMDXComponent=!0;const Uut={toc:[]};function Fut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Fut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Hut.isMDXComponent=!0;const Qut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Yut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nmt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}hmt.isMDXComponent=!0;const kmt={toc:[]};function fmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}fmt.isMDXComponent=!0;const ymt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Imt.isMDXComponent=!0;const Smt={toc:[]};function Pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Pmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Omt.isMDXComponent=!0;const Umt={toc:[]};function Fmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Fmt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Hmt.isMDXComponent=!0;const Qmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Ymt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ndt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}hdt.isMDXComponent=!0;const kdt={toc:[]};function fdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}fdt.isMDXComponent=!0;const ydt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Idt.isMDXComponent=!0;const Sdt={toc:[]};function Pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Pdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Odt.isMDXComponent=!0;const Udt={toc:[]};function Fdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Fdt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ydt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}nht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}hht.isMDXComponent=!0;const kht={toc:[]};function fht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}fht.isMDXComponent=!0;const yht={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Iht.isMDXComponent=!0;const Sht={toc:[]};function Pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Pht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Oht.isMDXComponent=!0;const Uht={toc:[]};function Fht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Fht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Hht.isMDXComponent=!0;const Qht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Yht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}nkt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hkt.isMDXComponent=!0;const kkt={toc:[]};function fkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}fkt.isMDXComponent=!0;const ykt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ikt.isMDXComponent=!0;const Skt={toc:[]};function Pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Okt.isMDXComponent=!0;const Ukt={toc:[]};function Fkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fkt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Ykt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hft.isMDXComponent=!0;const kft={toc:[]};function fft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}fft.isMDXComponent=!0;const yft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ift.isMDXComponent=!0;const Sft={toc:[]};function Pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Pft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Oft.isMDXComponent=!0;const Uft={toc:[]};function Fft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hft.isMDXComponent=!0;const Qft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Yft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hyt.isMDXComponent=!0;const kyt={toc:[]};function fyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fyt.isMDXComponent=!0;const yyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Iyt.isMDXComponent=!0;const Syt={toc:[]};function Pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Pyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Oyt.isMDXComponent=!0;const Uyt={toc:[]};function Fyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Hyt.isMDXComponent=!0;const Qyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Yyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hMt.isMDXComponent=!0;const kMt={toc:[]};function fMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fMt.isMDXComponent=!0;const yMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}IMt.isMDXComponent=!0;const SMt={toc:[]};function PMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}OMt.isMDXComponent=!0;const UMt={toc:[]};function FMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}FMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}HMt.isMDXComponent=!0;const QMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}YMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}hDt.isMDXComponent=!0;const kDt={toc:[]};function fDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fDt.isMDXComponent=!0;const yDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IDt.isMDXComponent=!0;const SDt={toc:[]};function PDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}PDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ODt.isMDXComponent=!0;const UDt={toc:[]};function FDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}FDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}HDt.isMDXComponent=!0;const QDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}YDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nwt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hwt.isMDXComponent=!0;const kwt={toc:[]};function fwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fwt.isMDXComponent=!0;const ywt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Iwt.isMDXComponent=!0;const Swt={toc:[]};function Pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Pwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Owt.isMDXComponent=!0;const Uwt={toc:[]};function Fwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Fwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ywt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}h_t.isMDXComponent=!0;const k_t={toc:[]};function f_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}f_t.isMDXComponent=!0;const y_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}I_t.isMDXComponent=!0;const S_t={toc:[]};function P_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}O_t.isMDXComponent=!0;const U_t={toc:[]};function F_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}F_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}H_t.isMDXComponent=!0;const Q_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Y_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}hXt.isMDXComponent=!0;const kXt={toc:[]};function fXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fXt.isMDXComponent=!0;const yXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}IXt.isMDXComponent=!0;const SXt={toc:[]};function PXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}PXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}OXt.isMDXComponent=!0;const UXt={toc:[]};function FXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}FXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}HXt.isMDXComponent=!0;const QXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}YXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hgt.isMDXComponent=!0;const kgt={toc:[]};function fgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}fgt.isMDXComponent=!0;const ygt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Igt.isMDXComponent=!0;const Sgt={toc:[]};function Pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ogt.isMDXComponent=!0;const Ugt={toc:[]};function Fgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fgt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ygt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}hTt.isMDXComponent=!0;const kTt={toc:[]};function fTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}fTt.isMDXComponent=!0;const yTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ITt.isMDXComponent=!0;const STt={toc:[]};function PTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}PTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}OTt.isMDXComponent=!0;const UTt={toc:[]};function FTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}FTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}HTt.isMDXComponent=!0;const QTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}YTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}hxt.isMDXComponent=!0;const kxt={toc:[]};function fxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fxt.isMDXComponent=!0;const yxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ixt.isMDXComponent=!0;const Sxt={toc:[]};function Pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Pxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Oxt.isMDXComponent=!0;const Uxt={toc:[]};function Fxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Fxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Yxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hCt.isMDXComponent=!0;const kCt={toc:[]};function fCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fCt.isMDXComponent=!0;const yCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ICt.isMDXComponent=!0;const SCt={toc:[]};function PCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}PCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}OCt.isMDXComponent=!0;const UCt={toc:[]};function FCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}FCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HCt.isMDXComponent=!0;const QCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}YCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}hvt.isMDXComponent=!0;const kvt={toc:[]};function fvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fvt.isMDXComponent=!0;const yvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ivt.isMDXComponent=!0;const Svt={toc:[]};function Pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Svt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Pvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ovt.isMDXComponent=!0;const Uvt={toc:[]};function Fvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Fvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Yvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}hLt.isMDXComponent=!0;const kLt={toc:[]};function fLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}fLt.isMDXComponent=!0;const yLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ILt.isMDXComponent=!0;const SLt={toc:[]};function PLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}OLt.isMDXComponent=!0;const ULt={toc:[]};function FLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}FLt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}HLt.isMDXComponent=!0;const QLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}YLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hZt.isMDXComponent=!0;const kZt={toc:[]};function fZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fZt.isMDXComponent=!0;const yZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}IZt.isMDXComponent=!0;const SZt={toc:[]};function PZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}OZt.isMDXComponent=!0;const UZt={toc:[]};function FZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}HZt.isMDXComponent=!0;const QZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}YZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}nbt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hbt.isMDXComponent=!0;const kbt={toc:[]};function fbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fbt.isMDXComponent=!0;const ybt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ibt.isMDXComponent=!0;const Sbt={toc:[]};function Pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Pbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Obt.isMDXComponent=!0;const Ubt={toc:[]};function Fbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fbt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ybt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}hNt.isMDXComponent=!0;const kNt={toc:[]};function fNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fNt.isMDXComponent=!0;const yNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}INt.isMDXComponent=!0;const SNt={toc:[]};function PNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}PNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ONt.isMDXComponent=!0;const UNt={toc:[]};function FNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}HNt.isMDXComponent=!0;const QNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hzt.isMDXComponent=!0;const kzt={toc:[]};function fzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}fzt.isMDXComponent=!0;const yzt={toc:[]};function Mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Izt.isMDXComponent=!0;const Szt={toc:[]};function Pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Szt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Pzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ozt.isMDXComponent=!0;const Uzt={toc:[]};function Fzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Fzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Yzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}hAt.isMDXComponent=!0;const kAt={toc:[]};function fAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}fAt.isMDXComponent=!0;const yAt={toc:[]};function MAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}IAt.isMDXComponent=!0;const SAt={toc:[]};function PAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}PAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}OAt.isMDXComponent=!0;const UAt={toc:[]};function FAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HAt.isMDXComponent=!0;const QAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}YAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hWt.isMDXComponent=!0;const kWt={toc:[]};function fWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}fWt.isMDXComponent=!0;const yWt={toc:[]};function MWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}IWt.isMDXComponent=!0;const SWt={toc:[]};function PWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}PWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}OWt.isMDXComponent=!0;const UWt={toc:[]};function FWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}HWt.isMDXComponent=!0;const QWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}YWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hRt.isMDXComponent=!0;const kRt={toc:[]};function fRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}fRt.isMDXComponent=!0;const yRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}IRt.isMDXComponent=!0;const SRt={toc:[]};function PRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ORt.isMDXComponent=!0;const URt={toc:[]};function FRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}FRt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}HRt.isMDXComponent=!0;const QRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hIt.isMDXComponent=!0;const kIt={toc:[]};function fIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fIt.isMDXComponent=!0;const yIt={toc:[]};function MIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}IIt.isMDXComponent=!0;const SIt={toc:[]};function PIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OIt.isMDXComponent=!0;const UIt={toc:[]};function FIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}FIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HIt.isMDXComponent=!0;const QIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}YIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hSt.isMDXComponent=!0;const kSt={toc:[]};function fSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}fSt.isMDXComponent=!0;const ySt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ISt.isMDXComponent=!0;const SSt={toc:[]};function PSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}PSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}OSt.isMDXComponent=!0;const USt={toc:[]};function FSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}FSt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}HSt.isMDXComponent=!0;const QSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}YSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hPt.isMDXComponent=!0;const kPt={toc:[]};function fPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}fPt.isMDXComponent=!0;const yPt={toc:[]};function MPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}IPt.isMDXComponent=!0;const SPt={toc:[]};function PPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}PPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}OPt.isMDXComponent=!0;const UPt={toc:[]};function FPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}FPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}HPt.isMDXComponent=!0;const QPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}YPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hEt.isMDXComponent=!0;const kEt={toc:[]};function fEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}fEt.isMDXComponent=!0;const yEt={toc:[]};function MEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}IEt.isMDXComponent=!0;const SEt={toc:[]};function PEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}OEt.isMDXComponent=!0;const UEt={toc:[]};function FEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}HEt.isMDXComponent=!0;const QEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}YEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hBt.isMDXComponent=!0;const kBt={toc:[]};function fBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}fBt.isMDXComponent=!0;const yBt={toc:[]};function MBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}IBt.isMDXComponent=!0;const SBt={toc:[]};function PBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}PBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}OBt.isMDXComponent=!0;const UBt={toc:[]};function FBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}HBt.isMDXComponent=!0;const QBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}hGt.isMDXComponent=!0;const kGt={toc:[]};function fGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fGt.isMDXComponent=!0;const yGt={toc:[]};function MGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}IGt.isMDXComponent=!0;const SGt={toc:[]};function PGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}OGt.isMDXComponent=!0;const UGt={toc:[]};function FGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}FGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}HGt.isMDXComponent=!0;const QGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}YGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hOt.isMDXComponent=!0;const kOt={toc:[]};function fOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fOt.isMDXComponent=!0;const yOt={toc:[]};function MOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}IOt.isMDXComponent=!0;const SOt={toc:[]};function POt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}POt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}OOt.isMDXComponent=!0;const UOt={toc:[]};function FOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}FOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}HOt.isMDXComponent=!0;const QOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hUt.isMDXComponent=!0;const kUt={toc:[]};function fUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}fUt.isMDXComponent=!0;const yUt={toc:[]};function MUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}IUt.isMDXComponent=!0;const SUt={toc:[]};function PUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}OUt.isMDXComponent=!0;const UUt={toc:[]};function FUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function HUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}HUt.isMDXComponent=!0;const QUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}YUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hFt.isMDXComponent=!0;const kFt={toc:[]};function fFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fFt.isMDXComponent=!0;const yFt={toc:[]};function MFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}IFt.isMDXComponent=!0;const SFt={toc:[]};function PFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}PFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}OFt.isMDXComponent=!0;const UFt={toc:[]};function FFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HFt.isMDXComponent=!0;const QFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hqt.isMDXComponent=!0;const kqt={toc:[]};function fqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}fqt.isMDXComponent=!0;const yqt={toc:[]};function Mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Iqt.isMDXComponent=!0;const Sqt={toc:[]};function Pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Pqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Oqt.isMDXComponent=!0;const Uqt={toc:[]};function Fqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Fqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Yqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hVt.isMDXComponent=!0;const kVt={toc:[]};function fVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}fVt.isMDXComponent=!0;const yVt={toc:[]};function MVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}IVt.isMDXComponent=!0;const SVt={toc:[]};function PVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}PVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}OVt.isMDXComponent=!0;const UVt={toc:[]};function FVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}FVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function HVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}HVt.isMDXComponent=!0;const QVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}YVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}njt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hjt.isMDXComponent=!0;const kjt={toc:[]};function fjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}fjt.isMDXComponent=!0;const yjt={toc:[]};function Mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ijt.isMDXComponent=!0;const Sjt={toc:[]};function Pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Pjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Ojt.isMDXComponent=!0;const Ujt={toc:[]};function Fjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Fjt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Yjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hHt.isMDXComponent=!0;const kHt={toc:[]};function fHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}fHt.isMDXComponent=!0;const yHt={toc:[]};function MHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IHt.isMDXComponent=!0;const SHt={toc:[]};function PHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}PHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OHt.isMDXComponent=!0;const UHt={toc:[]};function FHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}FHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function HHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}HHt.isMDXComponent=!0;const QHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hQt.isMDXComponent=!0;const kQt={toc:[]};function fQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}fQt.isMDXComponent=!0;const yQt={toc:[]};function MQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}MQt.isMDXComponent=!0;const DQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}IQt.isMDXComponent=!0;const SQt={toc:[]};function PQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}PQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}OQt.isMDXComponent=!0;const UQt={toc:[]};function FQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}FQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function HQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}HQt.isMDXComponent=!0;const QQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hYt.isMDXComponent=!0;const kYt={toc:[]};function fYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}fYt.isMDXComponent=!0;const yYt={toc:[]};function MYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IYt.isMDXComponent=!0;const SYt={toc:[]};function PYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}PYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}OYt.isMDXComponent=!0;const UYt={toc:[]};function FYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}FYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function HYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HYt.isMDXComponent=!0;const QYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}h$t.isMDXComponent=!0;const k$t={toc:[]};function f$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}f$t.isMDXComponent=!0;const y$t={toc:[]};function M$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}M$t.isMDXComponent=!0;const D$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}I$t.isMDXComponent=!0;const S$t={toc:[]};function P$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}P$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}O$t.isMDXComponent=!0;const U$t={toc:[]};function F$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}F$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function H$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H$t.isMDXComponent=!0;const Q$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Y$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}hKt.isMDXComponent=!0;const kKt={toc:[]};function fKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fKt.isMDXComponent=!0;const yKt={toc:[]};function MKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}IKt.isMDXComponent=!0;const SKt={toc:[]};function PKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}PKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}OKt.isMDXComponent=!0;const UKt={toc:[]};function FKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}VKt.isMDXComponent=!0;const jKt={toc:[]};function HKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}HKt.isMDXComponent=!0;const QKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}YKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hJt.isMDXComponent=!0;const kJt={toc:[]};function fJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fJt.isMDXComponent=!0;const yJt={toc:[]};function MJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IJt.isMDXComponent=!0;const SJt={toc:[]};function PJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}PJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}OJt.isMDXComponent=!0;const UJt={toc:[]};function FJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}FJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function HJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}HJt.isMDXComponent=!0;const QJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}h0t.isMDXComponent=!0;const k0t={toc:[]};function f0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}f0t.isMDXComponent=!0;const y0t={toc:[]};function M0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}M0t.isMDXComponent=!0;const D0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}I0t.isMDXComponent=!0;const S0t={toc:[]};function P0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}O0t.isMDXComponent=!0;const U0t={toc:[]};function F0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}F0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function H0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}H0t.isMDXComponent=!0;const Q0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}n4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}h4t.isMDXComponent=!0;const k4t={toc:[]};function f4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}f4t.isMDXComponent=!0;const y4t={toc:[]};function M4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}I4t.isMDXComponent=!0;const S4t={toc:[]};function P4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}P4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}O4t.isMDXComponent=!0;const U4t={toc:[]};function F4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}F4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function H4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}H4t.isMDXComponent=!0;const Q4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Y4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}h3t.isMDXComponent=!0;const k3t={toc:[]};function f3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}f3t.isMDXComponent=!0;const y3t={toc:[]};function M3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}I3t.isMDXComponent=!0;const S3t={toc:[]};function P3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}O3t.isMDXComponent=!0;const U3t={toc:[]};function F3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}V3t.isMDXComponent=!0;const j3t={toc:[]};function H3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}H3t.isMDXComponent=!0;const Q3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Y3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}h5t.isMDXComponent=!0;const k5t={toc:[]};function f5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}f5t.isMDXComponent=!0;const y5t={toc:[]};function M5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}I5t.isMDXComponent=!0;const S5t={toc:[]};function P5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}P5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}O5t.isMDXComponent=!0;const U5t={toc:[]};function F5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}F5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function H5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H5t.isMDXComponent=!0;const Q5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Y5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}h2t.isMDXComponent=!0;const k2t={toc:[]};function f2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}f2t.isMDXComponent=!0;const y2t={toc:[]};function M2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}M2t.isMDXComponent=!0;const D2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}I2t.isMDXComponent=!0;const S2t={toc:[]};function P2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}P2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}O2t.isMDXComponent=!0;const U2t={toc:[]};function F2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}F2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function H2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}H2t.isMDXComponent=!0;const Q2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Y2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}h1t.isMDXComponent=!0;const k1t={toc:[]};function f1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}f1t.isMDXComponent=!0;const y1t={toc:[]};function M1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}I1t.isMDXComponent=!0;const S1t={toc:[]};function P1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}P1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}O1t.isMDXComponent=!0;const U1t={toc:[]};function F1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}F1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function H1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}H1t.isMDXComponent=!0;const Q1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Y1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}h6t.isMDXComponent=!0;const k6t={toc:[]};function f6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}f6t.isMDXComponent=!0;const y6t={toc:[]};function M6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}I6t.isMDXComponent=!0;const S6t={toc:[]};function P6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}P6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}O6t.isMDXComponent=!0;const U6t={toc:[]};function F6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function H6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}H6t.isMDXComponent=!0;const Q6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Y6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}h8t.isMDXComponent=!0;const k8t={toc:[]};function f8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}f8t.isMDXComponent=!0;const y8t={toc:[]};function M8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}I8t.isMDXComponent=!0;const S8t={toc:[]};function P8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}P8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}O8t.isMDXComponent=!0;const U8t={toc:[]};function F8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function H8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}H8t.isMDXComponent=!0;const Q8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Y8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}n7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}h7t.isMDXComponent=!0;const k7t={toc:[]};function f7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}f7t.isMDXComponent=!0;const y7t={toc:[]};function M7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}I7t.isMDXComponent=!0;const S7t={toc:[]};function P7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}P7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}O7t.isMDXComponent=!0;const U7t={toc:[]};function F7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}F7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function H7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}H7t.isMDXComponent=!0;const Q7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Y7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}h9t.isMDXComponent=!0;const k9t={toc:[]};function f9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}f9t.isMDXComponent=!0;const y9t={toc:[]};function M9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}I9t.isMDXComponent=!0;const S9t={toc:[]};function P9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}P9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}O9t.isMDXComponent=!0;const U9t={toc:[]};function F9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function H9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}H9t.isMDXComponent=!0;const Q9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Y9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nte.isMDXComponent=!0;const ote={toc:[]};function pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pte.isMDXComponent=!0;const rte={toc:[]};function ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ste.isMDXComponent=!0;const cte={toc:[]};function ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ite.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hte.isMDXComponent=!0;const kte={toc:[]};function fte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fte.isMDXComponent=!0;const yte={toc:[]};function Mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mte.isMDXComponent=!0;const Dte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wte.isMDXComponent=!0;const _te={toc:[]};function Xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Xte.isMDXComponent=!0;const gte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Tte.isMDXComponent=!0;const xte={toc:[]};function Cte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Cte.isMDXComponent=!0;const vte={toc:[]};function Lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lte.isMDXComponent=!0;const Zte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bte.isMDXComponent=!0;const Nte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zte.isMDXComponent=!0;const Ate={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wte.isMDXComponent=!0;const Rte={toc:[]};function Ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Ite.isMDXComponent=!0;const Ste={toc:[]};function Pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ste,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Pte.isMDXComponent=!0;const Ete={toc:[]};function Bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bte.isMDXComponent=!0;const Gte={toc:[]};function Ote(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ote.isMDXComponent=!0;const Ute={toc:[]};function Fte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Fte.isMDXComponent=!0;const qte={toc:[]};function Vte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Vte.isMDXComponent=!0;const jte={toc:[]};function Hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Hte.isMDXComponent=!0;const Qte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Yte.isMDXComponent=!0;const $te={toc:[]};function Kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kte.isMDXComponent=!0;const Jte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nee.isMDXComponent=!0;const oee={toc:[]};function pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pee.isMDXComponent=!0;const ree={toc:[]};function see(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}see.isMDXComponent=!0;const cee={toc:[]};function iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hee.isMDXComponent=!0;const kee={toc:[]};function fee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fee.isMDXComponent=!0;const yee={toc:[]};function Mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mee.isMDXComponent=!0;const Dee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wee.isMDXComponent=!0;const _ee={toc:[]};function Xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Xee.isMDXComponent=!0;const gee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tee.isMDXComponent=!0;const xee={toc:[]};function Cee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Cee.isMDXComponent=!0;const vee={toc:[]};function Lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lee.isMDXComponent=!0;const Zee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bee.isMDXComponent=!0;const Nee={toc:[]};function zee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zee.isMDXComponent=!0;const Aee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wee.isMDXComponent=!0;const Ree={toc:[]};function Iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Iee.isMDXComponent=!0;const See={toc:[]};function Pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},See,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Pee.isMDXComponent=!0;const Eee={toc:[]};function Bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bee.isMDXComponent=!0;const Gee={toc:[]};function Oee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Oee.isMDXComponent=!0;const Uee={toc:[]};function Fee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fee.isMDXComponent=!0;const qee={toc:[]};function Vee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Vee.isMDXComponent=!0;const jee={toc:[]};function Hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hee.isMDXComponent=!0;const Qee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Yee.isMDXComponent=!0;const $ee={toc:[]};function Kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Kee.isMDXComponent=!0;const Jee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nne.isMDXComponent=!0;const one={toc:[]};function pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}pne.isMDXComponent=!0;const rne={toc:[]};function sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sne.isMDXComponent=!0;const cne={toc:[]};function ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ine.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hne.isMDXComponent=!0;const kne={toc:[]};function fne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}fne.isMDXComponent=!0;const yne={toc:[]};function Mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mne.isMDXComponent=!0;const Dne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wne.isMDXComponent=!0;const _ne={toc:[]};function Xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Xne.isMDXComponent=!0;const gne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Tne.isMDXComponent=!0;const xne={toc:[]};function Cne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Cne.isMDXComponent=!0;const vne={toc:[]};function Lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lne.isMDXComponent=!0;const Zne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}bne.isMDXComponent=!0;const Nne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}zne.isMDXComponent=!0;const Ane={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Wne.isMDXComponent=!0;const Rne={toc:[]};function Ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ine.isMDXComponent=!0;const Sne={toc:[]};function Pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Pne.isMDXComponent=!0;const Ene={toc:[]};function Bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Bne.isMDXComponent=!0;const Gne={toc:[]};function One(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}One.isMDXComponent=!0;const Une={toc:[]};function Fne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Fne.isMDXComponent=!0;const qne={toc:[]};function Vne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Vne.isMDXComponent=!0;const jne={toc:[]};function Hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Hne.isMDXComponent=!0;const Qne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Yne.isMDXComponent=!0;const $ne={toc:[]};function Kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Kne.isMDXComponent=!0;const Jne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}noe.isMDXComponent=!0;const ooe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}poe.isMDXComponent=!0;const roe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}soe.isMDXComponent=!0;const coe={toc:[]};function ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ioe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hoe.isMDXComponent=!0;const koe={toc:[]};function foe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},koe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}foe.isMDXComponent=!0;const yoe={toc:[]};function Moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Moe.isMDXComponent=!0;const Doe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}woe.isMDXComponent=!0;const _oe={toc:[]};function Xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Xoe.isMDXComponent=!0;const goe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Toe.isMDXComponent=!0;const xoe={toc:[]};function Coe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Coe.isMDXComponent=!0;const voe={toc:[]};function Loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Loe.isMDXComponent=!0;const Zoe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}boe.isMDXComponent=!0;const Noe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zoe.isMDXComponent=!0;const Aoe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Woe.isMDXComponent=!0;const Roe={toc:[]};function Ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ioe.isMDXComponent=!0;const Soe={toc:[]};function Poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Soe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Poe.isMDXComponent=!0;const Eoe={toc:[]};function Boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Boe.isMDXComponent=!0;const Goe={toc:[]};function Ooe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ooe.isMDXComponent=!0;const Uoe={toc:[]};function Foe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Foe.isMDXComponent=!0;const qoe={toc:[]};function Voe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Voe.isMDXComponent=!0;const joe={toc:[]};function Hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Hoe.isMDXComponent=!0;const Qoe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yoe.isMDXComponent=!0;const $oe={toc:[]};function Koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Koe.isMDXComponent=!0;const Joe={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}npe.isMDXComponent=!0;const ope={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ppe.isMDXComponent=!0;const rpe={toc:[]};function spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}spe.isMDXComponent=!0;const cpe={toc:[]};function ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ipe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hpe.isMDXComponent=!0;const kpe={toc:[]};function fpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}fpe.isMDXComponent=!0;const ype={toc:[]};function Mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mpe.isMDXComponent=!0;const Dpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wpe.isMDXComponent=!0;const _pe={toc:[]};function Xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Xpe.isMDXComponent=!0;const gpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Tpe.isMDXComponent=!0;const xpe={toc:[]};function Cpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Cpe.isMDXComponent=!0;const vpe={toc:[]};function Lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}bpe.isMDXComponent=!0;const Npe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zpe.isMDXComponent=!0;const Ape={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Wpe.isMDXComponent=!0;const Rpe={toc:[]};function Ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ipe.isMDXComponent=!0;const Spe={toc:[]};function Ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ppe.isMDXComponent=!0;const Epe={toc:[]};function Bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Bpe.isMDXComponent=!0;const Gpe={toc:[]};function Ope(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ope.isMDXComponent=!0;const Upe={toc:[]};function Fpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Fpe.isMDXComponent=!0;const qpe={toc:[]};function Vpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Vpe.isMDXComponent=!0;const jpe={toc:[]};function Hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hpe.isMDXComponent=!0;const Qpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ype.isMDXComponent=!0;const $pe={toc:[]};function Kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nre.isMDXComponent=!0;const ore={toc:[]};function pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pre.isMDXComponent=!0;const rre={toc:[]};function sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sre.isMDXComponent=!0;const cre={toc:[]};function ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}ire.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}hre.isMDXComponent=!0;const kre={toc:[]};function fre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}fre.isMDXComponent=!0;const yre={toc:[]};function Mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mre.isMDXComponent=!0;const Dre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wre.isMDXComponent=!0;const _re={toc:[]};function Xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Xre.isMDXComponent=!0;const gre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tre.isMDXComponent=!0;const xre={toc:[]};function Cre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Cre.isMDXComponent=!0;const vre={toc:[]};function Lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lre.isMDXComponent=!0;const Zre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}bre.isMDXComponent=!0;const Nre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}zre.isMDXComponent=!0;const Are={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Wre.isMDXComponent=!0;const Rre={toc:[]};function Ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ire.isMDXComponent=!0;const Sre={toc:[]};function Pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Pre.isMDXComponent=!0;const Ere={toc:[]};function Bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Bre.isMDXComponent=!0;const Gre={toc:[]};function Ore(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Ore.isMDXComponent=!0;const Ure={toc:[]};function Fre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fre.isMDXComponent=!0;const qre={toc:[]};function Vre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Vre.isMDXComponent=!0;const jre={toc:[]};function Hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Hre.isMDXComponent=!0;const Qre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Yre.isMDXComponent=!0;const $re={toc:[]};function Kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Kre.isMDXComponent=!0;const Jre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nse.isMDXComponent=!0;const ose={toc:[]};function pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pse.isMDXComponent=!0;const rse={toc:[]};function sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sse.isMDXComponent=!0;const cse={toc:[]};function ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}ise.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}hse.isMDXComponent=!0;const kse={toc:[]};function fse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fse.isMDXComponent=!0;const yse={toc:[]};function Mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Mse.isMDXComponent=!0;const Dse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}wse.isMDXComponent=!0;const _se={toc:[]};function Xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Xse.isMDXComponent=!0;const gse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Tse.isMDXComponent=!0;const xse={toc:[]};function Cse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Cse.isMDXComponent=!0;const vse={toc:[]};function Lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Lse.isMDXComponent=!0;const Zse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}bse.isMDXComponent=!0;const Nse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}zse.isMDXComponent=!0;const Ase={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wse.isMDXComponent=!0;const Rse={toc:[]};function Ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Ise.isMDXComponent=!0;const Sse={toc:[]};function Pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pse.isMDXComponent=!0;const Ese={toc:[]};function Bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Bse.isMDXComponent=!0;const Gse={toc:[]};function Ose(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ose.isMDXComponent=!0;const Use={toc:[]};function Fse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Fse.isMDXComponent=!0;const qse={toc:[]};function Vse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Vse.isMDXComponent=!0;const jse={toc:[]};function Hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Hse.isMDXComponent=!0;const Qse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Yse.isMDXComponent=!0;const $se={toc:[]};function Kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Kse.isMDXComponent=!0;const Jse={toc:[]};function tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nce.isMDXComponent=!0;const oce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pce.isMDXComponent=!0;const rce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sce.isMDXComponent=!0;const cce={toc:[]};function ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ice.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hce.isMDXComponent=!0;const kce={toc:[]};function fce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}fce.isMDXComponent=!0;const yce={toc:[]};function Mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Mce.isMDXComponent=!0;const Dce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wce.isMDXComponent=!0;const _ce={toc:[]};function Xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Xce.isMDXComponent=!0;const gce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Tce.isMDXComponent=!0;const xce={toc:[]};function Cce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Cce.isMDXComponent=!0;const vce={toc:[]};function Lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Lce.isMDXComponent=!0;const Zce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bce.isMDXComponent=!0;const Nce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zce.isMDXComponent=!0;const Ace={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Wce.isMDXComponent=!0;const Rce={toc:[]};function Ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Ice.isMDXComponent=!0;const Sce={toc:[]};function Pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Pce.isMDXComponent=!0;const Ece={toc:[]};function Bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Bce.isMDXComponent=!0;const Gce={toc:[]};function Oce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Oce.isMDXComponent=!0;const Uce={toc:[]};function Fce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fce.isMDXComponent=!0;const qce={toc:[]};function Vce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Vce.isMDXComponent=!0;const jce={toc:[]};function Hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Hce.isMDXComponent=!0;const Qce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yce.isMDXComponent=!0;const $ce={toc:[]};function Kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kce.isMDXComponent=!0;const Jce={toc:[]};function tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nie.isMDXComponent=!0;const oie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pie.isMDXComponent=!0;const rie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sie.isMDXComponent=!0;const cie={toc:[]};function iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hie.isMDXComponent=!0;const kie={toc:[]};function fie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}fie.isMDXComponent=!0;const yie={toc:[]};function Mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Mie.isMDXComponent=!0;const Die={toc:[]};function wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wie.isMDXComponent=!0;const _ie={toc:[]};function Xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Xie.isMDXComponent=!0;const gie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Tie.isMDXComponent=!0;const xie={toc:[]};function Cie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Cie.isMDXComponent=!0;const vie={toc:[]};function Lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lie.isMDXComponent=!0;const Zie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bie.isMDXComponent=!0;const Nie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zie.isMDXComponent=!0;const Aie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Wie.isMDXComponent=!0;const Rie={toc:[]};function Iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Iie.isMDXComponent=!0;const Sie={toc:[]};function Pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Pie.isMDXComponent=!0;const Eie={toc:[]};function Bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Bie.isMDXComponent=!0;const Gie={toc:[]};function Oie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Oie.isMDXComponent=!0;const Uie={toc:[]};function Fie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Fie.isMDXComponent=!0;const qie={toc:[]};function Vie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Vie.isMDXComponent=!0;const jie={toc:[]};function Hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Hie.isMDXComponent=!0;const Qie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Yie.isMDXComponent=!0;const $ie={toc:[]};function Kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kie.isMDXComponent=!0;const Jie={toc:[]};function tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}nae.isMDXComponent=!0;const oae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}pae.isMDXComponent=!0;const rae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}sae.isMDXComponent=!0;const cae={toc:[]};function iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hae.isMDXComponent=!0;const kae={toc:[]};function fae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}fae.isMDXComponent=!0;const yae={toc:[]};function Mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mae.isMDXComponent=!0;const Dae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wae.isMDXComponent=!0;const _ae={toc:[]};function Xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Xae.isMDXComponent=!0;const gae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Tae.isMDXComponent=!0;const xae={toc:[]};function Cae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Cae.isMDXComponent=!0;const vae={toc:[]};function Lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Lae.isMDXComponent=!0;const Zae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}bae.isMDXComponent=!0;const Nae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zae.isMDXComponent=!0;const Aae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Wae.isMDXComponent=!0;const Rae={toc:[]};function Iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Iae.isMDXComponent=!0;const Sae={toc:[]};function Pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Pae.isMDXComponent=!0;const Eae={toc:[]};function Bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Bae.isMDXComponent=!0;const Gae={toc:[]};function Oae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Oae.isMDXComponent=!0;const Uae={toc:[]};function Fae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Fae.isMDXComponent=!0;const qae={toc:[]};function Vae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Vae.isMDXComponent=!0;const jae={toc:[]};function Hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Hae.isMDXComponent=!0;const Qae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Yae.isMDXComponent=!0;const $ae={toc:[]};function Kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Kae.isMDXComponent=!0;const Jae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}nle.isMDXComponent=!0;const ole={toc:[]};function ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}ple.isMDXComponent=!0;const rle={toc:[]};function sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}sle.isMDXComponent=!0;const cle={toc:[]};function ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ile.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hle.isMDXComponent=!0;const kle={toc:[]};function fle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}fle.isMDXComponent=!0;const yle={toc:[]};function Mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mle.isMDXComponent=!0;const Dle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wle.isMDXComponent=!0;const _le={toc:[]};function Xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xle.isMDXComponent=!0;const gle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Tle.isMDXComponent=!0;const xle={toc:[]};function Cle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Cle.isMDXComponent=!0;const vle={toc:[]};function Lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lle.isMDXComponent=!0;const Zle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ble.isMDXComponent=!0;const Nle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zle.isMDXComponent=!0;const Ale={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wle.isMDXComponent=!0;const Rle={toc:[]};function Ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ile.isMDXComponent=!0;const Sle={toc:[]};function Ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ple.isMDXComponent=!0;const Ele={toc:[]};function Ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ble.isMDXComponent=!0;const Gle={toc:[]};function Ole(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ole.isMDXComponent=!0;const Ule={toc:[]};function Fle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Fle.isMDXComponent=!0;const qle={toc:[]};function Vle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Vle.isMDXComponent=!0;const jle={toc:[]};function Hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Hle.isMDXComponent=!0;const Qle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Yle.isMDXComponent=!0;const $le={toc:[]};function Kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Kle.isMDXComponent=!0;const Jle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nue.isMDXComponent=!0;const oue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pue.isMDXComponent=!0;const rue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sue.isMDXComponent=!0;const cue={toc:[]};function iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hue.isMDXComponent=!0;const kue={toc:[]};function fue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fue.isMDXComponent=!0;const yue={toc:[]};function Mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mue.isMDXComponent=!0;const Due={toc:[]};function wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wue.isMDXComponent=!0;const _ue={toc:[]};function Xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Xue.isMDXComponent=!0;const gue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Tue.isMDXComponent=!0;const xue={toc:[]};function Cue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Cue.isMDXComponent=!0;const vue={toc:[]};function Lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lue.isMDXComponent=!0;const Zue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bue.isMDXComponent=!0;const Nue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zue.isMDXComponent=!0;const Aue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wue.isMDXComponent=!0;const Rue={toc:[]};function Iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Iue.isMDXComponent=!0;const Sue={toc:[]};function Pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Pue.isMDXComponent=!0;const Eue={toc:[]};function Bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bue.isMDXComponent=!0;const Gue={toc:[]};function Oue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Oue.isMDXComponent=!0;const Uue={toc:[]};function Fue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Fue.isMDXComponent=!0;const que={toc:[]};function Vue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Vue.isMDXComponent=!0;const jue={toc:[]};function Hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Hue.isMDXComponent=!0;const Que={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Yue.isMDXComponent=!0;const $ue={toc:[]};function Kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kue.isMDXComponent=!0;const Jue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nme.isMDXComponent=!0;const ome={toc:[]};function pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pme.isMDXComponent=!0;const rme={toc:[]};function sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}sme.isMDXComponent=!0;const cme={toc:[]};function ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ime.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hme.isMDXComponent=!0;const kme={toc:[]};function fme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fme.isMDXComponent=!0;const yme={toc:[]};function Mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mme.isMDXComponent=!0;const Dme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wme.isMDXComponent=!0;const _me={toc:[]};function Xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Xme.isMDXComponent=!0;const gme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tme.isMDXComponent=!0;const xme={toc:[]};function Cme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Cme.isMDXComponent=!0;const vme={toc:[]};function Lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lme.isMDXComponent=!0;const Zme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bme.isMDXComponent=!0;const Nme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zme.isMDXComponent=!0;const Ame={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wme.isMDXComponent=!0;const Rme={toc:[]};function Ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Ime.isMDXComponent=!0;const Sme={toc:[]};function Pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Pme.isMDXComponent=!0;const Eme={toc:[]};function Bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bme.isMDXComponent=!0;const Gme={toc:[]};function Ome(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ome.isMDXComponent=!0;const Ume={toc:[]};function Fme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fme.isMDXComponent=!0;const qme={toc:[]};function Vme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Vme.isMDXComponent=!0;const jme={toc:[]};function Hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hme.isMDXComponent=!0;const Qme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Yme.isMDXComponent=!0;const $me={toc:[]};function Kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kme.isMDXComponent=!0;const Jme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nde.isMDXComponent=!0;const ode={toc:[]};function pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pde.isMDXComponent=!0;const rde={toc:[]};function sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sde.isMDXComponent=!0;const cde={toc:[]};function ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ide.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hde.isMDXComponent=!0;const kde={toc:[]};function fde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}fde.isMDXComponent=!0;const yde={toc:[]};function Mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mde.isMDXComponent=!0;const Dde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wde.isMDXComponent=!0;const _de={toc:[]};function Xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Xde.isMDXComponent=!0;const gde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Tde.isMDXComponent=!0;const xde={toc:[]};function Cde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Cde.isMDXComponent=!0;const vde={toc:[]};function Lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Lde.isMDXComponent=!0;const Zde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}bde.isMDXComponent=!0;const Nde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zde.isMDXComponent=!0;const Ade={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Wde.isMDXComponent=!0;const Rde={toc:[]};function Ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ide.isMDXComponent=!0;const Sde={toc:[]};function Pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pde.isMDXComponent=!0;const Ede={toc:[]};function Bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Bde.isMDXComponent=!0;const Gde={toc:[]};function Ode(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ode.isMDXComponent=!0;const Ude={toc:[]};function Fde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Fde.isMDXComponent=!0;const qde={toc:[]};function Vde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Vde.isMDXComponent=!0;const jde={toc:[]};function Hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hde.isMDXComponent=!0;const Qde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Yde.isMDXComponent=!0;const $de={toc:[]};function Kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kde.isMDXComponent=!0;const Jde={toc:[]};function the(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}phe.isMDXComponent=!0;const rhe={toc:[]};function she(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}she.isMDXComponent=!0;const che={toc:[]};function ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ihe.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hhe.isMDXComponent=!0;const khe={toc:[]};function fhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},khe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fhe.isMDXComponent=!0;const yhe={toc:[]};function Mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mhe.isMDXComponent=!0;const Dhe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}whe.isMDXComponent=!0;const _he={toc:[]};function Xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xhe.isMDXComponent=!0;const ghe={toc:[]};function The(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}The.isMDXComponent=!0;const xhe={toc:[]};function Che(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Che.isMDXComponent=!0;const vhe={toc:[]};function Lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}bhe.isMDXComponent=!0;const Nhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zhe.isMDXComponent=!0;const Ahe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Whe.isMDXComponent=!0;const Rhe={toc:[]};function Ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ihe.isMDXComponent=!0;const She={toc:[]};function Phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},She,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Phe.isMDXComponent=!0;const Ehe={toc:[]};function Bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Bhe.isMDXComponent=!0;const Ghe={toc:[]};function Ohe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ohe.isMDXComponent=!0;const Uhe={toc:[]};function Fhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Fhe.isMDXComponent=!0;const qhe={toc:[]};function Vhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vhe.isMDXComponent=!0;const jhe={toc:[]};function Hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Hhe.isMDXComponent=!0;const Qhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Yhe.isMDXComponent=!0;const $he={toc:[]};function Khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Khe.isMDXComponent=!0;const Jhe={toc:[]};function tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}nke.isMDXComponent=!0;const oke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}pke.isMDXComponent=!0;const rke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}ske.isMDXComponent=!0;const cke={toc:[]};function ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}ike.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hke.isMDXComponent=!0;const kke={toc:[]};function fke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fke.isMDXComponent=!0;const yke={toc:[]};function Mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mke.isMDXComponent=!0;const Dke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wke.isMDXComponent=!0;const _ke={toc:[]};function Xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xke.isMDXComponent=!0;const gke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Tke.isMDXComponent=!0;const xke={toc:[]};function Cke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Cke.isMDXComponent=!0;const vke={toc:[]};function Lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Lke.isMDXComponent=!0;const Zke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}bke.isMDXComponent=!0;const Nke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zke.isMDXComponent=!0;const Ake={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wke.isMDXComponent=!0;const Rke={toc:[]};function Ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ike.isMDXComponent=!0;const Ske={toc:[]};function Pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ske,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pke.isMDXComponent=!0;const Eke={toc:[]};function Bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Bke.isMDXComponent=!0;const Gke={toc:[]};function Oke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Oke.isMDXComponent=!0;const Uke={toc:[]};function Fke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fke.isMDXComponent=!0;const qke={toc:[]};function Vke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Vke.isMDXComponent=!0;const jke={toc:[]};function Hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hke.isMDXComponent=!0;const Qke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yke.isMDXComponent=!0;const $ke={toc:[]};function Kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kke.isMDXComponent=!0;const Jke={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pfe.isMDXComponent=!0;const rfe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sfe.isMDXComponent=!0;const cfe={toc:[]};function ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ife.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}hfe.isMDXComponent=!0;const kfe={toc:[]};function ffe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ffe.isMDXComponent=!0;const yfe={toc:[]};function Mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Mfe.isMDXComponent=!0;const Dfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wfe.isMDXComponent=!0;const _fe={toc:[]};function Xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Xfe.isMDXComponent=!0;const gfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Tfe.isMDXComponent=!0;const xfe={toc:[]};function Cfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Cfe.isMDXComponent=!0;const vfe={toc:[]};function Lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bfe.isMDXComponent=!0;const Nfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zfe.isMDXComponent=!0;const Afe={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wfe.isMDXComponent=!0;const Rfe={toc:[]};function Ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ife.isMDXComponent=!0;const Sfe={toc:[]};function Pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Pfe.isMDXComponent=!0;const Efe={toc:[]};function Bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bfe.isMDXComponent=!0;const Gfe={toc:[]};function Ofe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ofe.isMDXComponent=!0;const Ufe={toc:[]};function Ffe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ffe.isMDXComponent=!0;const qfe={toc:[]};function Vfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Vfe.isMDXComponent=!0;const jfe={toc:[]};function Hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Hfe.isMDXComponent=!0;const Qfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Yfe.isMDXComponent=!0;const $fe={toc:[]};function Kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]};function tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nye.isMDXComponent=!0;const oye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pye.isMDXComponent=!0;const rye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}sye.isMDXComponent=!0;const cye={toc:[]};function iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}iye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}hye.isMDXComponent=!0;const kye={toc:[]};function fye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fye.isMDXComponent=!0;const yye={toc:[]};function Mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mye.isMDXComponent=!0;const Dye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wye.isMDXComponent=!0;const _ye={toc:[]};function Xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xye.isMDXComponent=!0;const gye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tye.isMDXComponent=!0;const xye={toc:[]};function Cye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cye.isMDXComponent=!0;const vye={toc:[]};function Lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lye.isMDXComponent=!0;const Zye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bye.isMDXComponent=!0;const Nye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zye.isMDXComponent=!0;const Aye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wye.isMDXComponent=!0;const Rye={toc:[]};function Iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Iye.isMDXComponent=!0;const Sye={toc:[]};function Pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Pye.isMDXComponent=!0;const Eye={toc:[]};function Bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Bye.isMDXComponent=!0;const Gye={toc:[]};function Oye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Oye.isMDXComponent=!0;const Uye={toc:[]};function Fye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fye.isMDXComponent=!0;const qye={toc:[]};function Vye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vye.isMDXComponent=!0;const jye={toc:[]};function Hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Hye.isMDXComponent=!0;const Qye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Yye.isMDXComponent=!0;const $ye={toc:[]};function Kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kye.isMDXComponent=!0;const Jye={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pMe.isMDXComponent=!0;const rMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}sMe.isMDXComponent=!0;const cMe={toc:[]};function iMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hMe.isMDXComponent=!0;const kMe={toc:[]};function fMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fMe.isMDXComponent=!0;const yMe={toc:[]};function MMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}MMe.isMDXComponent=!0;const DMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wMe.isMDXComponent=!0;const _Me={toc:[]};function XMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}XMe.isMDXComponent=!0;const gMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}TMe.isMDXComponent=!0;const xMe={toc:[]};function CMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}CMe.isMDXComponent=!0;const vMe={toc:[]};function LMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}LMe.isMDXComponent=!0;const ZMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}bMe.isMDXComponent=!0;const NMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zMe.isMDXComponent=!0;const AMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}WMe.isMDXComponent=!0;const RMe={toc:[]};function IMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}IMe.isMDXComponent=!0;const SMe={toc:[]};function PMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}PMe.isMDXComponent=!0;const EMe={toc:[]};function BMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}BMe.isMDXComponent=!0;const GMe={toc:[]};function OMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OMe.isMDXComponent=!0;const UMe={toc:[]};function FMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}FMe.isMDXComponent=!0;const qMe={toc:[]};function VMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}VMe.isMDXComponent=!0;const jMe={toc:[]};function HMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}HMe.isMDXComponent=!0;const QMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}YMe.isMDXComponent=!0;const $Me={toc:[]};function KMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KMe.isMDXComponent=!0;const JMe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pDe.isMDXComponent=!0;const rDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sDe.isMDXComponent=!0;const cDe={toc:[]};function iDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hDe.isMDXComponent=!0;const kDe={toc:[]};function fDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fDe.isMDXComponent=!0;const yDe={toc:[]};function MDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MDe.isMDXComponent=!0;const DDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wDe.isMDXComponent=!0;const _De={toc:[]};function XDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}XDe.isMDXComponent=!0;const gDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}TDe.isMDXComponent=!0;const xDe={toc:[]};function CDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}CDe.isMDXComponent=!0;const vDe={toc:[]};function LDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}LDe.isMDXComponent=!0;const ZDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bDe.isMDXComponent=!0;const NDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}zDe.isMDXComponent=!0;const ADe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}WDe.isMDXComponent=!0;const RDe={toc:[]};function IDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}IDe.isMDXComponent=!0;const SDe={toc:[]};function PDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PDe.isMDXComponent=!0;const EDe={toc:[]};function BDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}BDe.isMDXComponent=!0;const GDe={toc:[]};function ODe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ODe.isMDXComponent=!0;const UDe={toc:[]};function FDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FDe.isMDXComponent=!0;const qDe={toc:[]};function VDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VDe.isMDXComponent=!0;const jDe={toc:[]};function HDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HDe.isMDXComponent=!0;const QDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}YDe.isMDXComponent=!0;const $De={toc:[]};function KDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}KDe.isMDXComponent=!0;const JDe={toc:[]};function twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}nwe.isMDXComponent=!0;const owe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pwe.isMDXComponent=!0;const rwe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}swe.isMDXComponent=!0;const cwe={toc:[]};function iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}hwe.isMDXComponent=!0;const kwe={toc:[]};function fwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fwe.isMDXComponent=!0;const ywe={toc:[]};function Mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mwe.isMDXComponent=!0;const Dwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wwe.isMDXComponent=!0;const _we={toc:[]};function Xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Xwe.isMDXComponent=!0;const gwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Twe.isMDXComponent=!0;const xwe={toc:[]};function Cwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Cwe.isMDXComponent=!0;const vwe={toc:[]};function Lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}bwe.isMDXComponent=!0;const Nwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zwe.isMDXComponent=!0;const Awe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wwe.isMDXComponent=!0;const Rwe={toc:[]};function Iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iwe.isMDXComponent=!0;const Swe={toc:[]};function Pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Pwe.isMDXComponent=!0;const Ewe={toc:[]};function Bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bwe.isMDXComponent=!0;const Gwe={toc:[]};function Owe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Owe.isMDXComponent=!0;const Uwe={toc:[]};function Fwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Fwe.isMDXComponent=!0;const qwe={toc:[]};function Vwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Vwe.isMDXComponent=!0;const jwe={toc:[]};function Hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Hwe.isMDXComponent=!0;const Qwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Ywe.isMDXComponent=!0;const $we={toc:[]};function Kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}p_e.isMDXComponent=!0;const r_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s_e.isMDXComponent=!0;const c_e={toc:[]};function i_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}i_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}h_e.isMDXComponent=!0;const k_e={toc:[]};function f_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}f_e.isMDXComponent=!0;const y_e={toc:[]};function M_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M_e.isMDXComponent=!0;const D_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}w_e.isMDXComponent=!0;const __e={toc:[]};function X_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}X_e.isMDXComponent=!0;const g_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}T_e.isMDXComponent=!0;const x_e={toc:[]};function C_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}C_e.isMDXComponent=!0;const v_e={toc:[]};function L_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}L_e.isMDXComponent=!0;const Z_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b_e.isMDXComponent=!0;const N_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}z_e.isMDXComponent=!0;const A_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W_e.isMDXComponent=!0;const R_e={toc:[]};function I_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}I_e.isMDXComponent=!0;const S_e={toc:[]};function P_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}P_e.isMDXComponent=!0;const E_e={toc:[]};function B_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}B_e.isMDXComponent=!0;const G_e={toc:[]};function O_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}O_e.isMDXComponent=!0;const U_e={toc:[]};function F_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}F_e.isMDXComponent=!0;const q_e={toc:[]};function V_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}V_e.isMDXComponent=!0;const j_e={toc:[]};function H_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}H_e.isMDXComponent=!0;const Q_e={toc:[]};function Y_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y_e.isMDXComponent=!0;const $_e={toc:[]};function K_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}K_e.isMDXComponent=!0;const J_e={toc:[]};function tXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}tXe.isMDXComponent=!0;const eXe={toc:[]};function nXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nXe.isMDXComponent=!0;const oXe={toc:[]};function pXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pXe.isMDXComponent=!0;const rXe={toc:[]};function sXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}sXe.isMDXComponent=!0;const cXe={toc:[]};function iXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iXe.isMDXComponent=!0;const aXe={toc:[]};function lXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lXe.isMDXComponent=!0;const uXe={toc:[]};function mXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mXe.isMDXComponent=!0;const dXe={toc:[]};function hXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}hXe.isMDXComponent=!0;const kXe={toc:[]};function fXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fXe.isMDXComponent=!0;const yXe={toc:[]};function MXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}MXe.isMDXComponent=!0;const DXe={toc:[]};function wXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wXe.isMDXComponent=!0;const _Xe={toc:[]};function XXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}XXe.isMDXComponent=!0;const gXe={toc:[]};function TXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}TXe.isMDXComponent=!0;const xXe={toc:[]};function CXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}CXe.isMDXComponent=!0;const vXe={toc:[]};function LXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LXe.isMDXComponent=!0;const ZXe={toc:[]};function bXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bXe.isMDXComponent=!0;const NXe={toc:[]};function zXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zXe.isMDXComponent=!0;const AXe={toc:[]};function WXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}WXe.isMDXComponent=!0;const RXe={toc:[]};function IXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IXe.isMDXComponent=!0;const SXe={toc:[]};function PXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PXe.isMDXComponent=!0;const EXe={toc:[]};function BXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BXe.isMDXComponent=!0;const GXe={toc:[]};function OXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OXe.isMDXComponent=!0;const UXe={toc:[]};function FXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FXe.isMDXComponent=!0;const qXe={toc:[]};function VXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VXe.isMDXComponent=!0;const jXe={toc:[]};function HXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HXe.isMDXComponent=!0;const QXe={toc:[]};function YXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YXe.isMDXComponent=!0;const $Xe={toc:[]};function KXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KXe.isMDXComponent=!0;const JXe={toc:[]};function tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tge.isMDXComponent=!0;const ege={toc:[]};function nge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nge.isMDXComponent=!0;const oge={toc:[]};function pge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pge.isMDXComponent=!0;const rge={toc:[]};function sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sge.isMDXComponent=!0;const cge={toc:[]};function ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}ige.isMDXComponent=!0;const age={toc:[]};function lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lge.isMDXComponent=!0;const uge={toc:[]};function mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mge.isMDXComponent=!0;const dge={toc:[]};function hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hge.isMDXComponent=!0;const kge={toc:[]};function fge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fge.isMDXComponent=!0;const yge={toc:[]};function Mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mge.isMDXComponent=!0;const Dge={toc:[]};function wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wge.isMDXComponent=!0;const _ge={toc:[]};function Xge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xge.isMDXComponent=!0;const gge={toc:[]};function Tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tge.isMDXComponent=!0;const xge={toc:[]};function Cge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Cge.isMDXComponent=!0;const vge={toc:[]};function Lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lge.isMDXComponent=!0;const Zge={toc:[]};function bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bge.isMDXComponent=!0;const Nge={toc:[]};function zge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zge.isMDXComponent=!0;const Age={toc:[]};function Wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wge.isMDXComponent=!0;const Rge={toc:[]};function Ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ige.isMDXComponent=!0;const Sge={toc:[]};function Pge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pge.isMDXComponent=!0;const Ege={toc:[]};function Bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bge.isMDXComponent=!0;const Gge={toc:[]};function Oge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Oge.isMDXComponent=!0;const Uge={toc:[]};function Fge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}Fge.isMDXComponent=!0;const qge={toc:[]};function Vge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Vge.isMDXComponent=!0;const jge={toc:[]};function Hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Hge.isMDXComponent=!0;const Qge={toc:[]};function Yge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Yge.isMDXComponent=!0;const $ge={toc:[]};function Kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Kge.isMDXComponent=!0;const Jge={toc:[]};function tTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tTe.isMDXComponent=!0;const eTe={toc:[]};function nTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nTe.isMDXComponent=!0;const oTe={toc:[]};function pTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pTe.isMDXComponent=!0;const rTe={toc:[]};function sTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sTe.isMDXComponent=!0;const cTe={toc:[]};function iTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iTe.isMDXComponent=!0;const aTe={toc:[]};function lTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lTe.isMDXComponent=!0;const uTe={toc:[]};function mTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mTe.isMDXComponent=!0;const dTe={toc:[]};function hTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hTe.isMDXComponent=!0;const kTe={toc:[]};function fTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}fTe.isMDXComponent=!0;const yTe={toc:[]};function MTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}MTe.isMDXComponent=!0;const DTe={toc:[]};function wTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}wTe.isMDXComponent=!0;const _Te={toc:[]};function XTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XTe.isMDXComponent=!0;const gTe={toc:[]};function TTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}TTe.isMDXComponent=!0;const xTe={toc:[]};function CTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CTe.isMDXComponent=!0;const vTe={toc:[]};function LTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LTe.isMDXComponent=!0;const ZTe={toc:[]};function bTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bTe.isMDXComponent=!0;const NTe={toc:[]};function zTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zTe.isMDXComponent=!0;const ATe={toc:[]};function WTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}WTe.isMDXComponent=!0;const RTe={toc:[]};function ITe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}ITe.isMDXComponent=!0;const STe={toc:[]};function PTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PTe.isMDXComponent=!0;const ETe={toc:[]};function BTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}BTe.isMDXComponent=!0;const GTe={toc:[]};function OTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OTe.isMDXComponent=!0;const UTe={toc:[]};function FTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FTe.isMDXComponent=!0;const qTe={toc:[]};function VTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VTe.isMDXComponent=!0;const jTe={toc:[]};function HTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HTe.isMDXComponent=!0;const QTe={toc:[]};function YTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YTe.isMDXComponent=!0;const $Te={toc:[]};function KTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}KTe.isMDXComponent=!0;const JTe={toc:[]};function txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}txe.isMDXComponent=!0;const exe={toc:[]};function nxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nxe.isMDXComponent=!0;const oxe={toc:[]};function pxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pxe.isMDXComponent=!0;const rxe={toc:[]};function sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sxe.isMDXComponent=!0;const cxe={toc:[]};function ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ixe.isMDXComponent=!0;const axe={toc:[]};function lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lxe.isMDXComponent=!0;const uxe={toc:[]};function mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mxe.isMDXComponent=!0;const dxe={toc:[]};function hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hxe.isMDXComponent=!0;const kxe={toc:[]};function fxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}fxe.isMDXComponent=!0;const yxe={toc:[]};function Mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Mxe.isMDXComponent=!0;const Dxe={toc:[]};function wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}wxe.isMDXComponent=!0;const _xe={toc:[]};function Xxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xxe.isMDXComponent=!0;const gxe={toc:[]};function Txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Txe.isMDXComponent=!0;const xxe={toc:[]};function Cxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cxe.isMDXComponent=!0;const vxe={toc:[]};function Lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]};function bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bxe.isMDXComponent=!0;const Nxe={toc:[]};function zxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zxe.isMDXComponent=!0;const Axe={toc:[]};function Wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Wxe.isMDXComponent=!0;const Rxe={toc:[]};function Ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Ixe.isMDXComponent=!0;const Sxe={toc:[]};function Pxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Pxe.isMDXComponent=!0;const Exe={toc:[]};function Bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Bxe.isMDXComponent=!0;const Gxe={toc:[]};function Oxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Oxe.isMDXComponent=!0;const Uxe={toc:[]};function Fxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Fxe.isMDXComponent=!0;const qxe={toc:[]};function Vxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Vxe.isMDXComponent=!0;const jxe={toc:[]};function Hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Hxe.isMDXComponent=!0;const Qxe={toc:[]};function Yxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yxe.isMDXComponent=!0;const $xe={toc:[]};function Kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]};function tCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tCe.isMDXComponent=!0;const eCe={toc:[]};function nCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nCe.isMDXComponent=!0;const oCe={toc:[]};function pCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pCe.isMDXComponent=!0;const rCe={toc:[]};function sCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sCe.isMDXComponent=!0;const cCe={toc:[]};function iCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}iCe.isMDXComponent=!0;const aCe={toc:[]};function lCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lCe.isMDXComponent=!0;const uCe={toc:[]};function mCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mCe.isMDXComponent=!0;const dCe={toc:[]};function hCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hCe.isMDXComponent=!0;const kCe={toc:[]};function fCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}fCe.isMDXComponent=!0;const yCe={toc:[]};function MCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MCe.isMDXComponent=!0;const DCe={toc:[]};function wCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wCe.isMDXComponent=!0;const _Ce={toc:[]};function XCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}XCe.isMDXComponent=!0;const gCe={toc:[]};function TCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}TCe.isMDXComponent=!0;const xCe={toc:[]};function CCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}CCe.isMDXComponent=!0;const vCe={toc:[]};function LCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}LCe.isMDXComponent=!0;const ZCe={toc:[]};function bCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}bCe.isMDXComponent=!0;const NCe={toc:[]};function zCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}zCe.isMDXComponent=!0;const ACe={toc:[]};function WCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WCe.isMDXComponent=!0;const RCe={toc:[]};function ICe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ICe.isMDXComponent=!0;const SCe={toc:[]};function PCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PCe.isMDXComponent=!0;const ECe={toc:[]};function BCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BCe.isMDXComponent=!0;const GCe={toc:[]};function OCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OCe.isMDXComponent=!0;const UCe={toc:[]};function FCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FCe.isMDXComponent=!0;const qCe={toc:[]};function VCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VCe.isMDXComponent=!0;const jCe={toc:[]};function HCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HCe.isMDXComponent=!0;const QCe={toc:[]};function YCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YCe.isMDXComponent=!0;const $Ce={toc:[]};function KCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KCe.isMDXComponent=!0;const JCe={toc:[]};function tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tve.isMDXComponent=!0;const eve={toc:[]};function nve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nve.isMDXComponent=!0;const ove={toc:[]};function pve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pve.isMDXComponent=!0;const rve={toc:[]};function sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sve.isMDXComponent=!0;const cve={toc:[]};function ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ive.isMDXComponent=!0;const ave={toc:[]};function lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lve.isMDXComponent=!0;const uve={toc:[]};function mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mve.isMDXComponent=!0;const dve={toc:[]};function hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hve.isMDXComponent=!0;const kve={toc:[]};function fve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fve.isMDXComponent=!0;const yve={toc:[]};function Mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mve.isMDXComponent=!0;const Dve={toc:[]};function wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wve.isMDXComponent=!0;const _ve={toc:[]};function Xve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Xve.isMDXComponent=!0;const gve={toc:[]};function Tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Tve.isMDXComponent=!0;const xve={toc:[]};function Cve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Cve.isMDXComponent=!0;const vve={toc:[]};function Lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lve.isMDXComponent=!0;const Zve={toc:[]};function bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bve.isMDXComponent=!0;const Nve={toc:[]};function zve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zve.isMDXComponent=!0;const Ave={toc:[]};function Wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wve.isMDXComponent=!0;const Rve={toc:[]};function Ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ive.isMDXComponent=!0;const Sve={toc:[]};function Pve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Pve.isMDXComponent=!0;const Eve={toc:[]};function Bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Bve.isMDXComponent=!0;const Gve={toc:[]};function Ove(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Ove.isMDXComponent=!0;const Uve={toc:[]};function Fve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fve.isMDXComponent=!0;const qve={toc:[]};function Vve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Vve.isMDXComponent=!0;const jve={toc:[]};function Hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hve.isMDXComponent=!0;const Qve={toc:[]};function Yve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Yve.isMDXComponent=!0;const $ve={toc:[]};function Kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kve.isMDXComponent=!0;const Jve={toc:[]};function tLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tLe.isMDXComponent=!0;const eLe={toc:[]};function nLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nLe.isMDXComponent=!0;const oLe={toc:[]};function pLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pLe.isMDXComponent=!0;const rLe={toc:[]};function sLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sLe.isMDXComponent=!0;const cLe={toc:[]};function iLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}iLe.isMDXComponent=!0;const aLe={toc:[]};function lLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lLe.isMDXComponent=!0;const uLe={toc:[]};function mLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}mLe.isMDXComponent=!0;const dLe={toc:[]};function hLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}hLe.isMDXComponent=!0;const kLe={toc:[]};function fLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}fLe.isMDXComponent=!0;const yLe={toc:[]};function MLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}MLe.isMDXComponent=!0;const DLe={toc:[]};function wLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}wLe.isMDXComponent=!0;const _Le={toc:[]};function XLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XLe.isMDXComponent=!0;const gLe={toc:[]};function TLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}TLe.isMDXComponent=!0;const xLe={toc:[]};function CLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CLe.isMDXComponent=!0;const vLe={toc:[]};function LLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LLe.isMDXComponent=!0;const ZLe={toc:[]};function bLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bLe.isMDXComponent=!0;const NLe={toc:[]};function zLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zLe.isMDXComponent=!0;const ALe={toc:[]};function WLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WLe.isMDXComponent=!0;const RLe={toc:[]};function ILe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ILe.isMDXComponent=!0;const SLe={toc:[]};function PLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PLe.isMDXComponent=!0;const ELe={toc:[]};function BLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}BLe.isMDXComponent=!0;const GLe={toc:[]};function OLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OLe.isMDXComponent=!0;const ULe={toc:[]};function FLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}FLe.isMDXComponent=!0;const qLe={toc:[]};function VLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VLe.isMDXComponent=!0;const jLe={toc:[]};function HLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HLe.isMDXComponent=!0;const QLe={toc:[]};function YLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YLe.isMDXComponent=!0;const $Le={toc:[]};function KLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KLe.isMDXComponent=!0;const JLe={toc:[]};function tZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}tZe.isMDXComponent=!0;const eZe={toc:[]};function nZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}nZe.isMDXComponent=!0;const oZe={toc:[]};function pZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pZe.isMDXComponent=!0;const rZe={toc:[]};function sZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sZe.isMDXComponent=!0;const cZe={toc:[]};function iZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iZe.isMDXComponent=!0;const aZe={toc:[]};function lZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lZe.isMDXComponent=!0;const uZe={toc:[]};function mZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mZe.isMDXComponent=!0;const dZe={toc:[]};function hZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hZe.isMDXComponent=!0;const kZe={toc:[]};function fZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}fZe.isMDXComponent=!0;const yZe={toc:[]};function MZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}MZe.isMDXComponent=!0;const DZe={toc:[]};function wZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wZe.isMDXComponent=!0;const _Ze={toc:[]};function XZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}XZe.isMDXComponent=!0;const gZe={toc:[]};function TZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TZe.isMDXComponent=!0;const xZe={toc:[]};function CZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}CZe.isMDXComponent=!0;const vZe={toc:[]};function LZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LZe.isMDXComponent=!0;const ZZe={toc:[]};function bZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bZe.isMDXComponent=!0;const NZe={toc:[]};function zZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}zZe.isMDXComponent=!0;const AZe={toc:[]};function WZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}WZe.isMDXComponent=!0;const RZe={toc:[]};function IZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}IZe.isMDXComponent=!0;const SZe={toc:[]};function PZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PZe.isMDXComponent=!0;const EZe={toc:[]};function BZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}BZe.isMDXComponent=!0;const GZe={toc:[]};function OZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}OZe.isMDXComponent=!0;const UZe={toc:[]};function FZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}FZe.isMDXComponent=!0;const qZe={toc:[]};function VZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}VZe.isMDXComponent=!0;const jZe={toc:[]};function HZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HZe.isMDXComponent=!0;const QZe={toc:[]};function YZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}YZe.isMDXComponent=!0;const $Ze={toc:[]};function KZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KZe.isMDXComponent=!0;const JZe={toc:[]};function tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tbe.isMDXComponent=!0;const ebe={toc:[]};function nbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nbe.isMDXComponent=!0;const obe={toc:[]};function pbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pbe.isMDXComponent=!0;const rbe={toc:[]};function sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sbe.isMDXComponent=!0;const cbe={toc:[]};function ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ibe.isMDXComponent=!0;const abe={toc:[]};function lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lbe.isMDXComponent=!0;const ube={toc:[]};function mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mbe.isMDXComponent=!0;const dbe={toc:[]};function hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hbe.isMDXComponent=!0;const kbe={toc:[]};function fbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fbe.isMDXComponent=!0;const ybe={toc:[]};function Mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mbe.isMDXComponent=!0;const Dbe={toc:[]};function wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wbe.isMDXComponent=!0;const _be={toc:[]};function Xbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xbe.isMDXComponent=!0;const gbe={toc:[]};function Tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tbe.isMDXComponent=!0;const xbe={toc:[]};function Cbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cbe.isMDXComponent=!0;const vbe={toc:[]};function Lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]};function bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bbe.isMDXComponent=!0;const Nbe={toc:[]};function zbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zbe.isMDXComponent=!0;const Abe={toc:[]};function Wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wbe.isMDXComponent=!0;const Rbe={toc:[]};function Ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ibe.isMDXComponent=!0;const Sbe={toc:[]};function Pbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pbe.isMDXComponent=!0;const Ebe={toc:[]};function Bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bbe.isMDXComponent=!0;const Gbe={toc:[]};function Obe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Obe.isMDXComponent=!0;const Ube={toc:[]};function Fbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Fbe.isMDXComponent=!0;const qbe={toc:[]};function Vbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Vbe.isMDXComponent=!0;const jbe={toc:[]};function Hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Hbe.isMDXComponent=!0;const Qbe={toc:[]};function Ybe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ybe.isMDXComponent=!0;const $be={toc:[]};function Kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]};function tNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tNe.isMDXComponent=!0;const eNe={toc:[]};function nNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nNe.isMDXComponent=!0;const oNe={toc:[]};function pNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}pNe.isMDXComponent=!0;const rNe={toc:[]};function sNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sNe.isMDXComponent=!0;const cNe={toc:[]};function iNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iNe.isMDXComponent=!0;const aNe={toc:[]};function lNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lNe.isMDXComponent=!0;const uNe={toc:[]};function mNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mNe.isMDXComponent=!0;const dNe={toc:[]};function hNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hNe.isMDXComponent=!0;const kNe={toc:[]};function fNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}fNe.isMDXComponent=!0;const yNe={toc:[]};function MNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MNe.isMDXComponent=!0;const DNe={toc:[]};function wNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wNe.isMDXComponent=!0;const _Ne={toc:[]};function XNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}XNe.isMDXComponent=!0;const gNe={toc:[]};function TNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}TNe.isMDXComponent=!0;const xNe={toc:[]};function CNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}CNe.isMDXComponent=!0;const vNe={toc:[]};function LNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LNe.isMDXComponent=!0;const ZNe={toc:[]};function bNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bNe.isMDXComponent=!0;const NNe={toc:[]};function zNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zNe.isMDXComponent=!0;const ANe={toc:[]};function WNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WNe.isMDXComponent=!0;const RNe={toc:[]};function INe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}INe.isMDXComponent=!0;const SNe={toc:[]};function PNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}PNe.isMDXComponent=!0;const ENe={toc:[]};function BNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BNe.isMDXComponent=!0;const GNe={toc:[]};function ONe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ONe.isMDXComponent=!0;const UNe={toc:[]};function FNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FNe.isMDXComponent=!0;const qNe={toc:[]};function VNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VNe.isMDXComponent=!0;const jNe={toc:[]};function HNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HNe.isMDXComponent=!0;const QNe={toc:[]};function YNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YNe.isMDXComponent=!0;const $Ne={toc:[]};function KNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KNe.isMDXComponent=!0;const JNe={toc:[]};function tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}tze.isMDXComponent=!0;const eze={toc:[]};function nze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nze.isMDXComponent=!0;const oze={toc:[]};function pze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pze.isMDXComponent=!0;const rze={toc:[]};function sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}sze.isMDXComponent=!0;const cze={toc:[]};function ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}ize.isMDXComponent=!0;const aze={toc:[]};function lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lze.isMDXComponent=!0;const uze={toc:[]};function mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mze.isMDXComponent=!0;const dze={toc:[]};function hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hze.isMDXComponent=!0;const kze={toc:[]};function fze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}fze.isMDXComponent=!0;const yze={toc:[]};function Mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mze.isMDXComponent=!0;const Dze={toc:[]};function wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wze.isMDXComponent=!0;const _ze={toc:[]};function Xze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xze.isMDXComponent=!0;const gze={toc:[]};function Tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Tze.isMDXComponent=!0;const xze={toc:[]};function Cze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cze.isMDXComponent=!0;const vze={toc:[]};function Lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lze.isMDXComponent=!0;const Zze={toc:[]};function bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bze.isMDXComponent=!0;const Nze={toc:[]};function zze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zze.isMDXComponent=!0;const Aze={toc:[]};function Wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wze.isMDXComponent=!0;const Rze={toc:[]};function Ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ize.isMDXComponent=!0;const Sze={toc:[]};function Pze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pze.isMDXComponent=!0;const Eze={toc:[]};function Bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bze.isMDXComponent=!0;const Gze={toc:[]};function Oze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oze.isMDXComponent=!0;const Uze={toc:[]};function Fze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fze.isMDXComponent=!0;const qze={toc:[]};function Vze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vze.isMDXComponent=!0;const jze={toc:[]};function Hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hze.isMDXComponent=!0;const Qze={toc:[]};function Yze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yze.isMDXComponent=!0;const $ze={toc:[]};function Kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kze.isMDXComponent=!0;const Jze={toc:[]};function tAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tAe.isMDXComponent=!0;const eAe={toc:[]};function nAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nAe.isMDXComponent=!0;const oAe={toc:[]};function pAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pAe.isMDXComponent=!0;const rAe={toc:[]};function sAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sAe.isMDXComponent=!0;const cAe={toc:[]};function iAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}iAe.isMDXComponent=!0;const aAe={toc:[]};function lAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lAe.isMDXComponent=!0;const uAe={toc:[]};function mAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mAe.isMDXComponent=!0;const dAe={toc:[]};function hAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hAe.isMDXComponent=!0;const kAe={toc:[]};function fAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fAe.isMDXComponent=!0;const yAe={toc:[]};function MAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}MAe.isMDXComponent=!0;const DAe={toc:[]};function wAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wAe.isMDXComponent=!0;const _Ae={toc:[]};function XAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}XAe.isMDXComponent=!0;const gAe={toc:[]};function TAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}TAe.isMDXComponent=!0;const xAe={toc:[]};function CAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}CAe.isMDXComponent=!0;const vAe={toc:[]};function LAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}LAe.isMDXComponent=!0;const ZAe={toc:[]};function bAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}bAe.isMDXComponent=!0;const NAe={toc:[]};function zAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zAe.isMDXComponent=!0;const AAe={toc:[]};function WAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WAe.isMDXComponent=!0;const RAe={toc:[]};function IAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IAe.isMDXComponent=!0;const SAe={toc:[]};function PAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}PAe.isMDXComponent=!0;const EAe={toc:[]};function BAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BAe.isMDXComponent=!0;const GAe={toc:[]};function OAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}OAe.isMDXComponent=!0;const UAe={toc:[]};function FAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}FAe.isMDXComponent=!0;const qAe={toc:[]};function VAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VAe.isMDXComponent=!0;const jAe={toc:[]};function HAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}HAe.isMDXComponent=!0;const QAe={toc:[]};function YAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}YAe.isMDXComponent=!0;const $Ae={toc:[]};function KAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}KAe.isMDXComponent=!0;const JAe={toc:[]};function tWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tWe.isMDXComponent=!0;const eWe={toc:[]};function nWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nWe.isMDXComponent=!0;const oWe={toc:[]};function pWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pWe.isMDXComponent=!0;const rWe={toc:[]};function sWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}sWe.isMDXComponent=!0;const cWe={toc:[]};function iWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}iWe.isMDXComponent=!0;const aWe={toc:[]};function lWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lWe.isMDXComponent=!0;const uWe={toc:[]};function mWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mWe.isMDXComponent=!0;const dWe={toc:[]};function hWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hWe.isMDXComponent=!0;const kWe={toc:[]};function fWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fWe.isMDXComponent=!0;const yWe={toc:[]};function MWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}MWe.isMDXComponent=!0;const DWe={toc:[]};function wWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wWe.isMDXComponent=!0;const _We={toc:[]};function XWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}XWe.isMDXComponent=!0;const gWe={toc:[]};function TWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TWe.isMDXComponent=!0;const xWe={toc:[]};function CWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}CWe.isMDXComponent=!0;const vWe={toc:[]};function LWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LWe.isMDXComponent=!0;const ZWe={toc:[]};function bWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}bWe.isMDXComponent=!0;const NWe={toc:[]};function zWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zWe.isMDXComponent=!0;const AWe={toc:[]};function WWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}WWe.isMDXComponent=!0;const RWe={toc:[]};function IWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IWe.isMDXComponent=!0;const SWe={toc:[]};function PWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PWe.isMDXComponent=!0;const EWe={toc:[]};function BWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BWe.isMDXComponent=!0;const GWe={toc:[]};function OWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}OWe.isMDXComponent=!0;const UWe={toc:[]};function FWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FWe.isMDXComponent=!0;const qWe={toc:[]};function VWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}VWe.isMDXComponent=!0;const jWe={toc:[]};function HWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HWe.isMDXComponent=!0;const QWe={toc:[]};function YWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}YWe.isMDXComponent=!0;const $We={toc:[]};function KWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KWe.isMDXComponent=!0;const JWe={toc:[]};function tRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tRe.isMDXComponent=!0;const eRe={toc:[]};function nRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}nRe.isMDXComponent=!0;const oRe={toc:[]};function pRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}pRe.isMDXComponent=!0;const rRe={toc:[]};function sRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sRe.isMDXComponent=!0;const cRe={toc:[]};function iRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iRe.isMDXComponent=!0;const aRe={toc:[]};function lRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lRe.isMDXComponent=!0;const uRe={toc:[]};function mRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mRe.isMDXComponent=!0;const dRe={toc:[]};function hRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hRe.isMDXComponent=!0;const kRe={toc:[]};function fRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}fRe.isMDXComponent=!0;const yRe={toc:[]};function MRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MRe.isMDXComponent=!0;const DRe={toc:[]};function wRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wRe.isMDXComponent=!0;const _Re={toc:[]};function XRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XRe.isMDXComponent=!0;const gRe={toc:[]};function TRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}TRe.isMDXComponent=!0;const xRe={toc:[]};function CRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}CRe.isMDXComponent=!0;const vRe={toc:[]};function LRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}LRe.isMDXComponent=!0;const ZRe={toc:[]};function bRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}bRe.isMDXComponent=!0;const NRe={toc:[]};function zRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zRe.isMDXComponent=!0;const ARe={toc:[]};function WRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WRe.isMDXComponent=!0;const RRe={toc:[]};function IRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}IRe.isMDXComponent=!0;const SRe={toc:[]};function PRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}PRe.isMDXComponent=!0;const ERe={toc:[]};function BRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}BRe.isMDXComponent=!0;const GRe={toc:[]};function ORe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}ORe.isMDXComponent=!0;const URe={toc:[]};function FRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}FRe.isMDXComponent=!0;const qRe={toc:[]};function VRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}VRe.isMDXComponent=!0;const jRe={toc:[]};function HRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HRe.isMDXComponent=!0;const QRe={toc:[]};function YRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}YRe.isMDXComponent=!0;const $Re={toc:[]};function KRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KRe.isMDXComponent=!0;const JRe={toc:[]};function tIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tIe.isMDXComponent=!0;const eIe={toc:[]};function nIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nIe.isMDXComponent=!0;const oIe={toc:[]};function pIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pIe.isMDXComponent=!0;const rIe={toc:[]};function sIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sIe.isMDXComponent=!0;const cIe={toc:[]};function iIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iIe.isMDXComponent=!0;const aIe={toc:[]};function lIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lIe.isMDXComponent=!0;const uIe={toc:[]};function mIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mIe.isMDXComponent=!0;const dIe={toc:[]};function hIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hIe.isMDXComponent=!0;const kIe={toc:[]};function fIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}fIe.isMDXComponent=!0;const yIe={toc:[]};function MIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MIe.isMDXComponent=!0;const DIe={toc:[]};function wIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wIe.isMDXComponent=!0;const _Ie={toc:[]};function XIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XIe.isMDXComponent=!0;const gIe={toc:[]};function TIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}TIe.isMDXComponent=!0;const xIe={toc:[]};function CIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}CIe.isMDXComponent=!0;const vIe={toc:[]};function LIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}LIe.isMDXComponent=!0;const ZIe={toc:[]};function bIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bIe.isMDXComponent=!0;const NIe={toc:[]};function zIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zIe.isMDXComponent=!0;const AIe={toc:[]};function WIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}WIe.isMDXComponent=!0;const RIe={toc:[]};function IIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}IIe.isMDXComponent=!0;const SIe={toc:[]};function PIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PIe.isMDXComponent=!0;const EIe={toc:[]};function BIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}BIe.isMDXComponent=!0;const GIe={toc:[]};function OIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OIe.isMDXComponent=!0;const UIe={toc:[]};function FIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FIe.isMDXComponent=!0;const qIe={toc:[]};function VIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VIe.isMDXComponent=!0;const jIe={toc:[]};function HIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HIe.isMDXComponent=!0;const QIe={toc:[]};function YIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}YIe.isMDXComponent=!0;const $Ie={toc:[]};function KIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}KIe.isMDXComponent=!0;const JIe={toc:[]};function tSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}tSe.isMDXComponent=!0;const eSe={toc:[]};function nSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}nSe.isMDXComponent=!0;const oSe={toc:[]};function pSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}pSe.isMDXComponent=!0;const rSe={toc:[]};function sSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}sSe.isMDXComponent=!0;const cSe={toc:[]};function iSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iSe.isMDXComponent=!0;const aSe={toc:[]};function lSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}lSe.isMDXComponent=!0;const uSe={toc:[]};function mSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}mSe.isMDXComponent=!0;const dSe={toc:[]};function hSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hSe.isMDXComponent=!0;const kSe={toc:[]};function fSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}fSe.isMDXComponent=!0;const ySe={toc:[]};function MSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}MSe.isMDXComponent=!0;const DSe={toc:[]};function wSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}wSe.isMDXComponent=!0;const _Se={toc:[]};function XSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}XSe.isMDXComponent=!0;const gSe={toc:[]};function TSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}TSe.isMDXComponent=!0;const xSe={toc:[]};function CSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}CSe.isMDXComponent=!0;const vSe={toc:[]};function LSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}LSe.isMDXComponent=!0;const ZSe={toc:[]};function bSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}bSe.isMDXComponent=!0;const NSe={toc:[]};function zSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}zSe.isMDXComponent=!0;const ASe={toc:[]};function WSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}WSe.isMDXComponent=!0;const RSe={toc:[]};function ISe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}ISe.isMDXComponent=!0;const SSe={toc:[]};function PSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}PSe.isMDXComponent=!0;const ESe={toc:[]};function BSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}BSe.isMDXComponent=!0;const GSe={toc:[]};function OSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}OSe.isMDXComponent=!0;const USe={toc:[]};function FSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}FSe.isMDXComponent=!0;const qSe={toc:[]};function VSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}VSe.isMDXComponent=!0;const jSe={toc:[]};function HSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}HSe.isMDXComponent=!0;const QSe={toc:[]};function YSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}YSe.isMDXComponent=!0;const $Se={toc:[]};function KSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}KSe.isMDXComponent=!0;const JSe={toc:[]};function tPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}tPe.isMDXComponent=!0;const ePe={toc:[]};function nPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}nPe.isMDXComponent=!0;const oPe={toc:[]};function pPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}pPe.isMDXComponent=!0;const rPe={toc:[]};function sPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}sPe.isMDXComponent=!0;const cPe={toc:[]};function iPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}iPe.isMDXComponent=!0;const aPe={toc:[]};function lPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}lPe.isMDXComponent=!0;const uPe={toc:[]};function mPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}mPe.isMDXComponent=!0;const dPe={toc:[]};function hPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}hPe.isMDXComponent=!0;const kPe={toc:[]};function fPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}fPe.isMDXComponent=!0;const yPe={toc:[]};function MPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}MPe.isMDXComponent=!0;const DPe={toc:[]};function wPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}wPe.isMDXComponent=!0;const _Pe={toc:[]};function XPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}XPe.isMDXComponent=!0;const gPe={toc:[]};function TPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}TPe.isMDXComponent=!0;const xPe={toc:[]};function CPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}CPe.isMDXComponent=!0;const vPe={toc:[]};function LPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}LPe.isMDXComponent=!0;const ZPe={toc:[]};function bPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}bPe.isMDXComponent=!0;const NPe={toc:[]};function zPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}zPe.isMDXComponent=!0;const APe={toc:[]};function WPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}WPe.isMDXComponent=!0;const RPe={toc:[]};function IPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}IPe.isMDXComponent=!0;const SPe={toc:[]};function PPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}PPe.isMDXComponent=!0;const EPe={toc:[]};function BPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}BPe.isMDXComponent=!0;const GPe={toc:[]};function OPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}OPe.isMDXComponent=!0;const UPe={toc:[]};function FPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}FPe.isMDXComponent=!0;const qPe={toc:[]};function VPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPe,n,{components:e,mdxType:"MDXLayout"}))}VPe.isMDXComponent=!0;const jPe={toc:[]};function HPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}HPe.isMDXComponent=!0;const QPe={toc:[]};function YPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}YPe.isMDXComponent=!0;const $Pe={toc:[]};function KPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}KPe.isMDXComponent=!0;const JPe={toc:[]};function tEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}tEe.isMDXComponent=!0;const eEe={toc:[]};function nEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}nEe.isMDXComponent=!0;const oEe={toc:[]};function pEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}pEe.isMDXComponent=!0;const rEe={toc:[]};function sEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}sEe.isMDXComponent=!0;const cEe={toc:[]};function iEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}iEe.isMDXComponent=!0;const aEe={toc:[]};function lEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}lEe.isMDXComponent=!0;const uEe={toc:[]};function mEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mEe.isMDXComponent=!0;const dEe={toc:[]};function hEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}hEe.isMDXComponent=!0;const kEe={toc:[]};function fEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}fEe.isMDXComponent=!0;const yEe={toc:[]};function MEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}MEe.isMDXComponent=!0;const DEe={toc:[]};function wEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}wEe.isMDXComponent=!0;const _Ee={toc:[]};function XEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}XEe.isMDXComponent=!0;const gEe={toc:[]};function TEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}TEe.isMDXComponent=!0;const xEe={toc:[]};function CEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}CEe.isMDXComponent=!0;const vEe={toc:[]};function LEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}LEe.isMDXComponent=!0;const ZEe={toc:[]};function bEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}bEe.isMDXComponent=!0;const NEe={toc:[]};function zEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}zEe.isMDXComponent=!0;const AEe={toc:[]};function WEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}WEe.isMDXComponent=!0;const REe={toc:[]};function IEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}IEe.isMDXComponent=!0;const SEe={toc:[]};function PEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}PEe.isMDXComponent=!0;const EEe={toc:[]};function BEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}BEe.isMDXComponent=!0;const GEe={toc:[]};function OEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}OEe.isMDXComponent=!0;const UEe={toc:[]};function FEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}FEe.isMDXComponent=!0;const qEe={toc:[]};function VEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}VEe.isMDXComponent=!0;const jEe={toc:[]};function HEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}HEe.isMDXComponent=!0;const QEe={toc:[]};function YEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}YEe.isMDXComponent=!0;const $Ee={toc:[]};function KEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}KEe.isMDXComponent=!0;const JEe={toc:[]};function tBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}tBe.isMDXComponent=!0;const eBe={toc:[]};function nBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}nBe.isMDXComponent=!0;const oBe={toc:[]};function pBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}pBe.isMDXComponent=!0;const rBe={toc:[]};function sBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}sBe.isMDXComponent=!0;const cBe={toc:[]};function iBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}iBe.isMDXComponent=!0;const aBe={toc:[]};function lBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}lBe.isMDXComponent=!0;const uBe={toc:[]};function mBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mBe.isMDXComponent=!0;const dBe={toc:[]};function hBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}hBe.isMDXComponent=!0;const kBe={toc:[]};function fBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}fBe.isMDXComponent=!0;const yBe={toc:[]};function MBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}MBe.isMDXComponent=!0;const DBe={toc:[]};function wBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}wBe.isMDXComponent=!0;const _Be={toc:[]};function XBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}XBe.isMDXComponent=!0;const gBe={toc:[]};function TBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}TBe.isMDXComponent=!0;const xBe={toc:[]};function CBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CBe.isMDXComponent=!0;const vBe={toc:[]};function LBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}LBe.isMDXComponent=!0;const ZBe={toc:[]};function bBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}bBe.isMDXComponent=!0;const NBe={toc:[]};function zBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}zBe.isMDXComponent=!0;const ABe={toc:[]};function WBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}WBe.isMDXComponent=!0;const RBe={toc:[]};function IBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}IBe.isMDXComponent=!0;const SBe={toc:[]};function PBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}PBe.isMDXComponent=!0;const EBe={toc:[]};function BBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}BBe.isMDXComponent=!0;const GBe={toc:[]};function OBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}OBe.isMDXComponent=!0;const UBe={toc:[]};function FBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}FBe.isMDXComponent=!0;const qBe={toc:[]};function VBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}VBe.isMDXComponent=!0;const jBe={toc:[]};function HBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}HBe.isMDXComponent=!0;const QBe={toc:[]};function YBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}YBe.isMDXComponent=!0;const $Be={toc:[]};function KBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}KBe.isMDXComponent=!0;const JBe={toc:[]};function tGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}tGe.isMDXComponent=!0;const eGe={toc:[]};function nGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}nGe.isMDXComponent=!0;const oGe={toc:[]};function pGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}pGe.isMDXComponent=!0;const rGe={toc:[]};function sGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}sGe.isMDXComponent=!0;const cGe={toc:[]};function iGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}iGe.isMDXComponent=!0;const aGe={toc:[]};function lGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}lGe.isMDXComponent=!0;const uGe={toc:[]};function mGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}mGe.isMDXComponent=!0;const dGe={toc:[]};function hGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}hGe.isMDXComponent=!0;const kGe={toc:[]};function fGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}fGe.isMDXComponent=!0;const yGe={toc:[]};function MGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}MGe.isMDXComponent=!0;const DGe={toc:[]};function wGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}wGe.isMDXComponent=!0;const _Ge={toc:[]};function XGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}XGe.isMDXComponent=!0;const gGe={toc:[]};function TGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}TGe.isMDXComponent=!0;const xGe={toc:[]};function CGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}CGe.isMDXComponent=!0;const vGe={toc:[]};function LGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}LGe.isMDXComponent=!0;const ZGe={toc:[]};function bGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function NGe(t){let{id:e}=t;const n=o[e]??p.Fragment;return p.createElement(n,null)}bGe.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),p=n(3328),r=n(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==e?void 0:e.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,n&&c),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),k&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,k.content.map((t=>t.text)).join(""))),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:f.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,e,n)=>{n.d(e,{Z:()=>Ot});var o=n(2784),p=n(7390),r=n(6835),s=n(68),c=n(6277),i=n(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,n&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},e)}var k=n(9817);function f(t){let{children:e,type:n,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(n);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),e):o.createElement("span",(0,l.Z)({id:r},i),e)}let y,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function w(t){let{children:e,type:n,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[n??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":p,key:e,className:a.element},t)))))}var _=n(8617);function X(t){var e;let{type:n}=t;const p=(0,_.RU)(n.project),r=null==p?void 0:p[n.id],s=n.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(f,{to:s,type:s?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(w,{type:y.Angle},n.typeArguments.map(((t,e)=>o.createElement(E,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(f,{type:"keyword"},e.name)}function T(t){let{type:e}=t;return e.elements?o.createElement(w,{type:y.Square},e.elements.map(((t,e)=>o.createElement(E,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Pipe},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,p]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(f,{type:p},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"asserts "),o.createElement(f,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(f,null,e.name," "),o.createElement(f,{type:"keyword"},"is "),o.createElement(E,{type:e.targetType}))}function Z(t){let{type:e}=t;const n=(0,_.in)();return o.createElement(Y,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Ampersand},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:e,type:n}),"}",o.createElement(f,{type:"string"},p))})),o.createElement(f,{type:"string"},"`"))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"typeof "),o.createElement(E,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.checkType}),o.createElement(f,{type:"keyword"}," extends "),o.createElement(E,{type:e.extendsType})," ? ",o.createElement(E,{type:e.trueType})," : ",o.createElement(E,{type:e.falseType}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"infer "),o.createElement(f,{type:"constant"},e.name))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.objectType}),"[",o.createElement(E,{type:e.indexType}),"]")}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},e.operator," "),o.createElement(E,{type:e.target}))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(f,{type:"class"},e.parameter),o.createElement(f,{type:"keyword"}," in "),o.createElement(E,{type:e.parameterType}),"]: ",o.createElement(E,{type:e.templateType}))))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(E,{type:e.element}))}function E(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return S;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function B(t){let{flags:e,explicitAccessModifier:n}=t;const p=[];return null!=e&&e.isAbstract&&p.push("abstract"),null!=e&&e.isStatic&&p.push("static"),null!=e&&e.isConst&&p.push("const"),null!=e&&e.isReadonly&&p.push("readonly"),null!=e&&e.isPrivate&&p.push("private"),null!=e&&e.isProtected&&p.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(f,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(E,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(f,{type:"plain"},e.defaultValue)))}function O(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.varianceModifier&&o.createElement(f,{type:"keyword"},e.varianceModifier," "),o.createElement(f,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:e.default})))}function U(t){var e,n;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(f,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(f,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(f,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(f,{to:"#",type:"keyword"},"new")," ",o.createElement(f,{type:"plain"},r.type.name)):i?"":o.createElement(f,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(w,{type:y.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function F(t){let{reflection:e}=t;return o.createElement(G,{reflection:e})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var e,n,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(f,{type:"keyword"},q[r.kind]," "),o.createElement(f,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))))}function j(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),o.createElement(f,{type:"keyword"},"type "),o.createElement(f,{type:"class-name"},e.name),e.typeParameters&&o.createElement(w,{type:y.Angle},e.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:n(t)}))))," = ",o.createElement(E,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(U,{reflection:e.signatures[0]}):e.children?o.createElement(w,{type:y.Curly},e.children.map((t=>o.createElement(Y,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(f,{type:"keyword"},"unknown"))}function Q(t){var e;let{reflection:n}=t;const p=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(U,{reflection:p})}function Y(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return U;case p.W.Property:return F;case p.W.Method:return Q;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function $(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,c.Z)(a.line,"token-line")},e),o.createElement("br",null))}var K=n(9322),J=n(3328);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>e.map(r)),[e]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(U,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(et,{parameters:c.parameters}))}var ot=n(7708);function pt(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===p.W.Class||n===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(3181),ut=n(3851),mt=n(4126),dt=n(2424),ht=n(2244),kt=n(4155);function ft(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function yt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??ft(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function Mt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Dt(t){let{queryString:e=!1,groupId:n}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(p.location.search);e.set(r,t),p.replace({...p.location,search:e.toString()})}),[r,p])]}function wt(t){const{defaultValue:e,queryString:n=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!Mt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=Dt({queryString:n,groupId:p}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[p,r]=(0,kt.Nk)(n);return[p,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=n(9741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:e,block:n,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=i.indexOf(e),o=s[n].value;o!==p&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=i.indexOf(t.currentTarget)+1;n=i[e]??i[0];break}case"ArrowLeft":{const e=i.indexOf(t.currentTarget)-1;n=i[e]??i[i.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},e)},s.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===e?0:-1,"aria-selected":p===e,key:e,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===e})}),n??e)})))}function xt(t){let{lazy:e,children:n,selectedValue:p}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==p}))))}function Ct(t){const e=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,e)),o.createElement(xt,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:e,hidden:n,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:n},e)}function bt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Ot,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const p=(0,lt.TH)(),r=(0,_.RU)(n),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[e,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),i.length>1?o.createElement(vt,{groupId:e.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var e,n,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var e;let{reflection:n,headless:p}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:n.overwrites}))))}function Wt(t){var e,n;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(F,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Rt(t){var e,n,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=n(8128);function St(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const Pt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),p=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:return Gt;case p.W.Module:return St;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{var o;const p=t[n];return p?(null==(o=e[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(2784),p=n(822);const r=o.createContext(null);function s(t){let{children:e}=t;const n=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),p=n(1263),r=n(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const p=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},6412:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(7896),p=(n(2784),n(876)),r=(n(8128),n(2072));const s={sidebar_position:3,slug:"/hierarchy"},c="Scene hierarchy",i={unversionedId:"getting-started/hierarchy",id:"getting-started/hierarchy",title:"Scene hierarchy",description:"Scenes are collections of nodes displayed in your animation. They're organized",source:"@site/docs/getting-started/hierarchy.mdx",sourceDirName:"getting-started",slug:"/hierarchy",permalink:"/docs/hierarchy",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/hierarchy.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/hierarchy"},sidebar:"docs",previous:{title:"Animation flow",permalink:"/docs/flow"},next:{title:"Positioning",permalink:"/docs/positioning"}},a={},l=[{value:"<code>Node.add</code>",id:"nodeadd",level:2},{value:"<code>Node.insert</code>",id:"nodeinsert",level:2},{value:"<code>Node.remove</code>",id:"noderemove",level:2},{value:"<code>Node.reparent</code>",id:"nodereparent",level:2},{value:"<code>Node.moveUp</code>",id:"nodemoveup",level:2},{value:"<code>Node.moveDown</code>",id:"nodemovedown",level:2},{value:"<code>Node.moveToTop</code>",id:"nodemovetotop",level:2},{value:"<code>Node.moveToBottom</code>",id:"nodemovetobottom",level:2},{value:"<code>Node.moveTo</code>",id:"nodemoveto",level:2},{value:"<code>Node.moveAbove</code>",id:"nodemoveabove",level:2},{value:"<code>Node.moveBelow</code>",id:"nodemovebelow",level:2},{value:"<code>Node.removeChildren</code>",id:"noderemovechildren",level:2}],u={toc:l};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"scene-hierarchy"},"Scene hierarchy"),(0,p.kt)("p",null,"Scenes are collections of nodes displayed in your animation. They're organized\nin a tree hierarchy, with the scene view at its root. This concept is similar to\nthe Document Object Model used to represent HTML and XML documents."),(0,p.kt)("p",null,"Here's an example of a simple scene hierarchy together with its object\nrepresentation:"),(0,p.kt)("div",{className:"row margin-bottom--md"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"view.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Txt>Hi</Txt>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("mermaid",{value:"graph TD;\n  view[Scene View]\n  circle([Circle])\n  layout([Layout])\n  rect([Rect])\n  text([text 'Hi'])\n    view--\x3ecircle;\n    view--\x3elayout;\n    layout--\x3erect;\n    layout--\x3etext;"}))),(0,p.kt)("p",null,"Each node is an instance of a class extending the base ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class. To\nmake the code more readable, Motion Canvas uses a custom\n",(0,p.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX")," runtime. This way, instead\nof instantiating the nodes ourselves, we can write an XML-like markup. Note that\nMotion Canvas does ",(0,p.kt)("strong",{parentName:"p"},"not")," use React itself, only JSX. There's no virtual DOM or\nreconciliation and the JSX tags are mapped directly to Node instances. These two\ncode snippets are equivalent:"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// JSX\nview.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Txt>Hi</Txt>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// No JSX\nview.add([\n  new Circle({}),\n  new Layout({\n    children: [\n      // highlight-start\n      new Rect({}),\n      new Txt({text: 'Hi'}),\n    ],\n  }),\n]);\n")))),(0,p.kt)("p",null,"Just like with DOM, it's possible to add, remove, and rearrange nodes at any\ntime. The ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class contains the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,p.kt)("inlineCode",{parentName:"a"},"children"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#parent"},(0,p.kt)("inlineCode",{parentName:"a"},"parent"))," properties that can be used to\ntraverse the tree. But in order to modify it, it's recommended to use the\nfollowing helper methods:"),(0,p.kt)("h2",{id:"nodeadd"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.add")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#add",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodeinsert"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.insert")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#insert",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.remove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#remove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodereparent"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.reparent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#reparent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveup"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveUp")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveUp",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovedown"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveDown")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveDown",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetotop"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToTop")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToTop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetobottom"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToBottom")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToBottom",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveto"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveTo")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveTo",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveabove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveAbove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveAbove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovebelow"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveBelow")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveBelow",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemovechildren"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.removeChildren")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#removeChildren",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}m.isMDXComponent=!0}}]);