"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1276],{876:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var o=n(2784);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){p(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,o,p=function(t,e){if(null==t)return{};var n,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(p[n]=t[n]);return p}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(p[n]=t[n])}return p}var i=o.createContext({}),a=function(t){var e=o.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=a(t.components);return o.createElement(i.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(n),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,s(s({ref:e},l),{},{components:n})):o.createElement(h,s({ref:e},l))}));function h(t,e){var n=arguments,p=e&&e.mdxType;if("string"==typeof t||p){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=n[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3851:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),p=n(2784),r=n(6277),s=n(1077),c=n(7683),i=n(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:e,id:n,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===e||!n)return p.createElement(e,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:n});return p.createElement(e,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:n}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${n}`,"aria-label":d,title:d},"\u200b"))}},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),p=n(8617),r=n(1930);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return o.createElement(r.Z,{reflection:n,headless:!0})}},136:(t,e,n)=>{n.d(e,{Z:()=>ZQe});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>te,content_0_1000:()=>Ey,content_0_1002:()=>Gy,content_0_1004:()=>Uy,content_0_1006:()=>qy,content_0_1008:()=>jy,content_0_1010:()=>Qy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>eM,content_0_1018:()=>oM,content_0_102:()=>ne,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>fM,content_0_1032:()=>yM,content_0_1034:()=>DM,content_0_1036:()=>_M,content_0_1038:()=>gM,content_0_104:()=>pe,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>PM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>UM,content_0_106:()=>se,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>QM,content_0_1066:()=>$M,content_0_1068:()=>JM,content_0_1070:()=>eD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>ie,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>fD,content_0_1086:()=>yD,content_0_1088:()=>DD,content_0_1090:()=>_D,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>le,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>PD,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>UD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_1118:()=>QD,content_0_112:()=>me,content_0_1120:()=>$D,content_0_1122:()=>JD,content_0_1124:()=>ew,content_0_1126:()=>ow,content_0_1128:()=>rw,content_0_1130:()=>cw,content_0_1132:()=>aw,content_0_1134:()=>uw,content_0_1136:()=>dw,content_0_1138:()=>fw,content_0_114:()=>he,content_0_1140:()=>yw,content_0_1142:()=>Dw,content_0_1144:()=>_w,content_0_1146:()=>gw,content_0_1148:()=>xw,content_0_1150:()=>vw,content_0_1152:()=>Zw,content_0_1154:()=>Nw,content_0_1156:()=>Aw,content_0_1158:()=>Rw,content_0_116:()=>ke,content_0_1160:()=>Pw,content_0_1162:()=>Ew,content_0_1164:()=>Gw,content_0_1166:()=>Uw,content_0_1168:()=>qw,content_0_1170:()=>jw,content_0_1172:()=>Qw,content_0_1174:()=>$w,content_0_1176:()=>Jw,content_0_1178:()=>e_,content_0_118:()=>Me,content_0_1180:()=>o_,content_0_1182:()=>r_,content_0_1184:()=>c_,content_0_1186:()=>a_,content_0_1188:()=>u_,content_0_1190:()=>d_,content_0_1192:()=>f_,content_0_1194:()=>y_,content_0_1196:()=>D_,content_0_1198:()=>__,content_0_12:()=>w,content_0_120:()=>we,content_0_1200:()=>g_,content_0_1202:()=>x_,content_0_1204:()=>v_,content_0_1206:()=>Z_,content_0_1208:()=>N_,content_0_1210:()=>A_,content_0_1212:()=>R_,content_0_1214:()=>P_,content_0_1216:()=>E_,content_0_1218:()=>G_,content_0_122:()=>Xe,content_0_1220:()=>U_,content_0_1222:()=>q_,content_0_1224:()=>j_,content_0_1226:()=>Q_,content_0_1228:()=>$_,content_0_1230:()=>J_,content_0_1232:()=>eX,content_0_1234:()=>oX,content_0_1236:()=>rX,content_0_1238:()=>cX,content_0_124:()=>Te,content_0_1240:()=>aX,content_0_1242:()=>uX,content_0_1244:()=>dX,content_0_1246:()=>fX,content_0_1248:()=>yX,content_0_1250:()=>DX,content_0_1252:()=>_X,content_0_1254:()=>gX,content_0_1256:()=>xX,content_0_1258:()=>vX,content_0_126:()=>Ce,content_0_1260:()=>ZX,content_0_1262:()=>NX,content_0_1264:()=>AX,content_0_1266:()=>RX,content_0_1268:()=>PX,content_0_1270:()=>EX,content_0_1272:()=>GX,content_0_1274:()=>UX,content_0_1276:()=>qX,content_0_1278:()=>jX,content_0_128:()=>Le,content_0_1280:()=>QX,content_0_1282:()=>$X,content_0_1284:()=>JX,content_0_1286:()=>eg,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>be,content_0_1300:()=>fg,content_0_1302:()=>yg,content_0_1304:()=>Dg,content_0_1306:()=>_g,content_0_1308:()=>gg,content_0_1310:()=>xg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>ze,content_0_1320:()=>Rg,content_0_1322:()=>Pg,content_0_1324:()=>Eg,content_0_1326:()=>Gg,content_0_1328:()=>Ug,content_0_1330:()=>qg,content_0_1332:()=>jg,content_0_1334:()=>Qg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>We,content_0_1340:()=>eT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>fT,content_0_1356:()=>yT,content_0_1358:()=>DT,content_0_136:()=>Ie,content_0_1360:()=>_T,content_0_1362:()=>gT,content_0_1364:()=>xT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>RT,content_0_1376:()=>PT,content_0_1378:()=>ET,content_0_138:()=>Se,content_0_1380:()=>GT,content_0_1382:()=>UT,content_0_1384:()=>qT,content_0_1386:()=>jT,content_0_1388:()=>QT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>ex,content_0_1396:()=>ox,content_0_1398:()=>rx,content_0_14:()=>X,content_0_140:()=>Be,content_0_1400:()=>cx,content_0_1402:()=>ax,content_0_1404:()=>ux,content_0_1406:()=>dx,content_0_1408:()=>fx,content_0_1410:()=>yx,content_0_1412:()=>Dx,content_0_1414:()=>_x,content_0_1416:()=>gx,content_0_1418:()=>xx,content_0_142:()=>Oe,content_0_1420:()=>vx,content_0_1422:()=>Zx,content_0_1424:()=>Nx,content_0_1426:()=>Ax,content_0_1428:()=>Rx,content_0_1430:()=>Px,content_0_1432:()=>Ex,content_0_1434:()=>Gx,content_0_1436:()=>Ux,content_0_1438:()=>qx,content_0_144:()=>Fe,content_0_1440:()=>jx,content_0_1442:()=>Qx,content_0_1444:()=>$x,content_0_1446:()=>Jx,content_0_1448:()=>eC,content_0_1450:()=>oC,content_0_1452:()=>rC,content_0_1454:()=>cC,content_0_1456:()=>aC,content_0_1458:()=>uC,content_0_146:()=>Ve,content_0_1460:()=>dC,content_0_1462:()=>fC,content_0_1464:()=>yC,content_0_1466:()=>DC,content_0_1468:()=>_C,content_0_1470:()=>gC,content_0_1472:()=>xC,content_0_1474:()=>vC,content_0_1476:()=>ZC,content_0_1478:()=>NC,content_0_148:()=>He,content_0_1480:()=>AC,content_0_1482:()=>RC,content_0_1484:()=>PC,content_0_1486:()=>EC,content_0_1488:()=>GC,content_0_1490:()=>UC,content_0_1492:()=>qC,content_0_1494:()=>jC,content_0_1496:()=>QC,content_0_1498:()=>$C,content_0_150:()=>Ye,content_0_1500:()=>JC,content_0_1502:()=>ev,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>fv,content_0_1518:()=>yv,content_0_152:()=>Ke,content_0_1520:()=>Dv,content_0_1522:()=>_v,content_0_1524:()=>gv,content_0_1526:()=>xv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Rv,content_0_1538:()=>Pv,content_0_154:()=>tn,content_0_1540:()=>Ev,content_0_1542:()=>Gv,content_0_1544:()=>Uv,content_0_1546:()=>qv,content_0_1548:()=>jv,content_0_1550:()=>Qv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>eL,content_0_1558:()=>oL,content_0_156:()=>nn,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>fL,content_0_1572:()=>yL,content_0_1574:()=>DL,content_0_1576:()=>_L,content_0_1578:()=>gL,content_0_158:()=>pn,content_0_1580:()=>xL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>RL,content_0_1592:()=>PL,content_0_1594:()=>EL,content_0_1596:()=>GL,content_0_1598:()=>UL,content_0_16:()=>T,content_0_160:()=>sn,content_0_1600:()=>qL,content_0_1602:()=>jL,content_0_1604:()=>QL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>eZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_1616:()=>cZ,content_0_1618:()=>aZ,content_0_162:()=>an,content_0_1620:()=>uZ,content_0_1622:()=>dZ,content_0_1624:()=>fZ,content_0_1626:()=>yZ,content_0_1628:()=>DZ,content_0_1630:()=>_Z,content_0_1632:()=>gZ,content_0_1634:()=>xZ,content_0_1636:()=>vZ,content_0_1638:()=>ZZ,content_0_164:()=>un,content_0_1640:()=>NZ,content_0_1642:()=>AZ,content_0_1644:()=>RZ,content_0_1646:()=>PZ,content_0_1648:()=>EZ,content_0_1650:()=>GZ,content_0_1652:()=>UZ,content_0_166:()=>dn,content_0_168:()=>fn,content_0_170:()=>yn,content_0_172:()=>Dn,content_0_174:()=>_n,content_0_176:()=>gn,content_0_178:()=>xn,content_0_18:()=>C,content_0_180:()=>vn,content_0_182:()=>Zn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>Rn,content_0_190:()=>Pn,content_0_192:()=>En,content_0_194:()=>Gn,content_0_196:()=>Un,content_0_198:()=>qn,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>jn,content_0_202:()=>Qn,content_0_204:()=>$n,content_0_206:()=>Jn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>So,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Fo,content_0_252:()=>Vo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>np,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Sp,content_0_30:()=>S,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Fp,content_0_306:()=>Vp,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Sr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Fr,content_0_36:()=>F,content_0_360:()=>Vr,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>ns,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ks,content_0_386:()=>Ms,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ss,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Fs,content_0_414:()=>Vs,content_0_416:()=>Hs,content_0_418:()=>Ys,content_0_42:()=>Y,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>nc,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>kc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Sc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Fc,content_0_468:()=>Vc,content_0_470:()=>Hc,content_0_472:()=>Yc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ni,content_0_48:()=>nt,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>ki,content_0_494:()=>Mi,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Si,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Fi,content_0_522:()=>Vi,content_0_524:()=>Hi,content_0_526:()=>Yi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ka,content_0_548:()=>Ma,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Sa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Fa,content_0_576:()=>Va,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Ya,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>Ml,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>kt,content_0_620:()=>Il,content_0_622:()=>Sl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Fl,content_0_630:()=>Vl,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>nu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Su,content_0_678:()=>Bu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>Fu,content_0_684:()=>Vu,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Sm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Fm,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Sd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Fd,content_0_792:()=>Vd,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Sh,content_0_84:()=>St,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Fh,content_0_846:()=>Vh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tf,content_0_856:()=>nf,content_0_858:()=>pf,content_0_86:()=>Bt,content_0_860:()=>sf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>yf,content_0_872:()=>Df,content_0_874:()=>_f,content_0_876:()=>gf,content_0_878:()=>xf,content_0_88:()=>Ot,content_0_880:()=>vf,content_0_882:()=>Zf,content_0_884:()=>Nf,content_0_886:()=>Af,content_0_888:()=>Rf,content_0_890:()=>Pf,content_0_892:()=>Ef,content_0_894:()=>Gf,content_0_896:()=>Uf,content_0_898:()=>qf,content_0_90:()=>Ft,content_0_900:()=>jf,content_0_902:()=>Qf,content_0_904:()=>$f,content_0_906:()=>Jf,content_0_908:()=>ek,content_0_910:()=>ok,content_0_912:()=>rk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>uk,content_0_92:()=>Vt,content_0_920:()=>dk,content_0_922:()=>fk,content_0_924:()=>yk,content_0_926:()=>Dk,content_0_928:()=>_k,content_0_930:()=>gk,content_0_932:()=>xk,content_0_934:()=>vk,content_0_936:()=>Zk,content_0_938:()=>Nk,content_0_94:()=>Ht,content_0_940:()=>Ak,content_0_942:()=>Rk,content_0_944:()=>Pk,content_0_946:()=>Ek,content_0_948:()=>Gk,content_0_950:()=>Uk,content_0_952:()=>qk,content_0_954:()=>jk,content_0_956:()=>Qk,content_0_958:()=>$k,content_0_96:()=>Yt,content_0_960:()=>Jk,content_0_962:()=>ey,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>fy,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>Dy,content_0_982:()=>_y,content_0_984:()=>gy,content_0_986:()=>xy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Ry,content_0_998:()=>Py,content_3539_0:()=>qZ,content_3539_10:()=>eb,content_3539_100:()=>PN,content_3539_1000:()=>DH,content_3539_1002:()=>_H,content_3539_1004:()=>gH,content_3539_1006:()=>xH,content_3539_1008:()=>vH,content_3539_1010:()=>ZH,content_3539_1012:()=>NH,content_3539_1014:()=>AH,content_3539_1016:()=>RH,content_3539_1018:()=>PH,content_3539_102:()=>EN,content_3539_1020:()=>EH,content_3539_1022:()=>GH,content_3539_1024:()=>UH,content_3539_1026:()=>qH,content_3539_1028:()=>jH,content_3539_1030:()=>QH,content_3539_1032:()=>$H,content_3539_1034:()=>JH,content_3539_1036:()=>eQ,content_3539_1038:()=>oQ,content_3539_104:()=>GN,content_3539_1040:()=>rQ,content_3539_1042:()=>cQ,content_3539_1044:()=>aQ,content_3539_1046:()=>uQ,content_3539_1048:()=>dQ,content_3539_1050:()=>fQ,content_3539_1052:()=>yQ,content_3539_1054:()=>DQ,content_3539_1056:()=>_Q,content_3539_1058:()=>gQ,content_3539_106:()=>UN,content_3539_1060:()=>xQ,content_3539_1062:()=>vQ,content_3539_1064:()=>ZQ,content_3539_1066:()=>NQ,content_3539_1068:()=>AQ,content_3539_1070:()=>RQ,content_3539_1072:()=>PQ,content_3539_1074:()=>EQ,content_3539_1076:()=>GQ,content_3539_1078:()=>UQ,content_3539_108:()=>qN,content_3539_1080:()=>qQ,content_3539_1082:()=>jQ,content_3539_1084:()=>QQ,content_3539_1086:()=>$Q,content_3539_1088:()=>JQ,content_3539_1090:()=>eY,content_3539_1092:()=>oY,content_3539_1094:()=>rY,content_3539_1096:()=>cY,content_3539_1098:()=>aY,content_3539_110:()=>jN,content_3539_1100:()=>uY,content_3539_1102:()=>dY,content_3539_1104:()=>fY,content_3539_1106:()=>yY,content_3539_1108:()=>DY,content_3539_1110:()=>_Y,content_3539_1112:()=>gY,content_3539_1114:()=>xY,content_3539_1116:()=>vY,content_3539_1118:()=>ZY,content_3539_112:()=>QN,content_3539_1120:()=>NY,content_3539_1122:()=>AY,content_3539_1124:()=>RY,content_3539_1126:()=>PY,content_3539_1128:()=>EY,content_3539_1130:()=>GY,content_3539_1132:()=>UY,content_3539_1134:()=>qY,content_3539_1136:()=>jY,content_3539_1138:()=>QY,content_3539_114:()=>$N,content_3539_1140:()=>$Y,content_3539_1142:()=>JY,content_3539_1144:()=>e$,content_3539_1146:()=>o$,content_3539_1148:()=>r$,content_3539_1150:()=>c$,content_3539_1152:()=>a$,content_3539_1154:()=>u$,content_3539_1156:()=>d$,content_3539_1158:()=>f$,content_3539_116:()=>JN,content_3539_1160:()=>y$,content_3539_1162:()=>D$,content_3539_1164:()=>_$,content_3539_1166:()=>g$,content_3539_1168:()=>x$,content_3539_1170:()=>v$,content_3539_1172:()=>Z$,content_3539_1174:()=>N$,content_3539_1176:()=>A$,content_3539_1178:()=>R$,content_3539_118:()=>ez,content_3539_1180:()=>P$,content_3539_1182:()=>E$,content_3539_1184:()=>G$,content_3539_1186:()=>U$,content_3539_1188:()=>q$,content_3539_1190:()=>j$,content_3539_1192:()=>Q$,content_3539_1194:()=>$$,content_3539_1196:()=>J$,content_3539_1198:()=>eK,content_3539_12:()=>ob,content_3539_120:()=>oz,content_3539_1200:()=>oK,content_3539_1202:()=>rK,content_3539_1204:()=>cK,content_3539_1206:()=>aK,content_3539_1208:()=>uK,content_3539_1210:()=>dK,content_3539_1212:()=>fK,content_3539_1214:()=>yK,content_3539_1216:()=>DK,content_3539_1218:()=>_K,content_3539_122:()=>rz,content_3539_1220:()=>gK,content_3539_1222:()=>xK,content_3539_1224:()=>vK,content_3539_1226:()=>ZK,content_3539_1228:()=>NK,content_3539_1230:()=>AK,content_3539_1232:()=>RK,content_3539_1234:()=>PK,content_3539_1236:()=>EK,content_3539_1238:()=>GK,content_3539_124:()=>cz,content_3539_1240:()=>UK,content_3539_1242:()=>qK,content_3539_1244:()=>jK,content_3539_1246:()=>QK,content_3539_1248:()=>$K,content_3539_1250:()=>JK,content_3539_1252:()=>eJ,content_3539_1254:()=>oJ,content_3539_1256:()=>rJ,content_3539_1258:()=>cJ,content_3539_126:()=>az,content_3539_1260:()=>aJ,content_3539_1262:()=>uJ,content_3539_1264:()=>dJ,content_3539_1266:()=>fJ,content_3539_1268:()=>yJ,content_3539_1270:()=>DJ,content_3539_1272:()=>_J,content_3539_1274:()=>gJ,content_3539_1276:()=>xJ,content_3539_1278:()=>vJ,content_3539_128:()=>uz,content_3539_1280:()=>ZJ,content_3539_1282:()=>NJ,content_3539_1284:()=>AJ,content_3539_1286:()=>RJ,content_3539_1288:()=>PJ,content_3539_1290:()=>EJ,content_3539_1292:()=>GJ,content_3539_1294:()=>UJ,content_3539_1296:()=>qJ,content_3539_1298:()=>jJ,content_3539_130:()=>dz,content_3539_1300:()=>QJ,content_3539_1302:()=>$J,content_3539_1304:()=>JJ,content_3539_1306:()=>e0,content_3539_1308:()=>o0,content_3539_1310:()=>r0,content_3539_1312:()=>c0,content_3539_1314:()=>a0,content_3539_1316:()=>u0,content_3539_1318:()=>d0,content_3539_132:()=>fz,content_3539_1320:()=>f0,content_3539_1322:()=>y0,content_3539_1324:()=>D0,content_3539_1326:()=>_0,content_3539_1328:()=>g0,content_3539_1330:()=>x0,content_3539_1332:()=>v0,content_3539_1334:()=>Z0,content_3539_1336:()=>N0,content_3539_1338:()=>A0,content_3539_134:()=>yz,content_3539_1340:()=>R0,content_3539_1342:()=>P0,content_3539_1344:()=>E0,content_3539_1346:()=>G0,content_3539_1348:()=>U0,content_3539_1350:()=>q0,content_3539_1352:()=>j0,content_3539_1354:()=>Q0,content_3539_1356:()=>$0,content_3539_1358:()=>J0,content_3539_136:()=>Dz,content_3539_1360:()=>e3,content_3539_1362:()=>o3,content_3539_1364:()=>r3,content_3539_1366:()=>c3,content_3539_1368:()=>a3,content_3539_1370:()=>u3,content_3539_1372:()=>d3,content_3539_1374:()=>f3,content_3539_1376:()=>y3,content_3539_1378:()=>D3,content_3539_138:()=>_z,content_3539_1380:()=>_3,content_3539_1382:()=>g3,content_3539_1384:()=>x3,content_3539_1386:()=>v3,content_3539_1388:()=>Z3,content_3539_1390:()=>N3,content_3539_1392:()=>A3,content_3539_1394:()=>R3,content_3539_1396:()=>P3,content_3539_1398:()=>E3,content_3539_14:()=>rb,content_3539_140:()=>gz,content_3539_1400:()=>G3,content_3539_1402:()=>U3,content_3539_1404:()=>q3,content_3539_1406:()=>j3,content_3539_1408:()=>Q3,content_3539_1410:()=>$3,content_3539_1412:()=>J3,content_3539_1414:()=>e5,content_3539_1416:()=>o5,content_3539_1418:()=>r5,content_3539_142:()=>xz,content_3539_1420:()=>c5,content_3539_1422:()=>a5,content_3539_1424:()=>u5,content_3539_1426:()=>d5,content_3539_1428:()=>f5,content_3539_1430:()=>y5,content_3539_1432:()=>D5,content_3539_1434:()=>_5,content_3539_1436:()=>g5,content_3539_1438:()=>x5,content_3539_144:()=>vz,content_3539_1440:()=>v5,content_3539_1442:()=>Z5,content_3539_1444:()=>N5,content_3539_1446:()=>A5,content_3539_1448:()=>R5,content_3539_1450:()=>P5,content_3539_1452:()=>E5,content_3539_1454:()=>G5,content_3539_1456:()=>U5,content_3539_1458:()=>q5,content_3539_146:()=>Zz,content_3539_1460:()=>j5,content_3539_1462:()=>Q5,content_3539_1464:()=>$5,content_3539_1466:()=>J5,content_3539_1468:()=>e9,content_3539_1470:()=>o9,content_3539_1472:()=>r9,content_3539_1474:()=>c9,content_3539_1476:()=>a9,content_3539_1478:()=>u9,content_3539_148:()=>Nz,content_3539_1480:()=>d9,content_3539_1482:()=>f9,content_3539_1484:()=>y9,content_3539_1486:()=>D9,content_3539_1488:()=>_9,content_3539_1490:()=>g9,content_3539_1492:()=>x9,content_3539_1494:()=>v9,content_3539_1496:()=>Z9,content_3539_1498:()=>N9,content_3539_150:()=>Az,content_3539_1500:()=>A9,content_3539_1502:()=>R9,content_3539_1504:()=>P9,content_3539_1506:()=>E9,content_3539_1508:()=>G9,content_3539_1510:()=>U9,content_3539_1512:()=>q9,content_3539_1514:()=>j9,content_3539_1516:()=>Q9,content_3539_1518:()=>$9,content_3539_152:()=>Rz,content_3539_1520:()=>J9,content_3539_1522:()=>e2,content_3539_1524:()=>o2,content_3539_1526:()=>r2,content_3539_1528:()=>c2,content_3539_1530:()=>a2,content_3539_1532:()=>u2,content_3539_1534:()=>d2,content_3539_1536:()=>f2,content_3539_1538:()=>y2,content_3539_154:()=>Pz,content_3539_1540:()=>D2,content_3539_1542:()=>_2,content_3539_1544:()=>g2,content_3539_1546:()=>x2,content_3539_1548:()=>v2,content_3539_1550:()=>Z2,content_3539_1552:()=>N2,content_3539_1554:()=>A2,content_3539_1556:()=>R2,content_3539_1558:()=>P2,content_3539_156:()=>Ez,content_3539_1560:()=>E2,content_3539_1562:()=>G2,content_3539_1564:()=>U2,content_3539_1566:()=>q2,content_3539_1568:()=>j2,content_3539_1570:()=>Q2,content_3539_1572:()=>$2,content_3539_1574:()=>J2,content_3539_1576:()=>e1,content_3539_1578:()=>o1,content_3539_158:()=>Gz,content_3539_1580:()=>r1,content_3539_1582:()=>c1,content_3539_1584:()=>a1,content_3539_1586:()=>u1,content_3539_1588:()=>d1,content_3539_1590:()=>f1,content_3539_1592:()=>y1,content_3539_1594:()=>D1,content_3539_1596:()=>_1,content_3539_1598:()=>g1,content_3539_16:()=>cb,content_3539_160:()=>Uz,content_3539_1600:()=>x1,content_3539_1602:()=>v1,content_3539_1604:()=>Z1,content_3539_1606:()=>N1,content_3539_1608:()=>A1,content_3539_1610:()=>R1,content_3539_1612:()=>P1,content_3539_1614:()=>E1,content_3539_1616:()=>G1,content_3539_1618:()=>U1,content_3539_162:()=>qz,content_3539_1620:()=>q1,content_3539_1622:()=>j1,content_3539_1624:()=>Q1,content_3539_1626:()=>$1,content_3539_1628:()=>J1,content_3539_1630:()=>e4,content_3539_1632:()=>o4,content_3539_1634:()=>r4,content_3539_1636:()=>c4,content_3539_1638:()=>a4,content_3539_164:()=>jz,content_3539_1640:()=>u4,content_3539_1642:()=>d4,content_3539_1644:()=>f4,content_3539_1646:()=>y4,content_3539_1648:()=>D4,content_3539_1650:()=>_4,content_3539_1652:()=>g4,content_3539_1654:()=>x4,content_3539_1656:()=>v4,content_3539_1658:()=>Z4,content_3539_166:()=>Qz,content_3539_1660:()=>N4,content_3539_1662:()=>A4,content_3539_1664:()=>R4,content_3539_1666:()=>P4,content_3539_1668:()=>E4,content_3539_1670:()=>G4,content_3539_1672:()=>U4,content_3539_1674:()=>q4,content_3539_1676:()=>j4,content_3539_1678:()=>Q4,content_3539_168:()=>$z,content_3539_1680:()=>$4,content_3539_1682:()=>J4,content_3539_1684:()=>e6,content_3539_1686:()=>o6,content_3539_1688:()=>r6,content_3539_1690:()=>c6,content_3539_1692:()=>a6,content_3539_1694:()=>u6,content_3539_1696:()=>d6,content_3539_1698:()=>f6,content_3539_170:()=>Jz,content_3539_1700:()=>y6,content_3539_1702:()=>D6,content_3539_1704:()=>_6,content_3539_1706:()=>g6,content_3539_1708:()=>x6,content_3539_1710:()=>v6,content_3539_1712:()=>Z6,content_3539_1714:()=>N6,content_3539_1716:()=>A6,content_3539_1718:()=>R6,content_3539_172:()=>eA,content_3539_1720:()=>P6,content_3539_1722:()=>E6,content_3539_1724:()=>G6,content_3539_1726:()=>U6,content_3539_1728:()=>q6,content_3539_1730:()=>j6,content_3539_1732:()=>Q6,content_3539_1734:()=>$6,content_3539_1736:()=>J6,content_3539_1738:()=>e8,content_3539_174:()=>oA,content_3539_1740:()=>o8,content_3539_1742:()=>r8,content_3539_1744:()=>c8,content_3539_1746:()=>a8,content_3539_1748:()=>u8,content_3539_1750:()=>d8,content_3539_1752:()=>f8,content_3539_1754:()=>y8,content_3539_1756:()=>D8,content_3539_1758:()=>_8,content_3539_176:()=>rA,content_3539_1760:()=>g8,content_3539_1762:()=>x8,content_3539_1764:()=>v8,content_3539_1766:()=>Z8,content_3539_1768:()=>N8,content_3539_1770:()=>A8,content_3539_1772:()=>R8,content_3539_1774:()=>P8,content_3539_1776:()=>E8,content_3539_1778:()=>G8,content_3539_178:()=>cA,content_3539_1780:()=>U8,content_3539_1782:()=>q8,content_3539_1784:()=>j8,content_3539_1786:()=>Q8,content_3539_1788:()=>$8,content_3539_1790:()=>J8,content_3539_1792:()=>e7,content_3539_1794:()=>o7,content_3539_1796:()=>r7,content_3539_1798:()=>c7,content_3539_18:()=>ab,content_3539_180:()=>aA,content_3539_1800:()=>a7,content_3539_1802:()=>u7,content_3539_1804:()=>d7,content_3539_1806:()=>f7,content_3539_1808:()=>y7,content_3539_1810:()=>D7,content_3539_1812:()=>_7,content_3539_1814:()=>g7,content_3539_1816:()=>x7,content_3539_1818:()=>v7,content_3539_182:()=>uA,content_3539_1820:()=>Z7,content_3539_1822:()=>N7,content_3539_1824:()=>A7,content_3539_1826:()=>R7,content_3539_1828:()=>P7,content_3539_1830:()=>E7,content_3539_1832:()=>G7,content_3539_1834:()=>U7,content_3539_1836:()=>q7,content_3539_1838:()=>j7,content_3539_184:()=>dA,content_3539_1840:()=>Q7,content_3539_1842:()=>$7,content_3539_1844:()=>J7,content_3539_1846:()=>ett,content_3539_1848:()=>ott,content_3539_1850:()=>rtt,content_3539_1852:()=>ctt,content_3539_1854:()=>att,content_3539_1856:()=>utt,content_3539_1858:()=>dtt,content_3539_186:()=>fA,content_3539_1860:()=>ftt,content_3539_1862:()=>ytt,content_3539_1864:()=>Dtt,content_3539_1866:()=>_tt,content_3539_1868:()=>gtt,content_3539_1870:()=>xtt,content_3539_1872:()=>vtt,content_3539_1874:()=>Ztt,content_3539_1876:()=>Ntt,content_3539_1878:()=>Att,content_3539_188:()=>yA,content_3539_1880:()=>Rtt,content_3539_1882:()=>Ptt,content_3539_1884:()=>Ett,content_3539_1886:()=>Gtt,content_3539_1888:()=>Utt,content_3539_1890:()=>qtt,content_3539_1892:()=>jtt,content_3539_1894:()=>Qtt,content_3539_1896:()=>$tt,content_3539_1898:()=>Jtt,content_3539_190:()=>DA,content_3539_1900:()=>eet,content_3539_1902:()=>oet,content_3539_1904:()=>ret,content_3539_1906:()=>cet,content_3539_1908:()=>aet,content_3539_1910:()=>met,content_3539_1912:()=>het,content_3539_1914:()=>ket,content_3539_1916:()=>Met,content_3539_1918:()=>wet,content_3539_192:()=>_A,content_3539_1920:()=>Xet,content_3539_1922:()=>Tet,content_3539_1924:()=>Cet,content_3539_1926:()=>Let,content_3539_1928:()=>bet,content_3539_1930:()=>zet,content_3539_1932:()=>Wet,content_3539_1934:()=>Iet,content_3539_1936:()=>Set,content_3539_1938:()=>Bet,content_3539_194:()=>gA,content_3539_1940:()=>Oet,content_3539_1942:()=>Fet,content_3539_1944:()=>Vet,content_3539_1946:()=>Het,content_3539_1948:()=>Yet,content_3539_1950:()=>Ket,content_3539_1952:()=>tnt,content_3539_1954:()=>nnt,content_3539_1956:()=>pnt,content_3539_1958:()=>snt,content_3539_196:()=>xA,content_3539_1960:()=>int,content_3539_1962:()=>lnt,content_3539_1964:()=>mnt,content_3539_1966:()=>hnt,content_3539_1968:()=>knt,content_3539_1970:()=>Mnt,content_3539_1972:()=>wnt,content_3539_1974:()=>Xnt,content_3539_1976:()=>Tnt,content_3539_1978:()=>Cnt,content_3539_198:()=>vA,content_3539_1980:()=>Lnt,content_3539_1982:()=>bnt,content_3539_1984:()=>znt,content_3539_1986:()=>Wnt,content_3539_1988:()=>Int,content_3539_1990:()=>Snt,content_3539_1992:()=>Bnt,content_3539_1994:()=>Ont,content_3539_1996:()=>Fnt,content_3539_1998:()=>Vnt,content_3539_2:()=>jZ,content_3539_20:()=>ub,content_3539_200:()=>ZA,content_3539_2000:()=>Hnt,content_3539_2002:()=>Ynt,content_3539_2004:()=>Knt,content_3539_2006:()=>tot,content_3539_2008:()=>not,content_3539_2010:()=>pot,content_3539_2012:()=>sot,content_3539_2014:()=>iot,content_3539_2016:()=>lot,content_3539_2018:()=>mot,content_3539_202:()=>NA,content_3539_2020:()=>hot,content_3539_2022:()=>kot,content_3539_2024:()=>Mot,content_3539_2026:()=>wot,content_3539_2028:()=>Xot,content_3539_2030:()=>Tot,content_3539_2032:()=>Cot,content_3539_2034:()=>Lot,content_3539_2036:()=>bot,content_3539_2038:()=>zot,content_3539_204:()=>AA,content_3539_2040:()=>Wot,content_3539_2042:()=>Iot,content_3539_2044:()=>Sot,content_3539_2046:()=>Bot,content_3539_2048:()=>Oot,content_3539_2050:()=>Fot,content_3539_2052:()=>Vot,content_3539_2054:()=>Hot,content_3539_2056:()=>Yot,content_3539_2058:()=>Kot,content_3539_206:()=>RA,content_3539_2060:()=>tpt,content_3539_2062:()=>npt,content_3539_2064:()=>ppt,content_3539_2066:()=>spt,content_3539_2068:()=>ipt,content_3539_2070:()=>lpt,content_3539_2072:()=>mpt,content_3539_2074:()=>hpt,content_3539_2076:()=>kpt,content_3539_2078:()=>Mpt,content_3539_208:()=>PA,content_3539_2080:()=>wpt,content_3539_2082:()=>Xpt,content_3539_2084:()=>Tpt,content_3539_2086:()=>Cpt,content_3539_2088:()=>Lpt,content_3539_2090:()=>bpt,content_3539_2092:()=>zpt,content_3539_2094:()=>Wpt,content_3539_2096:()=>Ipt,content_3539_2098:()=>Spt,content_3539_210:()=>EA,content_3539_2100:()=>Bpt,content_3539_2102:()=>Opt,content_3539_2104:()=>Fpt,content_3539_2106:()=>Vpt,content_3539_2108:()=>Hpt,content_3539_2110:()=>Ypt,content_3539_2112:()=>Kpt,content_3539_2114:()=>trt,content_3539_2116:()=>nrt,content_3539_2118:()=>prt,content_3539_212:()=>GA,content_3539_2120:()=>srt,content_3539_2122:()=>irt,content_3539_2124:()=>lrt,content_3539_2126:()=>mrt,content_3539_2128:()=>hrt,content_3539_2130:()=>krt,content_3539_2132:()=>Mrt,content_3539_2134:()=>wrt,content_3539_2136:()=>Xrt,content_3539_2138:()=>Trt,content_3539_214:()=>UA,content_3539_2140:()=>Crt,content_3539_2142:()=>Lrt,content_3539_2144:()=>brt,content_3539_2146:()=>zrt,content_3539_2148:()=>Wrt,content_3539_2150:()=>Irt,content_3539_2152:()=>Srt,content_3539_2154:()=>Brt,content_3539_2156:()=>Ort,content_3539_2158:()=>Frt,content_3539_216:()=>qA,content_3539_2160:()=>Vrt,content_3539_2162:()=>Hrt,content_3539_2164:()=>Yrt,content_3539_2166:()=>Krt,content_3539_2168:()=>tst,content_3539_2170:()=>nst,content_3539_2172:()=>pst,content_3539_2174:()=>sst,content_3539_2176:()=>ist,content_3539_2178:()=>lst,content_3539_218:()=>jA,content_3539_2180:()=>mst,content_3539_2182:()=>hst,content_3539_2184:()=>kst,content_3539_2186:()=>Mst,content_3539_2188:()=>wst,content_3539_2190:()=>Xst,content_3539_2192:()=>Tst,content_3539_2194:()=>Cst,content_3539_2196:()=>Lst,content_3539_2198:()=>bst,content_3539_22:()=>db,content_3539_220:()=>QA,content_3539_2200:()=>zst,content_3539_2202:()=>Wst,content_3539_2204:()=>Ist,content_3539_2206:()=>Sst,content_3539_2208:()=>Bst,content_3539_2210:()=>Ost,content_3539_2212:()=>Fst,content_3539_2214:()=>Vst,content_3539_2216:()=>Hst,content_3539_2218:()=>Yst,content_3539_222:()=>$A,content_3539_2220:()=>Kst,content_3539_2222:()=>tct,content_3539_2224:()=>nct,content_3539_2226:()=>pct,content_3539_2228:()=>sct,content_3539_2230:()=>ict,content_3539_2232:()=>lct,content_3539_2234:()=>mct,content_3539_2236:()=>hct,content_3539_2238:()=>kct,content_3539_224:()=>JA,content_3539_2240:()=>Mct,content_3539_2242:()=>wct,content_3539_2244:()=>Xct,content_3539_2246:()=>Tct,content_3539_2248:()=>Cct,content_3539_2250:()=>Lct,content_3539_2252:()=>bct,content_3539_2254:()=>zct,content_3539_2256:()=>Wct,content_3539_2258:()=>Ict,content_3539_226:()=>eW,content_3539_2260:()=>Sct,content_3539_2262:()=>Bct,content_3539_2264:()=>Oct,content_3539_2266:()=>Fct,content_3539_2268:()=>Vct,content_3539_2270:()=>Hct,content_3539_2272:()=>Yct,content_3539_2274:()=>Kct,content_3539_2276:()=>tit,content_3539_2278:()=>nit,content_3539_228:()=>oW,content_3539_2280:()=>pit,content_3539_2282:()=>sit,content_3539_2284:()=>iit,content_3539_2286:()=>lit,content_3539_2288:()=>mit,content_3539_2290:()=>hit,content_3539_2292:()=>kit,content_3539_2294:()=>Mit,content_3539_2296:()=>wit,content_3539_2298:()=>Xit,content_3539_230:()=>rW,content_3539_2300:()=>Tit,content_3539_2302:()=>Cit,content_3539_2304:()=>Lit,content_3539_2306:()=>bit,content_3539_2308:()=>zit,content_3539_2310:()=>Wit,content_3539_2312:()=>Iit,content_3539_2314:()=>Sit,content_3539_2316:()=>Bit,content_3539_2318:()=>Oit,content_3539_232:()=>cW,content_3539_2320:()=>Fit,content_3539_2322:()=>Vit,content_3539_2324:()=>Hit,content_3539_2326:()=>Yit,content_3539_2328:()=>Kit,content_3539_2330:()=>tat,content_3539_2332:()=>nat,content_3539_2334:()=>pat,content_3539_2336:()=>sat,content_3539_2338:()=>iat,content_3539_234:()=>aW,content_3539_2340:()=>lat,content_3539_2342:()=>mat,content_3539_2344:()=>hat,content_3539_2346:()=>kat,content_3539_2348:()=>Mat,content_3539_2350:()=>wat,content_3539_2352:()=>Xat,content_3539_2354:()=>Tat,content_3539_2356:()=>Cat,content_3539_2358:()=>Lat,content_3539_236:()=>uW,content_3539_2360:()=>bat,content_3539_2362:()=>zat,content_3539_2364:()=>Wat,content_3539_2366:()=>Iat,content_3539_2368:()=>Sat,content_3539_2370:()=>Bat,content_3539_2372:()=>Oat,content_3539_2374:()=>Fat,content_3539_2376:()=>Vat,content_3539_2378:()=>Hat,content_3539_238:()=>dW,content_3539_2380:()=>Yat,content_3539_2382:()=>Kat,content_3539_2384:()=>tlt,content_3539_2386:()=>nlt,content_3539_2388:()=>plt,content_3539_2390:()=>slt,content_3539_2392:()=>ilt,content_3539_2394:()=>llt,content_3539_2396:()=>mlt,content_3539_2398:()=>hlt,content_3539_24:()=>fb,content_3539_240:()=>fW,content_3539_2400:()=>klt,content_3539_2402:()=>Mlt,content_3539_2404:()=>wlt,content_3539_2406:()=>Xlt,content_3539_2408:()=>Tlt,content_3539_2410:()=>Clt,content_3539_2412:()=>Llt,content_3539_2414:()=>blt,content_3539_2416:()=>zlt,content_3539_2418:()=>Wlt,content_3539_242:()=>yW,content_3539_2420:()=>Ilt,content_3539_2422:()=>Slt,content_3539_2424:()=>Blt,content_3539_2426:()=>Olt,content_3539_2428:()=>Flt,content_3539_2430:()=>Vlt,content_3539_2432:()=>Hlt,content_3539_2434:()=>Ylt,content_3539_2436:()=>Klt,content_3539_2438:()=>tut,content_3539_244:()=>DW,content_3539_2440:()=>nut,content_3539_2442:()=>put,content_3539_2444:()=>sut,content_3539_2446:()=>iut,content_3539_2448:()=>lut,content_3539_2450:()=>mut,content_3539_2452:()=>hut,content_3539_2454:()=>kut,content_3539_2456:()=>Mut,content_3539_2458:()=>wut,content_3539_246:()=>_W,content_3539_2460:()=>Xut,content_3539_2462:()=>Tut,content_3539_2464:()=>Cut,content_3539_2466:()=>Lut,content_3539_2468:()=>but,content_3539_2470:()=>zut,content_3539_2472:()=>Wut,content_3539_2474:()=>Iut,content_3539_2476:()=>Sut,content_3539_2478:()=>But,content_3539_248:()=>gW,content_3539_2480:()=>Out,content_3539_2482:()=>Fut,content_3539_2484:()=>Vut,content_3539_2486:()=>Hut,content_3539_2488:()=>Yut,content_3539_2490:()=>Kut,content_3539_2492:()=>tmt,content_3539_2494:()=>nmt,content_3539_2496:()=>pmt,content_3539_2498:()=>smt,content_3539_250:()=>xW,content_3539_2500:()=>imt,content_3539_2502:()=>lmt,content_3539_2504:()=>mmt,content_3539_2506:()=>hmt,content_3539_2508:()=>kmt,content_3539_2510:()=>Mmt,content_3539_2512:()=>wmt,content_3539_2514:()=>Xmt,content_3539_2516:()=>Tmt,content_3539_2518:()=>Cmt,content_3539_252:()=>vW,content_3539_2520:()=>Lmt,content_3539_2522:()=>bmt,content_3539_2524:()=>zmt,content_3539_2526:()=>Wmt,content_3539_2528:()=>Imt,content_3539_2530:()=>Smt,content_3539_2532:()=>Bmt,content_3539_2534:()=>Omt,content_3539_2536:()=>Fmt,content_3539_2538:()=>Vmt,content_3539_254:()=>ZW,content_3539_2540:()=>Hmt,content_3539_2542:()=>Ymt,content_3539_2544:()=>Kmt,content_3539_2546:()=>tdt,content_3539_2548:()=>ndt,content_3539_2550:()=>pdt,content_3539_2552:()=>sdt,content_3539_2554:()=>idt,content_3539_2556:()=>ldt,content_3539_2558:()=>mdt,content_3539_256:()=>NW,content_3539_2560:()=>hdt,content_3539_2562:()=>kdt,content_3539_2564:()=>Mdt,content_3539_2566:()=>wdt,content_3539_2568:()=>Xdt,content_3539_2570:()=>Tdt,content_3539_2572:()=>Cdt,content_3539_2574:()=>Ldt,content_3539_2576:()=>bdt,content_3539_2578:()=>zdt,content_3539_258:()=>AW,content_3539_2580:()=>Wdt,content_3539_2582:()=>Idt,content_3539_2584:()=>Sdt,content_3539_2586:()=>Bdt,content_3539_2588:()=>Odt,content_3539_2590:()=>Fdt,content_3539_2592:()=>Vdt,content_3539_2594:()=>Hdt,content_3539_2596:()=>Ydt,content_3539_2598:()=>Kdt,content_3539_26:()=>yb,content_3539_260:()=>RW,content_3539_2600:()=>tht,content_3539_2602:()=>nht,content_3539_2604:()=>pht,content_3539_2606:()=>sht,content_3539_2608:()=>iht,content_3539_2610:()=>lht,content_3539_2612:()=>mht,content_3539_2614:()=>hht,content_3539_2616:()=>kht,content_3539_2618:()=>Mht,content_3539_262:()=>PW,content_3539_2620:()=>wht,content_3539_2622:()=>Xht,content_3539_2624:()=>Tht,content_3539_2626:()=>Cht,content_3539_2628:()=>Lht,content_3539_2630:()=>bht,content_3539_2632:()=>zht,content_3539_2634:()=>Wht,content_3539_2636:()=>Iht,content_3539_2638:()=>Sht,content_3539_264:()=>EW,content_3539_2640:()=>Bht,content_3539_2642:()=>Oht,content_3539_2644:()=>Fht,content_3539_2646:()=>Vht,content_3539_2648:()=>Hht,content_3539_2650:()=>Yht,content_3539_2652:()=>Kht,content_3539_2654:()=>tft,content_3539_2656:()=>nft,content_3539_2658:()=>pft,content_3539_266:()=>GW,content_3539_2660:()=>sft,content_3539_2662:()=>ift,content_3539_2664:()=>lft,content_3539_2666:()=>mft,content_3539_2668:()=>hft,content_3539_2670:()=>kft,content_3539_2672:()=>Mft,content_3539_2674:()=>wft,content_3539_2676:()=>Xft,content_3539_2678:()=>Tft,content_3539_268:()=>UW,content_3539_2680:()=>Cft,content_3539_2682:()=>Lft,content_3539_2684:()=>bft,content_3539_2686:()=>zft,content_3539_2688:()=>Wft,content_3539_2690:()=>Ift,content_3539_2692:()=>Sft,content_3539_2694:()=>Bft,content_3539_2696:()=>Oft,content_3539_2698:()=>Fft,content_3539_270:()=>qW,content_3539_2700:()=>Vft,content_3539_2702:()=>Hft,content_3539_2704:()=>Yft,content_3539_2706:()=>Kft,content_3539_2708:()=>tkt,content_3539_2710:()=>nkt,content_3539_2712:()=>pkt,content_3539_2714:()=>skt,content_3539_2716:()=>ikt,content_3539_2718:()=>lkt,content_3539_272:()=>jW,content_3539_2720:()=>mkt,content_3539_2722:()=>hkt,content_3539_2724:()=>kkt,content_3539_2726:()=>Mkt,content_3539_2728:()=>wkt,content_3539_2730:()=>Xkt,content_3539_2732:()=>Tkt,content_3539_2734:()=>Ckt,content_3539_2736:()=>Lkt,content_3539_2738:()=>bkt,content_3539_274:()=>QW,content_3539_2740:()=>zkt,content_3539_2742:()=>Wkt,content_3539_2744:()=>Ikt,content_3539_2746:()=>Skt,content_3539_2748:()=>Bkt,content_3539_2750:()=>Okt,content_3539_2752:()=>Fkt,content_3539_2754:()=>Vkt,content_3539_2756:()=>Hkt,content_3539_2758:()=>Ykt,content_3539_276:()=>$W,content_3539_2760:()=>Kkt,content_3539_2762:()=>tyt,content_3539_2764:()=>nyt,content_3539_2766:()=>pyt,content_3539_2768:()=>syt,content_3539_2770:()=>iyt,content_3539_2772:()=>lyt,content_3539_2774:()=>myt,content_3539_2776:()=>hyt,content_3539_2778:()=>kyt,content_3539_278:()=>JW,content_3539_2780:()=>Myt,content_3539_2782:()=>wyt,content_3539_2784:()=>Xyt,content_3539_2786:()=>Tyt,content_3539_2788:()=>Cyt,content_3539_2790:()=>Lyt,content_3539_2792:()=>byt,content_3539_2794:()=>zyt,content_3539_2796:()=>Wyt,content_3539_2798:()=>Iyt,content_3539_28:()=>Db,content_3539_280:()=>eR,content_3539_2800:()=>Syt,content_3539_2802:()=>Byt,content_3539_2804:()=>Oyt,content_3539_2806:()=>Fyt,content_3539_2808:()=>Vyt,content_3539_2810:()=>Hyt,content_3539_2812:()=>Yyt,content_3539_2814:()=>Kyt,content_3539_2816:()=>tMt,content_3539_2818:()=>nMt,content_3539_282:()=>oR,content_3539_2820:()=>pMt,content_3539_2822:()=>sMt,content_3539_2824:()=>iMt,content_3539_2826:()=>lMt,content_3539_2828:()=>mMt,content_3539_2830:()=>hMt,content_3539_2832:()=>kMt,content_3539_2834:()=>MMt,content_3539_2836:()=>wMt,content_3539_2838:()=>XMt,content_3539_284:()=>rR,content_3539_2840:()=>TMt,content_3539_2842:()=>CMt,content_3539_2844:()=>LMt,content_3539_2846:()=>bMt,content_3539_2848:()=>zMt,content_3539_2850:()=>WMt,content_3539_2852:()=>IMt,content_3539_2854:()=>SMt,content_3539_2856:()=>BMt,content_3539_2858:()=>OMt,content_3539_286:()=>cR,content_3539_2860:()=>FMt,content_3539_2862:()=>VMt,content_3539_2864:()=>HMt,content_3539_2866:()=>YMt,content_3539_2868:()=>KMt,content_3539_2870:()=>tDt,content_3539_2872:()=>nDt,content_3539_2874:()=>pDt,content_3539_2876:()=>sDt,content_3539_2878:()=>iDt,content_3539_288:()=>aR,content_3539_2880:()=>lDt,content_3539_2882:()=>mDt,content_3539_2884:()=>hDt,content_3539_2886:()=>kDt,content_3539_2888:()=>MDt,content_3539_2890:()=>wDt,content_3539_2892:()=>XDt,content_3539_2894:()=>TDt,content_3539_2896:()=>CDt,content_3539_2898:()=>LDt,content_3539_290:()=>uR,content_3539_2900:()=>bDt,content_3539_2902:()=>zDt,content_3539_2904:()=>WDt,content_3539_2906:()=>IDt,content_3539_2908:()=>SDt,content_3539_2910:()=>BDt,content_3539_2912:()=>ODt,content_3539_2914:()=>FDt,content_3539_2916:()=>VDt,content_3539_2918:()=>HDt,content_3539_292:()=>dR,content_3539_2920:()=>YDt,content_3539_2922:()=>KDt,content_3539_2924:()=>twt,content_3539_2926:()=>nwt,content_3539_2928:()=>pwt,content_3539_2930:()=>swt,content_3539_2932:()=>iwt,content_3539_2934:()=>lwt,content_3539_2936:()=>mwt,content_3539_2938:()=>hwt,content_3539_294:()=>fR,content_3539_2940:()=>kwt,content_3539_2942:()=>Mwt,content_3539_2944:()=>wwt,content_3539_2946:()=>Xwt,content_3539_2948:()=>Twt,content_3539_2950:()=>Cwt,content_3539_2952:()=>Lwt,content_3539_2954:()=>bwt,content_3539_2956:()=>zwt,content_3539_2958:()=>Wwt,content_3539_296:()=>yR,content_3539_2960:()=>Iwt,content_3539_2962:()=>Swt,content_3539_2964:()=>Bwt,content_3539_2966:()=>Owt,content_3539_2968:()=>Fwt,content_3539_2970:()=>Vwt,content_3539_2972:()=>Hwt,content_3539_2974:()=>Ywt,content_3539_2976:()=>Kwt,content_3539_2978:()=>t_t,content_3539_298:()=>DR,content_3539_2980:()=>n_t,content_3539_2982:()=>p_t,content_3539_2984:()=>s_t,content_3539_2986:()=>i_t,content_3539_2988:()=>l_t,content_3539_2990:()=>m_t,content_3539_2992:()=>h_t,content_3539_2994:()=>k_t,content_3539_2996:()=>M_t,content_3539_2998:()=>w_t,content_3539_30:()=>_b,content_3539_300:()=>_R,content_3539_3000:()=>X_t,content_3539_3002:()=>T_t,content_3539_3004:()=>C_t,content_3539_3006:()=>L_t,content_3539_3008:()=>b_t,content_3539_3010:()=>z_t,content_3539_3012:()=>W_t,content_3539_3014:()=>I_t,content_3539_3016:()=>S_t,content_3539_3018:()=>B_t,content_3539_302:()=>gR,content_3539_3020:()=>O_t,content_3539_3022:()=>F_t,content_3539_3024:()=>V_t,content_3539_3026:()=>H_t,content_3539_3028:()=>Y_t,content_3539_3030:()=>K_t,content_3539_3032:()=>tXt,content_3539_3034:()=>nXt,content_3539_3036:()=>pXt,content_3539_3038:()=>sXt,content_3539_304:()=>xR,content_3539_3040:()=>iXt,content_3539_3042:()=>lXt,content_3539_3044:()=>mXt,content_3539_3046:()=>hXt,content_3539_3048:()=>kXt,content_3539_3050:()=>MXt,content_3539_3052:()=>wXt,content_3539_3054:()=>XXt,content_3539_3056:()=>TXt,content_3539_3058:()=>CXt,content_3539_306:()=>vR,content_3539_3060:()=>LXt,content_3539_3062:()=>bXt,content_3539_3064:()=>zXt,content_3539_3066:()=>WXt,content_3539_3068:()=>IXt,content_3539_3070:()=>SXt,content_3539_3072:()=>BXt,content_3539_3074:()=>OXt,content_3539_3076:()=>FXt,content_3539_3078:()=>VXt,content_3539_308:()=>ZR,content_3539_3080:()=>HXt,content_3539_3082:()=>YXt,content_3539_3084:()=>KXt,content_3539_3086:()=>tgt,content_3539_3088:()=>ngt,content_3539_3090:()=>pgt,content_3539_3092:()=>sgt,content_3539_3094:()=>igt,content_3539_3096:()=>lgt,content_3539_3098:()=>mgt,content_3539_310:()=>NR,content_3539_3100:()=>hgt,content_3539_3102:()=>kgt,content_3539_3104:()=>Mgt,content_3539_3106:()=>wgt,content_3539_3108:()=>Xgt,content_3539_3110:()=>Tgt,content_3539_3112:()=>Cgt,content_3539_3114:()=>Lgt,content_3539_3116:()=>bgt,content_3539_3118:()=>zgt,content_3539_312:()=>AR,content_3539_3120:()=>Wgt,content_3539_3122:()=>Igt,content_3539_3124:()=>Sgt,content_3539_3126:()=>Bgt,content_3539_3128:()=>Ogt,content_3539_3130:()=>Fgt,content_3539_3132:()=>Vgt,content_3539_3134:()=>Hgt,content_3539_3136:()=>Ygt,content_3539_3138:()=>Kgt,content_3539_314:()=>RR,content_3539_3140:()=>tTt,content_3539_3142:()=>nTt,content_3539_3144:()=>pTt,content_3539_3146:()=>sTt,content_3539_3148:()=>iTt,content_3539_3150:()=>lTt,content_3539_3152:()=>mTt,content_3539_3154:()=>hTt,content_3539_3156:()=>kTt,content_3539_3158:()=>MTt,content_3539_316:()=>PR,content_3539_3160:()=>wTt,content_3539_3162:()=>XTt,content_3539_3164:()=>TTt,content_3539_3166:()=>CTt,content_3539_3168:()=>LTt,content_3539_3170:()=>bTt,content_3539_3172:()=>zTt,content_3539_3174:()=>WTt,content_3539_3176:()=>ITt,content_3539_3178:()=>STt,content_3539_318:()=>ER,content_3539_3180:()=>BTt,content_3539_3182:()=>OTt,content_3539_3184:()=>FTt,content_3539_3186:()=>VTt,content_3539_3188:()=>HTt,content_3539_3190:()=>YTt,content_3539_3192:()=>KTt,content_3539_3194:()=>txt,content_3539_3196:()=>nxt,content_3539_3198:()=>pxt,content_3539_32:()=>gb,content_3539_320:()=>GR,content_3539_3200:()=>sxt,content_3539_3202:()=>ixt,content_3539_3204:()=>lxt,content_3539_3206:()=>mxt,content_3539_3208:()=>hxt,content_3539_3210:()=>kxt,content_3539_3212:()=>Mxt,content_3539_3214:()=>wxt,content_3539_3216:()=>Xxt,content_3539_3218:()=>Txt,content_3539_322:()=>UR,content_3539_3220:()=>Cxt,content_3539_3222:()=>Lxt,content_3539_3224:()=>bxt,content_3539_3226:()=>zxt,content_3539_3228:()=>Wxt,content_3539_3230:()=>Ixt,content_3539_3232:()=>Sxt,content_3539_3234:()=>Bxt,content_3539_3236:()=>Oxt,content_3539_3238:()=>Fxt,content_3539_324:()=>qR,content_3539_3240:()=>Vxt,content_3539_3242:()=>Hxt,content_3539_3244:()=>Yxt,content_3539_3246:()=>Kxt,content_3539_3248:()=>tCt,content_3539_3250:()=>nCt,content_3539_3252:()=>pCt,content_3539_3254:()=>sCt,content_3539_3256:()=>iCt,content_3539_3258:()=>lCt,content_3539_326:()=>jR,content_3539_3260:()=>mCt,content_3539_3262:()=>hCt,content_3539_3264:()=>kCt,content_3539_3266:()=>MCt,content_3539_3268:()=>wCt,content_3539_3270:()=>XCt,content_3539_3272:()=>TCt,content_3539_3274:()=>CCt,content_3539_3276:()=>LCt,content_3539_3278:()=>bCt,content_3539_328:()=>QR,content_3539_3280:()=>zCt,content_3539_3282:()=>WCt,content_3539_3284:()=>ICt,content_3539_3286:()=>SCt,content_3539_3288:()=>BCt,content_3539_3290:()=>OCt,content_3539_3292:()=>FCt,content_3539_3294:()=>VCt,content_3539_3296:()=>HCt,content_3539_3298:()=>YCt,content_3539_330:()=>$R,content_3539_3300:()=>KCt,content_3539_3302:()=>tvt,content_3539_3304:()=>nvt,content_3539_3306:()=>pvt,content_3539_3308:()=>svt,content_3539_3310:()=>ivt,content_3539_3312:()=>lvt,content_3539_3314:()=>mvt,content_3539_3316:()=>hvt,content_3539_3318:()=>kvt,content_3539_332:()=>JR,content_3539_3320:()=>Mvt,content_3539_3322:()=>wvt,content_3539_3324:()=>Xvt,content_3539_3326:()=>Tvt,content_3539_3328:()=>Cvt,content_3539_3330:()=>Lvt,content_3539_3332:()=>bvt,content_3539_3334:()=>zvt,content_3539_3336:()=>Wvt,content_3539_3338:()=>Ivt,content_3539_334:()=>eI,content_3539_3340:()=>Svt,content_3539_3342:()=>Bvt,content_3539_3344:()=>Ovt,content_3539_3346:()=>Fvt,content_3539_3348:()=>Vvt,content_3539_3350:()=>Hvt,content_3539_3352:()=>Yvt,content_3539_3354:()=>Kvt,content_3539_3356:()=>tLt,content_3539_3358:()=>nLt,content_3539_336:()=>oI,content_3539_3360:()=>pLt,content_3539_3362:()=>sLt,content_3539_3364:()=>iLt,content_3539_3366:()=>lLt,content_3539_3368:()=>mLt,content_3539_3370:()=>hLt,content_3539_3372:()=>kLt,content_3539_3374:()=>MLt,content_3539_3376:()=>wLt,content_3539_3378:()=>XLt,content_3539_338:()=>rI,content_3539_3380:()=>TLt,content_3539_3382:()=>CLt,content_3539_3384:()=>LLt,content_3539_3386:()=>bLt,content_3539_3388:()=>zLt,content_3539_3390:()=>WLt,content_3539_3392:()=>ILt,content_3539_3394:()=>SLt,content_3539_3396:()=>BLt,content_3539_3398:()=>OLt,content_3539_34:()=>xb,content_3539_340:()=>cI,content_3539_3400:()=>FLt,content_3539_3402:()=>VLt,content_3539_3404:()=>HLt,content_3539_3406:()=>YLt,content_3539_3408:()=>KLt,content_3539_3410:()=>tZt,content_3539_3412:()=>nZt,content_3539_3414:()=>pZt,content_3539_3416:()=>sZt,content_3539_3418:()=>iZt,content_3539_342:()=>aI,content_3539_3420:()=>lZt,content_3539_3422:()=>mZt,content_3539_3424:()=>hZt,content_3539_3426:()=>kZt,content_3539_3428:()=>MZt,content_3539_3430:()=>wZt,content_3539_3432:()=>XZt,content_3539_3434:()=>TZt,content_3539_3436:()=>CZt,content_3539_3438:()=>LZt,content_3539_344:()=>uI,content_3539_3440:()=>bZt,content_3539_3442:()=>zZt,content_3539_3444:()=>WZt,content_3539_3446:()=>IZt,content_3539_3448:()=>SZt,content_3539_3450:()=>BZt,content_3539_3452:()=>OZt,content_3539_3454:()=>FZt,content_3539_3456:()=>VZt,content_3539_3458:()=>HZt,content_3539_346:()=>dI,content_3539_3460:()=>YZt,content_3539_3462:()=>KZt,content_3539_3464:()=>tbt,content_3539_3466:()=>nbt,content_3539_3468:()=>pbt,content_3539_3470:()=>sbt,content_3539_3472:()=>ibt,content_3539_3474:()=>lbt,content_3539_3476:()=>mbt,content_3539_3478:()=>hbt,content_3539_348:()=>fI,content_3539_3480:()=>kbt,content_3539_3482:()=>Mbt,content_3539_3484:()=>wbt,content_3539_3486:()=>Xbt,content_3539_3488:()=>Tbt,content_3539_3490:()=>Cbt,content_3539_3492:()=>Lbt,content_3539_3494:()=>bbt,content_3539_3496:()=>zbt,content_3539_3498:()=>Wbt,content_3539_350:()=>yI,content_3539_3500:()=>Ibt,content_3539_3502:()=>Sbt,content_3539_3504:()=>Bbt,content_3539_3506:()=>Obt,content_3539_3508:()=>Fbt,content_3539_3510:()=>Vbt,content_3539_3512:()=>Hbt,content_3539_3514:()=>Ybt,content_3539_3516:()=>Kbt,content_3539_3518:()=>tNt,content_3539_352:()=>DI,content_3539_3520:()=>nNt,content_3539_3522:()=>pNt,content_3539_3524:()=>sNt,content_3539_3526:()=>iNt,content_3539_3528:()=>lNt,content_3539_3530:()=>mNt,content_3539_3532:()=>hNt,content_3539_3534:()=>kNt,content_3539_3536:()=>MNt,content_3539_3538:()=>wNt,content_3539_354:()=>_I,content_3539_3540:()=>XNt,content_3539_3542:()=>TNt,content_3539_3544:()=>CNt,content_3539_3546:()=>LNt,content_3539_3548:()=>bNt,content_3539_3550:()=>zNt,content_3539_3552:()=>WNt,content_3539_3554:()=>INt,content_3539_3556:()=>SNt,content_3539_3558:()=>BNt,content_3539_356:()=>gI,content_3539_3560:()=>ONt,content_3539_3562:()=>FNt,content_3539_3564:()=>VNt,content_3539_3566:()=>HNt,content_3539_3568:()=>YNt,content_3539_3570:()=>KNt,content_3539_3572:()=>tzt,content_3539_3574:()=>nzt,content_3539_3576:()=>pzt,content_3539_3578:()=>szt,content_3539_358:()=>xI,content_3539_3580:()=>izt,content_3539_3582:()=>lzt,content_3539_3584:()=>mzt,content_3539_3586:()=>hzt,content_3539_3588:()=>kzt,content_3539_3590:()=>Mzt,content_3539_3592:()=>wzt,content_3539_3594:()=>Xzt,content_3539_3596:()=>Tzt,content_3539_3598:()=>Czt,content_3539_36:()=>vb,content_3539_360:()=>vI,content_3539_3600:()=>Lzt,content_3539_3602:()=>bzt,content_3539_3604:()=>zzt,content_3539_3606:()=>Wzt,content_3539_3608:()=>Izt,content_3539_3610:()=>Szt,content_3539_3612:()=>Bzt,content_3539_3614:()=>Ozt,content_3539_3616:()=>Fzt,content_3539_3618:()=>Vzt,content_3539_362:()=>ZI,content_3539_3620:()=>Hzt,content_3539_3622:()=>Yzt,content_3539_3624:()=>Kzt,content_3539_3626:()=>tAt,content_3539_3628:()=>nAt,content_3539_3630:()=>pAt,content_3539_3632:()=>sAt,content_3539_3634:()=>iAt,content_3539_3636:()=>lAt,content_3539_3638:()=>mAt,content_3539_364:()=>NI,content_3539_3640:()=>hAt,content_3539_3642:()=>kAt,content_3539_3644:()=>MAt,content_3539_3646:()=>wAt,content_3539_3648:()=>XAt,content_3539_3650:()=>TAt,content_3539_3652:()=>CAt,content_3539_3654:()=>LAt,content_3539_3656:()=>bAt,content_3539_3658:()=>zAt,content_3539_366:()=>AI,content_3539_3660:()=>WAt,content_3539_3662:()=>IAt,content_3539_3664:()=>SAt,content_3539_3666:()=>BAt,content_3539_3668:()=>OAt,content_3539_3670:()=>FAt,content_3539_3672:()=>VAt,content_3539_3674:()=>HAt,content_3539_3676:()=>YAt,content_3539_3678:()=>KAt,content_3539_368:()=>RI,content_3539_3680:()=>tWt,content_3539_3682:()=>nWt,content_3539_3684:()=>pWt,content_3539_3686:()=>sWt,content_3539_3688:()=>iWt,content_3539_3690:()=>lWt,content_3539_3692:()=>mWt,content_3539_3694:()=>hWt,content_3539_3696:()=>kWt,content_3539_3698:()=>MWt,content_3539_370:()=>PI,content_3539_3700:()=>wWt,content_3539_3702:()=>XWt,content_3539_3704:()=>TWt,content_3539_3706:()=>CWt,content_3539_3708:()=>LWt,content_3539_3710:()=>bWt,content_3539_3712:()=>zWt,content_3539_3714:()=>WWt,content_3539_3716:()=>IWt,content_3539_3718:()=>SWt,content_3539_372:()=>EI,content_3539_3720:()=>BWt,content_3539_3722:()=>OWt,content_3539_3724:()=>FWt,content_3539_3726:()=>VWt,content_3539_3728:()=>HWt,content_3539_3730:()=>YWt,content_3539_3732:()=>KWt,content_3539_3734:()=>tRt,content_3539_3736:()=>nRt,content_3539_3738:()=>pRt,content_3539_374:()=>GI,content_3539_3740:()=>sRt,content_3539_3742:()=>iRt,content_3539_3744:()=>lRt,content_3539_3746:()=>mRt,content_3539_3748:()=>hRt,content_3539_3750:()=>kRt,content_3539_3752:()=>MRt,content_3539_3754:()=>wRt,content_3539_3756:()=>XRt,content_3539_3758:()=>TRt,content_3539_376:()=>UI,content_3539_3760:()=>CRt,content_3539_3762:()=>LRt,content_3539_3764:()=>bRt,content_3539_3766:()=>zRt,content_3539_3768:()=>WRt,content_3539_3770:()=>IRt,content_3539_3772:()=>SRt,content_3539_3774:()=>BRt,content_3539_3776:()=>ORt,content_3539_3778:()=>FRt,content_3539_378:()=>qI,content_3539_3780:()=>VRt,content_3539_3782:()=>HRt,content_3539_3784:()=>YRt,content_3539_3786:()=>KRt,content_3539_3788:()=>tIt,content_3539_3790:()=>nIt,content_3539_3792:()=>pIt,content_3539_3794:()=>sIt,content_3539_3796:()=>iIt,content_3539_3798:()=>lIt,content_3539_38:()=>Zb,content_3539_380:()=>jI,content_3539_3800:()=>mIt,content_3539_3802:()=>hIt,content_3539_3804:()=>kIt,content_3539_3806:()=>MIt,content_3539_3808:()=>wIt,content_3539_3810:()=>XIt,content_3539_3812:()=>TIt,content_3539_3814:()=>CIt,content_3539_3816:()=>LIt,content_3539_3818:()=>bIt,content_3539_382:()=>QI,content_3539_3820:()=>zIt,content_3539_3822:()=>WIt,content_3539_3824:()=>IIt,content_3539_3826:()=>SIt,content_3539_3828:()=>BIt,content_3539_3830:()=>OIt,content_3539_3832:()=>FIt,content_3539_3834:()=>VIt,content_3539_3836:()=>HIt,content_3539_3838:()=>YIt,content_3539_384:()=>$I,content_3539_3840:()=>KIt,content_3539_3842:()=>tPt,content_3539_3844:()=>nPt,content_3539_3846:()=>pPt,content_3539_3848:()=>sPt,content_3539_3850:()=>iPt,content_3539_3852:()=>lPt,content_3539_3854:()=>mPt,content_3539_3856:()=>hPt,content_3539_3858:()=>kPt,content_3539_386:()=>JI,content_3539_3860:()=>MPt,content_3539_3862:()=>wPt,content_3539_3864:()=>XPt,content_3539_3866:()=>TPt,content_3539_3868:()=>CPt,content_3539_3870:()=>LPt,content_3539_3872:()=>bPt,content_3539_3874:()=>zPt,content_3539_3876:()=>WPt,content_3539_3878:()=>IPt,content_3539_388:()=>eP,content_3539_3880:()=>SPt,content_3539_3882:()=>BPt,content_3539_3884:()=>OPt,content_3539_3886:()=>FPt,content_3539_3888:()=>VPt,content_3539_3890:()=>HPt,content_3539_3892:()=>YPt,content_3539_3894:()=>KPt,content_3539_3896:()=>tSt,content_3539_3898:()=>nSt,content_3539_390:()=>oP,content_3539_3900:()=>pSt,content_3539_3902:()=>sSt,content_3539_3904:()=>iSt,content_3539_3906:()=>lSt,content_3539_3908:()=>mSt,content_3539_3910:()=>hSt,content_3539_3912:()=>kSt,content_3539_3914:()=>MSt,content_3539_3916:()=>wSt,content_3539_3918:()=>XSt,content_3539_392:()=>rP,content_3539_3920:()=>TSt,content_3539_3922:()=>CSt,content_3539_3924:()=>LSt,content_3539_3926:()=>bSt,content_3539_3928:()=>zSt,content_3539_3930:()=>WSt,content_3539_3932:()=>ISt,content_3539_3934:()=>SSt,content_3539_3936:()=>BSt,content_3539_3938:()=>OSt,content_3539_394:()=>cP,content_3539_3940:()=>FSt,content_3539_3942:()=>VSt,content_3539_3944:()=>HSt,content_3539_3946:()=>YSt,content_3539_3948:()=>KSt,content_3539_3950:()=>tEt,content_3539_3952:()=>nEt,content_3539_3954:()=>pEt,content_3539_3956:()=>sEt,content_3539_3958:()=>iEt,content_3539_396:()=>aP,content_3539_3960:()=>lEt,content_3539_3962:()=>mEt,content_3539_3964:()=>hEt,content_3539_3966:()=>kEt,content_3539_3968:()=>MEt,content_3539_3970:()=>wEt,content_3539_3972:()=>XEt,content_3539_3974:()=>TEt,content_3539_3976:()=>CEt,content_3539_3978:()=>LEt,content_3539_398:()=>uP,content_3539_3980:()=>bEt,content_3539_3982:()=>zEt,content_3539_3984:()=>WEt,content_3539_3986:()=>IEt,content_3539_3988:()=>SEt,content_3539_3990:()=>BEt,content_3539_3992:()=>OEt,content_3539_3994:()=>FEt,content_3539_3996:()=>VEt,content_3539_3998:()=>HEt,content_3539_4:()=>QZ,content_3539_40:()=>Nb,content_3539_400:()=>dP,content_3539_4000:()=>YEt,content_3539_4002:()=>KEt,content_3539_4004:()=>tBt,content_3539_4006:()=>nBt,content_3539_4008:()=>pBt,content_3539_4010:()=>sBt,content_3539_4012:()=>iBt,content_3539_4014:()=>lBt,content_3539_4016:()=>mBt,content_3539_4018:()=>hBt,content_3539_402:()=>fP,content_3539_4020:()=>kBt,content_3539_4022:()=>MBt,content_3539_4024:()=>wBt,content_3539_4026:()=>XBt,content_3539_4028:()=>TBt,content_3539_4030:()=>CBt,content_3539_4032:()=>LBt,content_3539_4034:()=>bBt,content_3539_4036:()=>zBt,content_3539_4038:()=>WBt,content_3539_404:()=>yP,content_3539_4040:()=>IBt,content_3539_4042:()=>SBt,content_3539_4044:()=>BBt,content_3539_4046:()=>OBt,content_3539_4048:()=>FBt,content_3539_4050:()=>VBt,content_3539_4052:()=>HBt,content_3539_4054:()=>YBt,content_3539_4056:()=>KBt,content_3539_4058:()=>tGt,content_3539_406:()=>DP,content_3539_4060:()=>nGt,content_3539_4062:()=>pGt,content_3539_4064:()=>sGt,content_3539_4066:()=>iGt,content_3539_4068:()=>lGt,content_3539_4070:()=>mGt,content_3539_4072:()=>hGt,content_3539_4074:()=>kGt,content_3539_4076:()=>MGt,content_3539_4078:()=>wGt,content_3539_408:()=>_P,content_3539_4080:()=>XGt,content_3539_4082:()=>TGt,content_3539_4084:()=>CGt,content_3539_4086:()=>LGt,content_3539_4088:()=>bGt,content_3539_4090:()=>zGt,content_3539_4092:()=>WGt,content_3539_4094:()=>IGt,content_3539_4096:()=>SGt,content_3539_4098:()=>BGt,content_3539_410:()=>gP,content_3539_4100:()=>OGt,content_3539_4102:()=>FGt,content_3539_4104:()=>VGt,content_3539_4106:()=>HGt,content_3539_4108:()=>YGt,content_3539_4110:()=>KGt,content_3539_4112:()=>tOt,content_3539_4114:()=>nOt,content_3539_4116:()=>pOt,content_3539_4118:()=>sOt,content_3539_412:()=>xP,content_3539_4120:()=>iOt,content_3539_4122:()=>lOt,content_3539_4124:()=>mOt,content_3539_4126:()=>hOt,content_3539_4128:()=>kOt,content_3539_4130:()=>MOt,content_3539_4132:()=>wOt,content_3539_4134:()=>XOt,content_3539_4136:()=>TOt,content_3539_4138:()=>COt,content_3539_414:()=>vP,content_3539_4140:()=>LOt,content_3539_4142:()=>bOt,content_3539_4144:()=>zOt,content_3539_4146:()=>WOt,content_3539_4148:()=>IOt,content_3539_4150:()=>SOt,content_3539_4152:()=>BOt,content_3539_4154:()=>OOt,content_3539_4156:()=>FOt,content_3539_4158:()=>VOt,content_3539_416:()=>ZP,content_3539_4160:()=>HOt,content_3539_4162:()=>YOt,content_3539_4164:()=>KOt,content_3539_4166:()=>tUt,content_3539_4168:()=>nUt,content_3539_4170:()=>pUt,content_3539_4172:()=>sUt,content_3539_4174:()=>iUt,content_3539_4176:()=>lUt,content_3539_4178:()=>mUt,content_3539_418:()=>NP,content_3539_4180:()=>hUt,content_3539_4182:()=>kUt,content_3539_4184:()=>MUt,content_3539_4186:()=>wUt,content_3539_4188:()=>XUt,content_3539_4190:()=>TUt,content_3539_4192:()=>CUt,content_3539_4194:()=>LUt,content_3539_4196:()=>bUt,content_3539_4198:()=>zUt,content_3539_42:()=>Ab,content_3539_420:()=>AP,content_3539_4200:()=>WUt,content_3539_4202:()=>IUt,content_3539_4204:()=>SUt,content_3539_4206:()=>BUt,content_3539_4208:()=>OUt,content_3539_4210:()=>FUt,content_3539_4212:()=>VUt,content_3539_4214:()=>HUt,content_3539_4216:()=>YUt,content_3539_4218:()=>KUt,content_3539_422:()=>RP,content_3539_4220:()=>tFt,content_3539_4222:()=>nFt,content_3539_4224:()=>pFt,content_3539_4226:()=>sFt,content_3539_4228:()=>iFt,content_3539_4230:()=>lFt,content_3539_4232:()=>mFt,content_3539_4234:()=>hFt,content_3539_4236:()=>kFt,content_3539_4238:()=>MFt,content_3539_424:()=>PP,content_3539_4240:()=>wFt,content_3539_4242:()=>XFt,content_3539_4244:()=>TFt,content_3539_4246:()=>CFt,content_3539_4248:()=>LFt,content_3539_4250:()=>bFt,content_3539_4252:()=>zFt,content_3539_4254:()=>WFt,content_3539_4256:()=>IFt,content_3539_4258:()=>SFt,content_3539_426:()=>EP,content_3539_4260:()=>BFt,content_3539_4262:()=>OFt,content_3539_4264:()=>FFt,content_3539_4266:()=>VFt,content_3539_4268:()=>HFt,content_3539_4270:()=>YFt,content_3539_4272:()=>KFt,content_3539_4274:()=>tqt,content_3539_4276:()=>nqt,content_3539_4278:()=>pqt,content_3539_428:()=>GP,content_3539_4280:()=>sqt,content_3539_4282:()=>iqt,content_3539_4284:()=>lqt,content_3539_4286:()=>mqt,content_3539_4288:()=>hqt,content_3539_4290:()=>kqt,content_3539_4292:()=>Mqt,content_3539_4294:()=>wqt,content_3539_4296:()=>Xqt,content_3539_4298:()=>Tqt,content_3539_430:()=>UP,content_3539_4300:()=>Cqt,content_3539_4302:()=>Lqt,content_3539_4304:()=>bqt,content_3539_4306:()=>zqt,content_3539_4308:()=>Wqt,content_3539_4310:()=>Iqt,content_3539_4312:()=>Sqt,content_3539_4314:()=>Bqt,content_3539_4316:()=>Oqt,content_3539_4318:()=>Fqt,content_3539_432:()=>qP,content_3539_4320:()=>Vqt,content_3539_4322:()=>Hqt,content_3539_4324:()=>Yqt,content_3539_4326:()=>Kqt,content_3539_4328:()=>tVt,content_3539_4330:()=>nVt,content_3539_4332:()=>pVt,content_3539_4334:()=>sVt,content_3539_4336:()=>iVt,content_3539_4338:()=>lVt,content_3539_434:()=>jP,content_3539_4340:()=>mVt,content_3539_4342:()=>hVt,content_3539_4344:()=>kVt,content_3539_4346:()=>MVt,content_3539_4348:()=>wVt,content_3539_4350:()=>XVt,content_3539_4352:()=>TVt,content_3539_4354:()=>CVt,content_3539_4356:()=>LVt,content_3539_4358:()=>bVt,content_3539_436:()=>QP,content_3539_4360:()=>zVt,content_3539_4362:()=>WVt,content_3539_4364:()=>IVt,content_3539_4366:()=>SVt,content_3539_4368:()=>BVt,content_3539_4370:()=>OVt,content_3539_4372:()=>FVt,content_3539_4374:()=>VVt,content_3539_4376:()=>HVt,content_3539_4378:()=>YVt,content_3539_438:()=>$P,content_3539_4380:()=>KVt,content_3539_4382:()=>tjt,content_3539_4384:()=>njt,content_3539_4386:()=>pjt,content_3539_4388:()=>sjt,content_3539_4390:()=>ijt,content_3539_4392:()=>ljt,content_3539_4394:()=>mjt,content_3539_4396:()=>hjt,content_3539_4398:()=>kjt,content_3539_44:()=>Rb,content_3539_440:()=>JP,content_3539_4400:()=>Mjt,content_3539_4402:()=>wjt,content_3539_4404:()=>Xjt,content_3539_4406:()=>Tjt,content_3539_4408:()=>Cjt,content_3539_4410:()=>Ljt,content_3539_4412:()=>bjt,content_3539_4414:()=>zjt,content_3539_4416:()=>Wjt,content_3539_4418:()=>Ijt,content_3539_442:()=>eS,content_3539_4420:()=>Sjt,content_3539_4422:()=>Bjt,content_3539_4424:()=>Ojt,content_3539_4426:()=>Fjt,content_3539_4428:()=>Vjt,content_3539_4430:()=>Hjt,content_3539_4432:()=>Yjt,content_3539_4434:()=>Kjt,content_3539_4436:()=>tHt,content_3539_4438:()=>nHt,content_3539_444:()=>oS,content_3539_4440:()=>pHt,content_3539_4442:()=>sHt,content_3539_4444:()=>iHt,content_3539_4446:()=>lHt,content_3539_4448:()=>mHt,content_3539_4450:()=>hHt,content_3539_4452:()=>kHt,content_3539_4454:()=>MHt,content_3539_4456:()=>wHt,content_3539_4458:()=>XHt,content_3539_446:()=>rS,content_3539_4460:()=>THt,content_3539_4462:()=>CHt,content_3539_4464:()=>LHt,content_3539_4466:()=>bHt,content_3539_4468:()=>zHt,content_3539_4470:()=>WHt,content_3539_4472:()=>IHt,content_3539_4474:()=>SHt,content_3539_4476:()=>BHt,content_3539_4478:()=>OHt,content_3539_448:()=>cS,content_3539_4480:()=>FHt,content_3539_4482:()=>VHt,content_3539_4484:()=>HHt,content_3539_4486:()=>YHt,content_3539_4488:()=>KHt,content_3539_4490:()=>tQt,content_3539_4492:()=>nQt,content_3539_4494:()=>pQt,content_3539_4496:()=>sQt,content_3539_4498:()=>iQt,content_3539_450:()=>aS,content_3539_4500:()=>lQt,content_3539_4502:()=>mQt,content_3539_4504:()=>hQt,content_3539_4506:()=>kQt,content_3539_4508:()=>MQt,content_3539_4510:()=>wQt,content_3539_4512:()=>XQt,content_3539_4514:()=>TQt,content_3539_4516:()=>CQt,content_3539_4518:()=>LQt,content_3539_452:()=>uS,content_3539_4520:()=>bQt,content_3539_4522:()=>zQt,content_3539_4524:()=>WQt,content_3539_4526:()=>IQt,content_3539_4528:()=>SQt,content_3539_4530:()=>BQt,content_3539_4532:()=>OQt,content_3539_4534:()=>FQt,content_3539_4536:()=>VQt,content_3539_4538:()=>HQt,content_3539_454:()=>dS,content_3539_4540:()=>YQt,content_3539_4542:()=>KQt,content_3539_4544:()=>tYt,content_3539_4546:()=>nYt,content_3539_4548:()=>pYt,content_3539_4550:()=>sYt,content_3539_4552:()=>iYt,content_3539_4554:()=>lYt,content_3539_4556:()=>mYt,content_3539_4558:()=>hYt,content_3539_456:()=>fS,content_3539_4560:()=>kYt,content_3539_4562:()=>MYt,content_3539_4564:()=>wYt,content_3539_4566:()=>XYt,content_3539_4568:()=>TYt,content_3539_4570:()=>CYt,content_3539_4572:()=>LYt,content_3539_4574:()=>bYt,content_3539_4576:()=>zYt,content_3539_4578:()=>WYt,content_3539_458:()=>yS,content_3539_4580:()=>IYt,content_3539_4582:()=>SYt,content_3539_4584:()=>BYt,content_3539_4586:()=>OYt,content_3539_4588:()=>FYt,content_3539_4590:()=>VYt,content_3539_4592:()=>HYt,content_3539_4594:()=>YYt,content_3539_4596:()=>KYt,content_3539_4598:()=>t$t,content_3539_46:()=>Pb,content_3539_460:()=>DS,content_3539_4600:()=>n$t,content_3539_4602:()=>p$t,content_3539_4604:()=>s$t,content_3539_4606:()=>i$t,content_3539_4608:()=>l$t,content_3539_4610:()=>m$t,content_3539_4612:()=>h$t,content_3539_4614:()=>k$t,content_3539_4616:()=>M$t,content_3539_4618:()=>w$t,content_3539_462:()=>_S,content_3539_4620:()=>X$t,content_3539_4622:()=>T$t,content_3539_4624:()=>C$t,content_3539_4626:()=>L$t,content_3539_4628:()=>b$t,content_3539_4630:()=>z$t,content_3539_4632:()=>W$t,content_3539_4634:()=>I$t,content_3539_4636:()=>S$t,content_3539_4638:()=>B$t,content_3539_464:()=>gS,content_3539_4640:()=>O$t,content_3539_4642:()=>F$t,content_3539_4644:()=>V$t,content_3539_4646:()=>H$t,content_3539_4648:()=>Y$t,content_3539_4650:()=>K$t,content_3539_4652:()=>tKt,content_3539_4654:()=>nKt,content_3539_4656:()=>pKt,content_3539_4658:()=>sKt,content_3539_466:()=>xS,content_3539_4660:()=>iKt,content_3539_4662:()=>lKt,content_3539_4664:()=>mKt,content_3539_4666:()=>hKt,content_3539_4668:()=>kKt,content_3539_4670:()=>MKt,content_3539_4672:()=>wKt,content_3539_4674:()=>XKt,content_3539_4676:()=>TKt,content_3539_4678:()=>CKt,content_3539_468:()=>vS,content_3539_4680:()=>LKt,content_3539_4682:()=>bKt,content_3539_4684:()=>zKt,content_3539_4686:()=>WKt,content_3539_4688:()=>IKt,content_3539_4690:()=>SKt,content_3539_4692:()=>BKt,content_3539_4694:()=>OKt,content_3539_4696:()=>FKt,content_3539_4698:()=>VKt,content_3539_470:()=>ZS,content_3539_4700:()=>HKt,content_3539_4702:()=>YKt,content_3539_4704:()=>KKt,content_3539_4706:()=>tJt,content_3539_4708:()=>nJt,content_3539_4710:()=>pJt,content_3539_4712:()=>sJt,content_3539_4714:()=>iJt,content_3539_4716:()=>lJt,content_3539_4718:()=>mJt,content_3539_472:()=>NS,content_3539_4720:()=>hJt,content_3539_4722:()=>kJt,content_3539_4724:()=>MJt,content_3539_4726:()=>wJt,content_3539_4728:()=>XJt,content_3539_4730:()=>TJt,content_3539_4732:()=>CJt,content_3539_4734:()=>LJt,content_3539_4736:()=>bJt,content_3539_4738:()=>zJt,content_3539_474:()=>AS,content_3539_4740:()=>WJt,content_3539_4742:()=>IJt,content_3539_4744:()=>SJt,content_3539_4746:()=>BJt,content_3539_4748:()=>OJt,content_3539_4750:()=>FJt,content_3539_4752:()=>VJt,content_3539_4754:()=>HJt,content_3539_4756:()=>YJt,content_3539_4758:()=>KJt,content_3539_476:()=>RS,content_3539_4760:()=>t0t,content_3539_4762:()=>n0t,content_3539_4764:()=>p0t,content_3539_4766:()=>s0t,content_3539_4768:()=>i0t,content_3539_4770:()=>l0t,content_3539_4772:()=>m0t,content_3539_4774:()=>h0t,content_3539_4776:()=>k0t,content_3539_4778:()=>M0t,content_3539_478:()=>PS,content_3539_4780:()=>w0t,content_3539_4782:()=>X0t,content_3539_4784:()=>T0t,content_3539_4786:()=>C0t,content_3539_4788:()=>L0t,content_3539_4790:()=>b0t,content_3539_4792:()=>z0t,content_3539_4794:()=>W0t,content_3539_4796:()=>I0t,content_3539_4798:()=>S0t,content_3539_48:()=>Eb,content_3539_480:()=>ES,content_3539_4800:()=>B0t,content_3539_4802:()=>O0t,content_3539_4804:()=>F0t,content_3539_4806:()=>V0t,content_3539_4808:()=>H0t,content_3539_4810:()=>Y0t,content_3539_4812:()=>K0t,content_3539_4814:()=>t3t,content_3539_4816:()=>n3t,content_3539_4818:()=>p3t,content_3539_482:()=>GS,content_3539_4820:()=>s3t,content_3539_4822:()=>i3t,content_3539_4824:()=>l3t,content_3539_4826:()=>m3t,content_3539_4828:()=>h3t,content_3539_4830:()=>k3t,content_3539_4832:()=>M3t,content_3539_4834:()=>w3t,content_3539_4836:()=>X3t,content_3539_4838:()=>T3t,content_3539_484:()=>US,content_3539_4840:()=>C3t,content_3539_4842:()=>L3t,content_3539_4844:()=>b3t,content_3539_4846:()=>z3t,content_3539_4848:()=>W3t,content_3539_4850:()=>I3t,content_3539_4852:()=>S3t,content_3539_4854:()=>B3t,content_3539_4856:()=>O3t,content_3539_4858:()=>F3t,content_3539_486:()=>qS,content_3539_4860:()=>V3t,content_3539_4862:()=>H3t,content_3539_4864:()=>Y3t,content_3539_4866:()=>K3t,content_3539_4868:()=>t5t,content_3539_4870:()=>n5t,content_3539_4872:()=>p5t,content_3539_4874:()=>s5t,content_3539_4876:()=>i5t,content_3539_4878:()=>l5t,content_3539_488:()=>jS,content_3539_4880:()=>m5t,content_3539_4882:()=>h5t,content_3539_4884:()=>k5t,content_3539_4886:()=>M5t,content_3539_4888:()=>w5t,content_3539_4890:()=>X5t,content_3539_4892:()=>T5t,content_3539_4894:()=>C5t,content_3539_4896:()=>L5t,content_3539_4898:()=>b5t,content_3539_490:()=>QS,content_3539_4900:()=>z5t,content_3539_4902:()=>W5t,content_3539_4904:()=>I5t,content_3539_4906:()=>S5t,content_3539_4908:()=>B5t,content_3539_4910:()=>O5t,content_3539_4912:()=>F5t,content_3539_4914:()=>V5t,content_3539_4916:()=>H5t,content_3539_4918:()=>Y5t,content_3539_492:()=>$S,content_3539_4920:()=>K5t,content_3539_4922:()=>t9t,content_3539_4924:()=>n9t,content_3539_4926:()=>p9t,content_3539_4928:()=>s9t,content_3539_4930:()=>i9t,content_3539_4932:()=>l9t,content_3539_4934:()=>m9t,content_3539_4936:()=>h9t,content_3539_4938:()=>k9t,content_3539_494:()=>JS,content_3539_4940:()=>M9t,content_3539_4942:()=>w9t,content_3539_4944:()=>X9t,content_3539_4946:()=>T9t,content_3539_4948:()=>C9t,content_3539_4950:()=>L9t,content_3539_4952:()=>b9t,content_3539_4954:()=>z9t,content_3539_4956:()=>W9t,content_3539_4958:()=>I9t,content_3539_496:()=>eE,content_3539_4960:()=>S9t,content_3539_4962:()=>B9t,content_3539_4964:()=>O9t,content_3539_4966:()=>F9t,content_3539_4968:()=>V9t,content_3539_4970:()=>H9t,content_3539_4972:()=>Y9t,content_3539_4974:()=>K9t,content_3539_4976:()=>t2t,content_3539_4978:()=>n2t,content_3539_498:()=>oE,content_3539_4980:()=>p2t,content_3539_4982:()=>s2t,content_3539_4984:()=>i2t,content_3539_4986:()=>l2t,content_3539_4988:()=>m2t,content_3539_4990:()=>h2t,content_3539_4992:()=>k2t,content_3539_4994:()=>M2t,content_3539_4996:()=>w2t,content_3539_4998:()=>X2t,content_3539_50:()=>Gb,content_3539_500:()=>rE,content_3539_5000:()=>T2t,content_3539_5002:()=>C2t,content_3539_5004:()=>L2t,content_3539_5006:()=>b2t,content_3539_5008:()=>z2t,content_3539_5010:()=>W2t,content_3539_5012:()=>I2t,content_3539_5014:()=>S2t,content_3539_5016:()=>B2t,content_3539_5018:()=>O2t,content_3539_502:()=>cE,content_3539_5020:()=>F2t,content_3539_5022:()=>V2t,content_3539_5024:()=>H2t,content_3539_5026:()=>Y2t,content_3539_5028:()=>K2t,content_3539_5030:()=>t1t,content_3539_5032:()=>n1t,content_3539_5034:()=>p1t,content_3539_5036:()=>s1t,content_3539_5038:()=>i1t,content_3539_504:()=>aE,content_3539_5040:()=>l1t,content_3539_5042:()=>m1t,content_3539_5044:()=>h1t,content_3539_5046:()=>k1t,content_3539_5048:()=>M1t,content_3539_5050:()=>w1t,content_3539_5052:()=>X1t,content_3539_5054:()=>T1t,content_3539_5056:()=>C1t,content_3539_5058:()=>L1t,content_3539_506:()=>uE,content_3539_5060:()=>b1t,content_3539_5062:()=>z1t,content_3539_5064:()=>W1t,content_3539_5066:()=>I1t,content_3539_5068:()=>S1t,content_3539_5070:()=>B1t,content_3539_5072:()=>O1t,content_3539_5074:()=>F1t,content_3539_5076:()=>V1t,content_3539_5078:()=>H1t,content_3539_508:()=>dE,content_3539_5080:()=>Y1t,content_3539_5082:()=>K1t,content_3539_5084:()=>t4t,content_3539_5086:()=>n4t,content_3539_5088:()=>p4t,content_3539_5090:()=>s4t,content_3539_5092:()=>i4t,content_3539_5094:()=>l4t,content_3539_5096:()=>m4t,content_3539_5098:()=>h4t,content_3539_510:()=>fE,content_3539_5100:()=>k4t,content_3539_5102:()=>M4t,content_3539_5104:()=>w4t,content_3539_5106:()=>X4t,content_3539_5108:()=>T4t,content_3539_5110:()=>C4t,content_3539_5112:()=>L4t,content_3539_5114:()=>b4t,content_3539_5116:()=>z4t,content_3539_5118:()=>W4t,content_3539_512:()=>yE,content_3539_5120:()=>I4t,content_3539_5122:()=>S4t,content_3539_5124:()=>B4t,content_3539_5126:()=>O4t,content_3539_5128:()=>F4t,content_3539_5130:()=>V4t,content_3539_5132:()=>H4t,content_3539_5134:()=>Y4t,content_3539_5136:()=>K4t,content_3539_5138:()=>t6t,content_3539_514:()=>DE,content_3539_5140:()=>n6t,content_3539_5142:()=>p6t,content_3539_5144:()=>s6t,content_3539_5146:()=>i6t,content_3539_5148:()=>l6t,content_3539_5150:()=>m6t,content_3539_5152:()=>h6t,content_3539_5154:()=>k6t,content_3539_5156:()=>M6t,content_3539_5158:()=>w6t,content_3539_516:()=>_E,content_3539_5160:()=>X6t,content_3539_5162:()=>T6t,content_3539_5164:()=>C6t,content_3539_5166:()=>L6t,content_3539_5168:()=>b6t,content_3539_5170:()=>z6t,content_3539_5172:()=>W6t,content_3539_5174:()=>I6t,content_3539_5176:()=>S6t,content_3539_5178:()=>B6t,content_3539_518:()=>gE,content_3539_5180:()=>O6t,content_3539_5182:()=>F6t,content_3539_5184:()=>V6t,content_3539_5186:()=>H6t,content_3539_5188:()=>Y6t,content_3539_5190:()=>K6t,content_3539_5192:()=>t8t,content_3539_5194:()=>n8t,content_3539_5196:()=>p8t,content_3539_5198:()=>s8t,content_3539_52:()=>Ub,content_3539_520:()=>xE,content_3539_5200:()=>i8t,content_3539_5202:()=>l8t,content_3539_5204:()=>m8t,content_3539_5206:()=>h8t,content_3539_5208:()=>k8t,content_3539_5210:()=>M8t,content_3539_5212:()=>w8t,content_3539_5214:()=>X8t,content_3539_5216:()=>T8t,content_3539_5218:()=>C8t,content_3539_522:()=>vE,content_3539_5220:()=>L8t,content_3539_5222:()=>b8t,content_3539_5224:()=>z8t,content_3539_5226:()=>W8t,content_3539_5228:()=>I8t,content_3539_5230:()=>S8t,content_3539_5232:()=>B8t,content_3539_5234:()=>O8t,content_3539_5236:()=>F8t,content_3539_5238:()=>V8t,content_3539_524:()=>ZE,content_3539_5240:()=>H8t,content_3539_5242:()=>Y8t,content_3539_5244:()=>K8t,content_3539_5246:()=>t7t,content_3539_5248:()=>n7t,content_3539_5250:()=>p7t,content_3539_5252:()=>s7t,content_3539_5254:()=>i7t,content_3539_5256:()=>l7t,content_3539_5258:()=>m7t,content_3539_526:()=>NE,content_3539_5260:()=>h7t,content_3539_5262:()=>k7t,content_3539_5264:()=>M7t,content_3539_5266:()=>w7t,content_3539_5268:()=>X7t,content_3539_5270:()=>T7t,content_3539_5272:()=>C7t,content_3539_5274:()=>L7t,content_3539_5276:()=>b7t,content_3539_5278:()=>z7t,content_3539_528:()=>AE,content_3539_5280:()=>W7t,content_3539_5282:()=>I7t,content_3539_5284:()=>S7t,content_3539_5286:()=>B7t,content_3539_5288:()=>O7t,content_3539_5290:()=>F7t,content_3539_5292:()=>V7t,content_3539_5294:()=>H7t,content_3539_5296:()=>Y7t,content_3539_5298:()=>K7t,content_3539_530:()=>RE,content_3539_5300:()=>tte,content_3539_5302:()=>nte,content_3539_5304:()=>pte,content_3539_5306:()=>ste,content_3539_5308:()=>ite,content_3539_5310:()=>lte,content_3539_5312:()=>mte,content_3539_5314:()=>hte,content_3539_5316:()=>kte,content_3539_5318:()=>Mte,content_3539_532:()=>PE,content_3539_5320:()=>wte,content_3539_5322:()=>Xte,content_3539_5324:()=>Tte,content_3539_5326:()=>Cte,content_3539_5328:()=>Lte,content_3539_5330:()=>bte,content_3539_5332:()=>zte,content_3539_5334:()=>Wte,content_3539_5336:()=>Ite,content_3539_5338:()=>Ste,content_3539_534:()=>EE,content_3539_5340:()=>Bte,content_3539_5342:()=>Ote,content_3539_5344:()=>Fte,content_3539_5346:()=>Vte,content_3539_5348:()=>Hte,content_3539_5350:()=>Yte,content_3539_5352:()=>Kte,content_3539_5354:()=>tee,content_3539_5356:()=>nee,content_3539_5358:()=>pee,content_3539_536:()=>GE,content_3539_5360:()=>see,content_3539_5362:()=>iee,content_3539_5364:()=>lee,content_3539_5366:()=>mee,content_3539_5368:()=>hee,content_3539_5370:()=>kee,content_3539_5372:()=>Mee,content_3539_5374:()=>wee,content_3539_5376:()=>Xee,content_3539_5378:()=>Tee,content_3539_538:()=>UE,content_3539_5380:()=>Cee,content_3539_5382:()=>Lee,content_3539_5384:()=>bee,content_3539_5386:()=>zee,content_3539_5388:()=>Wee,content_3539_5390:()=>Iee,content_3539_5392:()=>See,content_3539_5394:()=>Bee,content_3539_5396:()=>Oee,content_3539_5398:()=>Fee,content_3539_54:()=>qb,content_3539_540:()=>qE,content_3539_5400:()=>Vee,content_3539_5402:()=>Hee,content_3539_5404:()=>Yee,content_3539_5406:()=>Kee,content_3539_5408:()=>tne,content_3539_5410:()=>nne,content_3539_5412:()=>pne,content_3539_5414:()=>sne,content_3539_5416:()=>ine,content_3539_5418:()=>lne,content_3539_542:()=>jE,content_3539_5420:()=>mne,content_3539_5422:()=>hne,content_3539_5424:()=>kne,content_3539_5426:()=>Mne,content_3539_5428:()=>wne,content_3539_5430:()=>Xne,content_3539_5432:()=>Tne,content_3539_5434:()=>Cne,content_3539_5436:()=>Lne,content_3539_5438:()=>bne,content_3539_544:()=>QE,content_3539_5440:()=>zne,content_3539_5442:()=>Wne,content_3539_5444:()=>Ine,content_3539_5446:()=>Sne,content_3539_5448:()=>Bne,content_3539_5450:()=>One,content_3539_5452:()=>Fne,content_3539_5454:()=>Vne,content_3539_5456:()=>Hne,content_3539_5458:()=>Yne,content_3539_546:()=>$E,content_3539_5460:()=>Kne,content_3539_5462:()=>toe,content_3539_5464:()=>noe,content_3539_5466:()=>poe,content_3539_5468:()=>soe,content_3539_5470:()=>ioe,content_3539_5472:()=>loe,content_3539_5474:()=>moe,content_3539_5476:()=>hoe,content_3539_5478:()=>koe,content_3539_548:()=>JE,content_3539_5480:()=>Moe,content_3539_5482:()=>woe,content_3539_5484:()=>Xoe,content_3539_5486:()=>Toe,content_3539_5488:()=>Coe,content_3539_5490:()=>Loe,content_3539_5492:()=>boe,content_3539_5494:()=>zoe,content_3539_5496:()=>Woe,content_3539_5498:()=>Ioe,content_3539_550:()=>eB,content_3539_5500:()=>Soe,content_3539_5502:()=>Boe,content_3539_5504:()=>Ooe,content_3539_5506:()=>Foe,content_3539_5508:()=>Voe,content_3539_5510:()=>Hoe,content_3539_5512:()=>Yoe,content_3539_5514:()=>Koe,content_3539_5516:()=>tpe,content_3539_5518:()=>npe,content_3539_552:()=>oB,content_3539_5520:()=>ppe,content_3539_5522:()=>spe,content_3539_5524:()=>ipe,content_3539_5526:()=>lpe,content_3539_5528:()=>mpe,content_3539_5530:()=>hpe,content_3539_5532:()=>kpe,content_3539_5534:()=>Mpe,content_3539_5536:()=>wpe,content_3539_5538:()=>Xpe,content_3539_554:()=>rB,content_3539_5540:()=>Tpe,content_3539_5542:()=>Cpe,content_3539_5544:()=>Lpe,content_3539_5546:()=>bpe,content_3539_5548:()=>zpe,content_3539_5550:()=>Wpe,content_3539_5552:()=>Ipe,content_3539_5554:()=>Spe,content_3539_5556:()=>Bpe,content_3539_5558:()=>Ope,content_3539_556:()=>cB,content_3539_5560:()=>Fpe,content_3539_5562:()=>Vpe,content_3539_5564:()=>Hpe,content_3539_5566:()=>Ype,content_3539_5568:()=>Kpe,content_3539_5570:()=>tre,content_3539_5572:()=>nre,content_3539_5574:()=>pre,content_3539_5576:()=>sre,content_3539_5578:()=>ire,content_3539_558:()=>aB,content_3539_5580:()=>lre,content_3539_5582:()=>mre,content_3539_5584:()=>hre,content_3539_5586:()=>kre,content_3539_5588:()=>Mre,content_3539_5590:()=>wre,content_3539_5592:()=>Xre,content_3539_5594:()=>Tre,content_3539_5596:()=>Cre,content_3539_5598:()=>Lre,content_3539_56:()=>jb,content_3539_560:()=>uB,content_3539_5600:()=>bre,content_3539_5602:()=>zre,content_3539_5604:()=>Wre,content_3539_5606:()=>Ire,content_3539_5608:()=>Sre,content_3539_5610:()=>Bre,content_3539_5612:()=>Ore,content_3539_5614:()=>Fre,content_3539_5616:()=>Vre,content_3539_5618:()=>Hre,content_3539_562:()=>dB,content_3539_5620:()=>Yre,content_3539_5622:()=>Kre,content_3539_5624:()=>tse,content_3539_5626:()=>nse,content_3539_5628:()=>pse,content_3539_5630:()=>sse,content_3539_5632:()=>ise,content_3539_5634:()=>lse,content_3539_5636:()=>mse,content_3539_5638:()=>hse,content_3539_564:()=>fB,content_3539_5640:()=>kse,content_3539_5642:()=>Mse,content_3539_5644:()=>wse,content_3539_5646:()=>Xse,content_3539_5648:()=>Tse,content_3539_5650:()=>Cse,content_3539_5652:()=>Lse,content_3539_5654:()=>bse,content_3539_5656:()=>zse,content_3539_5658:()=>Wse,content_3539_566:()=>yB,content_3539_5660:()=>Ise,content_3539_5662:()=>Sse,content_3539_5664:()=>Bse,content_3539_5666:()=>Ose,content_3539_5668:()=>Fse,content_3539_5670:()=>Vse,content_3539_5672:()=>Hse,content_3539_5674:()=>Yse,content_3539_5676:()=>Kse,content_3539_5678:()=>tce,content_3539_568:()=>DB,content_3539_5680:()=>nce,content_3539_5682:()=>pce,content_3539_5684:()=>sce,content_3539_5686:()=>ice,content_3539_5688:()=>lce,content_3539_5690:()=>mce,content_3539_5692:()=>hce,content_3539_5694:()=>kce,content_3539_5696:()=>Mce,content_3539_5698:()=>wce,content_3539_570:()=>_B,content_3539_5700:()=>Xce,content_3539_5702:()=>Tce,content_3539_5704:()=>Cce,content_3539_5706:()=>Lce,content_3539_5708:()=>bce,content_3539_5710:()=>zce,content_3539_5712:()=>Wce,content_3539_5714:()=>Ice,content_3539_5716:()=>Sce,content_3539_5718:()=>Bce,content_3539_572:()=>gB,content_3539_5720:()=>Oce,content_3539_5722:()=>Fce,content_3539_5724:()=>Vce,content_3539_5726:()=>Hce,content_3539_5728:()=>Yce,content_3539_5730:()=>Kce,content_3539_5732:()=>tie,content_3539_5734:()=>nie,content_3539_5736:()=>pie,content_3539_5738:()=>sie,content_3539_574:()=>xB,content_3539_5740:()=>iie,content_3539_5742:()=>lie,content_3539_5744:()=>mie,content_3539_5746:()=>hie,content_3539_5748:()=>kie,content_3539_5750:()=>Mie,content_3539_5752:()=>wie,content_3539_5754:()=>Xie,content_3539_5756:()=>Tie,content_3539_5758:()=>Cie,content_3539_576:()=>vB,content_3539_5760:()=>Lie,content_3539_5762:()=>bie,content_3539_5764:()=>zie,content_3539_5766:()=>Wie,content_3539_5768:()=>Iie,content_3539_5770:()=>Sie,content_3539_5772:()=>Bie,content_3539_5774:()=>Oie,content_3539_5776:()=>Fie,content_3539_5778:()=>Vie,content_3539_578:()=>ZB,content_3539_5780:()=>Hie,content_3539_5782:()=>Yie,content_3539_5784:()=>Kie,content_3539_5786:()=>tae,content_3539_5788:()=>nae,content_3539_5790:()=>pae,content_3539_5792:()=>sae,content_3539_5794:()=>iae,content_3539_5796:()=>lae,content_3539_5798:()=>mae,content_3539_58:()=>Qb,content_3539_580:()=>NB,content_3539_5800:()=>hae,content_3539_5802:()=>kae,content_3539_5804:()=>Mae,content_3539_5806:()=>wae,content_3539_5808:()=>Xae,content_3539_5810:()=>Tae,content_3539_5812:()=>Cae,content_3539_5814:()=>Lae,content_3539_5816:()=>bae,content_3539_5818:()=>zae,content_3539_582:()=>AB,content_3539_5820:()=>Wae,content_3539_5822:()=>Iae,content_3539_5824:()=>Sae,content_3539_5826:()=>Bae,content_3539_5828:()=>Oae,content_3539_5830:()=>Fae,content_3539_5832:()=>Vae,content_3539_5834:()=>Hae,content_3539_5836:()=>Yae,content_3539_5838:()=>Kae,content_3539_584:()=>RB,content_3539_5840:()=>tle,content_3539_5842:()=>nle,content_3539_5844:()=>ple,content_3539_5846:()=>sle,content_3539_5848:()=>ile,content_3539_5850:()=>lle,content_3539_5852:()=>mle,content_3539_5854:()=>hle,content_3539_5856:()=>kle,content_3539_5858:()=>Mle,content_3539_586:()=>PB,content_3539_5860:()=>wle,content_3539_5862:()=>Xle,content_3539_5864:()=>Tle,content_3539_5866:()=>Cle,content_3539_5868:()=>Lle,content_3539_5870:()=>ble,content_3539_5872:()=>zle,content_3539_5874:()=>Wle,content_3539_5876:()=>Ile,content_3539_5878:()=>Sle,content_3539_588:()=>EB,content_3539_5880:()=>Ble,content_3539_5882:()=>Ole,content_3539_5884:()=>Fle,content_3539_5886:()=>Vle,content_3539_5888:()=>Hle,content_3539_5890:()=>Yle,content_3539_5892:()=>Kle,content_3539_5894:()=>tue,content_3539_5896:()=>nue,content_3539_5898:()=>pue,content_3539_590:()=>GB,content_3539_5900:()=>sue,content_3539_5902:()=>iue,content_3539_5904:()=>lue,content_3539_5906:()=>mue,content_3539_5908:()=>hue,content_3539_5910:()=>kue,content_3539_5912:()=>Mue,content_3539_5914:()=>wue,content_3539_5916:()=>Xue,content_3539_5918:()=>Tue,content_3539_592:()=>UB,content_3539_5920:()=>Cue,content_3539_5922:()=>Lue,content_3539_5924:()=>bue,content_3539_5926:()=>zue,content_3539_5928:()=>Wue,content_3539_5930:()=>Iue,content_3539_5932:()=>Sue,content_3539_5934:()=>Bue,content_3539_5936:()=>Oue,content_3539_5938:()=>Fue,content_3539_594:()=>qB,content_3539_5940:()=>Vue,content_3539_5942:()=>Hue,content_3539_5944:()=>Yue,content_3539_5946:()=>Kue,content_3539_5948:()=>tme,content_3539_5950:()=>nme,content_3539_5952:()=>pme,content_3539_5954:()=>sme,content_3539_5956:()=>ime,content_3539_5958:()=>lme,content_3539_596:()=>jB,content_3539_5960:()=>mme,content_3539_5962:()=>hme,content_3539_5964:()=>kme,content_3539_5966:()=>Mme,content_3539_5968:()=>wme,content_3539_5970:()=>Xme,content_3539_5972:()=>Tme,content_3539_5974:()=>Cme,content_3539_5976:()=>Lme,content_3539_5978:()=>bme,content_3539_598:()=>QB,content_3539_5980:()=>zme,content_3539_5982:()=>Wme,content_3539_5984:()=>Ime,content_3539_5986:()=>Sme,content_3539_5988:()=>Bme,content_3539_5990:()=>Ome,content_3539_5992:()=>Fme,content_3539_5994:()=>Vme,content_3539_5996:()=>Hme,content_3539_5998:()=>Yme,content_3539_6:()=>$Z,content_3539_60:()=>$b,content_3539_600:()=>$B,content_3539_6000:()=>Kme,content_3539_6002:()=>tde,content_3539_6004:()=>nde,content_3539_6006:()=>pde,content_3539_6008:()=>sde,content_3539_6010:()=>ide,content_3539_6012:()=>lde,content_3539_6014:()=>mde,content_3539_6016:()=>hde,content_3539_6018:()=>kde,content_3539_602:()=>JB,content_3539_6020:()=>Mde,content_3539_6022:()=>wde,content_3539_6024:()=>Xde,content_3539_6026:()=>Tde,content_3539_6028:()=>Cde,content_3539_6030:()=>Lde,content_3539_6032:()=>bde,content_3539_6034:()=>zde,content_3539_6036:()=>Wde,content_3539_6038:()=>Ide,content_3539_604:()=>eG,content_3539_6040:()=>Sde,content_3539_6042:()=>Bde,content_3539_6044:()=>Ode,content_3539_6046:()=>Fde,content_3539_6048:()=>Vde,content_3539_6050:()=>Hde,content_3539_6052:()=>Yde,content_3539_6054:()=>Kde,content_3539_6056:()=>the,content_3539_6058:()=>nhe,content_3539_606:()=>oG,content_3539_6060:()=>phe,content_3539_6062:()=>she,content_3539_6064:()=>ihe,content_3539_6066:()=>lhe,content_3539_6068:()=>mhe,content_3539_6070:()=>hhe,content_3539_6072:()=>khe,content_3539_6074:()=>Mhe,content_3539_6076:()=>whe,content_3539_6078:()=>Xhe,content_3539_608:()=>rG,content_3539_6080:()=>The,content_3539_6082:()=>Che,content_3539_6084:()=>Lhe,content_3539_6086:()=>bhe,content_3539_6088:()=>zhe,content_3539_6090:()=>Whe,content_3539_6092:()=>Ihe,content_3539_6094:()=>She,content_3539_6096:()=>Bhe,content_3539_6098:()=>Ohe,content_3539_610:()=>cG,content_3539_6100:()=>Fhe,content_3539_6102:()=>Vhe,content_3539_6104:()=>Hhe,content_3539_6106:()=>Yhe,content_3539_6108:()=>Khe,content_3539_6110:()=>tfe,content_3539_6112:()=>nfe,content_3539_6114:()=>pfe,content_3539_6116:()=>sfe,content_3539_6118:()=>ife,content_3539_612:()=>aG,content_3539_6120:()=>lfe,content_3539_6122:()=>mfe,content_3539_6124:()=>hfe,content_3539_6126:()=>kfe,content_3539_6128:()=>Mfe,content_3539_6130:()=>wfe,content_3539_6132:()=>Xfe,content_3539_6134:()=>Tfe,content_3539_6136:()=>Cfe,content_3539_6138:()=>Lfe,content_3539_614:()=>uG,content_3539_6140:()=>bfe,content_3539_6142:()=>zfe,content_3539_6144:()=>Wfe,content_3539_6146:()=>Ife,content_3539_6148:()=>Sfe,content_3539_6150:()=>Bfe,content_3539_6152:()=>Ofe,content_3539_6154:()=>Ffe,content_3539_6156:()=>Vfe,content_3539_6158:()=>Hfe,content_3539_616:()=>dG,content_3539_6160:()=>Yfe,content_3539_6162:()=>Kfe,content_3539_6164:()=>tke,content_3539_6166:()=>nke,content_3539_6168:()=>pke,content_3539_6170:()=>ske,content_3539_6172:()=>ike,content_3539_6174:()=>lke,content_3539_6176:()=>mke,content_3539_6178:()=>hke,content_3539_618:()=>fG,content_3539_6180:()=>kke,content_3539_6182:()=>Mke,content_3539_6184:()=>wke,content_3539_6186:()=>Xke,content_3539_6188:()=>Tke,content_3539_6190:()=>Cke,content_3539_6192:()=>Lke,content_3539_6194:()=>bke,content_3539_6196:()=>zke,content_3539_6198:()=>Wke,content_3539_62:()=>Jb,content_3539_620:()=>yG,content_3539_6200:()=>Ike,content_3539_6202:()=>Ske,content_3539_6204:()=>Bke,content_3539_6206:()=>Oke,content_3539_6208:()=>Fke,content_3539_6210:()=>Vke,content_3539_6212:()=>Hke,content_3539_6214:()=>Yke,content_3539_6216:()=>Kke,content_3539_6218:()=>tye,content_3539_622:()=>DG,content_3539_6220:()=>nye,content_3539_6222:()=>pye,content_3539_6224:()=>sye,content_3539_6226:()=>iye,content_3539_6228:()=>lye,content_3539_6230:()=>mye,content_3539_6232:()=>hye,content_3539_6234:()=>kye,content_3539_6236:()=>Mye,content_3539_6238:()=>wye,content_3539_624:()=>_G,content_3539_6240:()=>Xye,content_3539_6242:()=>Tye,content_3539_6244:()=>Cye,content_3539_6246:()=>Lye,content_3539_6248:()=>bye,content_3539_6250:()=>zye,content_3539_6252:()=>Wye,content_3539_6254:()=>Iye,content_3539_6256:()=>Sye,content_3539_6258:()=>Bye,content_3539_626:()=>gG,content_3539_6260:()=>Oye,content_3539_6262:()=>Fye,content_3539_6264:()=>Vye,content_3539_6266:()=>Hye,content_3539_6268:()=>Yye,content_3539_6270:()=>Kye,content_3539_6272:()=>tMe,content_3539_6274:()=>nMe,content_3539_6276:()=>pMe,content_3539_6278:()=>sMe,content_3539_628:()=>xG,content_3539_6280:()=>iMe,content_3539_6282:()=>lMe,content_3539_6284:()=>mMe,content_3539_6286:()=>hMe,content_3539_6288:()=>kMe,content_3539_6290:()=>MMe,content_3539_6292:()=>wMe,content_3539_6294:()=>XMe,content_3539_6296:()=>TMe,content_3539_6298:()=>CMe,content_3539_630:()=>vG,content_3539_6300:()=>LMe,content_3539_6302:()=>bMe,content_3539_6304:()=>zMe,content_3539_6306:()=>WMe,content_3539_6308:()=>IMe,content_3539_6310:()=>SMe,content_3539_6312:()=>BMe,content_3539_6314:()=>OMe,content_3539_6316:()=>FMe,content_3539_6318:()=>VMe,content_3539_632:()=>ZG,content_3539_6320:()=>HMe,content_3539_6322:()=>YMe,content_3539_6324:()=>KMe,content_3539_6326:()=>tDe,content_3539_6328:()=>nDe,content_3539_6330:()=>pDe,content_3539_6332:()=>sDe,content_3539_6334:()=>iDe,content_3539_6336:()=>lDe,content_3539_6338:()=>mDe,content_3539_634:()=>NG,content_3539_6340:()=>hDe,content_3539_6342:()=>kDe,content_3539_6344:()=>MDe,content_3539_6346:()=>wDe,content_3539_6348:()=>XDe,content_3539_6350:()=>TDe,content_3539_6352:()=>CDe,content_3539_6354:()=>LDe,content_3539_6356:()=>bDe,content_3539_6358:()=>zDe,content_3539_636:()=>AG,content_3539_6360:()=>WDe,content_3539_6362:()=>IDe,content_3539_6364:()=>SDe,content_3539_6366:()=>BDe,content_3539_6368:()=>ODe,content_3539_6370:()=>FDe,content_3539_6372:()=>VDe,content_3539_6374:()=>HDe,content_3539_6376:()=>YDe,content_3539_6378:()=>KDe,content_3539_638:()=>RG,content_3539_6380:()=>twe,content_3539_6382:()=>nwe,content_3539_6384:()=>pwe,content_3539_6386:()=>swe,content_3539_6388:()=>iwe,content_3539_6390:()=>lwe,content_3539_6392:()=>mwe,content_3539_6394:()=>hwe,content_3539_6396:()=>kwe,content_3539_6398:()=>Mwe,content_3539_64:()=>eN,content_3539_640:()=>PG,content_3539_6400:()=>wwe,content_3539_6402:()=>Xwe,content_3539_6404:()=>Twe,content_3539_6406:()=>Cwe,content_3539_6408:()=>Lwe,content_3539_6410:()=>bwe,content_3539_6412:()=>zwe,content_3539_6414:()=>Wwe,content_3539_6416:()=>Iwe,content_3539_6418:()=>Swe,content_3539_642:()=>EG,content_3539_6420:()=>Bwe,content_3539_6422:()=>Owe,content_3539_6424:()=>Fwe,content_3539_6426:()=>Vwe,content_3539_6428:()=>Hwe,content_3539_6430:()=>Ywe,content_3539_6432:()=>Kwe,content_3539_6434:()=>t_e,content_3539_6436:()=>n_e,content_3539_6438:()=>p_e,content_3539_644:()=>GG,content_3539_6440:()=>s_e,content_3539_6442:()=>i_e,content_3539_6444:()=>l_e,content_3539_6446:()=>m_e,content_3539_6448:()=>h_e,content_3539_6450:()=>k_e,content_3539_6452:()=>M_e,content_3539_6454:()=>w_e,content_3539_6456:()=>X_e,content_3539_6458:()=>T_e,content_3539_646:()=>UG,content_3539_6460:()=>C_e,content_3539_6462:()=>L_e,content_3539_6464:()=>b_e,content_3539_6466:()=>z_e,content_3539_6468:()=>W_e,content_3539_6470:()=>I_e,content_3539_6472:()=>S_e,content_3539_6474:()=>B_e,content_3539_6476:()=>O_e,content_3539_6478:()=>F_e,content_3539_648:()=>qG,content_3539_6480:()=>V_e,content_3539_6482:()=>H_e,content_3539_6484:()=>Y_e,content_3539_6486:()=>K_e,content_3539_6488:()=>tXe,content_3539_6490:()=>nXe,content_3539_6492:()=>pXe,content_3539_6494:()=>sXe,content_3539_6496:()=>iXe,content_3539_6498:()=>lXe,content_3539_650:()=>jG,content_3539_6500:()=>mXe,content_3539_6502:()=>hXe,content_3539_6504:()=>kXe,content_3539_6506:()=>MXe,content_3539_6508:()=>wXe,content_3539_6510:()=>XXe,content_3539_6512:()=>TXe,content_3539_6514:()=>CXe,content_3539_6516:()=>LXe,content_3539_6518:()=>bXe,content_3539_652:()=>QG,content_3539_6520:()=>zXe,content_3539_6522:()=>WXe,content_3539_6524:()=>IXe,content_3539_6526:()=>SXe,content_3539_6528:()=>BXe,content_3539_6530:()=>OXe,content_3539_6532:()=>FXe,content_3539_6534:()=>VXe,content_3539_6536:()=>HXe,content_3539_6538:()=>YXe,content_3539_654:()=>$G,content_3539_6540:()=>KXe,content_3539_6542:()=>tge,content_3539_6544:()=>nge,content_3539_6546:()=>pge,content_3539_6548:()=>sge,content_3539_6550:()=>ige,content_3539_6552:()=>lge,content_3539_6554:()=>mge,content_3539_6556:()=>hge,content_3539_6558:()=>kge,content_3539_656:()=>JG,content_3539_6560:()=>Mge,content_3539_6562:()=>wge,content_3539_6564:()=>Xge,content_3539_6566:()=>Tge,content_3539_6568:()=>Cge,content_3539_6570:()=>Lge,content_3539_6572:()=>bge,content_3539_6574:()=>zge,content_3539_6576:()=>Wge,content_3539_6578:()=>Ige,content_3539_658:()=>eO,content_3539_6580:()=>Sge,content_3539_6582:()=>Bge,content_3539_6584:()=>Oge,content_3539_6586:()=>Fge,content_3539_6588:()=>Vge,content_3539_6590:()=>Hge,content_3539_6592:()=>Yge,content_3539_6594:()=>Kge,content_3539_6596:()=>tTe,content_3539_6598:()=>nTe,content_3539_66:()=>oN,content_3539_660:()=>oO,content_3539_6600:()=>pTe,content_3539_6602:()=>sTe,content_3539_6604:()=>iTe,content_3539_6606:()=>lTe,content_3539_6608:()=>mTe,content_3539_6610:()=>hTe,content_3539_6612:()=>kTe,content_3539_6614:()=>MTe,content_3539_6616:()=>wTe,content_3539_6618:()=>XTe,content_3539_662:()=>rO,content_3539_6620:()=>TTe,content_3539_6622:()=>CTe,content_3539_6624:()=>LTe,content_3539_6626:()=>bTe,content_3539_6628:()=>zTe,content_3539_6630:()=>WTe,content_3539_6632:()=>ITe,content_3539_6634:()=>STe,content_3539_6636:()=>BTe,content_3539_6638:()=>OTe,content_3539_664:()=>cO,content_3539_6640:()=>FTe,content_3539_6642:()=>VTe,content_3539_6644:()=>HTe,content_3539_6646:()=>YTe,content_3539_6648:()=>KTe,content_3539_6650:()=>txe,content_3539_6652:()=>nxe,content_3539_6654:()=>pxe,content_3539_6656:()=>sxe,content_3539_6658:()=>ixe,content_3539_666:()=>aO,content_3539_6660:()=>lxe,content_3539_6662:()=>mxe,content_3539_6664:()=>hxe,content_3539_6666:()=>kxe,content_3539_6668:()=>Mxe,content_3539_6670:()=>wxe,content_3539_6672:()=>Xxe,content_3539_6674:()=>Txe,content_3539_6676:()=>Cxe,content_3539_6678:()=>Lxe,content_3539_668:()=>uO,content_3539_6680:()=>bxe,content_3539_6682:()=>zxe,content_3539_6684:()=>Wxe,content_3539_6686:()=>Ixe,content_3539_6688:()=>Sxe,content_3539_6690:()=>Bxe,content_3539_6692:()=>Oxe,content_3539_6694:()=>Fxe,content_3539_6696:()=>Vxe,content_3539_6698:()=>Hxe,content_3539_670:()=>dO,content_3539_6700:()=>Yxe,content_3539_6702:()=>Kxe,content_3539_6704:()=>tCe,content_3539_6706:()=>nCe,content_3539_6708:()=>pCe,content_3539_6710:()=>sCe,content_3539_6712:()=>iCe,content_3539_6714:()=>lCe,content_3539_6716:()=>mCe,content_3539_6718:()=>hCe,content_3539_672:()=>fO,content_3539_6720:()=>kCe,content_3539_6722:()=>MCe,content_3539_6724:()=>wCe,content_3539_6726:()=>XCe,content_3539_6728:()=>TCe,content_3539_6730:()=>CCe,content_3539_6732:()=>LCe,content_3539_6734:()=>bCe,content_3539_6736:()=>zCe,content_3539_6738:()=>WCe,content_3539_674:()=>yO,content_3539_6740:()=>ICe,content_3539_6742:()=>SCe,content_3539_6744:()=>BCe,content_3539_6746:()=>OCe,content_3539_6748:()=>FCe,content_3539_6750:()=>VCe,content_3539_6752:()=>HCe,content_3539_6754:()=>YCe,content_3539_6756:()=>KCe,content_3539_6758:()=>tve,content_3539_676:()=>DO,content_3539_6760:()=>nve,content_3539_6762:()=>pve,content_3539_6764:()=>sve,content_3539_6766:()=>ive,content_3539_6768:()=>lve,content_3539_6770:()=>mve,content_3539_6772:()=>hve,content_3539_6774:()=>kve,content_3539_6776:()=>Mve,content_3539_6778:()=>wve,content_3539_678:()=>_O,content_3539_6780:()=>Xve,content_3539_6782:()=>Tve,content_3539_6784:()=>Cve,content_3539_6786:()=>Lve,content_3539_6788:()=>bve,content_3539_6790:()=>zve,content_3539_6792:()=>Wve,content_3539_6794:()=>Ive,content_3539_6796:()=>Sve,content_3539_6798:()=>Bve,content_3539_68:()=>rN,content_3539_680:()=>gO,content_3539_6800:()=>Ove,content_3539_6802:()=>Fve,content_3539_6804:()=>Vve,content_3539_6806:()=>Hve,content_3539_6808:()=>Yve,content_3539_6810:()=>Kve,content_3539_6812:()=>tLe,content_3539_6814:()=>nLe,content_3539_6816:()=>pLe,content_3539_6818:()=>sLe,content_3539_682:()=>xO,content_3539_6820:()=>iLe,content_3539_6822:()=>lLe,content_3539_6824:()=>mLe,content_3539_6826:()=>hLe,content_3539_6828:()=>kLe,content_3539_6830:()=>MLe,content_3539_6832:()=>wLe,content_3539_6834:()=>XLe,content_3539_6836:()=>TLe,content_3539_6838:()=>CLe,content_3539_684:()=>vO,content_3539_6840:()=>LLe,content_3539_6842:()=>bLe,content_3539_6844:()=>zLe,content_3539_6846:()=>WLe,content_3539_6848:()=>ILe,content_3539_6850:()=>SLe,content_3539_6852:()=>BLe,content_3539_6854:()=>OLe,content_3539_6856:()=>FLe,content_3539_6858:()=>VLe,content_3539_686:()=>ZO,content_3539_6860:()=>HLe,content_3539_6862:()=>YLe,content_3539_6864:()=>KLe,content_3539_6866:()=>tZe,content_3539_6868:()=>nZe,content_3539_6870:()=>pZe,content_3539_6872:()=>sZe,content_3539_6874:()=>iZe,content_3539_6876:()=>lZe,content_3539_6878:()=>mZe,content_3539_688:()=>NO,content_3539_6880:()=>hZe,content_3539_6882:()=>kZe,content_3539_6884:()=>MZe,content_3539_6886:()=>wZe,content_3539_6888:()=>XZe,content_3539_6890:()=>TZe,content_3539_6892:()=>CZe,content_3539_6894:()=>LZe,content_3539_6896:()=>bZe,content_3539_6898:()=>zZe,content_3539_690:()=>AO,content_3539_6900:()=>WZe,content_3539_6902:()=>IZe,content_3539_6904:()=>SZe,content_3539_6906:()=>BZe,content_3539_6908:()=>OZe,content_3539_6910:()=>FZe,content_3539_6912:()=>VZe,content_3539_6914:()=>HZe,content_3539_6916:()=>YZe,content_3539_6918:()=>KZe,content_3539_692:()=>RO,content_3539_6920:()=>tbe,content_3539_6922:()=>nbe,content_3539_6924:()=>pbe,content_3539_6926:()=>sbe,content_3539_6928:()=>ibe,content_3539_6930:()=>lbe,content_3539_6932:()=>mbe,content_3539_6934:()=>hbe,content_3539_6936:()=>kbe,content_3539_6938:()=>Mbe,content_3539_694:()=>PO,content_3539_6940:()=>wbe,content_3539_6942:()=>Xbe,content_3539_6944:()=>Tbe,content_3539_6946:()=>Cbe,content_3539_6948:()=>Lbe,content_3539_6950:()=>bbe,content_3539_6952:()=>zbe,content_3539_6954:()=>Wbe,content_3539_6956:()=>Ibe,content_3539_6958:()=>Sbe,content_3539_696:()=>EO,content_3539_6960:()=>Bbe,content_3539_6962:()=>Obe,content_3539_6964:()=>Fbe,content_3539_6966:()=>Vbe,content_3539_6968:()=>Hbe,content_3539_6970:()=>Ybe,content_3539_6972:()=>Kbe,content_3539_6974:()=>tNe,content_3539_6976:()=>nNe,content_3539_6978:()=>pNe,content_3539_698:()=>GO,content_3539_6980:()=>sNe,content_3539_6982:()=>iNe,content_3539_6984:()=>lNe,content_3539_6986:()=>mNe,content_3539_6988:()=>hNe,content_3539_6990:()=>kNe,content_3539_6992:()=>MNe,content_3539_6994:()=>wNe,content_3539_6996:()=>XNe,content_3539_6998:()=>TNe,content_3539_70:()=>cN,content_3539_700:()=>UO,content_3539_7000:()=>CNe,content_3539_7002:()=>LNe,content_3539_7004:()=>bNe,content_3539_7006:()=>zNe,content_3539_7008:()=>WNe,content_3539_7010:()=>INe,content_3539_7012:()=>SNe,content_3539_7014:()=>BNe,content_3539_7016:()=>ONe,content_3539_7018:()=>FNe,content_3539_702:()=>qO,content_3539_7020:()=>VNe,content_3539_7022:()=>HNe,content_3539_7024:()=>YNe,content_3539_7026:()=>KNe,content_3539_7028:()=>tze,content_3539_7030:()=>nze,content_3539_7032:()=>pze,content_3539_7034:()=>sze,content_3539_7036:()=>ize,content_3539_7038:()=>lze,content_3539_704:()=>jO,content_3539_7040:()=>mze,content_3539_7042:()=>hze,content_3539_7044:()=>kze,content_3539_7046:()=>Mze,content_3539_7048:()=>wze,content_3539_7050:()=>Xze,content_3539_7052:()=>Tze,content_3539_7054:()=>Cze,content_3539_7056:()=>Lze,content_3539_7058:()=>bze,content_3539_706:()=>QO,content_3539_7060:()=>zze,content_3539_7062:()=>Wze,content_3539_7064:()=>Ize,content_3539_7066:()=>Sze,content_3539_7068:()=>Bze,content_3539_7070:()=>Oze,content_3539_7072:()=>Fze,content_3539_7074:()=>Vze,content_3539_7076:()=>Hze,content_3539_7078:()=>Yze,content_3539_708:()=>$O,content_3539_7080:()=>Kze,content_3539_7082:()=>tAe,content_3539_7084:()=>nAe,content_3539_7086:()=>pAe,content_3539_7088:()=>sAe,content_3539_7090:()=>iAe,content_3539_7092:()=>lAe,content_3539_7094:()=>mAe,content_3539_7096:()=>hAe,content_3539_7098:()=>kAe,content_3539_710:()=>JO,content_3539_7100:()=>MAe,content_3539_7102:()=>wAe,content_3539_7104:()=>XAe,content_3539_7106:()=>TAe,content_3539_7108:()=>CAe,content_3539_7110:()=>LAe,content_3539_7112:()=>bAe,content_3539_7114:()=>zAe,content_3539_7116:()=>WAe,content_3539_7118:()=>IAe,content_3539_712:()=>eU,content_3539_7120:()=>SAe,content_3539_7122:()=>BAe,content_3539_7124:()=>OAe,content_3539_7126:()=>FAe,content_3539_7128:()=>VAe,content_3539_7130:()=>HAe,content_3539_7132:()=>YAe,content_3539_7134:()=>KAe,content_3539_7136:()=>tWe,content_3539_7138:()=>nWe,content_3539_714:()=>oU,content_3539_7140:()=>pWe,content_3539_7142:()=>sWe,content_3539_7144:()=>iWe,content_3539_7146:()=>lWe,content_3539_7148:()=>mWe,content_3539_7150:()=>hWe,content_3539_7152:()=>kWe,content_3539_7154:()=>MWe,content_3539_7156:()=>wWe,content_3539_7158:()=>XWe,content_3539_716:()=>rU,content_3539_7160:()=>TWe,content_3539_7162:()=>CWe,content_3539_7164:()=>LWe,content_3539_7166:()=>bWe,content_3539_7168:()=>zWe,content_3539_7170:()=>WWe,content_3539_7172:()=>IWe,content_3539_7174:()=>SWe,content_3539_7176:()=>BWe,content_3539_7178:()=>OWe,content_3539_718:()=>cU,content_3539_7180:()=>FWe,content_3539_7182:()=>VWe,content_3539_7184:()=>HWe,content_3539_7186:()=>YWe,content_3539_7188:()=>KWe,content_3539_7190:()=>tRe,content_3539_7192:()=>nRe,content_3539_7194:()=>pRe,content_3539_7196:()=>sRe,content_3539_7198:()=>iRe,content_3539_72:()=>aN,content_3539_720:()=>aU,content_3539_7200:()=>lRe,content_3539_7202:()=>mRe,content_3539_7204:()=>hRe,content_3539_7206:()=>kRe,content_3539_7208:()=>MRe,content_3539_7210:()=>wRe,content_3539_7212:()=>XRe,content_3539_7214:()=>TRe,content_3539_7216:()=>CRe,content_3539_7218:()=>LRe,content_3539_722:()=>uU,content_3539_7220:()=>bRe,content_3539_7222:()=>zRe,content_3539_7224:()=>WRe,content_3539_7226:()=>IRe,content_3539_7228:()=>SRe,content_3539_7230:()=>BRe,content_3539_7232:()=>ORe,content_3539_7234:()=>FRe,content_3539_7236:()=>VRe,content_3539_7238:()=>HRe,content_3539_724:()=>dU,content_3539_7240:()=>YRe,content_3539_7242:()=>KRe,content_3539_7244:()=>tIe,content_3539_7246:()=>nIe,content_3539_7248:()=>pIe,content_3539_7250:()=>sIe,content_3539_7252:()=>iIe,content_3539_7254:()=>lIe,content_3539_7256:()=>mIe,content_3539_7258:()=>hIe,content_3539_726:()=>fU,content_3539_7260:()=>kIe,content_3539_7262:()=>MIe,content_3539_7264:()=>wIe,content_3539_7266:()=>XIe,content_3539_7268:()=>TIe,content_3539_7270:()=>CIe,content_3539_7272:()=>LIe,content_3539_7274:()=>bIe,content_3539_7276:()=>zIe,content_3539_7278:()=>WIe,content_3539_728:()=>yU,content_3539_7280:()=>IIe,content_3539_7282:()=>SIe,content_3539_7284:()=>BIe,content_3539_7286:()=>OIe,content_3539_7288:()=>FIe,content_3539_7290:()=>VIe,content_3539_7292:()=>HIe,content_3539_7294:()=>YIe,content_3539_7296:()=>KIe,content_3539_7298:()=>tPe,content_3539_730:()=>DU,content_3539_7300:()=>nPe,content_3539_7302:()=>pPe,content_3539_7304:()=>sPe,content_3539_7306:()=>iPe,content_3539_7308:()=>lPe,content_3539_7310:()=>mPe,content_3539_7312:()=>hPe,content_3539_7314:()=>kPe,content_3539_7316:()=>MPe,content_3539_7318:()=>wPe,content_3539_732:()=>_U,content_3539_7320:()=>XPe,content_3539_7322:()=>TPe,content_3539_7324:()=>CPe,content_3539_7326:()=>LPe,content_3539_7328:()=>bPe,content_3539_7330:()=>zPe,content_3539_7332:()=>WPe,content_3539_7334:()=>IPe,content_3539_7336:()=>SPe,content_3539_7338:()=>BPe,content_3539_734:()=>gU,content_3539_7340:()=>OPe,content_3539_7342:()=>FPe,content_3539_7344:()=>VPe,content_3539_7346:()=>HPe,content_3539_7348:()=>YPe,content_3539_7350:()=>KPe,content_3539_7352:()=>tSe,content_3539_7354:()=>nSe,content_3539_7356:()=>pSe,content_3539_7358:()=>sSe,content_3539_736:()=>xU,content_3539_7360:()=>iSe,content_3539_7362:()=>lSe,content_3539_7364:()=>mSe,content_3539_7366:()=>hSe,content_3539_7368:()=>kSe,content_3539_7370:()=>MSe,content_3539_7372:()=>wSe,content_3539_7374:()=>XSe,content_3539_7376:()=>TSe,content_3539_7378:()=>CSe,content_3539_738:()=>vU,content_3539_7380:()=>LSe,content_3539_7382:()=>bSe,content_3539_7384:()=>zSe,content_3539_7386:()=>WSe,content_3539_7388:()=>ISe,content_3539_7390:()=>SSe,content_3539_7392:()=>BSe,content_3539_7394:()=>OSe,content_3539_7396:()=>FSe,content_3539_7398:()=>VSe,content_3539_74:()=>uN,content_3539_740:()=>ZU,content_3539_7400:()=>HSe,content_3539_7402:()=>YSe,content_3539_7404:()=>KSe,content_3539_7406:()=>tEe,content_3539_7408:()=>nEe,content_3539_7410:()=>pEe,content_3539_7412:()=>sEe,content_3539_7414:()=>iEe,content_3539_7416:()=>lEe,content_3539_7418:()=>mEe,content_3539_742:()=>NU,content_3539_7420:()=>hEe,content_3539_7422:()=>kEe,content_3539_7424:()=>MEe,content_3539_7426:()=>wEe,content_3539_7428:()=>XEe,content_3539_7430:()=>TEe,content_3539_7432:()=>CEe,content_3539_7434:()=>LEe,content_3539_7436:()=>bEe,content_3539_7438:()=>zEe,content_3539_744:()=>AU,content_3539_7440:()=>WEe,content_3539_7442:()=>IEe,content_3539_7444:()=>SEe,content_3539_7446:()=>BEe,content_3539_7448:()=>OEe,content_3539_7450:()=>FEe,content_3539_7452:()=>VEe,content_3539_7454:()=>HEe,content_3539_7456:()=>YEe,content_3539_7458:()=>KEe,content_3539_746:()=>RU,content_3539_7460:()=>tBe,content_3539_7462:()=>nBe,content_3539_7464:()=>pBe,content_3539_7466:()=>sBe,content_3539_7468:()=>iBe,content_3539_7470:()=>lBe,content_3539_7472:()=>mBe,content_3539_7474:()=>hBe,content_3539_7476:()=>kBe,content_3539_7478:()=>MBe,content_3539_748:()=>PU,content_3539_7480:()=>wBe,content_3539_7482:()=>XBe,content_3539_7484:()=>TBe,content_3539_7486:()=>CBe,content_3539_7488:()=>LBe,content_3539_7490:()=>bBe,content_3539_7492:()=>zBe,content_3539_7494:()=>WBe,content_3539_7496:()=>IBe,content_3539_7498:()=>SBe,content_3539_750:()=>EU,content_3539_7500:()=>BBe,content_3539_7502:()=>OBe,content_3539_7504:()=>FBe,content_3539_7506:()=>VBe,content_3539_7508:()=>HBe,content_3539_7510:()=>YBe,content_3539_7512:()=>KBe,content_3539_7514:()=>tGe,content_3539_7516:()=>nGe,content_3539_7518:()=>pGe,content_3539_752:()=>GU,content_3539_7520:()=>sGe,content_3539_7522:()=>iGe,content_3539_7524:()=>lGe,content_3539_7526:()=>mGe,content_3539_7528:()=>hGe,content_3539_7530:()=>kGe,content_3539_7532:()=>MGe,content_3539_7534:()=>wGe,content_3539_7536:()=>XGe,content_3539_7538:()=>TGe,content_3539_754:()=>UU,content_3539_7540:()=>CGe,content_3539_7542:()=>LGe,content_3539_7544:()=>bGe,content_3539_7546:()=>zGe,content_3539_7548:()=>WGe,content_3539_7550:()=>IGe,content_3539_7552:()=>SGe,content_3539_7554:()=>BGe,content_3539_7556:()=>OGe,content_3539_7558:()=>FGe,content_3539_756:()=>qU,content_3539_7560:()=>VGe,content_3539_7562:()=>HGe,content_3539_7564:()=>YGe,content_3539_7566:()=>KGe,content_3539_7568:()=>tOe,content_3539_7570:()=>nOe,content_3539_7572:()=>pOe,content_3539_7574:()=>sOe,content_3539_7576:()=>iOe,content_3539_7578:()=>lOe,content_3539_758:()=>jU,content_3539_7580:()=>mOe,content_3539_7582:()=>hOe,content_3539_7584:()=>kOe,content_3539_7586:()=>MOe,content_3539_7588:()=>wOe,content_3539_7590:()=>XOe,content_3539_7592:()=>TOe,content_3539_7594:()=>COe,content_3539_7596:()=>LOe,content_3539_7598:()=>bOe,content_3539_76:()=>dN,content_3539_760:()=>QU,content_3539_7600:()=>zOe,content_3539_7602:()=>WOe,content_3539_7604:()=>IOe,content_3539_7606:()=>SOe,content_3539_7608:()=>BOe,content_3539_7610:()=>OOe,content_3539_7612:()=>FOe,content_3539_7614:()=>VOe,content_3539_7616:()=>HOe,content_3539_7618:()=>YOe,content_3539_762:()=>$U,content_3539_7620:()=>KOe,content_3539_7622:()=>tUe,content_3539_7624:()=>nUe,content_3539_7626:()=>pUe,content_3539_7628:()=>sUe,content_3539_7630:()=>iUe,content_3539_7632:()=>lUe,content_3539_7634:()=>mUe,content_3539_7636:()=>hUe,content_3539_7638:()=>kUe,content_3539_764:()=>JU,content_3539_7640:()=>MUe,content_3539_7642:()=>wUe,content_3539_7644:()=>XUe,content_3539_7646:()=>TUe,content_3539_7648:()=>CUe,content_3539_7650:()=>LUe,content_3539_7652:()=>bUe,content_3539_7654:()=>zUe,content_3539_7656:()=>WUe,content_3539_7658:()=>IUe,content_3539_766:()=>eF,content_3539_7660:()=>SUe,content_3539_7662:()=>BUe,content_3539_7664:()=>OUe,content_3539_7666:()=>FUe,content_3539_7668:()=>VUe,content_3539_7670:()=>HUe,content_3539_7672:()=>YUe,content_3539_7674:()=>KUe,content_3539_7676:()=>tFe,content_3539_7678:()=>nFe,content_3539_768:()=>oF,content_3539_7680:()=>pFe,content_3539_7682:()=>sFe,content_3539_7684:()=>iFe,content_3539_7686:()=>lFe,content_3539_7688:()=>mFe,content_3539_7690:()=>hFe,content_3539_7692:()=>kFe,content_3539_7694:()=>MFe,content_3539_7696:()=>wFe,content_3539_7698:()=>XFe,content_3539_770:()=>rF,content_3539_7700:()=>TFe,content_3539_7702:()=>CFe,content_3539_7704:()=>LFe,content_3539_7706:()=>bFe,content_3539_7708:()=>zFe,content_3539_7710:()=>WFe,content_3539_7712:()=>IFe,content_3539_7714:()=>SFe,content_3539_7716:()=>BFe,content_3539_7718:()=>OFe,content_3539_772:()=>cF,content_3539_7720:()=>FFe,content_3539_7722:()=>VFe,content_3539_7724:()=>HFe,content_3539_7726:()=>YFe,content_3539_7728:()=>KFe,content_3539_7730:()=>tqe,content_3539_7732:()=>nqe,content_3539_7734:()=>pqe,content_3539_7736:()=>sqe,content_3539_7738:()=>iqe,content_3539_774:()=>aF,content_3539_7740:()=>lqe,content_3539_7742:()=>mqe,content_3539_7744:()=>hqe,content_3539_7746:()=>kqe,content_3539_7748:()=>Mqe,content_3539_7750:()=>wqe,content_3539_7752:()=>Xqe,content_3539_7754:()=>Tqe,content_3539_7756:()=>Cqe,content_3539_7758:()=>Lqe,content_3539_776:()=>uF,content_3539_7760:()=>bqe,content_3539_7762:()=>zqe,content_3539_7764:()=>Wqe,content_3539_7766:()=>Iqe,content_3539_7768:()=>Sqe,content_3539_7770:()=>Bqe,content_3539_7772:()=>Oqe,content_3539_7774:()=>Fqe,content_3539_7776:()=>Vqe,content_3539_7778:()=>Hqe,content_3539_778:()=>dF,content_3539_7780:()=>Yqe,content_3539_7782:()=>Kqe,content_3539_7784:()=>tVe,content_3539_7786:()=>nVe,content_3539_7788:()=>pVe,content_3539_7790:()=>sVe,content_3539_7792:()=>iVe,content_3539_7794:()=>lVe,content_3539_7796:()=>mVe,content_3539_7798:()=>hVe,content_3539_78:()=>fN,content_3539_780:()=>fF,content_3539_7800:()=>kVe,content_3539_7802:()=>MVe,content_3539_7804:()=>wVe,content_3539_7806:()=>XVe,content_3539_7808:()=>TVe,content_3539_7810:()=>CVe,content_3539_7812:()=>LVe,content_3539_7814:()=>bVe,content_3539_7816:()=>zVe,content_3539_7818:()=>WVe,content_3539_782:()=>yF,content_3539_7820:()=>IVe,content_3539_7822:()=>SVe,content_3539_7824:()=>BVe,content_3539_7826:()=>OVe,content_3539_7828:()=>FVe,content_3539_7830:()=>VVe,content_3539_7832:()=>HVe,content_3539_7834:()=>YVe,content_3539_7836:()=>KVe,content_3539_7838:()=>tje,content_3539_784:()=>DF,content_3539_7840:()=>nje,content_3539_7842:()=>pje,content_3539_7844:()=>sje,content_3539_7846:()=>ije,content_3539_7848:()=>lje,content_3539_7850:()=>mje,content_3539_7852:()=>hje,content_3539_7854:()=>kje,content_3539_7856:()=>Mje,content_3539_7858:()=>wje,content_3539_786:()=>_F,content_3539_7860:()=>Xje,content_3539_7862:()=>Tje,content_3539_7864:()=>Cje,content_3539_7866:()=>Lje,content_3539_7868:()=>bje,content_3539_7870:()=>zje,content_3539_7872:()=>Wje,content_3539_7874:()=>Ije,content_3539_7876:()=>Sje,content_3539_7878:()=>Bje,content_3539_788:()=>gF,content_3539_7880:()=>Oje,content_3539_7882:()=>Fje,content_3539_7884:()=>Vje,content_3539_7886:()=>Hje,content_3539_7888:()=>Yje,content_3539_7890:()=>Kje,content_3539_7892:()=>tHe,content_3539_7894:()=>nHe,content_3539_7896:()=>pHe,content_3539_7898:()=>sHe,content_3539_790:()=>xF,content_3539_7900:()=>iHe,content_3539_7902:()=>lHe,content_3539_7904:()=>mHe,content_3539_7906:()=>hHe,content_3539_7908:()=>kHe,content_3539_7910:()=>MHe,content_3539_7912:()=>wHe,content_3539_7914:()=>XHe,content_3539_7916:()=>THe,content_3539_7918:()=>CHe,content_3539_792:()=>vF,content_3539_7920:()=>LHe,content_3539_7922:()=>bHe,content_3539_7924:()=>zHe,content_3539_7926:()=>WHe,content_3539_7928:()=>IHe,content_3539_7930:()=>SHe,content_3539_7932:()=>BHe,content_3539_7934:()=>OHe,content_3539_7936:()=>FHe,content_3539_7938:()=>VHe,content_3539_794:()=>ZF,content_3539_7940:()=>HHe,content_3539_7942:()=>YHe,content_3539_7944:()=>KHe,content_3539_7946:()=>tQe,content_3539_7948:()=>nQe,content_3539_7950:()=>pQe,content_3539_7952:()=>sQe,content_3539_7954:()=>iQe,content_3539_7956:()=>lQe,content_3539_7958:()=>mQe,content_3539_796:()=>NF,content_3539_7960:()=>hQe,content_3539_7962:()=>kQe,content_3539_7964:()=>MQe,content_3539_7966:()=>wQe,content_3539_7968:()=>XQe,content_3539_7970:()=>TQe,content_3539_7972:()=>CQe,content_3539_7974:()=>LQe,content_3539_798:()=>AF,content_3539_8:()=>JZ,content_3539_80:()=>yN,content_3539_800:()=>RF,content_3539_802:()=>PF,content_3539_804:()=>EF,content_3539_806:()=>GF,content_3539_808:()=>UF,content_3539_810:()=>qF,content_3539_812:()=>jF,content_3539_814:()=>QF,content_3539_816:()=>$F,content_3539_818:()=>JF,content_3539_82:()=>DN,content_3539_820:()=>eq,content_3539_822:()=>oq,content_3539_824:()=>rq,content_3539_826:()=>cq,content_3539_828:()=>aq,content_3539_830:()=>uq,content_3539_832:()=>dq,content_3539_834:()=>fq,content_3539_836:()=>yq,content_3539_838:()=>Dq,content_3539_84:()=>_N,content_3539_840:()=>_q,content_3539_842:()=>gq,content_3539_844:()=>xq,content_3539_846:()=>vq,content_3539_848:()=>Zq,content_3539_850:()=>Nq,content_3539_852:()=>Aq,content_3539_854:()=>Rq,content_3539_856:()=>Pq,content_3539_858:()=>Eq,content_3539_86:()=>gN,content_3539_860:()=>Gq,content_3539_862:()=>Uq,content_3539_864:()=>qq,content_3539_866:()=>jq,content_3539_868:()=>Qq,content_3539_870:()=>$q,content_3539_872:()=>Jq,content_3539_874:()=>eV,content_3539_876:()=>oV,content_3539_878:()=>rV,content_3539_88:()=>xN,content_3539_880:()=>cV,content_3539_882:()=>aV,content_3539_884:()=>uV,content_3539_886:()=>dV,content_3539_888:()=>fV,content_3539_890:()=>yV,content_3539_892:()=>DV,content_3539_894:()=>_V,content_3539_896:()=>gV,content_3539_898:()=>xV,content_3539_90:()=>vN,content_3539_900:()=>vV,content_3539_902:()=>ZV,content_3539_904:()=>NV,content_3539_906:()=>AV,content_3539_908:()=>RV,content_3539_910:()=>PV,content_3539_912:()=>EV,content_3539_914:()=>GV,content_3539_916:()=>UV,content_3539_918:()=>qV,content_3539_92:()=>ZN,content_3539_920:()=>jV,content_3539_922:()=>QV,content_3539_924:()=>$V,content_3539_926:()=>JV,content_3539_928:()=>ej,content_3539_930:()=>oj,content_3539_932:()=>rj,content_3539_934:()=>cj,content_3539_936:()=>aj,content_3539_938:()=>uj,content_3539_94:()=>NN,content_3539_940:()=>dj,content_3539_942:()=>fj,content_3539_944:()=>yj,content_3539_946:()=>Dj,content_3539_948:()=>_j,content_3539_950:()=>gj,content_3539_952:()=>xj,content_3539_954:()=>vj,content_3539_956:()=>Zj,content_3539_958:()=>Nj,content_3539_96:()=>AN,content_3539_960:()=>Aj,content_3539_962:()=>Rj,content_3539_964:()=>Pj,content_3539_966:()=>Ej,content_3539_968:()=>Gj,content_3539_970:()=>Uj,content_3539_972:()=>qj,content_3539_974:()=>jj,content_3539_976:()=>Qj,content_3539_978:()=>$j,content_3539_98:()=>RN,content_3539_980:()=>Jj,content_3539_982:()=>eH,content_3539_984:()=>oH,content_3539_986:()=>rH,content_3539_988:()=>cH,content_3539_990:()=>aH,content_3539_992:()=>uH,content_3539_994:()=>dH,content_3539_996:()=>fH,content_3539_998:()=>yH});var p=n(2784),r=n(7896),s=n(876);const c={toc:[]};function i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const f={toc:[]};function k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}k.isMDXComponent=!0;const y={toc:[]};function M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}I.isMDXComponent=!0;const P={toc:[]};function S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}S.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}O.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}F.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}V.isMDXComponent=!0;const j={toc:[]};function H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}H.isMDXComponent=!0;const Q={toc:[]};function Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Y.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nt.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const ft={toc:[]};function kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}kt.isMDXComponent=!0;const yt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}It.isMDXComponent=!0;const Pt={toc:[]};function St(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}St.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ot.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ft.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Ht.isMDXComponent=!0;const Qt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Yt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}ne.isMDXComponent=!0;const oe={toc:[]};function pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pe.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}se.isMDXComponent=!0;const ce={toc:[]};function ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}ie.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}he.isMDXComponent=!0;const fe={toc:[]};function ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}ke.isMDXComponent=!0;const ye={toc:[]};function Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Me.isMDXComponent=!0;const De={toc:[]};function we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}we.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Xe.isMDXComponent=!0;const ge={toc:[]};function Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}Te.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}Ce.isMDXComponent=!0;const ve={toc:[]};function Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}be.isMDXComponent=!0;const Ne={toc:[]};function ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}ze.isMDXComponent=!0;const Ae={toc:[]};function We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}We.isMDXComponent=!0;const Re={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Ie.isMDXComponent=!0;const Pe={toc:[]};function Se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Se.isMDXComponent=!0;const Ee={toc:[]};function Be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Be.isMDXComponent=!0;const Ge={toc:[]};function Oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}))}Oe.isMDXComponent=!0;const Ue={toc:[]};function Fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Fe.isMDXComponent=!0;const qe={toc:[]};function Ve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}Ve.isMDXComponent=!0;const je={toc:[]};function He(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}He.isMDXComponent=!0;const Qe={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Ye.isMDXComponent=!0;const $e={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Ke.isMDXComponent=!0;const Je={toc:[]};function tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}nn.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}fn.isMDXComponent=!0;const kn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}yn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Rn.isMDXComponent=!0;const In={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Pn.isMDXComponent=!0;const Sn={toc:[]};function En(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Gn.isMDXComponent=!0;const On={toc:[]};function Un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Un.isMDXComponent=!0;const Fn={toc:[]};function qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}jn.isMDXComponent=!0;const Hn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Qn.isMDXComponent=!0;const Yn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const fo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ko.isMDXComponent=!0;const yo={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Io.isMDXComponent=!0;const Po={toc:[]};function So(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}So.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Oo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Fo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Ho.isMDXComponent=!0;const Qo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Yo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}np.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const fp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}kp.isMDXComponent=!0;const yp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ip.isMDXComponent=!0;const Pp={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Sp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Op.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Fp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hp.isMDXComponent=!0;const Qp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Yp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nr.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const fr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}kr.isMDXComponent=!0;const yr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ir.isMDXComponent=!0;const Pr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Sr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Or.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Fr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Vr.isMDXComponent=!0;const jr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Hr.isMDXComponent=!0;const Qr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Yr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}ns.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const fs={toc:[]};function ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ks.isMDXComponent=!0;const ys={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Is.isMDXComponent=!0;const Ps={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ss.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Os.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Fs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Vs.isMDXComponent=!0;const js={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Hs.isMDXComponent=!0;const Qs={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ys.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}nc.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const fc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}kc.isMDXComponent=!0;const yc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ic.isMDXComponent=!0;const Pc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Sc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Oc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hc.isMDXComponent=!0;const Qc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ni.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const fi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ki.isMDXComponent=!0;const yi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ii.isMDXComponent=!0;const Pi={toc:[]};function Si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Si.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Oi.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Hi.isMDXComponent=!0;const Qi={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}na.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const fa={toc:[]};function ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ka.isMDXComponent=!0;const ya={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ia.isMDXComponent=!0;const Pa={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Oa.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Fa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Va.isMDXComponent=!0;const ja={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ha.isMDXComponent=!0;const Qa={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ya.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}nl.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const fl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}kl.isMDXComponent=!0;const yl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Il.isMDXComponent=!0;const Pl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Sl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Ol.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hl.isMDXComponent=!0;const Ql={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const fu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ku.isMDXComponent=!0;const yu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Iu.isMDXComponent=!0;const Pu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Su.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ou.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Fu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Hu.isMDXComponent=!0;const Qu={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Yu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}nm.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const fm={toc:[]};function km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}km.isMDXComponent=!0;const ym={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Im.isMDXComponent=!0;const Pm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Om.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hm.isMDXComponent=!0;const Qm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ym.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nd.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const fd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}kd.isMDXComponent=!0;const yd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Id.isMDXComponent=!0;const Pd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Od.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hd.isMDXComponent=!0;const Qd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const fh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kh.isMDXComponent=!0;const yh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ih.isMDXComponent=!0;const Ph={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Sh.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Oh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Fh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Hh.isMDXComponent=!0;const Qh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Yh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}nf.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}ff.isMDXComponent=!0;const kf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Rf.isMDXComponent=!0;const If={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Pf.isMDXComponent=!0;const Sf={toc:[]};function Ef(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Gf.isMDXComponent=!0;const Of={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ff,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}jf.isMDXComponent=!0;const Hf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Qf.isMDXComponent=!0;const Yf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Jf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ok.isMDXComponent=!0;const pk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}rk.isMDXComponent=!0;const sk={toc:[]};function ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ck.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Dk.isMDXComponent=!0;const wk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_k.isMDXComponent=!0;const Xk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gk.isMDXComponent=!0;const Tk={toc:[]};function xk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}xk.isMDXComponent=!0;const Ck={toc:[]};function vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zk.isMDXComponent=!0;const bk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ak.isMDXComponent=!0;const Wk={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Rk.isMDXComponent=!0;const Ik={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ik,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Pk.isMDXComponent=!0;const Sk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ek.isMDXComponent=!0;const Bk={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Gk.isMDXComponent=!0;const Ok={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Uk.isMDXComponent=!0;const Fk={toc:[]};function qk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qk.isMDXComponent=!0;const Vk={toc:[]};function jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jk.isMDXComponent=!0;const Hk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Qk.isMDXComponent=!0;const Yk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$k.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jk.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const My={toc:[]};function Dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Dy.isMDXComponent=!0;const wy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}_y.isMDXComponent=!0;const Xy={toc:[]};function gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function xy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}xy.isMDXComponent=!0;const Cy={toc:[]};function vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ry.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Py.isMDXComponent=!0;const Sy={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Ey.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Uy.isMDXComponent=!0;const Fy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}qy.isMDXComponent=!0;const Vy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Hy={toc:[]};function Qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Qy.isMDXComponent=!0;const Yy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}fM.isMDXComponent=!0;const kM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}RM.isMDXComponent=!0;const IM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}PM.isMDXComponent=!0;const SM={toc:[]};function EM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}GM.isMDXComponent=!0;const OM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}UM.isMDXComponent=!0;const FM={toc:[]};function qM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jM.isMDXComponent=!0;const HM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}QM.isMDXComponent=!0;const YM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}fD.isMDXComponent=!0;const kD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}yD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}RD.isMDXComponent=!0;const ID={toc:[]};function PD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}PD.isMDXComponent=!0;const SD={toc:[]};function ED(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}GD.isMDXComponent=!0;const OD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}UD.isMDXComponent=!0;const FD={toc:[]};function qD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}jD.isMDXComponent=!0;const HD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}QD.isMDXComponent=!0;const YD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}JD.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}fw.isMDXComponent=!0;const kw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}yw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Pw.isMDXComponent=!0;const Sw={toc:[]};function Ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}jw.isMDXComponent=!0;const Hw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Qw.isMDXComponent=!0;const Yw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Jw.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}f_.isMDXComponent=!0;const k_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}y_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}R_.isMDXComponent=!0;const I_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}P_.isMDXComponent=!0;const S_={toc:[]};function E_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}G_.isMDXComponent=!0;const O_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}U_.isMDXComponent=!0;const F_={toc:[]};function q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}j_.isMDXComponent=!0;const H_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Q_.isMDXComponent=!0;const Y_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}J_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}fX.isMDXComponent=!0;const kX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}yX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}RX.isMDXComponent=!0;const IX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}PX.isMDXComponent=!0;const SX={toc:[]};function EX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}GX.isMDXComponent=!0;const OX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}UX.isMDXComponent=!0;const FX={toc:[]};function qX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}jX.isMDXComponent=!0;const HX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}QX.isMDXComponent=!0;const YX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}JX.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}fg.isMDXComponent=!0;const kg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}yg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Pg.isMDXComponent=!0;const Sg={toc:[]};function Eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Gg.isMDXComponent=!0;const Og={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}jg.isMDXComponent=!0;const Hg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Qg.isMDXComponent=!0;const Yg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Jg.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}fT.isMDXComponent=!0;const kT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}yT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}RT.isMDXComponent=!0;const IT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}PT.isMDXComponent=!0;const ST={toc:[]};function ET(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}GT.isMDXComponent=!0;const OT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}UT.isMDXComponent=!0;const FT={toc:[]};function qT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}jT.isMDXComponent=!0;const HT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}QT.isMDXComponent=!0;const YT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}JT.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}fx.isMDXComponent=!0;const kx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}yx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Px(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Px.isMDXComponent=!0;const Sx={toc:[]};function Ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Ux.isMDXComponent=!0;const Fx={toc:[]};function qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}jx.isMDXComponent=!0;const Hx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}Qx.isMDXComponent=!0;const Yx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}Jx.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}fC.isMDXComponent=!0;const kC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}yC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}RC.isMDXComponent=!0;const IC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}PC.isMDXComponent=!0;const SC={toc:[]};function EC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}GC.isMDXComponent=!0;const OC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}UC.isMDXComponent=!0;const FC={toc:[]};function qC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}jC.isMDXComponent=!0;const HC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}QC.isMDXComponent=!0;const YC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}JC.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}fv.isMDXComponent=!0;const kv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}yv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}Pv.isMDXComponent=!0;const Sv={toc:[]};function Ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}jv.isMDXComponent=!0;const Hv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Qv.isMDXComponent=!0;const Yv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}Jv.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}fL.isMDXComponent=!0;const kL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}yL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}RL.isMDXComponent=!0;const IL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}PL.isMDXComponent=!0;const SL={toc:[]};function EL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}GL.isMDXComponent=!0;const OL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}UL.isMDXComponent=!0;const FL={toc:[]};function qL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}jL.isMDXComponent=!0;const HL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}QL.isMDXComponent=!0;const YL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}JL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}fZ.isMDXComponent=!0;const kZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}yZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}PZ.isMDXComponent=!0;const SZ={toc:[]};function EZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}GZ.isMDXComponent=!0;const OZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function qZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}jZ.isMDXComponent=!0;const HZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}QZ.isMDXComponent=!0;const YZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}JZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}fb.isMDXComponent=!0;const kb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}yb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pb.isMDXComponent=!0;const Sb={toc:[]};function Eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ub.isMDXComponent=!0;const Fb={toc:[]};function qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}jb.isMDXComponent=!0;const Hb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qb.isMDXComponent=!0;const Yb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Jb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}fN.isMDXComponent=!0;const kN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}yN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}RN.isMDXComponent=!0;const IN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}PN.isMDXComponent=!0;const SN={toc:[]};function EN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}GN.isMDXComponent=!0;const ON={toc:[]};function UN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}UN.isMDXComponent=!0;const FN={toc:[]};function qN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}jN.isMDXComponent=!0;const HN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QN.isMDXComponent=!0;const YN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JN.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}fz.isMDXComponent=!0;const kz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}yz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pz.isMDXComponent=!0;const Sz={toc:[]};function Ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Uz.isMDXComponent=!0;const Fz={toc:[]};function qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}jz.isMDXComponent=!0;const Hz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Qz.isMDXComponent=!0;const Yz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Jz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}fA.isMDXComponent=!0;const kA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}yA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}RA.isMDXComponent=!0;const IA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}PA.isMDXComponent=!0;const SA={toc:[]};function EA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}GA.isMDXComponent=!0;const OA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}UA.isMDXComponent=!0;const FA={toc:[]};function qA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}jA.isMDXComponent=!0;const HA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}QA.isMDXComponent=!0;const YA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}JA.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fW.isMDXComponent=!0;const kW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}yW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}RW.isMDXComponent=!0;const IW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}PW.isMDXComponent=!0;const SW={toc:[]};function EW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GW.isMDXComponent=!0;const OW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}UW.isMDXComponent=!0;const FW={toc:[]};function qW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}jW.isMDXComponent=!0;const HW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QW.isMDXComponent=!0;const YW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JW.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}fR.isMDXComponent=!0;const kR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}yR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}RR.isMDXComponent=!0;const IR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PR.isMDXComponent=!0;const SR={toc:[]};function ER(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}GR.isMDXComponent=!0;const OR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}UR.isMDXComponent=!0;const FR={toc:[]};function qR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jR.isMDXComponent=!0;const HR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}QR.isMDXComponent=!0;const YR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}JR.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fI.isMDXComponent=!0;const kI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}yI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}RI.isMDXComponent=!0;const II={toc:[]};function PI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}PI.isMDXComponent=!0;const SI={toc:[]};function EI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}GI.isMDXComponent=!0;const OI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}UI.isMDXComponent=!0;const FI={toc:[]};function qI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}jI.isMDXComponent=!0;const HI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QI.isMDXComponent=!0;const YI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JI.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fP.isMDXComponent=!0;const kP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}yP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}RP.isMDXComponent=!0;const IP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PP.isMDXComponent=!0;const SP={toc:[]};function EP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GP.isMDXComponent=!0;const OP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}UP.isMDXComponent=!0;const FP={toc:[]};function qP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}jP.isMDXComponent=!0;const HP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}QP.isMDXComponent=!0;const YP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}JP.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}fS.isMDXComponent=!0;const kS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}RS.isMDXComponent=!0;const IS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}PS.isMDXComponent=!0;const SS={toc:[]};function ES(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}GS.isMDXComponent=!0;const OS={toc:[]};function US(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}US.isMDXComponent=!0;const FS={toc:[]};function qS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jS.isMDXComponent=!0;const HS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}QS.isMDXComponent=!0;const YS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}JS.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}fE.isMDXComponent=!0;const kE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}yE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}RE.isMDXComponent=!0;const IE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PE.isMDXComponent=!0;const SE={toc:[]};function EE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}GE.isMDXComponent=!0;const OE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}UE.isMDXComponent=!0;const FE={toc:[]};function qE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}jE.isMDXComponent=!0;const HE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QE.isMDXComponent=!0;const YE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}JE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}fB.isMDXComponent=!0;const kB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}yB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}RB.isMDXComponent=!0;const IB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PB.isMDXComponent=!0;const SB={toc:[]};function EB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GB.isMDXComponent=!0;const OB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UB.isMDXComponent=!0;const FB={toc:[]};function qB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}jB.isMDXComponent=!0;const HB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QB.isMDXComponent=!0;const YB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}JB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}fG.isMDXComponent=!0;const kG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RG.isMDXComponent=!0;const IG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}PG.isMDXComponent=!0;const SG={toc:[]};function EG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GG.isMDXComponent=!0;const OG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}UG.isMDXComponent=!0;const FG={toc:[]};function qG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}jG.isMDXComponent=!0;const HG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}QG.isMDXComponent=!0;const YG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}JG.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}fO.isMDXComponent=!0;const kO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}RO.isMDXComponent=!0;const IO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}PO.isMDXComponent=!0;const SO={toc:[]};function EO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}GO.isMDXComponent=!0;const OO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}UO.isMDXComponent=!0;const FO={toc:[]};function qO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}jO.isMDXComponent=!0;const HO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}QO.isMDXComponent=!0;const YO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}JO.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fU.isMDXComponent=!0;const kU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}yU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}RU.isMDXComponent=!0;const IU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}PU.isMDXComponent=!0;const SU={toc:[]};function EU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}GU.isMDXComponent=!0;const OU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}UU.isMDXComponent=!0;const FU={toc:[]};function qU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}jU.isMDXComponent=!0;const HU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}QU.isMDXComponent=!0;const YU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}JU.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fF.isMDXComponent=!0;const kF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}yF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}RF.isMDXComponent=!0;const IF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}PF.isMDXComponent=!0;const SF={toc:[]};function EF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}GF.isMDXComponent=!0;const OF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}UF.isMDXComponent=!0;const FF={toc:[]};function qF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}jF.isMDXComponent=!0;const HF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}QF.isMDXComponent=!0;const YF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}JF.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}fq.isMDXComponent=!0;const kq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Pq.isMDXComponent=!0;const Sq={toc:[]};function Eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Uq.isMDXComponent=!0;const Fq={toc:[]};function qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}jq.isMDXComponent=!0;const Hq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qq.isMDXComponent=!0;const Yq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Jq.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fV.isMDXComponent=!0;const kV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}RV.isMDXComponent=!0;const IV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}PV.isMDXComponent=!0;const SV={toc:[]};function EV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}GV.isMDXComponent=!0;const OV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}UV.isMDXComponent=!0;const FV={toc:[]};function qV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}jV.isMDXComponent=!0;const HV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}QV.isMDXComponent=!0;const YV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}JV.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fj.isMDXComponent=!0;const kj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Pj.isMDXComponent=!0;const Sj={toc:[]};function Ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Uj.isMDXComponent=!0;const Fj={toc:[]};function qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}jj.isMDXComponent=!0;const Hj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Qj.isMDXComponent=!0;const Yj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Jj.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}fH.isMDXComponent=!0;const kH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}yH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}RH.isMDXComponent=!0;const IH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}PH.isMDXComponent=!0;const SH={toc:[]};function EH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GH.isMDXComponent=!0;const OH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}UH.isMDXComponent=!0;const FH={toc:[]};function qH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jH.isMDXComponent=!0;const HH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}QH.isMDXComponent=!0;const YH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}JH.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}fQ.isMDXComponent=!0;const kQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}yQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PQ.isMDXComponent=!0;const SQ={toc:[]};function EQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}UQ.isMDXComponent=!0;const FQ={toc:[]};function qQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}jQ.isMDXComponent=!0;const HQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}QQ.isMDXComponent=!0;const YQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}JQ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}fY.isMDXComponent=!0;const kY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}yY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}RY.isMDXComponent=!0;const IY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}PY.isMDXComponent=!0;const SY={toc:[]};function EY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GY.isMDXComponent=!0;const OY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}UY.isMDXComponent=!0;const FY={toc:[]};function qY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}jY.isMDXComponent=!0;const HY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QY.isMDXComponent=!0;const YY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}JY.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}f$.isMDXComponent=!0;const k$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}y$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}R$.isMDXComponent=!0;const I$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}P$.isMDXComponent=!0;const S$={toc:[]};function E$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}G$.isMDXComponent=!0;const O$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}U$.isMDXComponent=!0;const F$={toc:[]};function q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}j$.isMDXComponent=!0;const H$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Q$.isMDXComponent=!0;const Y$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}J$.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fK.isMDXComponent=!0;const kK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}yK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}RK.isMDXComponent=!0;const IK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}PK.isMDXComponent=!0;const SK={toc:[]};function EK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}GK.isMDXComponent=!0;const OK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}UK.isMDXComponent=!0;const FK={toc:[]};function qK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}jK.isMDXComponent=!0;const HK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QK.isMDXComponent=!0;const YK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}JK.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}fJ.isMDXComponent=!0;const kJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}yJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PJ.isMDXComponent=!0;const SJ={toc:[]};function EJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GJ.isMDXComponent=!0;const OJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}UJ.isMDXComponent=!0;const FJ={toc:[]};function qJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}jJ.isMDXComponent=!0;const HJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QJ.isMDXComponent=!0;const YJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JJ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}f0.isMDXComponent=!0;const k0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}y0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}R0.isMDXComponent=!0;const I0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}P0.isMDXComponent=!0;const S0={toc:[]};function E0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}G0.isMDXComponent=!0;const O0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}U0.isMDXComponent=!0;const F0={toc:[]};function q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}j0.isMDXComponent=!0;const H0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Q0.isMDXComponent=!0;const Y0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}J0.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}f3.isMDXComponent=!0;const k3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}y3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}R3.isMDXComponent=!0;const I3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P3.isMDXComponent=!0;const S3={toc:[]};function E3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}G3.isMDXComponent=!0;const O3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}U3.isMDXComponent=!0;const F3={toc:[]};function q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}j3.isMDXComponent=!0;const H3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Q3.isMDXComponent=!0;const Y3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}J3.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}f5.isMDXComponent=!0;const k5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}y5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}D5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}R5.isMDXComponent=!0;const I5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}P5.isMDXComponent=!0;const S5={toc:[]};function E5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}G5.isMDXComponent=!0;const O5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}U5.isMDXComponent=!0;const F5={toc:[]};function q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}j5.isMDXComponent=!0;const H5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Q5.isMDXComponent=!0;const Y5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}J5.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}f9.isMDXComponent=!0;const k9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}y9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}D9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}R9.isMDXComponent=!0;const I9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}P9.isMDXComponent=!0;const S9={toc:[]};function E9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}G9.isMDXComponent=!0;const O9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}U9.isMDXComponent=!0;const F9={toc:[]};function q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}j9.isMDXComponent=!0;const H9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Q9.isMDXComponent=!0;const Y9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}J9.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}f2.isMDXComponent=!0;const k2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}y2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}D2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}R2.isMDXComponent=!0;const I2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}P2.isMDXComponent=!0;const S2={toc:[]};function E2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}G2.isMDXComponent=!0;const O2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}U2.isMDXComponent=!0;const F2={toc:[]};function q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}j2.isMDXComponent=!0;const H2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Q2.isMDXComponent=!0;const Y2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}J2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}f1.isMDXComponent=!0;const k1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}y1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}R1.isMDXComponent=!0;const I1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}P1.isMDXComponent=!0;const S1={toc:[]};function E1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}G1.isMDXComponent=!0;const O1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}U1.isMDXComponent=!0;const F1={toc:[]};function q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}j1.isMDXComponent=!0;const H1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Q1.isMDXComponent=!0;const Y1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}J1.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}f4.isMDXComponent=!0;const k4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}y4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}D4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}R4.isMDXComponent=!0;const I4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}P4.isMDXComponent=!0;const S4={toc:[]};function E4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}G4.isMDXComponent=!0;const O4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}U4.isMDXComponent=!0;const F4={toc:[]};function q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}j4.isMDXComponent=!0;const H4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Q4.isMDXComponent=!0;const Y4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}J4.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}f6.isMDXComponent=!0;const k6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}y6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}D6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}R6.isMDXComponent=!0;const I6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}P6.isMDXComponent=!0;const S6={toc:[]};function E6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}G6.isMDXComponent=!0;const O6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}U6.isMDXComponent=!0;const F6={toc:[]};function q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}j6.isMDXComponent=!0;const H6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Q6.isMDXComponent=!0;const Y6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}J6.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}f8.isMDXComponent=!0;const k8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}y8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}D8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}R8.isMDXComponent=!0;const I8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}P8.isMDXComponent=!0;const S8={toc:[]};function E8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}G8.isMDXComponent=!0;const O8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}U8.isMDXComponent=!0;const F8={toc:[]};function q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}j8.isMDXComponent=!0;const H8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Q8.isMDXComponent=!0;const Y8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}J8.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}f7.isMDXComponent=!0;const k7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}y7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}D7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}R7.isMDXComponent=!0;const I7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}P7.isMDXComponent=!0;const S7={toc:[]};function E7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}G7.isMDXComponent=!0;const O7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}U7.isMDXComponent=!0;const F7={toc:[]};function q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}j7.isMDXComponent=!0;const H7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Q7.isMDXComponent=!0;const Y7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}J7.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ftt.isMDXComponent=!0;const ktt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ytt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Dtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ptt.isMDXComponent=!0;const Stt={toc:[]};function Ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Utt.isMDXComponent=!0;const Ftt={toc:[]};function qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jtt.isMDXComponent=!0;const Htt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qtt.isMDXComponent=!0;const Ytt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Jtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}het.isMDXComponent=!0;const fet={toc:[]};function ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ket.isMDXComponent=!0;const yet={toc:[]};function Met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Met.isMDXComponent=!0;const Det={toc:[]};function wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Iet.isMDXComponent=!0;const Pet={toc:[]};function Set(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Set.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Oet.isMDXComponent=!0;const Uet={toc:[]};function Fet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Fet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Het.isMDXComponent=!0;const Qet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Yet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nnt.isMDXComponent=!0;const ont={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pnt.isMDXComponent=!0;const rnt={toc:[]};function snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}snt.isMDXComponent=!0;const cnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}int.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}hnt.isMDXComponent=!0;const fnt={toc:[]};function knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}knt.isMDXComponent=!0;const ynt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}wnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Xnt.isMDXComponent=!0;const gnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Tnt.isMDXComponent=!0;const xnt={toc:[]};function Cnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Cnt.isMDXComponent=!0;const vnt={toc:[]};function Lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}bnt.isMDXComponent=!0;const Nnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wnt.isMDXComponent=!0;const Rnt={toc:[]};function Int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Int.isMDXComponent=!0;const Pnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Snt.isMDXComponent=!0;const Ent={toc:[]};function Bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Bnt.isMDXComponent=!0;const Gnt={toc:[]};function Ont(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ont.isMDXComponent=!0;const Unt={toc:[]};function Fnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Fnt.isMDXComponent=!0;const qnt={toc:[]};function Vnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Vnt.isMDXComponent=!0;const jnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Hnt.isMDXComponent=!0;const Qnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Ynt.isMDXComponent=!0;const $nt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Knt.isMDXComponent=!0;const Jnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}not.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hot.isMDXComponent=!0;const fot={toc:[]};function kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kot.isMDXComponent=!0;const yot={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Iot.isMDXComponent=!0;const Pot={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Sot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Oot.isMDXComponent=!0;const Uot={toc:[]};function Fot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Fot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Hot.isMDXComponent=!0;const Qot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Yot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}npt.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kpt.isMDXComponent=!0;const ypt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ipt.isMDXComponent=!0;const Ppt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Spt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Opt.isMDXComponent=!0;const Upt={toc:[]};function Fpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fpt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Ypt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nrt.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hrt.isMDXComponent=!0;const frt={toc:[]};function krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}krt.isMDXComponent=!0;const yrt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Irt.isMDXComponent=!0;const Prt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Srt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Ort.isMDXComponent=!0;const Urt={toc:[]};function Frt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Frt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Hrt.isMDXComponent=!0;const Qrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nst.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}hst.isMDXComponent=!0;const fst={toc:[]};function kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kst.isMDXComponent=!0;const yst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ist.isMDXComponent=!0;const Pst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Sst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ost.isMDXComponent=!0;const Ust={toc:[]};function Fst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Fst.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Hst.isMDXComponent=!0;const Qst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Yst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nct.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}hct.isMDXComponent=!0;const fct={toc:[]};function kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kct.isMDXComponent=!0;const yct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ict.isMDXComponent=!0;const Pct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Sct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Oct.isMDXComponent=!0;const Uct={toc:[]};function Fct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Fct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Vct.isMDXComponent=!0;const jct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Hct.isMDXComponent=!0;const Qct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Yct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}hit.isMDXComponent=!0;const fit={toc:[]};function kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}kit.isMDXComponent=!0;const yit={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Iit.isMDXComponent=!0;const Pit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Sit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Oit.isMDXComponent=!0;const Uit={toc:[]};function Fit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Fit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Vit.isMDXComponent=!0;const jit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Hit.isMDXComponent=!0;const Qit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Yit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}nat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}hat.isMDXComponent=!0;const fat={toc:[]};function kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kat.isMDXComponent=!0;const yat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Iat.isMDXComponent=!0;const Pat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Sat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Oat.isMDXComponent=!0;const Uat={toc:[]};function Fat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Fat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Hat.isMDXComponent=!0;const Qat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Yat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nlt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hlt.isMDXComponent=!0;const flt={toc:[]};function klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}klt.isMDXComponent=!0;const ylt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ilt.isMDXComponent=!0;const Plt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Slt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Olt.isMDXComponent=!0;const Ult={toc:[]};function Flt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Flt.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ylt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}nut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}hut.isMDXComponent=!0;const fut={toc:[]};function kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kut.isMDXComponent=!0;const yut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Iut.isMDXComponent=!0;const Put={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Sut.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Out.isMDXComponent=!0;const Uut={toc:[]};function Fut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Fut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}Hut.isMDXComponent=!0;const Qut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Yut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nmt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hmt.isMDXComponent=!0;const fmt={toc:[]};function kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kmt.isMDXComponent=!0;const ymt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Imt.isMDXComponent=!0;const Pmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Smt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Omt.isMDXComponent=!0;const Umt={toc:[]};function Fmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Fmt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Hmt.isMDXComponent=!0;const Qmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Ymt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ndt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}kdt.isMDXComponent=!0;const ydt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Idt.isMDXComponent=!0;const Pdt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Sdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Odt.isMDXComponent=!0;const Udt={toc:[]};function Fdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Fdt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ydt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hht.isMDXComponent=!0;const fht={toc:[]};function kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}kht.isMDXComponent=!0;const yht={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Iht.isMDXComponent=!0;const Pht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Sht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Oht.isMDXComponent=!0;const Uht={toc:[]};function Fht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Fht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Hht.isMDXComponent=!0;const Qht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Yht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hft.isMDXComponent=!0;const fft={toc:[]};function kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kft.isMDXComponent=!0;const yft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Ift.isMDXComponent=!0;const Pft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Sft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Oft.isMDXComponent=!0;const Uft={toc:[]};function Fft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Fft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Hft.isMDXComponent=!0;const Qft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Yft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nkt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kkt.isMDXComponent=!0;const ykt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Ikt.isMDXComponent=!0;const Pkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Skt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Okt.isMDXComponent=!0;const Ukt={toc:[]};function Fkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fkt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Ykt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kyt.isMDXComponent=!0;const yyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Iyt.isMDXComponent=!0;const Pyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Syt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Oyt.isMDXComponent=!0;const Uyt={toc:[]};function Fyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Fyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Hyt.isMDXComponent=!0;const Qyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Yyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function kMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kMt.isMDXComponent=!0;const yMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IMt.isMDXComponent=!0;const PMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}SMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}OMt.isMDXComponent=!0;const UMt={toc:[]};function FMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}FMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}HMt.isMDXComponent=!0;const QMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}YMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function kDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kDt.isMDXComponent=!0;const yDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}IDt.isMDXComponent=!0;const PDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ODt.isMDXComponent=!0;const UDt={toc:[]};function FDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}HDt.isMDXComponent=!0;const QDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}YDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nwt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hwt.isMDXComponent=!0;const fwt={toc:[]};function kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kwt.isMDXComponent=!0;const ywt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Iwt.isMDXComponent=!0;const Pwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Swt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Owt.isMDXComponent=!0;const Uwt={toc:[]};function Fwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Fwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ywt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function k_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k_t.isMDXComponent=!0;const y_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}I_t.isMDXComponent=!0;const P_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}S_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}O_t.isMDXComponent=!0;const U_t={toc:[]};function F_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}F_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}H_t.isMDXComponent=!0;const Q_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function kXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kXt.isMDXComponent=!0;const yXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IXt.isMDXComponent=!0;const PXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}SXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OXt.isMDXComponent=!0;const UXt={toc:[]};function FXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}HXt.isMDXComponent=!0;const QXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}YXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kgt.isMDXComponent=!0;const ygt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Igt.isMDXComponent=!0;const Pgt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Sgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ogt.isMDXComponent=!0;const Ugt={toc:[]};function Fgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fgt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ygt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function kTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kTt.isMDXComponent=!0;const yTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ITt.isMDXComponent=!0;const PTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}STt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OTt.isMDXComponent=!0;const UTt={toc:[]};function FTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}FTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}HTt.isMDXComponent=!0;const QTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}YTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}kxt.isMDXComponent=!0;const yxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Ixt.isMDXComponent=!0;const Pxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Sxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Oxt.isMDXComponent=!0;const Uxt={toc:[]};function Fxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Fxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Yxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hCt.isMDXComponent=!0;const fCt={toc:[]};function kCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kCt.isMDXComponent=!0;const yCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ICt.isMDXComponent=!0;const PCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}SCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}OCt.isMDXComponent=!0;const UCt={toc:[]};function FCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}FCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}HCt.isMDXComponent=!0;const QCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kvt.isMDXComponent=!0;const yvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Ivt.isMDXComponent=!0;const Pvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Svt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Ovt.isMDXComponent=!0;const Uvt={toc:[]};function Fvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Fvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Yvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function kLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}kLt.isMDXComponent=!0;const yLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}MLt.isMDXComponent=!0;const DLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ILt.isMDXComponent=!0;const PLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}SLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}OLt.isMDXComponent=!0;const ULt={toc:[]};function FLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FLt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}HLt.isMDXComponent=!0;const QLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}YLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function kZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kZt.isMDXComponent=!0;const yZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}IZt.isMDXComponent=!0;const PZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}SZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}OZt.isMDXComponent=!0;const UZt={toc:[]};function FZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HZt.isMDXComponent=!0;const QZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}YZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nbt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kbt.isMDXComponent=!0;const ybt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ibt.isMDXComponent=!0;const Pbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Sbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Obt.isMDXComponent=!0;const Ubt={toc:[]};function Fbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Fbt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Ybt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function kNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kNt.isMDXComponent=!0;const yNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}INt.isMDXComponent=!0;const PNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}SNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ONt.isMDXComponent=!0;const UNt={toc:[]};function FNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}HNt.isMDXComponent=!0;const QNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}YNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}kzt.isMDXComponent=!0;const yzt={toc:[]};function Mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Izt.isMDXComponent=!0;const Pzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Szt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ozt.isMDXComponent=!0;const Uzt={toc:[]};function Fzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Fzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Yzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function kAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}kAt.isMDXComponent=!0;const yAt={toc:[]};function MAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}IAt.isMDXComponent=!0;const PAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}SAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}OAt.isMDXComponent=!0;const UAt={toc:[]};function FAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}FAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}HAt.isMDXComponent=!0;const QAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hWt.isMDXComponent=!0;const fWt={toc:[]};function kWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kWt.isMDXComponent=!0;const yWt={toc:[]};function MWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}IWt.isMDXComponent=!0;const PWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OWt.isMDXComponent=!0;const UWt={toc:[]};function FWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}FWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}HWt.isMDXComponent=!0;const QWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}YWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function kRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kRt.isMDXComponent=!0;const yRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IRt.isMDXComponent=!0;const PRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}SRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}ORt.isMDXComponent=!0;const URt={toc:[]};function FRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}FRt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}HRt.isMDXComponent=!0;const QRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function kIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kIt.isMDXComponent=!0;const yIt={toc:[]};function MIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}IIt.isMDXComponent=!0;const PIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}SIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}OIt.isMDXComponent=!0;const UIt={toc:[]};function FIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}HIt.isMDXComponent=!0;const QIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}YIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function kPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kPt.isMDXComponent=!0;const yPt={toc:[]};function MPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}IPt.isMDXComponent=!0;const PPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}SPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}OPt.isMDXComponent=!0;const UPt={toc:[]};function FPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}FPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}HPt.isMDXComponent=!0;const QPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}YPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function kSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kSt.isMDXComponent=!0;const ySt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ISt.isMDXComponent=!0;const PSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}SSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}OSt.isMDXComponent=!0;const USt={toc:[]};function FSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FSt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HSt.isMDXComponent=!0;const QSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}YSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function kEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}kEt.isMDXComponent=!0;const yEt={toc:[]};function MEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}MEt.isMDXComponent=!0;const DEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}IEt.isMDXComponent=!0;const PEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}SEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}OEt.isMDXComponent=!0;const UEt={toc:[]};function FEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}FEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HEt.isMDXComponent=!0;const QEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}YEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function kBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}kBt.isMDXComponent=!0;const yBt={toc:[]};function MBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}IBt.isMDXComponent=!0;const PBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}SBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}OBt.isMDXComponent=!0;const UBt={toc:[]};function FBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}FBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}HBt.isMDXComponent=!0;const QBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function kGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}kGt.isMDXComponent=!0;const yGt={toc:[]};function MGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IGt.isMDXComponent=!0;const PGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}SGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}OGt.isMDXComponent=!0;const UGt={toc:[]};function FGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}FGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}HGt.isMDXComponent=!0;const QGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}YGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function kOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kOt.isMDXComponent=!0;const yOt={toc:[]};function MOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}IOt.isMDXComponent=!0;const POt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SOt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OOt.isMDXComponent=!0;const UOt={toc:[]};function FOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}FOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}HOt.isMDXComponent=!0;const QOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}YOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function kUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kUt.isMDXComponent=!0;const yUt={toc:[]};function MUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}IUt.isMDXComponent=!0;const PUt={toc:[]};function SUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}SUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}OUt.isMDXComponent=!0;const UUt={toc:[]};function FUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function HUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}HUt.isMDXComponent=!0;const QUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}YUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function kFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}kFt.isMDXComponent=!0;const yFt={toc:[]};function MFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IFt.isMDXComponent=!0;const PFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}SFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OFt.isMDXComponent=!0;const UFt={toc:[]};function FFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}FFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}HFt.isMDXComponent=!0;const QFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}YFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kqt.isMDXComponent=!0;const yqt={toc:[]};function Mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}Iqt.isMDXComponent=!0;const Pqt={toc:[]};function Sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}Sqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Oqt.isMDXComponent=!0;const Uqt={toc:[]};function Fqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Fqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Yqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function kVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}kVt.isMDXComponent=!0;const yVt={toc:[]};function MVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}IVt.isMDXComponent=!0;const PVt={toc:[]};function SVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}SVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}OVt.isMDXComponent=!0;const UVt={toc:[]};function FVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}FVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function HVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}HVt.isMDXComponent=!0;const QVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}njt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}kjt.isMDXComponent=!0;const yjt={toc:[]};function Mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ijt.isMDXComponent=!0;const Pjt={toc:[]};function Sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Sjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ojt.isMDXComponent=!0;const Ujt={toc:[]};function Fjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Fjt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Yjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}nHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function kHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kHt.isMDXComponent=!0;const yHt={toc:[]};function MHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}IHt.isMDXComponent=!0;const PHt={toc:[]};function SHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}SHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OHt.isMDXComponent=!0;const UHt={toc:[]};function FHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}FHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function HHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}HHt.isMDXComponent=!0;const QHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function kQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kQt.isMDXComponent=!0;const yQt={toc:[]};function MQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}MQt.isMDXComponent=!0;const DQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}IQt.isMDXComponent=!0;const PQt={toc:[]};function SQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}SQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}OQt.isMDXComponent=!0;const UQt={toc:[]};function FQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}FQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function HQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}HQt.isMDXComponent=!0;const QQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}YQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function kYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kYt.isMDXComponent=!0;const yYt={toc:[]};function MYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IYt.isMDXComponent=!0;const PYt={toc:[]};function SYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}SYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OYt.isMDXComponent=!0;const UYt={toc:[]};function FYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function HYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}HYt.isMDXComponent=!0;const QYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}YYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}KYt.isMDXComponent=!0;const JYt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}h$t.isMDXComponent=!0;const f$t={toc:[]};function k$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}k$t.isMDXComponent=!0;const y$t={toc:[]};function M$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}M$t.isMDXComponent=!0;const D$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}I$t.isMDXComponent=!0;const P$t={toc:[]};function S$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}O$t.isMDXComponent=!0;const U$t={toc:[]};function F$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}F$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function H$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}H$t.isMDXComponent=!0;const Q$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Y$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}nKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function kKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kKt.isMDXComponent=!0;const yKt={toc:[]};function MKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}MKt.isMDXComponent=!0;const DKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}IKt.isMDXComponent=!0;const PKt={toc:[]};function SKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OKt.isMDXComponent=!0;const UKt={toc:[]};function FKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}FKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VKt.isMDXComponent=!0;const jKt={toc:[]};function HKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}HKt.isMDXComponent=!0;const QKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}YKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function kJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kJt.isMDXComponent=!0;const yJt={toc:[]};function MJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IJt.isMDXComponent=!0;const PJt={toc:[]};function SJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}SJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}OJt.isMDXComponent=!0;const UJt={toc:[]};function FJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}FJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function HJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}HJt.isMDXComponent=!0;const QJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function k0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}k0t.isMDXComponent=!0;const y0t={toc:[]};function M0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}M0t.isMDXComponent=!0;const D0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}I0t.isMDXComponent=!0;const P0t={toc:[]};function S0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}S0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}O0t.isMDXComponent=!0;const U0t={toc:[]};function F0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}F0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function H0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}H0t.isMDXComponent=!0;const Q0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Y0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function k3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}k3t.isMDXComponent=!0;const y3t={toc:[]};function M3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}I3t.isMDXComponent=!0;const P3t={toc:[]};function S3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}S3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}O3t.isMDXComponent=!0;const U3t={toc:[]};function F3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}F3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}V3t.isMDXComponent=!0;const j3t={toc:[]};function H3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}H3t.isMDXComponent=!0;const Q3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Y3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function k5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}k5t.isMDXComponent=!0;const y5t={toc:[]};function M5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I5t.isMDXComponent=!0;const P5t={toc:[]};function S5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}S5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}O5t.isMDXComponent=!0;const U5t={toc:[]};function F5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}F5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function H5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}H5t.isMDXComponent=!0;const Q5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Y5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function k9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}k9t.isMDXComponent=!0;const y9t={toc:[]};function M9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}I9t.isMDXComponent=!0;const P9t={toc:[]};function S9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}S9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}O9t.isMDXComponent=!0;const U9t={toc:[]};function F9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}F9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function H9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}H9t.isMDXComponent=!0;const Q9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Y9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function k2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}k2t.isMDXComponent=!0;const y2t={toc:[]};function M2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}M2t.isMDXComponent=!0;const D2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}I2t.isMDXComponent=!0;const P2t={toc:[]};function S2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}S2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O2t.isMDXComponent=!0;const U2t={toc:[]};function F2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}F2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function H2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}H2t.isMDXComponent=!0;const Q2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Y2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function k1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}k1t.isMDXComponent=!0;const y1t={toc:[]};function M1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}I1t.isMDXComponent=!0;const P1t={toc:[]};function S1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}S1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}O1t.isMDXComponent=!0;const U1t={toc:[]};function F1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}F1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function H1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}H1t.isMDXComponent=!0;const Q1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Y1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}n4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function k4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}k4t.isMDXComponent=!0;const y4t={toc:[]};function M4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}I4t.isMDXComponent=!0;const P4t={toc:[]};function S4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}S4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}O4t.isMDXComponent=!0;const U4t={toc:[]};function F4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}F4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function H4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}H4t.isMDXComponent=!0;const Q4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Y4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function k6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}k6t.isMDXComponent=!0;const y6t={toc:[]};function M6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}I6t.isMDXComponent=!0;const P6t={toc:[]};function S6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}S6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}O6t.isMDXComponent=!0;const U6t={toc:[]};function F6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function H6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}H6t.isMDXComponent=!0;const Q6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Y6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function k8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}k8t.isMDXComponent=!0;const y8t={toc:[]};function M8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}I8t.isMDXComponent=!0;const P8t={toc:[]};function S8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}S8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}O8t.isMDXComponent=!0;const U8t={toc:[]};function F8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}F8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function H8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}H8t.isMDXComponent=!0;const Q8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Y8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}h7t.isMDXComponent=!0;const f7t={toc:[]};function k7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}k7t.isMDXComponent=!0;const y7t={toc:[]};function M7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}M7t.isMDXComponent=!0;const D7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}I7t.isMDXComponent=!0;const P7t={toc:[]};function S7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}S7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}O7t.isMDXComponent=!0;const U7t={toc:[]};function F7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}F7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function H7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}H7t.isMDXComponent=!0;const Q7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Y7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K7t.isMDXComponent=!0;const J7t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}nte.isMDXComponent=!0;const ote={toc:[]};function pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pte.isMDXComponent=!0;const rte={toc:[]};function ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ste.isMDXComponent=!0;const cte={toc:[]};function ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ite.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hte.isMDXComponent=!0;const fte={toc:[]};function kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kte.isMDXComponent=!0;const yte={toc:[]};function Mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Mte.isMDXComponent=!0;const Dte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wte.isMDXComponent=!0;const _te={toc:[]};function Xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Xte.isMDXComponent=!0;const gte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Tte.isMDXComponent=!0;const xte={toc:[]};function Cte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Cte.isMDXComponent=!0;const vte={toc:[]};function Lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Lte.isMDXComponent=!0;const Zte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bte.isMDXComponent=!0;const Nte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zte.isMDXComponent=!0;const Ate={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wte.isMDXComponent=!0;const Rte={toc:[]};function Ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ite.isMDXComponent=!0;const Pte={toc:[]};function Ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ste.isMDXComponent=!0;const Ete={toc:[]};function Bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Bte.isMDXComponent=!0;const Gte={toc:[]};function Ote(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ote.isMDXComponent=!0;const Ute={toc:[]};function Fte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Fte.isMDXComponent=!0;const qte={toc:[]};function Vte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Vte.isMDXComponent=!0;const jte={toc:[]};function Hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Hte.isMDXComponent=!0;const Qte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Yte.isMDXComponent=!0;const $te={toc:[]};function Kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kte.isMDXComponent=!0;const Jte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nee.isMDXComponent=!0;const oee={toc:[]};function pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pee.isMDXComponent=!0;const ree={toc:[]};function see(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}see.isMDXComponent=!0;const cee={toc:[]};function iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hee.isMDXComponent=!0;const fee={toc:[]};function kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kee.isMDXComponent=!0;const yee={toc:[]};function Mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mee.isMDXComponent=!0;const Dee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wee.isMDXComponent=!0;const _ee={toc:[]};function Xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Xee.isMDXComponent=!0;const gee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Tee.isMDXComponent=!0;const xee={toc:[]};function Cee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Cee.isMDXComponent=!0;const vee={toc:[]};function Lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lee.isMDXComponent=!0;const Zee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bee.isMDXComponent=!0;const Nee={toc:[]};function zee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zee.isMDXComponent=!0;const Aee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wee.isMDXComponent=!0;const Ree={toc:[]};function Iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Iee.isMDXComponent=!0;const Pee={toc:[]};function See(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}See.isMDXComponent=!0;const Eee={toc:[]};function Bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Bee.isMDXComponent=!0;const Gee={toc:[]};function Oee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Oee.isMDXComponent=!0;const Uee={toc:[]};function Fee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Fee.isMDXComponent=!0;const qee={toc:[]};function Vee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Vee.isMDXComponent=!0;const jee={toc:[]};function Hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Hee.isMDXComponent=!0;const Qee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Yee.isMDXComponent=!0;const $ee={toc:[]};function Kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Kee.isMDXComponent=!0;const Jee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nne.isMDXComponent=!0;const one={toc:[]};function pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pne.isMDXComponent=!0;const rne={toc:[]};function sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sne.isMDXComponent=!0;const cne={toc:[]};function ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ine.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hne.isMDXComponent=!0;const fne={toc:[]};function kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kne.isMDXComponent=!0;const yne={toc:[]};function Mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mne.isMDXComponent=!0;const Dne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wne.isMDXComponent=!0;const _ne={toc:[]};function Xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Xne.isMDXComponent=!0;const gne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Tne.isMDXComponent=!0;const xne={toc:[]};function Cne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Cne.isMDXComponent=!0;const vne={toc:[]};function Lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Lne.isMDXComponent=!0;const Zne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bne.isMDXComponent=!0;const Nne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zne.isMDXComponent=!0;const Ane={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Wne.isMDXComponent=!0;const Rne={toc:[]};function Ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Ine.isMDXComponent=!0;const Pne={toc:[]};function Sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Sne.isMDXComponent=!0;const Ene={toc:[]};function Bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Bne.isMDXComponent=!0;const Gne={toc:[]};function One(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}One.isMDXComponent=!0;const Une={toc:[]};function Fne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Fne.isMDXComponent=!0;const qne={toc:[]};function Vne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Vne.isMDXComponent=!0;const jne={toc:[]};function Hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Hne.isMDXComponent=!0;const Qne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Yne.isMDXComponent=!0;const $ne={toc:[]};function Kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Kne.isMDXComponent=!0;const Jne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}noe.isMDXComponent=!0;const ooe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}poe.isMDXComponent=!0;const roe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}soe.isMDXComponent=!0;const coe={toc:[]};function ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ioe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hoe.isMDXComponent=!0;const foe={toc:[]};function koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}koe.isMDXComponent=!0;const yoe={toc:[]};function Moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Moe.isMDXComponent=!0;const Doe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}woe.isMDXComponent=!0;const _oe={toc:[]};function Xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Xoe.isMDXComponent=!0;const goe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Toe.isMDXComponent=!0;const xoe={toc:[]};function Coe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Coe.isMDXComponent=!0;const voe={toc:[]};function Loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Loe.isMDXComponent=!0;const Zoe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}boe.isMDXComponent=!0;const Noe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zoe.isMDXComponent=!0;const Aoe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Woe.isMDXComponent=!0;const Roe={toc:[]};function Ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ioe.isMDXComponent=!0;const Poe={toc:[]};function Soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Soe.isMDXComponent=!0;const Eoe={toc:[]};function Boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Boe.isMDXComponent=!0;const Goe={toc:[]};function Ooe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ooe.isMDXComponent=!0;const Uoe={toc:[]};function Foe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Foe.isMDXComponent=!0;const qoe={toc:[]};function Voe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}Voe.isMDXComponent=!0;const joe={toc:[]};function Hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}Hoe.isMDXComponent=!0;const Qoe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Yoe.isMDXComponent=!0;const $oe={toc:[]};function Koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Koe.isMDXComponent=!0;const Joe={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}npe.isMDXComponent=!0;const ope={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ppe.isMDXComponent=!0;const rpe={toc:[]};function spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}spe.isMDXComponent=!0;const cpe={toc:[]};function ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ipe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hpe.isMDXComponent=!0;const fpe={toc:[]};function kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kpe.isMDXComponent=!0;const ype={toc:[]};function Mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Mpe.isMDXComponent=!0;const Dpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wpe.isMDXComponent=!0;const _pe={toc:[]};function Xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Xpe.isMDXComponent=!0;const gpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Tpe.isMDXComponent=!0;const xpe={toc:[]};function Cpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Cpe.isMDXComponent=!0;const vpe={toc:[]};function Lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}bpe.isMDXComponent=!0;const Npe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zpe.isMDXComponent=!0;const Ape={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Wpe.isMDXComponent=!0;const Rpe={toc:[]};function Ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ipe.isMDXComponent=!0;const Ppe={toc:[]};function Spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Spe.isMDXComponent=!0;const Epe={toc:[]};function Bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Bpe.isMDXComponent=!0;const Gpe={toc:[]};function Ope(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ope.isMDXComponent=!0;const Upe={toc:[]};function Fpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fpe.isMDXComponent=!0;const qpe={toc:[]};function Vpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Vpe.isMDXComponent=!0;const jpe={toc:[]};function Hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Hpe.isMDXComponent=!0;const Qpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ype.isMDXComponent=!0;const $pe={toc:[]};function Kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nre.isMDXComponent=!0;const ore={toc:[]};function pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pre.isMDXComponent=!0;const rre={toc:[]};function sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sre.isMDXComponent=!0;const cre={toc:[]};function ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ire.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}hre.isMDXComponent=!0;const fre={toc:[]};function kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}kre.isMDXComponent=!0;const yre={toc:[]};function Mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Mre.isMDXComponent=!0;const Dre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wre.isMDXComponent=!0;const _re={toc:[]};function Xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Xre.isMDXComponent=!0;const gre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tre.isMDXComponent=!0;const xre={toc:[]};function Cre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Cre.isMDXComponent=!0;const vre={toc:[]};function Lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lre.isMDXComponent=!0;const Zre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bre.isMDXComponent=!0;const Nre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zre.isMDXComponent=!0;const Are={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wre.isMDXComponent=!0;const Rre={toc:[]};function Ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ire.isMDXComponent=!0;const Pre={toc:[]};function Sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Sre.isMDXComponent=!0;const Ere={toc:[]};function Bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Bre.isMDXComponent=!0;const Gre={toc:[]};function Ore(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ore.isMDXComponent=!0;const Ure={toc:[]};function Fre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fre.isMDXComponent=!0;const qre={toc:[]};function Vre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Vre.isMDXComponent=!0;const jre={toc:[]};function Hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hre.isMDXComponent=!0;const Qre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yre.isMDXComponent=!0;const $re={toc:[]};function Kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kre.isMDXComponent=!0;const Jre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}nse.isMDXComponent=!0;const ose={toc:[]};function pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}pse.isMDXComponent=!0;const rse={toc:[]};function sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}sse.isMDXComponent=!0;const cse={toc:[]};function ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}ise.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hse.isMDXComponent=!0;const fse={toc:[]};function kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kse.isMDXComponent=!0;const yse={toc:[]};function Mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mse.isMDXComponent=!0;const Dse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wse.isMDXComponent=!0;const _se={toc:[]};function Xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Xse.isMDXComponent=!0;const gse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Tse.isMDXComponent=!0;const xse={toc:[]};function Cse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Cse.isMDXComponent=!0;const vse={toc:[]};function Lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Lse.isMDXComponent=!0;const Zse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}bse.isMDXComponent=!0;const Nse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}zse.isMDXComponent=!0;const Ase={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Wse.isMDXComponent=!0;const Rse={toc:[]};function Ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ise.isMDXComponent=!0;const Pse={toc:[]};function Sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Sse.isMDXComponent=!0;const Ese={toc:[]};function Bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Bse.isMDXComponent=!0;const Gse={toc:[]};function Ose(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ose.isMDXComponent=!0;const Use={toc:[]};function Fse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Fse.isMDXComponent=!0;const qse={toc:[]};function Vse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vse.isMDXComponent=!0;const jse={toc:[]};function Hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Hse.isMDXComponent=!0;const Qse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Yse.isMDXComponent=!0;const $se={toc:[]};function Kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kse.isMDXComponent=!0;const Jse={toc:[]};function tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nce.isMDXComponent=!0;const oce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pce.isMDXComponent=!0;const rce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sce.isMDXComponent=!0;const cce={toc:[]};function ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ice.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}hce.isMDXComponent=!0;const fce={toc:[]};function kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}kce.isMDXComponent=!0;const yce={toc:[]};function Mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Mce.isMDXComponent=!0;const Dce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wce.isMDXComponent=!0;const _ce={toc:[]};function Xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Xce.isMDXComponent=!0;const gce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Tce.isMDXComponent=!0;const xce={toc:[]};function Cce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Cce.isMDXComponent=!0;const vce={toc:[]};function Lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Lce.isMDXComponent=!0;const Zce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bce.isMDXComponent=!0;const Nce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}zce.isMDXComponent=!0;const Ace={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Wce.isMDXComponent=!0;const Rce={toc:[]};function Ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Ice.isMDXComponent=!0;const Pce={toc:[]};function Sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Sce.isMDXComponent=!0;const Ece={toc:[]};function Bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Bce.isMDXComponent=!0;const Gce={toc:[]};function Oce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Oce.isMDXComponent=!0;const Uce={toc:[]};function Fce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Fce.isMDXComponent=!0;const qce={toc:[]};function Vce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Vce.isMDXComponent=!0;const jce={toc:[]};function Hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Hce.isMDXComponent=!0;const Qce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Yce.isMDXComponent=!0;const $ce={toc:[]};function Kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kce.isMDXComponent=!0;const Jce={toc:[]};function tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nie.isMDXComponent=!0;const oie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pie.isMDXComponent=!0;const rie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}sie.isMDXComponent=!0;const cie={toc:[]};function iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}iie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}hie.isMDXComponent=!0;const fie={toc:[]};function kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kie.isMDXComponent=!0;const yie={toc:[]};function Mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Mie.isMDXComponent=!0;const Die={toc:[]};function wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wie.isMDXComponent=!0;const _ie={toc:[]};function Xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Xie.isMDXComponent=!0;const gie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Tie.isMDXComponent=!0;const xie={toc:[]};function Cie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Cie.isMDXComponent=!0;const vie={toc:[]};function Lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Lie.isMDXComponent=!0;const Zie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bie.isMDXComponent=!0;const Nie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}zie.isMDXComponent=!0;const Aie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Wie.isMDXComponent=!0;const Rie={toc:[]};function Iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Iie.isMDXComponent=!0;const Pie={toc:[]};function Sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Sie.isMDXComponent=!0;const Eie={toc:[]};function Bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Bie.isMDXComponent=!0;const Gie={toc:[]};function Oie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Oie.isMDXComponent=!0;const Uie={toc:[]};function Fie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Fie.isMDXComponent=!0;const qie={toc:[]};function Vie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Vie.isMDXComponent=!0;const jie={toc:[]};function Hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Hie.isMDXComponent=!0;const Qie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Yie.isMDXComponent=!0;const $ie={toc:[]};function Kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kie.isMDXComponent=!0;const Jie={toc:[]};function tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}nae.isMDXComponent=!0;const oae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pae.isMDXComponent=!0;const rae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}sae.isMDXComponent=!0;const cae={toc:[]};function iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}iae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hae.isMDXComponent=!0;const fae={toc:[]};function kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}kae.isMDXComponent=!0;const yae={toc:[]};function Mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Mae.isMDXComponent=!0;const Dae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}wae.isMDXComponent=!0;const _ae={toc:[]};function Xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Xae.isMDXComponent=!0;const gae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Tae.isMDXComponent=!0;const xae={toc:[]};function Cae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Cae.isMDXComponent=!0;const vae={toc:[]};function Lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Lae.isMDXComponent=!0;const Zae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}bae.isMDXComponent=!0;const Nae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}zae.isMDXComponent=!0;const Aae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wae.isMDXComponent=!0;const Rae={toc:[]};function Iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Iae.isMDXComponent=!0;const Pae={toc:[]};function Sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Sae.isMDXComponent=!0;const Eae={toc:[]};function Bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bae.isMDXComponent=!0;const Gae={toc:[]};function Oae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Oae.isMDXComponent=!0;const Uae={toc:[]};function Fae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fae.isMDXComponent=!0;const qae={toc:[]};function Vae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Vae.isMDXComponent=!0;const jae={toc:[]};function Hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Hae.isMDXComponent=!0;const Qae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Yae.isMDXComponent=!0;const $ae={toc:[]};function Kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kae.isMDXComponent=!0;const Jae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nle.isMDXComponent=!0;const ole={toc:[]};function ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ple.isMDXComponent=!0;const rle={toc:[]};function sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}sle.isMDXComponent=!0;const cle={toc:[]};function ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ile.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}hle.isMDXComponent=!0;const fle={toc:[]};function kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kle.isMDXComponent=!0;const yle={toc:[]};function Mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Mle.isMDXComponent=!0;const Dle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wle.isMDXComponent=!0;const _le={toc:[]};function Xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Xle.isMDXComponent=!0;const gle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Tle.isMDXComponent=!0;const xle={toc:[]};function Cle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Cle.isMDXComponent=!0;const vle={toc:[]};function Lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Lle.isMDXComponent=!0;const Zle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ble.isMDXComponent=!0;const Nle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}zle.isMDXComponent=!0;const Ale={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Wle.isMDXComponent=!0;const Rle={toc:[]};function Ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ile.isMDXComponent=!0;const Ple={toc:[]};function Sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Sle.isMDXComponent=!0;const Ele={toc:[]};function Ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ble.isMDXComponent=!0;const Gle={toc:[]};function Ole(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Ole.isMDXComponent=!0;const Ule={toc:[]};function Fle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Fle.isMDXComponent=!0;const qle={toc:[]};function Vle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Vle.isMDXComponent=!0;const jle={toc:[]};function Hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Hle.isMDXComponent=!0;const Qle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Yle.isMDXComponent=!0;const $le={toc:[]};function Kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kle.isMDXComponent=!0;const Jle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}nue.isMDXComponent=!0;const oue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}pue.isMDXComponent=!0;const rue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}sue.isMDXComponent=!0;const cue={toc:[]};function iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}iue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hue.isMDXComponent=!0;const fue={toc:[]};function kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kue.isMDXComponent=!0;const yue={toc:[]};function Mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mue.isMDXComponent=!0;const Due={toc:[]};function wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wue.isMDXComponent=!0;const _ue={toc:[]};function Xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Xue.isMDXComponent=!0;const gue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Tue.isMDXComponent=!0;const xue={toc:[]};function Cue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Cue.isMDXComponent=!0;const vue={toc:[]};function Lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Lue.isMDXComponent=!0;const Zue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bue.isMDXComponent=!0;const Nue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zue.isMDXComponent=!0;const Aue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Wue.isMDXComponent=!0;const Rue={toc:[]};function Iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Iue.isMDXComponent=!0;const Pue={toc:[]};function Sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Sue.isMDXComponent=!0;const Eue={toc:[]};function Bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bue.isMDXComponent=!0;const Gue={toc:[]};function Oue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Oue.isMDXComponent=!0;const Uue={toc:[]};function Fue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Fue.isMDXComponent=!0;const que={toc:[]};function Vue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Vue.isMDXComponent=!0;const jue={toc:[]};function Hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Hue.isMDXComponent=!0;const Que={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Yue.isMDXComponent=!0;const $ue={toc:[]};function Kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Kue.isMDXComponent=!0;const Jue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nme.isMDXComponent=!0;const ome={toc:[]};function pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}pme.isMDXComponent=!0;const rme={toc:[]};function sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}sme.isMDXComponent=!0;const cme={toc:[]};function ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ime.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}hme.isMDXComponent=!0;const fme={toc:[]};function kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kme.isMDXComponent=!0;const yme={toc:[]};function Mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Mme.isMDXComponent=!0;const Dme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wme.isMDXComponent=!0;const _me={toc:[]};function Xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Xme.isMDXComponent=!0;const gme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Tme.isMDXComponent=!0;const xme={toc:[]};function Cme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Cme.isMDXComponent=!0;const vme={toc:[]};function Lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Lme.isMDXComponent=!0;const Zme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}bme.isMDXComponent=!0;const Nme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}zme.isMDXComponent=!0;const Ame={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wme.isMDXComponent=!0;const Rme={toc:[]};function Ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ime.isMDXComponent=!0;const Pme={toc:[]};function Sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Sme.isMDXComponent=!0;const Eme={toc:[]};function Bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Bme.isMDXComponent=!0;const Gme={toc:[]};function Ome(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ome.isMDXComponent=!0;const Ume={toc:[]};function Fme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fme.isMDXComponent=!0;const qme={toc:[]};function Vme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Vme.isMDXComponent=!0;const jme={toc:[]};function Hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Hme.isMDXComponent=!0;const Qme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Yme.isMDXComponent=!0;const $me={toc:[]};function Kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Kme.isMDXComponent=!0;const Jme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nde.isMDXComponent=!0;const ode={toc:[]};function pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pde.isMDXComponent=!0;const rde={toc:[]};function sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}sde.isMDXComponent=!0;const cde={toc:[]};function ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}ide.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hde.isMDXComponent=!0;const fde={toc:[]};function kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kde.isMDXComponent=!0;const yde={toc:[]};function Mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Mde.isMDXComponent=!0;const Dde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wde.isMDXComponent=!0;const _de={toc:[]};function Xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Xde.isMDXComponent=!0;const gde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Tde.isMDXComponent=!0;const xde={toc:[]};function Cde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Cde.isMDXComponent=!0;const vde={toc:[]};function Lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Lde.isMDXComponent=!0;const Zde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}bde.isMDXComponent=!0;const Nde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}zde.isMDXComponent=!0;const Ade={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Wde.isMDXComponent=!0;const Rde={toc:[]};function Ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ide.isMDXComponent=!0;const Pde={toc:[]};function Sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Sde.isMDXComponent=!0;const Ede={toc:[]};function Bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Bde.isMDXComponent=!0;const Gde={toc:[]};function Ode(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ode.isMDXComponent=!0;const Ude={toc:[]};function Fde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fde.isMDXComponent=!0;const qde={toc:[]};function Vde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Vde.isMDXComponent=!0;const jde={toc:[]};function Hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Hde.isMDXComponent=!0;const Qde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Yde.isMDXComponent=!0;const $de={toc:[]};function Kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kde.isMDXComponent=!0;const Jde={toc:[]};function the(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}phe.isMDXComponent=!0;const rhe={toc:[]};function she(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}she.isMDXComponent=!0;const che={toc:[]};function ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ihe.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hhe.isMDXComponent=!0;const fhe={toc:[]};function khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}khe.isMDXComponent=!0;const yhe={toc:[]};function Mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mhe.isMDXComponent=!0;const Dhe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}whe.isMDXComponent=!0;const _he={toc:[]};function Xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Xhe.isMDXComponent=!0;const ghe={toc:[]};function The(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}The.isMDXComponent=!0;const xhe={toc:[]};function Che(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Che.isMDXComponent=!0;const vhe={toc:[]};function Lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bhe.isMDXComponent=!0;const Nhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}zhe.isMDXComponent=!0;const Ahe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Whe.isMDXComponent=!0;const Rhe={toc:[]};function Ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ihe.isMDXComponent=!0;const Phe={toc:[]};function She(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}She.isMDXComponent=!0;const Ehe={toc:[]};function Bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Bhe.isMDXComponent=!0;const Ghe={toc:[]};function Ohe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ohe.isMDXComponent=!0;const Uhe={toc:[]};function Fhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fhe.isMDXComponent=!0;const qhe={toc:[]};function Vhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vhe.isMDXComponent=!0;const jhe={toc:[]};function Hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hhe.isMDXComponent=!0;const Qhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Yhe.isMDXComponent=!0;const $he={toc:[]};function Khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Khe.isMDXComponent=!0;const Jhe={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pfe.isMDXComponent=!0;const rfe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sfe.isMDXComponent=!0;const cfe={toc:[]};function ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ife.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hfe.isMDXComponent=!0;const ffe={toc:[]};function kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kfe.isMDXComponent=!0;const yfe={toc:[]};function Mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Mfe.isMDXComponent=!0;const Dfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wfe.isMDXComponent=!0;const _fe={toc:[]};function Xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Xfe.isMDXComponent=!0;const gfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tfe.isMDXComponent=!0;const xfe={toc:[]};function Cfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Cfe.isMDXComponent=!0;const vfe={toc:[]};function Lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}bfe.isMDXComponent=!0;const Nfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}zfe.isMDXComponent=!0;const Afe={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wfe.isMDXComponent=!0;const Rfe={toc:[]};function Ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ife.isMDXComponent=!0;const Pfe={toc:[]};function Sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Sfe.isMDXComponent=!0;const Efe={toc:[]};function Bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Bfe.isMDXComponent=!0;const Gfe={toc:[]};function Ofe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ofe.isMDXComponent=!0;const Ufe={toc:[]};function Ffe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ffe.isMDXComponent=!0;const qfe={toc:[]};function Vfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Vfe.isMDXComponent=!0;const jfe={toc:[]};function Hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Hfe.isMDXComponent=!0;const Qfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Yfe.isMDXComponent=!0;const $fe={toc:[]};function Kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]};function tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nke.isMDXComponent=!0;const oke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pke.isMDXComponent=!0;const rke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ske.isMDXComponent=!0;const cke={toc:[]};function ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ike.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}hke.isMDXComponent=!0;const fke={toc:[]};function kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}kke.isMDXComponent=!0;const yke={toc:[]};function Mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Mke.isMDXComponent=!0;const Dke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wke.isMDXComponent=!0;const _ke={toc:[]};function Xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xke.isMDXComponent=!0;const gke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tke.isMDXComponent=!0;const xke={toc:[]};function Cke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Cke.isMDXComponent=!0;const vke={toc:[]};function Lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lke.isMDXComponent=!0;const Zke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bke.isMDXComponent=!0;const Nke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zke.isMDXComponent=!0;const Ake={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Wke.isMDXComponent=!0;const Rke={toc:[]};function Ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Ike.isMDXComponent=!0;const Pke={toc:[]};function Ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Ske.isMDXComponent=!0;const Eke={toc:[]};function Bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Bke.isMDXComponent=!0;const Gke={toc:[]};function Oke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Oke.isMDXComponent=!0;const Uke={toc:[]};function Fke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}Fke.isMDXComponent=!0;const qke={toc:[]};function Vke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Vke.isMDXComponent=!0;const jke={toc:[]};function Hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Hke.isMDXComponent=!0;const Qke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Yke.isMDXComponent=!0;const $ke={toc:[]};function Kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kke.isMDXComponent=!0;const Jke={toc:[]};function tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nye.isMDXComponent=!0;const oye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pye.isMDXComponent=!0;const rye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sye.isMDXComponent=!0;const cye={toc:[]};function iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}iye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}hye.isMDXComponent=!0;const fye={toc:[]};function kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}kye.isMDXComponent=!0;const yye={toc:[]};function Mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Mye.isMDXComponent=!0;const Dye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wye.isMDXComponent=!0;const _ye={toc:[]};function Xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xye.isMDXComponent=!0;const gye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Tye.isMDXComponent=!0;const xye={toc:[]};function Cye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Cye.isMDXComponent=!0;const vye={toc:[]};function Lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lye.isMDXComponent=!0;const Zye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bye.isMDXComponent=!0;const Nye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}zye.isMDXComponent=!0;const Aye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Wye.isMDXComponent=!0;const Rye={toc:[]};function Iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Iye.isMDXComponent=!0;const Pye={toc:[]};function Sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Sye.isMDXComponent=!0;const Eye={toc:[]};function Bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Bye.isMDXComponent=!0;const Gye={toc:[]};function Oye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Oye.isMDXComponent=!0;const Uye={toc:[]};function Fye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Fye.isMDXComponent=!0;const qye={toc:[]};function Vye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vye.isMDXComponent=!0;const jye={toc:[]};function Hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Hye.isMDXComponent=!0;const Qye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Yye.isMDXComponent=!0;const $ye={toc:[]};function Kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kye.isMDXComponent=!0;const Jye={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pMe.isMDXComponent=!0;const rMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sMe.isMDXComponent=!0;const cMe={toc:[]};function iMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}hMe.isMDXComponent=!0;const fMe={toc:[]};function kMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}kMe.isMDXComponent=!0;const yMe={toc:[]};function MMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}MMe.isMDXComponent=!0;const DMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wMe.isMDXComponent=!0;const _Me={toc:[]};function XMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}XMe.isMDXComponent=!0;const gMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}TMe.isMDXComponent=!0;const xMe={toc:[]};function CMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}CMe.isMDXComponent=!0;const vMe={toc:[]};function LMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}LMe.isMDXComponent=!0;const ZMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bMe.isMDXComponent=!0;const NMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}zMe.isMDXComponent=!0;const AMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}WMe.isMDXComponent=!0;const RMe={toc:[]};function IMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}IMe.isMDXComponent=!0;const PMe={toc:[]};function SMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SMe.isMDXComponent=!0;const EMe={toc:[]};function BMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}BMe.isMDXComponent=!0;const GMe={toc:[]};function OMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}OMe.isMDXComponent=!0;const UMe={toc:[]};function FMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FMe.isMDXComponent=!0;const qMe={toc:[]};function VMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}VMe.isMDXComponent=!0;const jMe={toc:[]};function HMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}HMe.isMDXComponent=!0;const QMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}YMe.isMDXComponent=!0;const $Me={toc:[]};function KMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}KMe.isMDXComponent=!0;const JMe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pDe.isMDXComponent=!0;const rDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}sDe.isMDXComponent=!0;const cDe={toc:[]};function iDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}iDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}hDe.isMDXComponent=!0;const fDe={toc:[]};function kDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kDe.isMDXComponent=!0;const yDe={toc:[]};function MDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MDe.isMDXComponent=!0;const DDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wDe.isMDXComponent=!0;const _De={toc:[]};function XDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}XDe.isMDXComponent=!0;const gDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}TDe.isMDXComponent=!0;const xDe={toc:[]};function CDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}CDe.isMDXComponent=!0;const vDe={toc:[]};function LDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}LDe.isMDXComponent=!0;const ZDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bDe.isMDXComponent=!0;const NDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}zDe.isMDXComponent=!0;const ADe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}WDe.isMDXComponent=!0;const RDe={toc:[]};function IDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}IDe.isMDXComponent=!0;const PDe={toc:[]};function SDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}SDe.isMDXComponent=!0;const EDe={toc:[]};function BDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}BDe.isMDXComponent=!0;const GDe={toc:[]};function ODe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ODe.isMDXComponent=!0;const UDe={toc:[]};function FDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}FDe.isMDXComponent=!0;const qDe={toc:[]};function VDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}VDe.isMDXComponent=!0;const jDe={toc:[]};function HDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}HDe.isMDXComponent=!0;const QDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YDe.isMDXComponent=!0;const $De={toc:[]};function KDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}KDe.isMDXComponent=!0;const JDe={toc:[]};function twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}nwe.isMDXComponent=!0;const owe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pwe.isMDXComponent=!0;const rwe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}swe.isMDXComponent=!0;const cwe={toc:[]};function iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}iwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}hwe.isMDXComponent=!0;const fwe={toc:[]};function kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kwe.isMDXComponent=!0;const ywe={toc:[]};function Mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mwe.isMDXComponent=!0;const Dwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wwe.isMDXComponent=!0;const _we={toc:[]};function Xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Xwe.isMDXComponent=!0;const gwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Twe.isMDXComponent=!0;const xwe={toc:[]};function Cwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Cwe.isMDXComponent=!0;const vwe={toc:[]};function Lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}bwe.isMDXComponent=!0;const Nwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}zwe.isMDXComponent=!0;const Awe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wwe.isMDXComponent=!0;const Rwe={toc:[]};function Iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Iwe.isMDXComponent=!0;const Pwe={toc:[]};function Swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Swe.isMDXComponent=!0;const Ewe={toc:[]};function Bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Bwe.isMDXComponent=!0;const Gwe={toc:[]};function Owe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Owe.isMDXComponent=!0;const Uwe={toc:[]};function Fwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Fwe.isMDXComponent=!0;const qwe={toc:[]};function Vwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Vwe.isMDXComponent=!0;const jwe={toc:[]};function Hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Hwe.isMDXComponent=!0;const Qwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Ywe.isMDXComponent=!0;const $we={toc:[]};function Kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}p_e.isMDXComponent=!0;const r_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}s_e.isMDXComponent=!0;const c_e={toc:[]};function i_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}i_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}h_e.isMDXComponent=!0;const f_e={toc:[]};function k_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}k_e.isMDXComponent=!0;const y_e={toc:[]};function M_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}M_e.isMDXComponent=!0;const D_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}w_e.isMDXComponent=!0;const __e={toc:[]};function X_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}X_e.isMDXComponent=!0;const g_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}T_e.isMDXComponent=!0;const x_e={toc:[]};function C_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}C_e.isMDXComponent=!0;const v_e={toc:[]};function L_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}L_e.isMDXComponent=!0;const Z_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}b_e.isMDXComponent=!0;const N_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}z_e.isMDXComponent=!0;const A_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}W_e.isMDXComponent=!0;const R_e={toc:[]};function I_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}I_e.isMDXComponent=!0;const P_e={toc:[]};function S_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}S_e.isMDXComponent=!0;const E_e={toc:[]};function B_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}B_e.isMDXComponent=!0;const G_e={toc:[]};function O_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}O_e.isMDXComponent=!0;const U_e={toc:[]};function F_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}F_e.isMDXComponent=!0;const q_e={toc:[]};function V_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}V_e.isMDXComponent=!0;const j_e={toc:[]};function H_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}H_e.isMDXComponent=!0;const Q_e={toc:[]};function Y_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Y_e.isMDXComponent=!0;const $_e={toc:[]};function K_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}K_e.isMDXComponent=!0;const J_e={toc:[]};function tXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tXe.isMDXComponent=!0;const eXe={toc:[]};function nXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nXe.isMDXComponent=!0;const oXe={toc:[]};function pXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pXe.isMDXComponent=!0;const rXe={toc:[]};function sXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sXe.isMDXComponent=!0;const cXe={toc:[]};function iXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iXe.isMDXComponent=!0;const aXe={toc:[]};function lXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lXe.isMDXComponent=!0;const uXe={toc:[]};function mXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mXe.isMDXComponent=!0;const dXe={toc:[]};function hXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hXe.isMDXComponent=!0;const fXe={toc:[]};function kXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}kXe.isMDXComponent=!0;const yXe={toc:[]};function MXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}MXe.isMDXComponent=!0;const DXe={toc:[]};function wXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wXe.isMDXComponent=!0;const _Xe={toc:[]};function XXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}XXe.isMDXComponent=!0;const gXe={toc:[]};function TXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}TXe.isMDXComponent=!0;const xXe={toc:[]};function CXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}CXe.isMDXComponent=!0;const vXe={toc:[]};function LXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LXe.isMDXComponent=!0;const ZXe={toc:[]};function bXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bXe.isMDXComponent=!0;const NXe={toc:[]};function zXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}zXe.isMDXComponent=!0;const AXe={toc:[]};function WXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WXe.isMDXComponent=!0;const RXe={toc:[]};function IXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}IXe.isMDXComponent=!0;const PXe={toc:[]};function SXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}SXe.isMDXComponent=!0;const EXe={toc:[]};function BXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BXe.isMDXComponent=!0;const GXe={toc:[]};function OXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}OXe.isMDXComponent=!0;const UXe={toc:[]};function FXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}FXe.isMDXComponent=!0;const qXe={toc:[]};function VXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VXe.isMDXComponent=!0;const jXe={toc:[]};function HXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}HXe.isMDXComponent=!0;const QXe={toc:[]};function YXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YXe.isMDXComponent=!0;const $Xe={toc:[]};function KXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}KXe.isMDXComponent=!0;const JXe={toc:[]};function tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}tge.isMDXComponent=!0;const ege={toc:[]};function nge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}nge.isMDXComponent=!0;const oge={toc:[]};function pge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pge.isMDXComponent=!0;const rge={toc:[]};function sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}sge.isMDXComponent=!0;const cge={toc:[]};function ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ige.isMDXComponent=!0;const age={toc:[]};function lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}lge.isMDXComponent=!0;const uge={toc:[]};function mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}mge.isMDXComponent=!0;const dge={toc:[]};function hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}hge.isMDXComponent=!0;const fge={toc:[]};function kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kge.isMDXComponent=!0;const yge={toc:[]};function Mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mge.isMDXComponent=!0;const Dge={toc:[]};function wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}wge.isMDXComponent=!0;const _ge={toc:[]};function Xge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Xge.isMDXComponent=!0;const gge={toc:[]};function Tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Tge.isMDXComponent=!0;const xge={toc:[]};function Cge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cge.isMDXComponent=!0;const vge={toc:[]};function Lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lge.isMDXComponent=!0;const Zge={toc:[]};function bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bge.isMDXComponent=!0;const Nge={toc:[]};function zge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}zge.isMDXComponent=!0;const Age={toc:[]};function Wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Wge.isMDXComponent=!0;const Rge={toc:[]};function Ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ige.isMDXComponent=!0;const Pge={toc:[]};function Sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Sge.isMDXComponent=!0;const Ege={toc:[]};function Bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Bge.isMDXComponent=!0;const Gge={toc:[]};function Oge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Oge.isMDXComponent=!0;const Uge={toc:[]};function Fge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fge.isMDXComponent=!0;const qge={toc:[]};function Vge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Vge.isMDXComponent=!0;const jge={toc:[]};function Hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Hge.isMDXComponent=!0;const Qge={toc:[]};function Yge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Yge.isMDXComponent=!0;const $ge={toc:[]};function Kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Kge.isMDXComponent=!0;const Jge={toc:[]};function tTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}tTe.isMDXComponent=!0;const eTe={toc:[]};function nTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nTe.isMDXComponent=!0;const oTe={toc:[]};function pTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pTe.isMDXComponent=!0;const rTe={toc:[]};function sTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}sTe.isMDXComponent=!0;const cTe={toc:[]};function iTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iTe.isMDXComponent=!0;const aTe={toc:[]};function lTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lTe.isMDXComponent=!0;const uTe={toc:[]};function mTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}mTe.isMDXComponent=!0;const dTe={toc:[]};function hTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hTe.isMDXComponent=!0;const fTe={toc:[]};function kTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kTe.isMDXComponent=!0;const yTe={toc:[]};function MTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}MTe.isMDXComponent=!0;const DTe={toc:[]};function wTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wTe.isMDXComponent=!0;const _Te={toc:[]};function XTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}XTe.isMDXComponent=!0;const gTe={toc:[]};function TTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}TTe.isMDXComponent=!0;const xTe={toc:[]};function CTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}CTe.isMDXComponent=!0;const vTe={toc:[]};function LTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LTe.isMDXComponent=!0;const ZTe={toc:[]};function bTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bTe.isMDXComponent=!0;const NTe={toc:[]};function zTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zTe.isMDXComponent=!0;const ATe={toc:[]};function WTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}WTe.isMDXComponent=!0;const RTe={toc:[]};function ITe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ITe.isMDXComponent=!0;const PTe={toc:[]};function STe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}STe.isMDXComponent=!0;const ETe={toc:[]};function BTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BTe.isMDXComponent=!0;const GTe={toc:[]};function OTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}OTe.isMDXComponent=!0;const UTe={toc:[]};function FTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FTe.isMDXComponent=!0;const qTe={toc:[]};function VTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}VTe.isMDXComponent=!0;const jTe={toc:[]};function HTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}HTe.isMDXComponent=!0;const QTe={toc:[]};function YTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}YTe.isMDXComponent=!0;const $Te={toc:[]};function KTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}KTe.isMDXComponent=!0;const JTe={toc:[]};function txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}txe.isMDXComponent=!0;const exe={toc:[]};function nxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nxe.isMDXComponent=!0;const oxe={toc:[]};function pxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pxe.isMDXComponent=!0;const rxe={toc:[]};function sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sxe.isMDXComponent=!0;const cxe={toc:[]};function ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ixe.isMDXComponent=!0;const axe={toc:[]};function lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lxe.isMDXComponent=!0;const uxe={toc:[]};function mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mxe.isMDXComponent=!0;const dxe={toc:[]};function hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hxe.isMDXComponent=!0;const fxe={toc:[]};function kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kxe.isMDXComponent=!0;const yxe={toc:[]};function Mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mxe.isMDXComponent=!0;const Dxe={toc:[]};function wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wxe.isMDXComponent=!0;const _xe={toc:[]};function Xxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Xxe.isMDXComponent=!0;const gxe={toc:[]};function Txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Txe.isMDXComponent=!0;const xxe={toc:[]};function Cxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Cxe.isMDXComponent=!0;const vxe={toc:[]};function Lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]};function bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bxe.isMDXComponent=!0;const Nxe={toc:[]};function zxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}zxe.isMDXComponent=!0;const Axe={toc:[]};function Wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Wxe.isMDXComponent=!0;const Rxe={toc:[]};function Ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ixe.isMDXComponent=!0;const Pxe={toc:[]};function Sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Sxe.isMDXComponent=!0;const Exe={toc:[]};function Bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Bxe.isMDXComponent=!0;const Gxe={toc:[]};function Oxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Oxe.isMDXComponent=!0;const Uxe={toc:[]};function Fxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fxe.isMDXComponent=!0;const qxe={toc:[]};function Vxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Vxe.isMDXComponent=!0;const jxe={toc:[]};function Hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Hxe.isMDXComponent=!0;const Qxe={toc:[]};function Yxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Yxe.isMDXComponent=!0;const $xe={toc:[]};function Kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]};function tCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tCe.isMDXComponent=!0;const eCe={toc:[]};function nCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nCe.isMDXComponent=!0;const oCe={toc:[]};function pCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pCe.isMDXComponent=!0;const rCe={toc:[]};function sCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sCe.isMDXComponent=!0;const cCe={toc:[]};function iCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iCe.isMDXComponent=!0;const aCe={toc:[]};function lCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}lCe.isMDXComponent=!0;const uCe={toc:[]};function mCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mCe.isMDXComponent=!0;const dCe={toc:[]};function hCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hCe.isMDXComponent=!0;const fCe={toc:[]};function kCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kCe.isMDXComponent=!0;const yCe={toc:[]};function MCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MCe.isMDXComponent=!0;const DCe={toc:[]};function wCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}wCe.isMDXComponent=!0;const _Ce={toc:[]};function XCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}XCe.isMDXComponent=!0;const gCe={toc:[]};function TCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}TCe.isMDXComponent=!0;const xCe={toc:[]};function CCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CCe.isMDXComponent=!0;const vCe={toc:[]};function LCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LCe.isMDXComponent=!0;const ZCe={toc:[]};function bCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bCe.isMDXComponent=!0;const NCe={toc:[]};function zCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zCe.isMDXComponent=!0;const ACe={toc:[]};function WCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WCe.isMDXComponent=!0;const RCe={toc:[]};function ICe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ICe.isMDXComponent=!0;const PCe={toc:[]};function SCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}SCe.isMDXComponent=!0;const ECe={toc:[]};function BCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}BCe.isMDXComponent=!0;const GCe={toc:[]};function OCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}OCe.isMDXComponent=!0;const UCe={toc:[]};function FCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}FCe.isMDXComponent=!0;const qCe={toc:[]};function VCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VCe.isMDXComponent=!0;const jCe={toc:[]};function HCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HCe.isMDXComponent=!0;const QCe={toc:[]};function YCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YCe.isMDXComponent=!0;const $Ce={toc:[]};function KCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KCe.isMDXComponent=!0;const JCe={toc:[]};function tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}tve.isMDXComponent=!0;const eve={toc:[]};function nve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}nve.isMDXComponent=!0;const ove={toc:[]};function pve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pve.isMDXComponent=!0;const rve={toc:[]};function sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sve.isMDXComponent=!0;const cve={toc:[]};function ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ive.isMDXComponent=!0;const ave={toc:[]};function lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lve.isMDXComponent=!0;const uve={toc:[]};function mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mve.isMDXComponent=!0;const dve={toc:[]};function hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hve.isMDXComponent=!0;const fve={toc:[]};function kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kve.isMDXComponent=!0;const yve={toc:[]};function Mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Mve.isMDXComponent=!0;const Dve={toc:[]};function wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wve.isMDXComponent=!0;const _ve={toc:[]};function Xve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Xve.isMDXComponent=!0;const gve={toc:[]};function Tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tve.isMDXComponent=!0;const xve={toc:[]};function Cve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Cve.isMDXComponent=!0;const vve={toc:[]};function Lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lve.isMDXComponent=!0;const Zve={toc:[]};function bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bve.isMDXComponent=!0;const Nve={toc:[]};function zve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}zve.isMDXComponent=!0;const Ave={toc:[]};function Wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Wve.isMDXComponent=!0;const Rve={toc:[]};function Ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ive.isMDXComponent=!0;const Pve={toc:[]};function Sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Sve.isMDXComponent=!0;const Eve={toc:[]};function Bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Bve.isMDXComponent=!0;const Gve={toc:[]};function Ove(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ove.isMDXComponent=!0;const Uve={toc:[]};function Fve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Fve.isMDXComponent=!0;const qve={toc:[]};function Vve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Vve.isMDXComponent=!0;const jve={toc:[]};function Hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hve.isMDXComponent=!0;const Qve={toc:[]};function Yve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yve.isMDXComponent=!0;const $ve={toc:[]};function Kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kve.isMDXComponent=!0;const Jve={toc:[]};function tLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tLe.isMDXComponent=!0;const eLe={toc:[]};function nLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nLe.isMDXComponent=!0;const oLe={toc:[]};function pLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pLe.isMDXComponent=!0;const rLe={toc:[]};function sLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sLe.isMDXComponent=!0;const cLe={toc:[]};function iLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iLe.isMDXComponent=!0;const aLe={toc:[]};function lLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lLe.isMDXComponent=!0;const uLe={toc:[]};function mLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mLe.isMDXComponent=!0;const dLe={toc:[]};function hLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hLe.isMDXComponent=!0;const fLe={toc:[]};function kLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kLe.isMDXComponent=!0;const yLe={toc:[]};function MLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MLe.isMDXComponent=!0;const DLe={toc:[]};function wLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wLe.isMDXComponent=!0;const _Le={toc:[]};function XLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XLe.isMDXComponent=!0;const gLe={toc:[]};function TLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}TLe.isMDXComponent=!0;const xLe={toc:[]};function CLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}CLe.isMDXComponent=!0;const vLe={toc:[]};function LLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LLe.isMDXComponent=!0;const ZLe={toc:[]};function bLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bLe.isMDXComponent=!0;const NLe={toc:[]};function zLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zLe.isMDXComponent=!0;const ALe={toc:[]};function WLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WLe.isMDXComponent=!0;const RLe={toc:[]};function ILe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ILe.isMDXComponent=!0;const PLe={toc:[]};function SLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SLe.isMDXComponent=!0;const ELe={toc:[]};function BLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BLe.isMDXComponent=!0;const GLe={toc:[]};function OLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}OLe.isMDXComponent=!0;const ULe={toc:[]};function FLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FLe.isMDXComponent=!0;const qLe={toc:[]};function VLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}VLe.isMDXComponent=!0;const jLe={toc:[]};function HLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HLe.isMDXComponent=!0;const QLe={toc:[]};function YLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YLe.isMDXComponent=!0;const $Le={toc:[]};function KLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KLe.isMDXComponent=!0;const JLe={toc:[]};function tZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tZe.isMDXComponent=!0;const eZe={toc:[]};function nZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nZe.isMDXComponent=!0;const oZe={toc:[]};function pZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pZe.isMDXComponent=!0;const rZe={toc:[]};function sZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sZe.isMDXComponent=!0;const cZe={toc:[]};function iZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iZe.isMDXComponent=!0;const aZe={toc:[]};function lZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lZe.isMDXComponent=!0;const uZe={toc:[]};function mZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mZe.isMDXComponent=!0;const dZe={toc:[]};function hZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hZe.isMDXComponent=!0;const fZe={toc:[]};function kZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kZe.isMDXComponent=!0;const yZe={toc:[]};function MZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}MZe.isMDXComponent=!0;const DZe={toc:[]};function wZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wZe.isMDXComponent=!0;const _Ze={toc:[]};function XZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}XZe.isMDXComponent=!0;const gZe={toc:[]};function TZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TZe.isMDXComponent=!0;const xZe={toc:[]};function CZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}CZe.isMDXComponent=!0;const vZe={toc:[]};function LZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LZe.isMDXComponent=!0;const ZZe={toc:[]};function bZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}bZe.isMDXComponent=!0;const NZe={toc:[]};function zZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zZe.isMDXComponent=!0;const AZe={toc:[]};function WZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}WZe.isMDXComponent=!0;const RZe={toc:[]};function IZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IZe.isMDXComponent=!0;const PZe={toc:[]};function SZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}SZe.isMDXComponent=!0;const EZe={toc:[]};function BZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BZe.isMDXComponent=!0;const GZe={toc:[]};function OZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}OZe.isMDXComponent=!0;const UZe={toc:[]};function FZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FZe.isMDXComponent=!0;const qZe={toc:[]};function VZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VZe.isMDXComponent=!0;const jZe={toc:[]};function HZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HZe.isMDXComponent=!0;const QZe={toc:[]};function YZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}YZe.isMDXComponent=!0;const $Ze={toc:[]};function KZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KZe.isMDXComponent=!0;const JZe={toc:[]};function tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tbe.isMDXComponent=!0;const ebe={toc:[]};function nbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nbe.isMDXComponent=!0;const obe={toc:[]};function pbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pbe.isMDXComponent=!0;const rbe={toc:[]};function sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sbe.isMDXComponent=!0;const cbe={toc:[]};function ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ibe.isMDXComponent=!0;const abe={toc:[]};function lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lbe.isMDXComponent=!0;const ube={toc:[]};function mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mbe.isMDXComponent=!0;const dbe={toc:[]};function hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}hbe.isMDXComponent=!0;const fbe={toc:[]};function kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}kbe.isMDXComponent=!0;const ybe={toc:[]};function Mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mbe.isMDXComponent=!0;const Dbe={toc:[]};function wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wbe.isMDXComponent=!0;const _be={toc:[]};function Xbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xbe.isMDXComponent=!0;const gbe={toc:[]};function Tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tbe.isMDXComponent=!0;const xbe={toc:[]};function Cbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cbe.isMDXComponent=!0;const vbe={toc:[]};function Lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]};function bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}bbe.isMDXComponent=!0;const Nbe={toc:[]};function zbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}zbe.isMDXComponent=!0;const Abe={toc:[]};function Wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Wbe.isMDXComponent=!0;const Rbe={toc:[]};function Ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ibe.isMDXComponent=!0;const Pbe={toc:[]};function Sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Sbe.isMDXComponent=!0;const Ebe={toc:[]};function Bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Bbe.isMDXComponent=!0;const Gbe={toc:[]};function Obe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Obe.isMDXComponent=!0;const Ube={toc:[]};function Fbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fbe.isMDXComponent=!0;const qbe={toc:[]};function Vbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Vbe.isMDXComponent=!0;const jbe={toc:[]};function Hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Hbe.isMDXComponent=!0;const Qbe={toc:[]};function Ybe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ybe.isMDXComponent=!0;const $be={toc:[]};function Kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]};function tNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}tNe.isMDXComponent=!0;const eNe={toc:[]};function nNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}nNe.isMDXComponent=!0;const oNe={toc:[]};function pNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pNe.isMDXComponent=!0;const rNe={toc:[]};function sNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}sNe.isMDXComponent=!0;const cNe={toc:[]};function iNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}iNe.isMDXComponent=!0;const aNe={toc:[]};function lNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lNe.isMDXComponent=!0;const uNe={toc:[]};function mNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mNe.isMDXComponent=!0;const dNe={toc:[]};function hNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hNe.isMDXComponent=!0;const fNe={toc:[]};function kNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kNe.isMDXComponent=!0;const yNe={toc:[]};function MNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MNe.isMDXComponent=!0;const DNe={toc:[]};function wNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wNe.isMDXComponent=!0;const _Ne={toc:[]};function XNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}XNe.isMDXComponent=!0;const gNe={toc:[]};function TNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}TNe.isMDXComponent=!0;const xNe={toc:[]};function CNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CNe.isMDXComponent=!0;const vNe={toc:[]};function LNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LNe.isMDXComponent=!0;const ZNe={toc:[]};function bNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bNe.isMDXComponent=!0;const NNe={toc:[]};function zNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zNe.isMDXComponent=!0;const ANe={toc:[]};function WNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WNe.isMDXComponent=!0;const RNe={toc:[]};function INe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}INe.isMDXComponent=!0;const PNe={toc:[]};function SNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}SNe.isMDXComponent=!0;const ENe={toc:[]};function BNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}BNe.isMDXComponent=!0;const GNe={toc:[]};function ONe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ONe.isMDXComponent=!0;const UNe={toc:[]};function FNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}FNe.isMDXComponent=!0;const qNe={toc:[]};function VNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}VNe.isMDXComponent=!0;const jNe={toc:[]};function HNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}HNe.isMDXComponent=!0;const QNe={toc:[]};function YNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YNe.isMDXComponent=!0;const $Ne={toc:[]};function KNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KNe.isMDXComponent=!0;const JNe={toc:[]};function tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}tze.isMDXComponent=!0;const eze={toc:[]};function nze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}nze.isMDXComponent=!0;const oze={toc:[]};function pze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pze.isMDXComponent=!0;const rze={toc:[]};function sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}sze.isMDXComponent=!0;const cze={toc:[]};function ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}ize.isMDXComponent=!0;const aze={toc:[]};function lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lze.isMDXComponent=!0;const uze={toc:[]};function mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mze.isMDXComponent=!0;const dze={toc:[]};function hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hze.isMDXComponent=!0;const fze={toc:[]};function kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kze.isMDXComponent=!0;const yze={toc:[]};function Mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mze.isMDXComponent=!0;const Dze={toc:[]};function wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wze.isMDXComponent=!0;const _ze={toc:[]};function Xze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Xze.isMDXComponent=!0;const gze={toc:[]};function Tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Tze.isMDXComponent=!0;const xze={toc:[]};function Cze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Cze.isMDXComponent=!0;const vze={toc:[]};function Lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Lze.isMDXComponent=!0;const Zze={toc:[]};function bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}bze.isMDXComponent=!0;const Nze={toc:[]};function zze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}zze.isMDXComponent=!0;const Aze={toc:[]};function Wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Wze.isMDXComponent=!0;const Rze={toc:[]};function Ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Ize.isMDXComponent=!0;const Pze={toc:[]};function Sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sze.isMDXComponent=!0;const Eze={toc:[]};function Bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bze.isMDXComponent=!0;const Gze={toc:[]};function Oze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oze.isMDXComponent=!0;const Uze={toc:[]};function Fze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Fze.isMDXComponent=!0;const qze={toc:[]};function Vze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vze.isMDXComponent=!0;const jze={toc:[]};function Hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Hze.isMDXComponent=!0;const Qze={toc:[]};function Yze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Yze.isMDXComponent=!0;const $ze={toc:[]};function Kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Kze.isMDXComponent=!0;const Jze={toc:[]};function tAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tAe.isMDXComponent=!0;const eAe={toc:[]};function nAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nAe.isMDXComponent=!0;const oAe={toc:[]};function pAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pAe.isMDXComponent=!0;const rAe={toc:[]};function sAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sAe.isMDXComponent=!0;const cAe={toc:[]};function iAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iAe.isMDXComponent=!0;const aAe={toc:[]};function lAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lAe.isMDXComponent=!0;const uAe={toc:[]};function mAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mAe.isMDXComponent=!0;const dAe={toc:[]};function hAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hAe.isMDXComponent=!0;const fAe={toc:[]};function kAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kAe.isMDXComponent=!0;const yAe={toc:[]};function MAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}MAe.isMDXComponent=!0;const DAe={toc:[]};function wAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}wAe.isMDXComponent=!0;const _Ae={toc:[]};function XAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XAe.isMDXComponent=!0;const gAe={toc:[]};function TAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}TAe.isMDXComponent=!0;const xAe={toc:[]};function CAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CAe.isMDXComponent=!0;const vAe={toc:[]};function LAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LAe.isMDXComponent=!0;const ZAe={toc:[]};function bAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bAe.isMDXComponent=!0;const NAe={toc:[]};function zAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zAe.isMDXComponent=!0;const AAe={toc:[]};function WAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WAe.isMDXComponent=!0;const RAe={toc:[]};function IAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}IAe.isMDXComponent=!0;const PAe={toc:[]};function SAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SAe.isMDXComponent=!0;const EAe={toc:[]};function BAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}BAe.isMDXComponent=!0;const GAe={toc:[]};function OAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OAe.isMDXComponent=!0;const UAe={toc:[]};function FAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}FAe.isMDXComponent=!0;const qAe={toc:[]};function VAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VAe.isMDXComponent=!0;const jAe={toc:[]};function HAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HAe.isMDXComponent=!0;const QAe={toc:[]};function YAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YAe.isMDXComponent=!0;const $Ae={toc:[]};function KAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KAe.isMDXComponent=!0;const JAe={toc:[]};function tWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tWe.isMDXComponent=!0;const eWe={toc:[]};function nWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}nWe.isMDXComponent=!0;const oWe={toc:[]};function pWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pWe.isMDXComponent=!0;const rWe={toc:[]};function sWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}sWe.isMDXComponent=!0;const cWe={toc:[]};function iWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iWe.isMDXComponent=!0;const aWe={toc:[]};function lWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lWe.isMDXComponent=!0;const uWe={toc:[]};function mWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}mWe.isMDXComponent=!0;const dWe={toc:[]};function hWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}hWe.isMDXComponent=!0;const fWe={toc:[]};function kWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kWe.isMDXComponent=!0;const yWe={toc:[]};function MWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}MWe.isMDXComponent=!0;const DWe={toc:[]};function wWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wWe.isMDXComponent=!0;const _We={toc:[]};function XWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}XWe.isMDXComponent=!0;const gWe={toc:[]};function TWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TWe.isMDXComponent=!0;const xWe={toc:[]};function CWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}CWe.isMDXComponent=!0;const vWe={toc:[]};function LWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}LWe.isMDXComponent=!0;const ZWe={toc:[]};function bWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}bWe.isMDXComponent=!0;const NWe={toc:[]};function zWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zWe.isMDXComponent=!0;const AWe={toc:[]};function WWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}WWe.isMDXComponent=!0;const RWe={toc:[]};function IWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}IWe.isMDXComponent=!0;const PWe={toc:[]};function SWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}SWe.isMDXComponent=!0;const EWe={toc:[]};function BWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}BWe.isMDXComponent=!0;const GWe={toc:[]};function OWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OWe.isMDXComponent=!0;const UWe={toc:[]};function FWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FWe.isMDXComponent=!0;const qWe={toc:[]};function VWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}VWe.isMDXComponent=!0;const jWe={toc:[]};function HWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HWe.isMDXComponent=!0;const QWe={toc:[]};function YWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}YWe.isMDXComponent=!0;const $We={toc:[]};function KWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KWe.isMDXComponent=!0;const JWe={toc:[]};function tRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}tRe.isMDXComponent=!0;const eRe={toc:[]};function nRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nRe.isMDXComponent=!0;const oRe={toc:[]};function pRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pRe.isMDXComponent=!0;const rRe={toc:[]};function sRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}sRe.isMDXComponent=!0;const cRe={toc:[]};function iRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}iRe.isMDXComponent=!0;const aRe={toc:[]};function lRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lRe.isMDXComponent=!0;const uRe={toc:[]};function mRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mRe.isMDXComponent=!0;const dRe={toc:[]};function hRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hRe.isMDXComponent=!0;const fRe={toc:[]};function kRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kRe.isMDXComponent=!0;const yRe={toc:[]};function MRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MRe.isMDXComponent=!0;const DRe={toc:[]};function wRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wRe.isMDXComponent=!0;const _Re={toc:[]};function XRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}XRe.isMDXComponent=!0;const gRe={toc:[]};function TRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}TRe.isMDXComponent=!0;const xRe={toc:[]};function CRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CRe.isMDXComponent=!0;const vRe={toc:[]};function LRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LRe.isMDXComponent=!0;const ZRe={toc:[]};function bRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bRe.isMDXComponent=!0;const NRe={toc:[]};function zRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zRe.isMDXComponent=!0;const ARe={toc:[]};function WRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WRe.isMDXComponent=!0;const RRe={toc:[]};function IRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}IRe.isMDXComponent=!0;const PRe={toc:[]};function SRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}SRe.isMDXComponent=!0;const ERe={toc:[]};function BRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}BRe.isMDXComponent=!0;const GRe={toc:[]};function ORe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ORe.isMDXComponent=!0;const URe={toc:[]};function FRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}FRe.isMDXComponent=!0;const qRe={toc:[]};function VRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}VRe.isMDXComponent=!0;const jRe={toc:[]};function HRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}HRe.isMDXComponent=!0;const QRe={toc:[]};function YRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}YRe.isMDXComponent=!0;const $Re={toc:[]};function KRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}KRe.isMDXComponent=!0;const JRe={toc:[]};function tIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tIe.isMDXComponent=!0;const eIe={toc:[]};function nIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nIe.isMDXComponent=!0;const oIe={toc:[]};function pIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pIe.isMDXComponent=!0;const rIe={toc:[]};function sIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}sIe.isMDXComponent=!0;const cIe={toc:[]};function iIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iIe.isMDXComponent=!0;const aIe={toc:[]};function lIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lIe.isMDXComponent=!0;const uIe={toc:[]};function mIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mIe.isMDXComponent=!0;const dIe={toc:[]};function hIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}hIe.isMDXComponent=!0;const fIe={toc:[]};function kIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kIe.isMDXComponent=!0;const yIe={toc:[]};function MIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}MIe.isMDXComponent=!0;const DIe={toc:[]};function wIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wIe.isMDXComponent=!0;const _Ie={toc:[]};function XIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}XIe.isMDXComponent=!0;const gIe={toc:[]};function TIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TIe.isMDXComponent=!0;const xIe={toc:[]};function CIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}CIe.isMDXComponent=!0;const vIe={toc:[]};function LIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LIe.isMDXComponent=!0;const ZIe={toc:[]};function bIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bIe.isMDXComponent=!0;const NIe={toc:[]};function zIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zIe.isMDXComponent=!0;const AIe={toc:[]};function WIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}WIe.isMDXComponent=!0;const RIe={toc:[]};function IIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IIe.isMDXComponent=!0;const PIe={toc:[]};function SIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}SIe.isMDXComponent=!0;const EIe={toc:[]};function BIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BIe.isMDXComponent=!0;const GIe={toc:[]};function OIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}OIe.isMDXComponent=!0;const UIe={toc:[]};function FIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FIe.isMDXComponent=!0;const qIe={toc:[]};function VIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}VIe.isMDXComponent=!0;const jIe={toc:[]};function HIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HIe.isMDXComponent=!0;const QIe={toc:[]};function YIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}YIe.isMDXComponent=!0;const $Ie={toc:[]};function KIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}KIe.isMDXComponent=!0;const JIe={toc:[]};function tPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}tPe.isMDXComponent=!0;const ePe={toc:[]};function nPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nPe.isMDXComponent=!0;const oPe={toc:[]};function pPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pPe.isMDXComponent=!0;const rPe={toc:[]};function sPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sPe.isMDXComponent=!0;const cPe={toc:[]};function iPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}iPe.isMDXComponent=!0;const aPe={toc:[]};function lPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lPe.isMDXComponent=!0;const uPe={toc:[]};function mPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mPe.isMDXComponent=!0;const dPe={toc:[]};function hPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}hPe.isMDXComponent=!0;const fPe={toc:[]};function kPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}kPe.isMDXComponent=!0;const yPe={toc:[]};function MPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MPe.isMDXComponent=!0;const DPe={toc:[]};function wPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wPe.isMDXComponent=!0;const _Pe={toc:[]};function XPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XPe.isMDXComponent=!0;const gPe={toc:[]};function TPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}TPe.isMDXComponent=!0;const xPe={toc:[]};function CPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CPe.isMDXComponent=!0;const vPe={toc:[]};function LPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LPe.isMDXComponent=!0;const ZPe={toc:[]};function bPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}bPe.isMDXComponent=!0;const NPe={toc:[]};function zPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}zPe.isMDXComponent=!0;const APe={toc:[]};function WPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WPe.isMDXComponent=!0;const RPe={toc:[]};function IPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}IPe.isMDXComponent=!0;const PPe={toc:[]};function SPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SPe.isMDXComponent=!0;const EPe={toc:[]};function BPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}BPe.isMDXComponent=!0;const GPe={toc:[]};function OPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}OPe.isMDXComponent=!0;const UPe={toc:[]};function FPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}FPe.isMDXComponent=!0;const qPe={toc:[]};function VPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VPe.isMDXComponent=!0;const jPe={toc:[]};function HPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HPe.isMDXComponent=!0;const QPe={toc:[]};function YPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YPe.isMDXComponent=!0;const $Pe={toc:[]};function KPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KPe.isMDXComponent=!0;const JPe={toc:[]};function tSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tSe.isMDXComponent=!0;const eSe={toc:[]};function nSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nSe.isMDXComponent=!0;const oSe={toc:[]};function pSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pSe.isMDXComponent=!0;const rSe={toc:[]};function sSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}sSe.isMDXComponent=!0;const cSe={toc:[]};function iSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}iSe.isMDXComponent=!0;const aSe={toc:[]};function lSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lSe.isMDXComponent=!0;const uSe={toc:[]};function mSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mSe.isMDXComponent=!0;const dSe={toc:[]};function hSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hSe.isMDXComponent=!0;const fSe={toc:[]};function kSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kSe.isMDXComponent=!0;const ySe={toc:[]};function MSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}MSe.isMDXComponent=!0;const DSe={toc:[]};function wSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wSe.isMDXComponent=!0;const _Se={toc:[]};function XSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}XSe.isMDXComponent=!0;const gSe={toc:[]};function TSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}TSe.isMDXComponent=!0;const xSe={toc:[]};function CSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}CSe.isMDXComponent=!0;const vSe={toc:[]};function LSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LSe.isMDXComponent=!0;const ZSe={toc:[]};function bSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bSe.isMDXComponent=!0;const NSe={toc:[]};function zSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zSe.isMDXComponent=!0;const ASe={toc:[]};function WSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WSe.isMDXComponent=!0;const RSe={toc:[]};function ISe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ISe.isMDXComponent=!0;const PSe={toc:[]};function SSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}SSe.isMDXComponent=!0;const ESe={toc:[]};function BSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}BSe.isMDXComponent=!0;const GSe={toc:[]};function OSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}OSe.isMDXComponent=!0;const USe={toc:[]};function FSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FSe.isMDXComponent=!0;const qSe={toc:[]};function VSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}VSe.isMDXComponent=!0;const jSe={toc:[]};function HSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}HSe.isMDXComponent=!0;const QSe={toc:[]};function YSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}YSe.isMDXComponent=!0;const $Se={toc:[]};function KSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}KSe.isMDXComponent=!0;const JSe={toc:[]};function tEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tEe.isMDXComponent=!0;const eEe={toc:[]};function nEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}nEe.isMDXComponent=!0;const oEe={toc:[]};function pEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pEe.isMDXComponent=!0;const rEe={toc:[]};function sEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sEe.isMDXComponent=!0;const cEe={toc:[]};function iEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iEe.isMDXComponent=!0;const aEe={toc:[]};function lEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lEe.isMDXComponent=!0;const uEe={toc:[]};function mEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mEe.isMDXComponent=!0;const dEe={toc:[]};function hEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hEe.isMDXComponent=!0;const fEe={toc:[]};function kEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kEe.isMDXComponent=!0;const yEe={toc:[]};function MEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}MEe.isMDXComponent=!0;const DEe={toc:[]};function wEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wEe.isMDXComponent=!0;const _Ee={toc:[]};function XEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}XEe.isMDXComponent=!0;const gEe={toc:[]};function TEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}TEe.isMDXComponent=!0;const xEe={toc:[]};function CEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CEe.isMDXComponent=!0;const vEe={toc:[]};function LEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LEe.isMDXComponent=!0;const ZEe={toc:[]};function bEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bEe.isMDXComponent=!0;const NEe={toc:[]};function zEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}zEe.isMDXComponent=!0;const AEe={toc:[]};function WEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WEe.isMDXComponent=!0;const REe={toc:[]};function IEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}IEe.isMDXComponent=!0;const PEe={toc:[]};function SEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SEe.isMDXComponent=!0;const EEe={toc:[]};function BEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}BEe.isMDXComponent=!0;const GEe={toc:[]};function OEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OEe.isMDXComponent=!0;const UEe={toc:[]};function FEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FEe.isMDXComponent=!0;const qEe={toc:[]};function VEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VEe.isMDXComponent=!0;const jEe={toc:[]};function HEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HEe.isMDXComponent=!0;const QEe={toc:[]};function YEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YEe.isMDXComponent=!0;const $Ee={toc:[]};function KEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}KEe.isMDXComponent=!0;const JEe={toc:[]};function tBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tBe.isMDXComponent=!0;const eBe={toc:[]};function nBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nBe.isMDXComponent=!0;const oBe={toc:[]};function pBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pBe.isMDXComponent=!0;const rBe={toc:[]};function sBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sBe.isMDXComponent=!0;const cBe={toc:[]};function iBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iBe.isMDXComponent=!0;const aBe={toc:[]};function lBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lBe.isMDXComponent=!0;const uBe={toc:[]};function mBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mBe.isMDXComponent=!0;const dBe={toc:[]};function hBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hBe.isMDXComponent=!0;const fBe={toc:[]};function kBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kBe.isMDXComponent=!0;const yBe={toc:[]};function MBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MBe.isMDXComponent=!0;const DBe={toc:[]};function wBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wBe.isMDXComponent=!0;const _Be={toc:[]};function XBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}XBe.isMDXComponent=!0;const gBe={toc:[]};function TBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TBe.isMDXComponent=!0;const xBe={toc:[]};function CBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}CBe.isMDXComponent=!0;const vBe={toc:[]};function LBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LBe.isMDXComponent=!0;const ZBe={toc:[]};function bBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bBe.isMDXComponent=!0;const NBe={toc:[]};function zBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zBe.isMDXComponent=!0;const ABe={toc:[]};function WBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WBe.isMDXComponent=!0;const RBe={toc:[]};function IBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IBe.isMDXComponent=!0;const PBe={toc:[]};function SBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}SBe.isMDXComponent=!0;const EBe={toc:[]};function BBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BBe.isMDXComponent=!0;const GBe={toc:[]};function OBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}OBe.isMDXComponent=!0;const UBe={toc:[]};function FBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FBe.isMDXComponent=!0;const qBe={toc:[]};function VBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}VBe.isMDXComponent=!0;const jBe={toc:[]};function HBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HBe.isMDXComponent=!0;const QBe={toc:[]};function YBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}YBe.isMDXComponent=!0;const $Be={toc:[]};function KBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KBe.isMDXComponent=!0;const JBe={toc:[]};function tGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tGe.isMDXComponent=!0;const eGe={toc:[]};function nGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nGe.isMDXComponent=!0;const oGe={toc:[]};function pGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pGe.isMDXComponent=!0;const rGe={toc:[]};function sGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}sGe.isMDXComponent=!0;const cGe={toc:[]};function iGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}iGe.isMDXComponent=!0;const aGe={toc:[]};function lGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lGe.isMDXComponent=!0;const uGe={toc:[]};function mGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mGe.isMDXComponent=!0;const dGe={toc:[]};function hGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hGe.isMDXComponent=!0;const fGe={toc:[]};function kGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kGe.isMDXComponent=!0;const yGe={toc:[]};function MGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MGe.isMDXComponent=!0;const DGe={toc:[]};function wGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wGe.isMDXComponent=!0;const _Ge={toc:[]};function XGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}XGe.isMDXComponent=!0;const gGe={toc:[]};function TGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}TGe.isMDXComponent=!0;const xGe={toc:[]};function CGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CGe.isMDXComponent=!0;const vGe={toc:[]};function LGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LGe.isMDXComponent=!0;const ZGe={toc:[]};function bGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bGe.isMDXComponent=!0;const NGe={toc:[]};function zGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}zGe.isMDXComponent=!0;const AGe={toc:[]};function WGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WGe.isMDXComponent=!0;const RGe={toc:[]};function IGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}IGe.isMDXComponent=!0;const PGe={toc:[]};function SGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SGe.isMDXComponent=!0;const EGe={toc:[]};function BGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}BGe.isMDXComponent=!0;const GGe={toc:[]};function OGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}OGe.isMDXComponent=!0;const UGe={toc:[]};function FGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FGe.isMDXComponent=!0;const qGe={toc:[]};function VGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}VGe.isMDXComponent=!0;const jGe={toc:[]};function HGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}HGe.isMDXComponent=!0;const QGe={toc:[]};function YGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}YGe.isMDXComponent=!0;const $Ge={toc:[]};function KGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KGe.isMDXComponent=!0;const JGe={toc:[]};function tOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}tOe.isMDXComponent=!0;const eOe={toc:[]};function nOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nOe.isMDXComponent=!0;const oOe={toc:[]};function pOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pOe.isMDXComponent=!0;const rOe={toc:[]};function sOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}sOe.isMDXComponent=!0;const cOe={toc:[]};function iOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}iOe.isMDXComponent=!0;const aOe={toc:[]};function lOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lOe.isMDXComponent=!0;const uOe={toc:[]};function mOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mOe.isMDXComponent=!0;const dOe={toc:[]};function hOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hOe.isMDXComponent=!0;const fOe={toc:[]};function kOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kOe.isMDXComponent=!0;const yOe={toc:[]};function MOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MOe.isMDXComponent=!0;const DOe={toc:[]};function wOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wOe.isMDXComponent=!0;const _Oe={toc:[]};function XOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XOe.isMDXComponent=!0;const gOe={toc:[]};function TOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}TOe.isMDXComponent=!0;const xOe={toc:[]};function COe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}COe.isMDXComponent=!0;const vOe={toc:[]};function LOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LOe.isMDXComponent=!0;const ZOe={toc:[]};function bOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bOe.isMDXComponent=!0;const NOe={toc:[]};function zOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zOe.isMDXComponent=!0;const AOe={toc:[]};function WOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WOe.isMDXComponent=!0;const ROe={toc:[]};function IOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}IOe.isMDXComponent=!0;const POe={toc:[]};function SOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SOe.isMDXComponent=!0;const EOe={toc:[]};function BOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BOe.isMDXComponent=!0;const GOe={toc:[]};function OOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OOe.isMDXComponent=!0;const UOe={toc:[]};function FOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}FOe.isMDXComponent=!0;const qOe={toc:[]};function VOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VOe.isMDXComponent=!0;const jOe={toc:[]};function HOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}HOe.isMDXComponent=!0;const QOe={toc:[]};function YOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YOe.isMDXComponent=!0;const $Oe={toc:[]};function KOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KOe.isMDXComponent=!0;const JOe={toc:[]};function tUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}tUe.isMDXComponent=!0;const eUe={toc:[]};function nUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}nUe.isMDXComponent=!0;const oUe={toc:[]};function pUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pUe.isMDXComponent=!0;const rUe={toc:[]};function sUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sUe.isMDXComponent=!0;const cUe={toc:[]};function iUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iUe.isMDXComponent=!0;const aUe={toc:[]};function lUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lUe.isMDXComponent=!0;const uUe={toc:[]};function mUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mUe.isMDXComponent=!0;const dUe={toc:[]};function hUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hUe.isMDXComponent=!0;const fUe={toc:[]};function kUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}kUe.isMDXComponent=!0;const yUe={toc:[]};function MUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}MUe.isMDXComponent=!0;const DUe={toc:[]};function wUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wUe.isMDXComponent=!0;const _Ue={toc:[]};function XUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}XUe.isMDXComponent=!0;const gUe={toc:[]};function TUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}TUe.isMDXComponent=!0;const xUe={toc:[]};function CUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}CUe.isMDXComponent=!0;const vUe={toc:[]};function LUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}LUe.isMDXComponent=!0;const ZUe={toc:[]};function bUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bUe.isMDXComponent=!0;const NUe={toc:[]};function zUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zUe.isMDXComponent=!0;const AUe={toc:[]};function WUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}WUe.isMDXComponent=!0;const RUe={toc:[]};function IUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}IUe.isMDXComponent=!0;const PUe={toc:[]};function SUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}SUe.isMDXComponent=!0;const EUe={toc:[]};function BUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}BUe.isMDXComponent=!0;const GUe={toc:[]};function OUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}OUe.isMDXComponent=!0;const UUe={toc:[]};function FUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}FUe.isMDXComponent=!0;const qUe={toc:[]};function VUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VUe.isMDXComponent=!0;const jUe={toc:[]};function HUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}HUe.isMDXComponent=!0;const QUe={toc:[]};function YUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YUe.isMDXComponent=!0;const $Ue={toc:[]};function KUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KUe.isMDXComponent=!0;const JUe={toc:[]};function tFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tFe.isMDXComponent=!0;const eFe={toc:[]};function nFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nFe.isMDXComponent=!0;const oFe={toc:[]};function pFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pFe.isMDXComponent=!0;const rFe={toc:[]};function sFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sFe.isMDXComponent=!0;const cFe={toc:[]};function iFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iFe.isMDXComponent=!0;const aFe={toc:[]};function lFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lFe.isMDXComponent=!0;const uFe={toc:[]};function mFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mFe.isMDXComponent=!0;const dFe={toc:[]};function hFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hFe.isMDXComponent=!0;const fFe={toc:[]};function kFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}kFe.isMDXComponent=!0;const yFe={toc:[]};function MFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}MFe.isMDXComponent=!0;const DFe={toc:[]};function wFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wFe.isMDXComponent=!0;const _Fe={toc:[]};function XFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}XFe.isMDXComponent=!0;const gFe={toc:[]};function TFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}TFe.isMDXComponent=!0;const xFe={toc:[]};function CFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}CFe.isMDXComponent=!0;const vFe={toc:[]};function LFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LFe.isMDXComponent=!0;const ZFe={toc:[]};function bFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}bFe.isMDXComponent=!0;const NFe={toc:[]};function zFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}zFe.isMDXComponent=!0;const AFe={toc:[]};function WFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}WFe.isMDXComponent=!0;const RFe={toc:[]};function IFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IFe.isMDXComponent=!0;const PFe={toc:[]};function SFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SFe.isMDXComponent=!0;const EFe={toc:[]};function BFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BFe.isMDXComponent=!0;const GFe={toc:[]};function OFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OFe.isMDXComponent=!0;const UFe={toc:[]};function FFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FFe.isMDXComponent=!0;const qFe={toc:[]};function VFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VFe.isMDXComponent=!0;const jFe={toc:[]};function HFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}HFe.isMDXComponent=!0;const QFe={toc:[]};function YFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}YFe.isMDXComponent=!0;const $Fe={toc:[]};function KFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}KFe.isMDXComponent=!0;const JFe={toc:[]};function tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}tqe.isMDXComponent=!0;const eqe={toc:[]};function nqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}nqe.isMDXComponent=!0;const oqe={toc:[]};function pqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}pqe.isMDXComponent=!0;const rqe={toc:[]};function sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}sqe.isMDXComponent=!0;const cqe={toc:[]};function iqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iqe.isMDXComponent=!0;const aqe={toc:[]};function lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lqe.isMDXComponent=!0;const uqe={toc:[]};function mqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}mqe.isMDXComponent=!0;const dqe={toc:[]};function hqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}hqe.isMDXComponent=!0;const fqe={toc:[]};function kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}kqe.isMDXComponent=!0;const yqe={toc:[]};function Mqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Mqe.isMDXComponent=!0;const Dqe={toc:[]};function wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}wqe.isMDXComponent=!0;const _qe={toc:[]};function Xqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Xqe.isMDXComponent=!0;const gqe={toc:[]};function Tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Tqe.isMDXComponent=!0;const xqe={toc:[]};function Cqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}Cqe.isMDXComponent=!0;const vqe={toc:[]};function Lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]};function bqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}bqe.isMDXComponent=!0;const Nqe={toc:[]};function zqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}zqe.isMDXComponent=!0;const Aqe={toc:[]};function Wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}Wqe.isMDXComponent=!0;const Rqe={toc:[]};function Iqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}Iqe.isMDXComponent=!0;const Pqe={toc:[]};function Sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}Sqe.isMDXComponent=!0;const Eqe={toc:[]};function Bqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}Bqe.isMDXComponent=!0;const Gqe={toc:[]};function Oqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}Oqe.isMDXComponent=!0;const Uqe={toc:[]};function Fqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}Fqe.isMDXComponent=!0;const qqe={toc:[]};function Vqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}Vqe.isMDXComponent=!0;const jqe={toc:[]};function Hqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}Hqe.isMDXComponent=!0;const Qqe={toc:[]};function Yqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}Yqe.isMDXComponent=!0;const $qe={toc:[]};function Kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]};function tVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}tVe.isMDXComponent=!0;const eVe={toc:[]};function nVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}nVe.isMDXComponent=!0;const oVe={toc:[]};function pVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}pVe.isMDXComponent=!0;const rVe={toc:[]};function sVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}sVe.isMDXComponent=!0;const cVe={toc:[]};function iVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iVe.isMDXComponent=!0;const aVe={toc:[]};function lVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lVe.isMDXComponent=!0;const uVe={toc:[]};function mVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}mVe.isMDXComponent=!0;const dVe={toc:[]};function hVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}hVe.isMDXComponent=!0;const fVe={toc:[]};function kVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}kVe.isMDXComponent=!0;const yVe={toc:[]};function MVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}MVe.isMDXComponent=!0;const DVe={toc:[]};function wVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}wVe.isMDXComponent=!0;const _Ve={toc:[]};function XVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}XVe.isMDXComponent=!0;const gVe={toc:[]};function TVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}TVe.isMDXComponent=!0;const xVe={toc:[]};function CVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}CVe.isMDXComponent=!0;const vVe={toc:[]};function LVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}LVe.isMDXComponent=!0;const ZVe={toc:[]};function bVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}bVe.isMDXComponent=!0;const NVe={toc:[]};function zVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}zVe.isMDXComponent=!0;const AVe={toc:[]};function WVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}WVe.isMDXComponent=!0;const RVe={toc:[]};function IVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}IVe.isMDXComponent=!0;const PVe={toc:[]};function SVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}SVe.isMDXComponent=!0;const EVe={toc:[]};function BVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}BVe.isMDXComponent=!0;const GVe={toc:[]};function OVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}OVe.isMDXComponent=!0;const UVe={toc:[]};function FVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVe,n,{components:e,mdxType:"MDXLayout"}))}FVe.isMDXComponent=!0;const qVe={toc:[]};function VVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}VVe.isMDXComponent=!0;const jVe={toc:[]};function HVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}HVe.isMDXComponent=!0;const QVe={toc:[]};function YVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}YVe.isMDXComponent=!0;const $Ve={toc:[]};function KVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}KVe.isMDXComponent=!0;const JVe={toc:[]};function tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}tje.isMDXComponent=!0;const eje={toc:[]};function nje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}nje.isMDXComponent=!0;const oje={toc:[]};function pje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}pje.isMDXComponent=!0;const rje={toc:[]};function sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}sje.isMDXComponent=!0;const cje={toc:[]};function ije(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}ije.isMDXComponent=!0;const aje={toc:[]};function lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}lje.isMDXComponent=!0;const uje={toc:[]};function mje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}mje.isMDXComponent=!0;const dje={toc:[]};function hje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}hje.isMDXComponent=!0;const fje={toc:[]};function kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}kje.isMDXComponent=!0;const yje={toc:[]};function Mje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Mje.isMDXComponent=!0;const Dje={toc:[]};function wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wje.isMDXComponent=!0;const _je={toc:[]};function Xje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Xje.isMDXComponent=!0;const gje={toc:[]};function Tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}Tje.isMDXComponent=!0;const xje={toc:[]};function Cje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}Cje.isMDXComponent=!0;const vje={toc:[]};function Lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Lje.isMDXComponent=!0;const Zje={toc:[]};function bje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}bje.isMDXComponent=!0;const Nje={toc:[]};function zje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}zje.isMDXComponent=!0;const Aje={toc:[]};function Wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}Wje.isMDXComponent=!0;const Rje={toc:[]};function Ije(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}Ije.isMDXComponent=!0;const Pje={toc:[]};function Sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}Sje.isMDXComponent=!0;const Eje={toc:[]};function Bje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Bje.isMDXComponent=!0;const Gje={toc:[]};function Oje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Oje.isMDXComponent=!0;const Uje={toc:[]};function Fje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}Fje.isMDXComponent=!0;const qje={toc:[]};function Vje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}Vje.isMDXComponent=!0;const jje={toc:[]};function Hje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Hje.isMDXComponent=!0;const Qje={toc:[]};function Yje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}Yje.isMDXComponent=!0;const $je={toc:[]};function Kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}Kje.isMDXComponent=!0;const Jje={toc:[]};function tHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}tHe.isMDXComponent=!0;const eHe={toc:[]};function nHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}nHe.isMDXComponent=!0;const oHe={toc:[]};function pHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}pHe.isMDXComponent=!0;const rHe={toc:[]};function sHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}sHe.isMDXComponent=!0;const cHe={toc:[]};function iHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}iHe.isMDXComponent=!0;const aHe={toc:[]};function lHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lHe.isMDXComponent=!0;const uHe={toc:[]};function mHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}mHe.isMDXComponent=!0;const dHe={toc:[]};function hHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}hHe.isMDXComponent=!0;const fHe={toc:[]};function kHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}kHe.isMDXComponent=!0;const yHe={toc:[]};function MHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}MHe.isMDXComponent=!0;const DHe={toc:[]};function wHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}wHe.isMDXComponent=!0;const _He={toc:[]};function XHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}XHe.isMDXComponent=!0;const gHe={toc:[]};function THe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}THe.isMDXComponent=!0;const xHe={toc:[]};function CHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}CHe.isMDXComponent=!0;const vHe={toc:[]};function LHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}LHe.isMDXComponent=!0;const ZHe={toc:[]};function bHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}bHe.isMDXComponent=!0;const NHe={toc:[]};function zHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}zHe.isMDXComponent=!0;const AHe={toc:[]};function WHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}WHe.isMDXComponent=!0;const RHe={toc:[]};function IHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}IHe.isMDXComponent=!0;const PHe={toc:[]};function SHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}SHe.isMDXComponent=!0;const EHe={toc:[]};function BHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}BHe.isMDXComponent=!0;const GHe={toc:[]};function OHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}OHe.isMDXComponent=!0;const UHe={toc:[]};function FHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}FHe.isMDXComponent=!0;const qHe={toc:[]};function VHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}VHe.isMDXComponent=!0;const jHe={toc:[]};function HHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}HHe.isMDXComponent=!0;const QHe={toc:[]};function YHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}YHe.isMDXComponent=!0;const $He={toc:[]};function KHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}KHe.isMDXComponent=!0;const JHe={toc:[]};function tQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}tQe.isMDXComponent=!0;const eQe={toc:[]};function nQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}nQe.isMDXComponent=!0;const oQe={toc:[]};function pQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}pQe.isMDXComponent=!0;const rQe={toc:[]};function sQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}sQe.isMDXComponent=!0;const cQe={toc:[]};function iQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}iQe.isMDXComponent=!0;const aQe={toc:[]};function lQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}lQe.isMDXComponent=!0;const uQe={toc:[]};function mQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}mQe.isMDXComponent=!0;const dQe={toc:[]};function hQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}hQe.isMDXComponent=!0;const fQe={toc:[]};function kQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}kQe.isMDXComponent=!0;const yQe={toc:[]};function MQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}MQe.isMDXComponent=!0;const DQe={toc:[]};function wQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}wQe.isMDXComponent=!0;const _Qe={toc:[]};function XQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}XQe.isMDXComponent=!0;const gQe={toc:[]};function TQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}TQe.isMDXComponent=!0;const xQe={toc:[]};function CQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}CQe.isMDXComponent=!0;const vQe={toc:[]};function LQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function ZQe(t){let{id:e}=t;const n=o[e]??p.Fragment;return p.createElement(n,null)}LQe.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),p=n(136),r=n(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==e?void 0:e.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,n&&c),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,e,n)=>{n.d(e,{Z:()=>Ot});var o=n(2784),p=n(7390),r=n(6835),s=n(68),c=n(6277),i=n(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,n&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},e)}var f=n(9817);function k(t){let{children:e,type:n,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(n);return p?o.createElement(f.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),e):o.createElement("span",(0,l.Z)({id:r},i),e)}let y,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function w(t){let{children:e,type:n,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[n??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":p,key:e,className:a.element},t)))))}var _=n(8617);function X(t){var e;let{type:n}=t;const p=(0,_.RU)(n.project),r=null==p?void 0:p[n.id],s=n.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:s,type:s?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(w,{type:y.Angle},n.typeArguments.map(((t,e)=>o.createElement(E,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function T(t){let{type:e}=t;return e.elements?o.createElement(w,{type:y.Square},e.elements.map(((t,e)=>o.createElement(E,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.elementType}),"[]")}function C(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Pipe},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,p]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:p},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(E,{type:e.targetType}))}function Z(t){let{type:e}=t;const n=(0,_.in)();return o.createElement(Y,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Ampersand},e.types.map(((t,e)=>o.createElement(E,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:e,type:n}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(E,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(E,{type:e.extendsType})," ? ",o.createElement(E,{type:e.trueType})," : ",o.createElement(E,{type:e.falseType}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:e.objectType}),"[",o.createElement(E,{type:e.indexType}),"]")}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(E,{type:e.target}))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(E,{type:e.parameterType}),"]: ",o.createElement(E,{type:e.templateType}))))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(E,{type:e.element}))}function E(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return S;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function B(t){let{flags:e,explicitAccessModifier:n}=t;const p=[];return null!=e&&e.isAbstract&&p.push("abstract"),null!=e&&e.isStatic&&p.push("static"),null!=e&&e.isConst&&p.push("const"),null!=e&&e.isReadonly&&p.push("readonly"),null!=e&&e.isPrivate&&p.push("private"),null!=e&&e.isProtected&&p.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(E,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function O(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:e.default})))}function U(t){var e,n;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):i?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(w,{type:y.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function F(t){let{reflection:e}=t;return o.createElement(G,{reflection:e})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var e,n,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(k,{type:"keyword"},q[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,e)=>o.createElement(E,{key:e,type:t}))))))}function j(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(w,{type:y.Angle},e.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:n(t)}))))," = ",o.createElement(E,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(U,{reflection:e.signatures[0]}):e.children?o.createElement(w,{type:y.Curly},e.children.map((t=>o.createElement(Y,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function Q(t){var e;let{reflection:n}=t;const p=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(U,{reflection:p})}function Y(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return U;case p.W.Property:return F;case p.W.Method:return Q;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function $(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,c.Z)(a.line,"token-line")},e),o.createElement("br",null))}var K=n(9322),J=n(136);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>e.map(r)),[e]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(U,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(et,{parameters:c.parameters}))}var ot=n(7708);function pt(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===p.W.Class||n===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(3181),ut=n(3851),mt=n(4126),dt=n(2424),ht=n(2244),ft=n(4155);function kt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function yt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??kt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function Mt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Dt(t){let{queryString:e=!1,groupId:n}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(p.location.search);e.set(r,t),p.replace({...p.location,search:e.toString()})}),[r,p])]}function wt(t){const{defaultValue:e,queryString:n=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!Mt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=Dt({queryString:n,groupId:p}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[p,r]=(0,ft.Nk)(n);return[p,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=n(9741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:e,block:n,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=i.indexOf(e),o=s[n].value;o!==p&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=i.indexOf(t.currentTarget)+1;n=i[e]??i[0];break}case"ArrowLeft":{const e=i.indexOf(t.currentTarget)-1;n=i[e]??i[i.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},e)},s.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===e?0:-1,"aria-selected":p===e,key:e,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===e})}),n??e)})))}function xt(t){let{lazy:e,children:n,selectedValue:p}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==p}))))}function Ct(t){const e=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,e)),o.createElement(xt,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(e)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:e,hidden:n,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:n},e)}function bt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Ot,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const p=(0,lt.TH)(),r=(0,_.RU)(n),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[e,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),i.length>1?o.createElement(vt,{groupId:e.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var e,n,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var e;let{reflection:n,headless:p}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:n.overwrites}))))}function Wt(t){var e,n;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(F,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Rt(t){var e,n,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=n(8128);function Pt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const St="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),p=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,c.Z)("card padding--lg",St)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:return Gt;case p.W.Module:return Pt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{var o;const p=t[n];return p?(null==(o=e[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(2784),p=n(822);const r=o.createContext(null);function s(t){let{children:e}=t;const n=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),p=n(1263),r=n(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const p=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},6412:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(7896),p=(n(2784),n(876)),r=(n(8128),n(2072));const s={sidebar_position:3,slug:"/hierarchy"},c="Scene hierarchy",i={unversionedId:"getting-started/hierarchy",id:"getting-started/hierarchy",title:"Scene hierarchy",description:"Scenes are collections of nodes displayed in your animation. They're organized",source:"@site/docs/getting-started/hierarchy.mdx",sourceDirName:"getting-started",slug:"/hierarchy",permalink:"/docs/hierarchy",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/hierarchy.mdx",tags:[],version:"current",lastUpdatedBy:"Waldemar Lehner",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/hierarchy"},sidebar:"docs",previous:{title:"Animation flow",permalink:"/docs/flow"},next:{title:"Positioning",permalink:"/docs/positioning"}},a={},l=[{value:"<code>Node.add</code>",id:"nodeadd",level:2},{value:"<code>Node.insert</code>",id:"nodeinsert",level:2},{value:"<code>Node.remove</code>",id:"noderemove",level:2},{value:"<code>Node.reparent</code>",id:"nodereparent",level:2},{value:"<code>Node.moveUp</code>",id:"nodemoveup",level:2},{value:"<code>Node.moveDown</code>",id:"nodemovedown",level:2},{value:"<code>Node.moveToTop</code>",id:"nodemovetotop",level:2},{value:"<code>Node.moveToBottom</code>",id:"nodemovetobottom",level:2},{value:"<code>Node.moveTo</code>",id:"nodemoveto",level:2},{value:"<code>Node.moveAbove</code>",id:"nodemoveabove",level:2},{value:"<code>Node.moveBelow</code>",id:"nodemovebelow",level:2},{value:"<code>Node.removeChildren</code>",id:"noderemovechildren",level:2}],u={toc:l};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"scene-hierarchy"},"Scene hierarchy"),(0,p.kt)("p",null,"Scenes are collections of nodes displayed in your animation. They're organized\nin a tree hierarchy, with the scene view at its root. This concept is similar to\nthe Document Object Model used to represent HTML and XML documents."),(0,p.kt)("p",null,"Here's an example of a simple scene hierarchy together with its object\nrepresentation:"),(0,p.kt)("div",{className:"row margin-bottom--md"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"view.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Txt>Hi</Txt>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("mermaid",{value:"graph TD;\n  view[Scene View]\n  circle([Circle])\n  layout([Layout])\n  rect([Rect])\n  text([text 'Hi'])\n    view--\x3ecircle;\n    view--\x3elayout;\n    layout--\x3erect;\n    layout--\x3etext;"}))),(0,p.kt)("p",null,"Each node is an instance of a class extending the base ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class. To\nmake the code more readable, Motion Canvas uses a custom\n",(0,p.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX")," runtime. This way, instead\nof instantiating the nodes ourselves, we can write an XML-like markup. Note that\nMotion Canvas does ",(0,p.kt)("strong",{parentName:"p"},"not")," use React itself, only JSX. There's no virtual DOM or\nreconciliation and the JSX tags are mapped directly to Node instances. These two\ncode snippets are equivalent:"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// JSX\nview.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Txt>Hi</Txt>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// No JSX\nview.add([\n  new Circle({}),\n  new Layout({\n    children: [\n      // highlight-start\n      new Rect({}),\n      new Txt({text: 'Hi'}),\n    ],\n  }),\n]);\n")))),(0,p.kt)("p",null,"Just like with DOM, it's possible to add, remove, and rearrange nodes at any\ntime. The ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class contains the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,p.kt)("inlineCode",{parentName:"a"},"children"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#parent"},(0,p.kt)("inlineCode",{parentName:"a"},"parent"))," properties that can be used to\ntraverse the tree. But in order to modify it, it's recommended to use the\nfollowing helper methods:"),(0,p.kt)("h2",{id:"nodeadd"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.add")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#add",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodeinsert"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.insert")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#insert",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.remove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#remove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodereparent"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.reparent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#reparent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveup"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveUp")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveUp",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovedown"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveDown")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveDown",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetotop"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToTop")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToTop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetobottom"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToBottom")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToBottom",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveto"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveTo")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveTo",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveabove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveAbove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveAbove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovebelow"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveBelow")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveBelow",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemovechildren"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.removeChildren")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#removeChildren",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}m.isMDXComponent=!0}}]);