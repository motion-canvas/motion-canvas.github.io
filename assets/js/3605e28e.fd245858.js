"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var i=o.createContext({}),a=function(t){var n=o.useContext(i),e=n;return t&&(e="function"==typeof t?t(n):s(s({},n),t)),e},l=function(t){var n=a(t.components);return o.createElement(i.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(e),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,s(s({ref:n},l),{},{components:e})):o.createElement(h,s({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,s=new Array(r);s[0]=d;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=e[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(6277),s=e(1077),c=e(7683),i=e(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:e}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},2665:(t,n,e)=>{e.d(n,{Z:()=>f});var o=e(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=e(9817),d=e(6277);function h(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return o.createElement(m.Z,{to:e,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function f(t){let{name:n,banner:e,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,e&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${n}.js`,auto:e}),o.createElement(h,{name:a||n}))}e(1263).Z.canUseDOM&&e.e(5455).then(e.bind(e,5455))},2072:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(2784),p=e(8617),r=e(1930);function s(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},4404:(t,n,e)=>{e.d(n,{Z:()=>nWn});var o={};e.r(o),e.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>tn,content_0_1000:()=>Ey,content_0_1002:()=>Gy,content_0_1004:()=>Fy,content_0_1006:()=>qy,content_0_1008:()=>jy,content_0_1010:()=>Hy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>nM,content_0_1018:()=>oM,content_0_102:()=>en,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>fM,content_0_1032:()=>yM,content_0_1034:()=>DM,content_0_1036:()=>XM,content_0_1038:()=>gM,content_0_104:()=>pn,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>SM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>FM,content_0_106:()=>sn,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>HM,content_0_1066:()=>$M,content_0_1068:()=>JM,content_0_1070:()=>nD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>an,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>fD,content_0_1086:()=>yD,content_0_1088:()=>DD,content_0_1090:()=>XD,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>un,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>SD,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>FD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_1118:()=>HD,content_0_112:()=>dn,content_0_1120:()=>$D,content_0_1122:()=>JD,content_0_1124:()=>n_,content_0_1126:()=>o_,content_0_1128:()=>r_,content_0_1130:()=>c_,content_0_1132:()=>a_,content_0_1134:()=>u_,content_0_1136:()=>d_,content_0_1138:()=>f_,content_0_114:()=>fn,content_0_1140:()=>y_,content_0_1142:()=>D_,content_0_1144:()=>X_,content_0_1146:()=>g_,content_0_1148:()=>x_,content_0_1150:()=>v_,content_0_1152:()=>Z_,content_0_1154:()=>N_,content_0_1156:()=>A_,content_0_1158:()=>R_,content_0_116:()=>yn,content_0_1160:()=>S_,content_0_1162:()=>E_,content_0_1164:()=>G_,content_0_1166:()=>F_,content_0_1168:()=>q_,content_0_1170:()=>j_,content_0_1172:()=>H_,content_0_1174:()=>$_,content_0_1176:()=>J_,content_0_1178:()=>nX,content_0_118:()=>Dn,content_0_1180:()=>oX,content_0_1182:()=>rX,content_0_1184:()=>cX,content_0_1186:()=>aX,content_0_1188:()=>uX,content_0_1190:()=>dX,content_0_1192:()=>fX,content_0_1194:()=>yX,content_0_1196:()=>DX,content_0_1198:()=>XX,content_0_12:()=>_,content_0_120:()=>Xn,content_0_1200:()=>gX,content_0_1202:()=>xX,content_0_1204:()=>vX,content_0_1206:()=>ZX,content_0_1208:()=>NX,content_0_1210:()=>AX,content_0_1212:()=>RX,content_0_1214:()=>SX,content_0_1216:()=>EX,content_0_1218:()=>GX,content_0_122:()=>gn,content_0_1220:()=>FX,content_0_1222:()=>qX,content_0_1224:()=>jX,content_0_1226:()=>HX,content_0_1228:()=>$X,content_0_1230:()=>JX,content_0_1232:()=>nw,content_0_1234:()=>ow,content_0_1236:()=>rw,content_0_1238:()=>cw,content_0_124:()=>xn,content_0_1240:()=>aw,content_0_1242:()=>uw,content_0_1244:()=>dw,content_0_1246:()=>fw,content_0_1248:()=>yw,content_0_1250:()=>Dw,content_0_1252:()=>Xw,content_0_1254:()=>gw,content_0_1256:()=>xw,content_0_1258:()=>vw,content_0_126:()=>vn,content_0_1260:()=>Zw,content_0_1262:()=>Nw,content_0_1264:()=>Aw,content_0_1266:()=>Rw,content_0_1268:()=>Sw,content_0_1270:()=>Ew,content_0_1272:()=>Gw,content_0_1274:()=>Fw,content_0_1276:()=>qw,content_0_1278:()=>jw,content_0_128:()=>Zn,content_0_1280:()=>Hw,content_0_1282:()=>$w,content_0_1284:()=>Jw,content_0_1286:()=>ng,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>Nn,content_0_1300:()=>fg,content_0_1302:()=>yg,content_0_1304:()=>Dg,content_0_1306:()=>Xg,content_0_1308:()=>gg,content_0_1310:()=>xg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>An,content_0_1320:()=>Rg,content_0_1322:()=>Sg,content_0_1324:()=>Eg,content_0_1326:()=>Gg,content_0_1328:()=>Fg,content_0_1330:()=>qg,content_0_1332:()=>jg,content_0_1334:()=>Hg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>Rn,content_0_1340:()=>nT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>fT,content_0_1356:()=>yT,content_0_1358:()=>DT,content_0_136:()=>Sn,content_0_1360:()=>XT,content_0_1362:()=>gT,content_0_1364:()=>xT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>RT,content_0_1376:()=>ST,content_0_1378:()=>ET,content_0_138:()=>En,content_0_1380:()=>GT,content_0_1382:()=>FT,content_0_1384:()=>qT,content_0_1386:()=>jT,content_0_1388:()=>HT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>nx,content_0_1396:()=>ox,content_0_1398:()=>rx,content_0_14:()=>w,content_0_140:()=>Gn,content_0_1400:()=>cx,content_0_1402:()=>ax,content_0_1404:()=>ux,content_0_1406:()=>dx,content_0_1408:()=>fx,content_0_1410:()=>yx,content_0_1412:()=>Dx,content_0_1414:()=>Xx,content_0_1416:()=>gx,content_0_1418:()=>xx,content_0_142:()=>Fn,content_0_1420:()=>vx,content_0_1422:()=>Zx,content_0_1424:()=>Nx,content_0_1426:()=>Ax,content_0_1428:()=>Rx,content_0_1430:()=>Sx,content_0_1432:()=>Ex,content_0_1434:()=>Gx,content_0_1436:()=>Fx,content_0_1438:()=>qx,content_0_144:()=>qn,content_0_1440:()=>jx,content_0_1442:()=>Hx,content_0_1444:()=>$x,content_0_1446:()=>Jx,content_0_1448:()=>nC,content_0_1450:()=>oC,content_0_1452:()=>rC,content_0_1454:()=>cC,content_0_1456:()=>aC,content_0_1458:()=>uC,content_0_146:()=>jn,content_0_1460:()=>dC,content_0_1462:()=>fC,content_0_1464:()=>yC,content_0_1466:()=>DC,content_0_1468:()=>XC,content_0_1470:()=>gC,content_0_1472:()=>xC,content_0_1474:()=>vC,content_0_1476:()=>ZC,content_0_1478:()=>NC,content_0_148:()=>Hn,content_0_1480:()=>AC,content_0_1482:()=>RC,content_0_1484:()=>SC,content_0_1486:()=>EC,content_0_1488:()=>GC,content_0_1490:()=>FC,content_0_1492:()=>qC,content_0_1494:()=>jC,content_0_1496:()=>HC,content_0_1498:()=>$C,content_0_150:()=>$n,content_0_1500:()=>JC,content_0_1502:()=>nv,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>fv,content_0_1518:()=>yv,content_0_152:()=>Jn,content_0_1520:()=>Dv,content_0_1522:()=>Xv,content_0_1524:()=>gv,content_0_1526:()=>xv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Rv,content_0_1538:()=>Sv,content_0_154:()=>ne,content_0_1540:()=>Ev,content_0_1542:()=>Gv,content_0_1544:()=>Fv,content_0_1546:()=>qv,content_0_1548:()=>jv,content_0_1550:()=>Hv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>nL,content_0_1558:()=>oL,content_0_156:()=>oe,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>fL,content_0_1572:()=>yL,content_0_1574:()=>DL,content_0_1576:()=>XL,content_0_1578:()=>gL,content_0_158:()=>re,content_0_1580:()=>xL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>RL,content_0_1592:()=>SL,content_0_1594:()=>EL,content_0_1596:()=>GL,content_0_1598:()=>FL,content_0_16:()=>T,content_0_160:()=>ce,content_0_1600:()=>qL,content_0_1602:()=>jL,content_0_1604:()=>HL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>nZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_162:()=>ae,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>fe,content_0_170:()=>ye,content_0_172:()=>De,content_0_174:()=>Xe,content_0_176:()=>ge,content_0_178:()=>xe,content_0_18:()=>C,content_0_180:()=>ve,content_0_182:()=>Ze,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Se,content_0_192:()=>Ee,content_0_194:()=>Ge,content_0_196:()=>Fe,content_0_198:()=>qe,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>je,content_0_202:()=>He,content_0_204:()=>$e,content_0_206:()=>Je,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Mo,content_0_226:()=>_o,content_0_228:()=>wo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>Po,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Uo,content_0_252:()=>Vo,content_0_254:()=>Qo,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>_p,content_0_282:()=>wp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Up,content_0_306:()=>Vp,content_0_308:()=>Qp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Mr,content_0_334:()=>_r,content_0_336:()=>wr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Pr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Ur,content_0_36:()=>U,content_0_360:()=>Vr,content_0_362:()=>Qr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>es,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ks,content_0_386:()=>Ms,content_0_388:()=>_s,content_0_390:()=>ws,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>Q,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ps,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Us,content_0_414:()=>Vs,content_0_416:()=>Qs,content_0_418:()=>Ys,content_0_42:()=>Y,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>ec,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>kc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>_c,content_0_444:()=>wc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Pc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Uc,content_0_468:()=>Vc,content_0_470:()=>Qc,content_0_472:()=>Yc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ei,content_0_48:()=>et,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>ki,content_0_494:()=>Mi,content_0_496:()=>_i,content_0_498:()=>wi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Pi,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Ui,content_0_522:()=>Vi,content_0_524:()=>Qi,content_0_526:()=>Yi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>ea,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ka,content_0_548:()=>Ma,content_0_550:()=>_a,content_0_552:()=>wa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Pa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Ua,content_0_576:()=>Va,content_0_578:()=>Qa,content_0_58:()=>mt,content_0_580:()=>Ya,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>Ml,content_0_604:()=>_l,content_0_606:()=>wl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>kt,content_0_620:()=>Il,content_0_622:()=>Pl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Ul,content_0_630:()=>Vl,content_0_632:()=>Ql,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Mu,content_0_658:()=>_u,content_0_66:()=>_t,content_0_660:()=>wu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Pu,content_0_678:()=>Bu,content_0_68:()=>wt,content_0_680:()=>Ou,content_0_682:()=>Uu,content_0_684:()=>Vu,content_0_686:()=>Qu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Mm,content_0_712:()=>_m,content_0_714:()=>wm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Pm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Um,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Qm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Md,content_0_766:()=>_d,content_0_768:()=>wd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Pd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Ud,content_0_792:()=>Vd,content_0_794:()=>Qd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>_h,content_0_822:()=>wh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Uh,content_0_846:()=>Vh,content_0_848:()=>Qh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tf,content_0_856:()=>ef,content_0_858:()=>pf,content_0_86:()=>Bt,content_0_860:()=>sf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>yf,content_0_872:()=>Df,content_0_874:()=>Xf,content_0_876:()=>gf,content_0_878:()=>xf,content_0_88:()=>Ot,content_0_880:()=>vf,content_0_882:()=>Zf,content_0_884:()=>Nf,content_0_886:()=>Af,content_0_888:()=>Rf,content_0_890:()=>Sf,content_0_892:()=>Ef,content_0_894:()=>Gf,content_0_896:()=>Ff,content_0_898:()=>qf,content_0_90:()=>Ut,content_0_900:()=>jf,content_0_902:()=>Hf,content_0_904:()=>$f,content_0_906:()=>Jf,content_0_908:()=>nk,content_0_910:()=>ok,content_0_912:()=>rk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>uk,content_0_92:()=>Vt,content_0_920:()=>dk,content_0_922:()=>fk,content_0_924:()=>yk,content_0_926:()=>Dk,content_0_928:()=>Xk,content_0_930:()=>gk,content_0_932:()=>xk,content_0_934:()=>vk,content_0_936:()=>Zk,content_0_938:()=>Nk,content_0_94:()=>Qt,content_0_940:()=>Ak,content_0_942:()=>Rk,content_0_944:()=>Sk,content_0_946:()=>Ek,content_0_948:()=>Gk,content_0_950:()=>Fk,content_0_952:()=>qk,content_0_954:()=>jk,content_0_956:()=>Hk,content_0_958:()=>$k,content_0_96:()=>Yt,content_0_960:()=>Jk,content_0_962:()=>ny,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>fy,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>Dy,content_0_982:()=>Xy,content_0_984:()=>gy,content_0_986:()=>xy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Ry,content_0_998:()=>Sy,content_3498_0:()=>cZ,content_3498_10:()=>yZ,content_3498_100:()=>Jb,content_3498_1000:()=>Rj,content_3498_1002:()=>Sj,content_3498_1004:()=>Ej,content_3498_1006:()=>Gj,content_3498_1008:()=>Fj,content_3498_1010:()=>qj,content_3498_1012:()=>jj,content_3498_1014:()=>Hj,content_3498_1016:()=>$j,content_3498_1018:()=>Jj,content_3498_102:()=>nN,content_3498_1020:()=>nQ,content_3498_1022:()=>oQ,content_3498_1024:()=>rQ,content_3498_1026:()=>cQ,content_3498_1028:()=>aQ,content_3498_1030:()=>uQ,content_3498_1032:()=>dQ,content_3498_1034:()=>fQ,content_3498_1036:()=>yQ,content_3498_1038:()=>DQ,content_3498_104:()=>oN,content_3498_1040:()=>XQ,content_3498_1042:()=>gQ,content_3498_1044:()=>xQ,content_3498_1046:()=>vQ,content_3498_1048:()=>ZQ,content_3498_1050:()=>NQ,content_3498_1052:()=>AQ,content_3498_1054:()=>RQ,content_3498_1056:()=>SQ,content_3498_1058:()=>EQ,content_3498_106:()=>rN,content_3498_1060:()=>GQ,content_3498_1062:()=>FQ,content_3498_1064:()=>qQ,content_3498_1066:()=>jQ,content_3498_1068:()=>HQ,content_3498_1070:()=>$Q,content_3498_1072:()=>JQ,content_3498_1074:()=>nH,content_3498_1076:()=>oH,content_3498_1078:()=>rH,content_3498_108:()=>cN,content_3498_1080:()=>cH,content_3498_1082:()=>aH,content_3498_1084:()=>uH,content_3498_1086:()=>dH,content_3498_1088:()=>fH,content_3498_1090:()=>yH,content_3498_1092:()=>DH,content_3498_1094:()=>XH,content_3498_1096:()=>gH,content_3498_1098:()=>xH,content_3498_110:()=>aN,content_3498_1100:()=>vH,content_3498_1102:()=>ZH,content_3498_1104:()=>NH,content_3498_1106:()=>AH,content_3498_1108:()=>RH,content_3498_1110:()=>SH,content_3498_1112:()=>EH,content_3498_1114:()=>GH,content_3498_1116:()=>FH,content_3498_1118:()=>qH,content_3498_112:()=>uN,content_3498_1120:()=>jH,content_3498_1122:()=>HH,content_3498_1124:()=>$H,content_3498_1126:()=>JH,content_3498_1128:()=>nY,content_3498_1130:()=>oY,content_3498_1132:()=>rY,content_3498_1134:()=>cY,content_3498_1136:()=>aY,content_3498_1138:()=>uY,content_3498_114:()=>dN,content_3498_1140:()=>dY,content_3498_1142:()=>fY,content_3498_1144:()=>yY,content_3498_1146:()=>DY,content_3498_1148:()=>XY,content_3498_1150:()=>gY,content_3498_1152:()=>xY,content_3498_1154:()=>vY,content_3498_1156:()=>ZY,content_3498_1158:()=>NY,content_3498_116:()=>fN,content_3498_1160:()=>AY,content_3498_1162:()=>RY,content_3498_1164:()=>SY,content_3498_1166:()=>EY,content_3498_1168:()=>GY,content_3498_1170:()=>FY,content_3498_1172:()=>qY,content_3498_1174:()=>jY,content_3498_1176:()=>HY,content_3498_1178:()=>$Y,content_3498_118:()=>yN,content_3498_1180:()=>JY,content_3498_1182:()=>n$,content_3498_1184:()=>o$,content_3498_1186:()=>r$,content_3498_1188:()=>c$,content_3498_1190:()=>a$,content_3498_1192:()=>u$,content_3498_1194:()=>d$,content_3498_1196:()=>f$,content_3498_1198:()=>y$,content_3498_12:()=>DZ,content_3498_120:()=>DN,content_3498_1200:()=>D$,content_3498_1202:()=>X$,content_3498_1204:()=>g$,content_3498_1206:()=>x$,content_3498_1208:()=>v$,content_3498_1210:()=>Z$,content_3498_1212:()=>N$,content_3498_1214:()=>A$,content_3498_1216:()=>R$,content_3498_1218:()=>S$,content_3498_122:()=>XN,content_3498_1220:()=>E$,content_3498_1222:()=>G$,content_3498_1224:()=>F$,content_3498_1226:()=>q$,content_3498_1228:()=>j$,content_3498_1230:()=>H$,content_3498_1232:()=>$$,content_3498_1234:()=>J$,content_3498_1236:()=>nK,content_3498_1238:()=>oK,content_3498_124:()=>gN,content_3498_1240:()=>rK,content_3498_1242:()=>cK,content_3498_1244:()=>aK,content_3498_1246:()=>uK,content_3498_1248:()=>dK,content_3498_1250:()=>fK,content_3498_1252:()=>yK,content_3498_1254:()=>DK,content_3498_1256:()=>XK,content_3498_1258:()=>gK,content_3498_126:()=>xN,content_3498_1260:()=>xK,content_3498_1262:()=>vK,content_3498_1264:()=>ZK,content_3498_1266:()=>NK,content_3498_1268:()=>AK,content_3498_1270:()=>RK,content_3498_1272:()=>SK,content_3498_1274:()=>EK,content_3498_1276:()=>GK,content_3498_1278:()=>FK,content_3498_128:()=>vN,content_3498_1280:()=>qK,content_3498_1282:()=>jK,content_3498_1284:()=>HK,content_3498_1286:()=>$K,content_3498_1288:()=>JK,content_3498_1290:()=>nJ,content_3498_1292:()=>oJ,content_3498_1294:()=>rJ,content_3498_1296:()=>cJ,content_3498_1298:()=>aJ,content_3498_130:()=>ZN,content_3498_1300:()=>uJ,content_3498_1302:()=>dJ,content_3498_1304:()=>fJ,content_3498_1306:()=>yJ,content_3498_1308:()=>DJ,content_3498_1310:()=>XJ,content_3498_1312:()=>gJ,content_3498_1314:()=>xJ,content_3498_1316:()=>vJ,content_3498_1318:()=>ZJ,content_3498_132:()=>NN,content_3498_1320:()=>NJ,content_3498_1322:()=>AJ,content_3498_1324:()=>RJ,content_3498_1326:()=>SJ,content_3498_1328:()=>EJ,content_3498_1330:()=>GJ,content_3498_1332:()=>FJ,content_3498_1334:()=>qJ,content_3498_1336:()=>jJ,content_3498_1338:()=>HJ,content_3498_134:()=>AN,content_3498_1340:()=>$J,content_3498_1342:()=>JJ,content_3498_1344:()=>n0,content_3498_1346:()=>o0,content_3498_1348:()=>r0,content_3498_1350:()=>c0,content_3498_1352:()=>a0,content_3498_1354:()=>u0,content_3498_1356:()=>d0,content_3498_1358:()=>f0,content_3498_136:()=>RN,content_3498_1360:()=>y0,content_3498_1362:()=>D0,content_3498_1364:()=>X0,content_3498_1366:()=>g0,content_3498_1368:()=>x0,content_3498_1370:()=>v0,content_3498_1372:()=>Z0,content_3498_1374:()=>N0,content_3498_1376:()=>A0,content_3498_1378:()=>R0,content_3498_138:()=>SN,content_3498_1380:()=>S0,content_3498_1382:()=>E0,content_3498_1384:()=>G0,content_3498_1386:()=>F0,content_3498_1388:()=>q0,content_3498_1390:()=>j0,content_3498_1392:()=>H0,content_3498_1394:()=>$0,content_3498_1396:()=>J0,content_3498_1398:()=>n4,content_3498_14:()=>XZ,content_3498_140:()=>EN,content_3498_1400:()=>o4,content_3498_1402:()=>r4,content_3498_1404:()=>c4,content_3498_1406:()=>a4,content_3498_1408:()=>u4,content_3498_1410:()=>d4,content_3498_1412:()=>f4,content_3498_1414:()=>y4,content_3498_1416:()=>D4,content_3498_1418:()=>X4,content_3498_142:()=>GN,content_3498_1420:()=>g4,content_3498_1422:()=>x4,content_3498_1424:()=>v4,content_3498_1426:()=>Z4,content_3498_1428:()=>N4,content_3498_1430:()=>A4,content_3498_1432:()=>R4,content_3498_1434:()=>S4,content_3498_1436:()=>E4,content_3498_1438:()=>G4,content_3498_144:()=>FN,content_3498_1440:()=>F4,content_3498_1442:()=>q4,content_3498_1444:()=>j4,content_3498_1446:()=>H4,content_3498_1448:()=>$4,content_3498_1450:()=>J4,content_3498_1452:()=>n8,content_3498_1454:()=>o8,content_3498_1456:()=>r8,content_3498_1458:()=>c8,content_3498_146:()=>qN,content_3498_1460:()=>a8,content_3498_1462:()=>u8,content_3498_1464:()=>d8,content_3498_1466:()=>f8,content_3498_1468:()=>y8,content_3498_1470:()=>D8,content_3498_1472:()=>X8,content_3498_1474:()=>g8,content_3498_1476:()=>x8,content_3498_1478:()=>v8,content_3498_148:()=>jN,content_3498_1480:()=>Z8,content_3498_1482:()=>N8,content_3498_1484:()=>A8,content_3498_1486:()=>R8,content_3498_1488:()=>S8,content_3498_1490:()=>E8,content_3498_1492:()=>G8,content_3498_1494:()=>F8,content_3498_1496:()=>q8,content_3498_1498:()=>j8,content_3498_150:()=>HN,content_3498_1500:()=>H8,content_3498_1502:()=>$8,content_3498_1504:()=>J8,content_3498_1506:()=>n3,content_3498_1508:()=>o3,content_3498_1510:()=>r3,content_3498_1512:()=>c3,content_3498_1514:()=>a3,content_3498_1516:()=>u3,content_3498_1518:()=>d3,content_3498_152:()=>$N,content_3498_1520:()=>f3,content_3498_1522:()=>y3,content_3498_1524:()=>D3,content_3498_1526:()=>X3,content_3498_1528:()=>g3,content_3498_1530:()=>x3,content_3498_1532:()=>v3,content_3498_1534:()=>Z3,content_3498_1536:()=>N3,content_3498_1538:()=>A3,content_3498_154:()=>JN,content_3498_1540:()=>R3,content_3498_1542:()=>S3,content_3498_1544:()=>E3,content_3498_1546:()=>G3,content_3498_1548:()=>F3,content_3498_1550:()=>q3,content_3498_1552:()=>j3,content_3498_1554:()=>H3,content_3498_1556:()=>$3,content_3498_1558:()=>J3,content_3498_156:()=>nz,content_3498_1560:()=>n9,content_3498_1562:()=>o9,content_3498_1564:()=>r9,content_3498_1566:()=>c9,content_3498_1568:()=>a9,content_3498_1570:()=>u9,content_3498_1572:()=>d9,content_3498_1574:()=>f9,content_3498_1576:()=>y9,content_3498_1578:()=>D9,content_3498_158:()=>oz,content_3498_1580:()=>X9,content_3498_1582:()=>g9,content_3498_1584:()=>x9,content_3498_1586:()=>v9,content_3498_1588:()=>Z9,content_3498_1590:()=>N9,content_3498_1592:()=>A9,content_3498_1594:()=>R9,content_3498_1596:()=>S9,content_3498_1598:()=>E9,content_3498_16:()=>gZ,content_3498_160:()=>rz,content_3498_1600:()=>G9,content_3498_1602:()=>F9,content_3498_1604:()=>q9,content_3498_1606:()=>j9,content_3498_1608:()=>H9,content_3498_1610:()=>$9,content_3498_1612:()=>J9,content_3498_1614:()=>n2,content_3498_1616:()=>o2,content_3498_1618:()=>r2,content_3498_162:()=>cz,content_3498_1620:()=>c2,content_3498_1622:()=>a2,content_3498_1624:()=>u2,content_3498_1626:()=>d2,content_3498_1628:()=>f2,content_3498_1630:()=>y2,content_3498_1632:()=>D2,content_3498_1634:()=>X2,content_3498_1636:()=>g2,content_3498_1638:()=>x2,content_3498_164:()=>az,content_3498_1640:()=>v2,content_3498_1642:()=>Z2,content_3498_1644:()=>N2,content_3498_1646:()=>A2,content_3498_1648:()=>R2,content_3498_1650:()=>S2,content_3498_1652:()=>E2,content_3498_1654:()=>G2,content_3498_1656:()=>F2,content_3498_1658:()=>q2,content_3498_166:()=>uz,content_3498_1660:()=>j2,content_3498_1662:()=>H2,content_3498_1664:()=>$2,content_3498_1666:()=>J2,content_3498_1668:()=>n1,content_3498_1670:()=>o1,content_3498_1672:()=>r1,content_3498_1674:()=>c1,content_3498_1676:()=>a1,content_3498_1678:()=>u1,content_3498_168:()=>dz,content_3498_1680:()=>d1,content_3498_1682:()=>f1,content_3498_1684:()=>y1,content_3498_1686:()=>D1,content_3498_1688:()=>X1,content_3498_1690:()=>g1,content_3498_1692:()=>x1,content_3498_1694:()=>v1,content_3498_1696:()=>Z1,content_3498_1698:()=>N1,content_3498_170:()=>fz,content_3498_1700:()=>A1,content_3498_1702:()=>R1,content_3498_1704:()=>S1,content_3498_1706:()=>E1,content_3498_1708:()=>G1,content_3498_1710:()=>F1,content_3498_1712:()=>q1,content_3498_1714:()=>j1,content_3498_1716:()=>H1,content_3498_1718:()=>$1,content_3498_172:()=>yz,content_3498_1720:()=>J1,content_3498_1722:()=>n6,content_3498_1724:()=>o6,content_3498_1726:()=>r6,content_3498_1728:()=>c6,content_3498_1730:()=>a6,content_3498_1732:()=>u6,content_3498_1734:()=>d6,content_3498_1736:()=>f6,content_3498_1738:()=>y6,content_3498_174:()=>Dz,content_3498_1740:()=>D6,content_3498_1742:()=>X6,content_3498_1744:()=>g6,content_3498_1746:()=>x6,content_3498_1748:()=>v6,content_3498_1750:()=>Z6,content_3498_1752:()=>N6,content_3498_1754:()=>A6,content_3498_1756:()=>R6,content_3498_1758:()=>S6,content_3498_176:()=>Xz,content_3498_1760:()=>E6,content_3498_1762:()=>G6,content_3498_1764:()=>F6,content_3498_1766:()=>q6,content_3498_1768:()=>j6,content_3498_1770:()=>H6,content_3498_1772:()=>$6,content_3498_1774:()=>J6,content_3498_1776:()=>n5,content_3498_1778:()=>o5,content_3498_178:()=>gz,content_3498_1780:()=>r5,content_3498_1782:()=>c5,content_3498_1784:()=>a5,content_3498_1786:()=>u5,content_3498_1788:()=>d5,content_3498_1790:()=>f5,content_3498_1792:()=>y5,content_3498_1794:()=>D5,content_3498_1796:()=>X5,content_3498_1798:()=>g5,content_3498_18:()=>xZ,content_3498_180:()=>xz,content_3498_1800:()=>x5,content_3498_1802:()=>v5,content_3498_1804:()=>Z5,content_3498_1806:()=>N5,content_3498_1808:()=>A5,content_3498_1810:()=>R5,content_3498_1812:()=>S5,content_3498_1814:()=>E5,content_3498_1816:()=>G5,content_3498_1818:()=>F5,content_3498_182:()=>vz,content_3498_1820:()=>q5,content_3498_1822:()=>j5,content_3498_1824:()=>H5,content_3498_1826:()=>$5,content_3498_1828:()=>J5,content_3498_1830:()=>n7,content_3498_1832:()=>o7,content_3498_1834:()=>r7,content_3498_1836:()=>c7,content_3498_1838:()=>a7,content_3498_184:()=>Zz,content_3498_1840:()=>u7,content_3498_1842:()=>d7,content_3498_1844:()=>f7,content_3498_1846:()=>y7,content_3498_1848:()=>D7,content_3498_1850:()=>X7,content_3498_1852:()=>g7,content_3498_1854:()=>x7,content_3498_1856:()=>v7,content_3498_1858:()=>Z7,content_3498_186:()=>Nz,content_3498_1860:()=>N7,content_3498_1862:()=>A7,content_3498_1864:()=>R7,content_3498_1866:()=>S7,content_3498_1868:()=>E7,content_3498_1870:()=>G7,content_3498_1872:()=>F7,content_3498_1874:()=>q7,content_3498_1876:()=>j7,content_3498_1878:()=>H7,content_3498_188:()=>Az,content_3498_1880:()=>$7,content_3498_1882:()=>J7,content_3498_1884:()=>ntt,content_3498_1886:()=>ott,content_3498_1888:()=>rtt,content_3498_1890:()=>ctt,content_3498_1892:()=>att,content_3498_1894:()=>utt,content_3498_1896:()=>dtt,content_3498_1898:()=>ftt,content_3498_190:()=>Rz,content_3498_1900:()=>ytt,content_3498_1902:()=>Dtt,content_3498_1904:()=>Xtt,content_3498_1906:()=>gtt,content_3498_1908:()=>xtt,content_3498_1910:()=>vtt,content_3498_1912:()=>Ztt,content_3498_1914:()=>Ntt,content_3498_1916:()=>Att,content_3498_1918:()=>Rtt,content_3498_192:()=>Sz,content_3498_1920:()=>Stt,content_3498_1922:()=>Ett,content_3498_1924:()=>Gtt,content_3498_1926:()=>Ftt,content_3498_1928:()=>qtt,content_3498_1930:()=>jtt,content_3498_1932:()=>Htt,content_3498_1934:()=>$tt,content_3498_1936:()=>Jtt,content_3498_1938:()=>nnt,content_3498_194:()=>Ez,content_3498_1940:()=>ont,content_3498_1942:()=>rnt,content_3498_1944:()=>cnt,content_3498_1946:()=>ant,content_3498_1948:()=>unt,content_3498_1950:()=>dnt,content_3498_1952:()=>fnt,content_3498_1954:()=>ynt,content_3498_1956:()=>Dnt,content_3498_1958:()=>Xnt,content_3498_196:()=>Gz,content_3498_1960:()=>gnt,content_3498_1962:()=>xnt,content_3498_1964:()=>vnt,content_3498_1966:()=>Znt,content_3498_1968:()=>Nnt,content_3498_1970:()=>Ant,content_3498_1972:()=>Rnt,content_3498_1974:()=>Snt,content_3498_1976:()=>Ent,content_3498_1978:()=>Gnt,content_3498_198:()=>Fz,content_3498_1980:()=>Fnt,content_3498_1982:()=>qnt,content_3498_1984:()=>jnt,content_3498_1986:()=>Hnt,content_3498_1988:()=>$nt,content_3498_1990:()=>Jnt,content_3498_1992:()=>net,content_3498_1994:()=>oet,content_3498_1996:()=>ret,content_3498_1998:()=>cet,content_3498_2:()=>aZ,content_3498_20:()=>vZ,content_3498_200:()=>qz,content_3498_2000:()=>aet,content_3498_2002:()=>met,content_3498_2004:()=>het,content_3498_2006:()=>ket,content_3498_2008:()=>Met,content_3498_2010:()=>_et,content_3498_2012:()=>wet,content_3498_2014:()=>Tet,content_3498_2016:()=>Cet,content_3498_2018:()=>Let,content_3498_202:()=>jz,content_3498_2020:()=>bet,content_3498_2022:()=>zet,content_3498_2024:()=>Wet,content_3498_2026:()=>Iet,content_3498_2028:()=>Pet,content_3498_2030:()=>Bet,content_3498_2032:()=>Oet,content_3498_2034:()=>Uet,content_3498_2036:()=>Vet,content_3498_2038:()=>Qet,content_3498_204:()=>Hz,content_3498_2040:()=>Yet,content_3498_2042:()=>Ket,content_3498_2044:()=>tot,content_3498_2046:()=>eot,content_3498_2048:()=>pot,content_3498_2050:()=>sot,content_3498_2052:()=>iot,content_3498_2054:()=>lot,content_3498_2056:()=>mot,content_3498_2058:()=>hot,content_3498_206:()=>$z,content_3498_2060:()=>kot,content_3498_2062:()=>Mot,content_3498_2064:()=>_ot,content_3498_2066:()=>wot,content_3498_2068:()=>Tot,content_3498_2070:()=>Cot,content_3498_2072:()=>Lot,content_3498_2074:()=>bot,content_3498_2076:()=>zot,content_3498_2078:()=>Wot,content_3498_208:()=>Jz,content_3498_2080:()=>Iot,content_3498_2082:()=>Pot,content_3498_2084:()=>Bot,content_3498_2086:()=>Oot,content_3498_2088:()=>Uot,content_3498_2090:()=>Vot,content_3498_2092:()=>Qot,content_3498_2094:()=>Yot,content_3498_2096:()=>Kot,content_3498_2098:()=>tpt,content_3498_210:()=>nA,content_3498_2100:()=>ept,content_3498_2102:()=>ppt,content_3498_2104:()=>spt,content_3498_2106:()=>ipt,content_3498_2108:()=>lpt,content_3498_2110:()=>mpt,content_3498_2112:()=>hpt,content_3498_2114:()=>kpt,content_3498_2116:()=>Mpt,content_3498_2118:()=>_pt,content_3498_212:()=>oA,content_3498_2120:()=>wpt,content_3498_2122:()=>Tpt,content_3498_2124:()=>Cpt,content_3498_2126:()=>Lpt,content_3498_2128:()=>bpt,content_3498_2130:()=>zpt,content_3498_2132:()=>Wpt,content_3498_2134:()=>Ipt,content_3498_2136:()=>Ppt,content_3498_2138:()=>Bpt,content_3498_214:()=>rA,content_3498_2140:()=>Opt,content_3498_2142:()=>Upt,content_3498_2144:()=>Vpt,content_3498_2146:()=>Qpt,content_3498_2148:()=>Ypt,content_3498_2150:()=>Kpt,content_3498_2152:()=>trt,content_3498_2154:()=>ert,content_3498_2156:()=>prt,content_3498_2158:()=>srt,content_3498_216:()=>cA,content_3498_2160:()=>irt,content_3498_2162:()=>lrt,content_3498_2164:()=>mrt,content_3498_2166:()=>hrt,content_3498_2168:()=>krt,content_3498_2170:()=>Mrt,content_3498_2172:()=>_rt,content_3498_2174:()=>wrt,content_3498_2176:()=>Trt,content_3498_2178:()=>Crt,content_3498_218:()=>aA,content_3498_2180:()=>Lrt,content_3498_2182:()=>brt,content_3498_2184:()=>zrt,content_3498_2186:()=>Wrt,content_3498_2188:()=>Irt,content_3498_2190:()=>Prt,content_3498_2192:()=>Brt,content_3498_2194:()=>Ort,content_3498_2196:()=>Urt,content_3498_2198:()=>Vrt,content_3498_22:()=>ZZ,content_3498_220:()=>uA,content_3498_2200:()=>Qrt,content_3498_2202:()=>Yrt,content_3498_2204:()=>Krt,content_3498_2206:()=>tst,content_3498_2208:()=>est,content_3498_2210:()=>pst,content_3498_2212:()=>sst,content_3498_2214:()=>ist,content_3498_2216:()=>lst,content_3498_2218:()=>mst,content_3498_222:()=>dA,content_3498_2220:()=>hst,content_3498_2222:()=>kst,content_3498_2224:()=>Mst,content_3498_2226:()=>_st,content_3498_2228:()=>wst,content_3498_2230:()=>Tst,content_3498_2232:()=>Cst,content_3498_2234:()=>Lst,content_3498_2236:()=>bst,content_3498_2238:()=>zst,content_3498_224:()=>fA,content_3498_2240:()=>Wst,content_3498_2242:()=>Ist,content_3498_2244:()=>Pst,content_3498_2246:()=>Bst,content_3498_2248:()=>Ost,content_3498_2250:()=>Ust,content_3498_2252:()=>Vst,content_3498_2254:()=>Qst,content_3498_2256:()=>Yst,content_3498_2258:()=>Kst,content_3498_226:()=>yA,content_3498_2260:()=>tct,content_3498_2262:()=>ect,content_3498_2264:()=>pct,content_3498_2266:()=>sct,content_3498_2268:()=>ict,content_3498_2270:()=>lct,content_3498_2272:()=>mct,content_3498_2274:()=>hct,content_3498_2276:()=>kct,content_3498_2278:()=>Mct,content_3498_228:()=>DA,content_3498_2280:()=>_ct,content_3498_2282:()=>wct,content_3498_2284:()=>Tct,content_3498_2286:()=>Cct,content_3498_2288:()=>Lct,content_3498_2290:()=>bct,content_3498_2292:()=>zct,content_3498_2294:()=>Wct,content_3498_2296:()=>Ict,content_3498_2298:()=>Pct,content_3498_230:()=>XA,content_3498_2300:()=>Bct,content_3498_2302:()=>Oct,content_3498_2304:()=>Uct,content_3498_2306:()=>Vct,content_3498_2308:()=>Qct,content_3498_2310:()=>Yct,content_3498_2312:()=>Kct,content_3498_2314:()=>tit,content_3498_2316:()=>eit,content_3498_2318:()=>pit,content_3498_232:()=>gA,content_3498_2320:()=>sit,content_3498_2322:()=>iit,content_3498_2324:()=>lit,content_3498_2326:()=>mit,content_3498_2328:()=>hit,content_3498_2330:()=>kit,content_3498_2332:()=>Mit,content_3498_2334:()=>_it,content_3498_2336:()=>wit,content_3498_2338:()=>Tit,content_3498_234:()=>xA,content_3498_2340:()=>Cit,content_3498_2342:()=>Lit,content_3498_2344:()=>bit,content_3498_2346:()=>zit,content_3498_2348:()=>Wit,content_3498_2350:()=>Iit,content_3498_2352:()=>Pit,content_3498_2354:()=>Bit,content_3498_2356:()=>Oit,content_3498_2358:()=>Uit,content_3498_236:()=>vA,content_3498_2360:()=>Vit,content_3498_2362:()=>Qit,content_3498_2364:()=>Yit,content_3498_2366:()=>Kit,content_3498_2368:()=>tat,content_3498_2370:()=>eat,content_3498_2372:()=>pat,content_3498_2374:()=>sat,content_3498_2376:()=>iat,content_3498_2378:()=>lat,content_3498_238:()=>ZA,content_3498_2380:()=>mat,content_3498_2382:()=>hat,content_3498_2384:()=>kat,content_3498_2386:()=>Mat,content_3498_2388:()=>_at,content_3498_2390:()=>wat,content_3498_2392:()=>Tat,content_3498_2394:()=>Cat,content_3498_2396:()=>Lat,content_3498_2398:()=>bat,content_3498_24:()=>NZ,content_3498_240:()=>NA,content_3498_2400:()=>zat,content_3498_2402:()=>Wat,content_3498_2404:()=>Iat,content_3498_2406:()=>Pat,content_3498_2408:()=>Bat,content_3498_2410:()=>Oat,content_3498_2412:()=>Uat,content_3498_2414:()=>Vat,content_3498_2416:()=>Qat,content_3498_2418:()=>Yat,content_3498_242:()=>AA,content_3498_2420:()=>Kat,content_3498_2422:()=>tlt,content_3498_2424:()=>elt,content_3498_2426:()=>plt,content_3498_2428:()=>slt,content_3498_2430:()=>ilt,content_3498_2432:()=>llt,content_3498_2434:()=>mlt,content_3498_2436:()=>hlt,content_3498_2438:()=>klt,content_3498_244:()=>RA,content_3498_2440:()=>Mlt,content_3498_2442:()=>_lt,content_3498_2444:()=>wlt,content_3498_2446:()=>Tlt,content_3498_2448:()=>Clt,content_3498_2450:()=>Llt,content_3498_2452:()=>blt,content_3498_2454:()=>zlt,content_3498_2456:()=>Wlt,content_3498_2458:()=>Ilt,content_3498_246:()=>SA,content_3498_2460:()=>Plt,content_3498_2462:()=>Blt,content_3498_2464:()=>Olt,content_3498_2466:()=>Ult,content_3498_2468:()=>Vlt,content_3498_2470:()=>Qlt,content_3498_2472:()=>Ylt,content_3498_2474:()=>Klt,content_3498_2476:()=>tut,content_3498_2478:()=>eut,content_3498_248:()=>EA,content_3498_2480:()=>put,content_3498_2482:()=>sut,content_3498_2484:()=>iut,content_3498_2486:()=>lut,content_3498_2488:()=>mut,content_3498_2490:()=>hut,content_3498_2492:()=>kut,content_3498_2494:()=>Mut,content_3498_2496:()=>_ut,content_3498_2498:()=>wut,content_3498_250:()=>GA,content_3498_2500:()=>Tut,content_3498_2502:()=>Cut,content_3498_2504:()=>Lut,content_3498_2506:()=>but,content_3498_2508:()=>zut,content_3498_2510:()=>Wut,content_3498_2512:()=>Iut,content_3498_2514:()=>Put,content_3498_2516:()=>But,content_3498_2518:()=>Out,content_3498_252:()=>FA,content_3498_2520:()=>Uut,content_3498_2522:()=>Vut,content_3498_2524:()=>Qut,content_3498_2526:()=>Yut,content_3498_2528:()=>Kut,content_3498_2530:()=>tmt,content_3498_2532:()=>emt,content_3498_2534:()=>pmt,content_3498_2536:()=>smt,content_3498_2538:()=>imt,content_3498_254:()=>qA,content_3498_2540:()=>lmt,content_3498_2542:()=>mmt,content_3498_2544:()=>hmt,content_3498_2546:()=>kmt,content_3498_2548:()=>Mmt,content_3498_2550:()=>_mt,content_3498_2552:()=>wmt,content_3498_2554:()=>Tmt,content_3498_2556:()=>Cmt,content_3498_2558:()=>Lmt,content_3498_256:()=>jA,content_3498_2560:()=>bmt,content_3498_2562:()=>zmt,content_3498_2564:()=>Wmt,content_3498_2566:()=>Imt,content_3498_2568:()=>Pmt,content_3498_2570:()=>Bmt,content_3498_2572:()=>Omt,content_3498_2574:()=>Umt,content_3498_2576:()=>Vmt,content_3498_2578:()=>Qmt,content_3498_258:()=>HA,content_3498_2580:()=>Ymt,content_3498_2582:()=>Kmt,content_3498_2584:()=>tdt,content_3498_2586:()=>edt,content_3498_2588:()=>pdt,content_3498_2590:()=>sdt,content_3498_2592:()=>idt,content_3498_2594:()=>ldt,content_3498_2596:()=>mdt,content_3498_2598:()=>hdt,content_3498_26:()=>AZ,content_3498_260:()=>$A,content_3498_2600:()=>kdt,content_3498_2602:()=>Mdt,content_3498_2604:()=>_dt,content_3498_2606:()=>wdt,content_3498_2608:()=>Tdt,content_3498_2610:()=>Cdt,content_3498_2612:()=>Ldt,content_3498_2614:()=>bdt,content_3498_2616:()=>zdt,content_3498_2618:()=>Wdt,content_3498_262:()=>JA,content_3498_2620:()=>Idt,content_3498_2622:()=>Pdt,content_3498_2624:()=>Bdt,content_3498_2626:()=>Odt,content_3498_2628:()=>Udt,content_3498_2630:()=>Vdt,content_3498_2632:()=>Qdt,content_3498_2634:()=>Ydt,content_3498_2636:()=>Kdt,content_3498_2638:()=>tht,content_3498_264:()=>nW,content_3498_2640:()=>eht,content_3498_2642:()=>pht,content_3498_2644:()=>sht,content_3498_2646:()=>iht,content_3498_2648:()=>lht,content_3498_2650:()=>mht,content_3498_2652:()=>hht,content_3498_2654:()=>kht,content_3498_2656:()=>Mht,content_3498_2658:()=>_ht,content_3498_266:()=>oW,content_3498_2660:()=>wht,content_3498_2662:()=>Tht,content_3498_2664:()=>Cht,content_3498_2666:()=>Lht,content_3498_2668:()=>bht,content_3498_2670:()=>zht,content_3498_2672:()=>Wht,content_3498_2674:()=>Iht,content_3498_2676:()=>Pht,content_3498_2678:()=>Bht,content_3498_268:()=>rW,content_3498_2680:()=>Oht,content_3498_2682:()=>Uht,content_3498_2684:()=>Vht,content_3498_2686:()=>Qht,content_3498_2688:()=>Yht,content_3498_2690:()=>Kht,content_3498_2692:()=>tft,content_3498_2694:()=>eft,content_3498_2696:()=>pft,content_3498_2698:()=>sft,content_3498_270:()=>cW,content_3498_2700:()=>ift,content_3498_2702:()=>lft,content_3498_2704:()=>mft,content_3498_2706:()=>hft,content_3498_2708:()=>kft,content_3498_2710:()=>Mft,content_3498_2712:()=>_ft,content_3498_2714:()=>wft,content_3498_2716:()=>Tft,content_3498_2718:()=>Cft,content_3498_272:()=>aW,content_3498_2720:()=>Lft,content_3498_2722:()=>bft,content_3498_2724:()=>zft,content_3498_2726:()=>Wft,content_3498_2728:()=>Ift,content_3498_2730:()=>Pft,content_3498_2732:()=>Bft,content_3498_2734:()=>Oft,content_3498_2736:()=>Uft,content_3498_2738:()=>Vft,content_3498_274:()=>uW,content_3498_2740:()=>Qft,content_3498_2742:()=>Yft,content_3498_2744:()=>Kft,content_3498_2746:()=>tkt,content_3498_2748:()=>ekt,content_3498_2750:()=>pkt,content_3498_2752:()=>skt,content_3498_2754:()=>ikt,content_3498_2756:()=>lkt,content_3498_2758:()=>mkt,content_3498_276:()=>dW,content_3498_2760:()=>hkt,content_3498_2762:()=>kkt,content_3498_2764:()=>Mkt,content_3498_2766:()=>_kt,content_3498_2768:()=>wkt,content_3498_2770:()=>Tkt,content_3498_2772:()=>Ckt,content_3498_2774:()=>Lkt,content_3498_2776:()=>bkt,content_3498_2778:()=>zkt,content_3498_278:()=>fW,content_3498_2780:()=>Wkt,content_3498_2782:()=>Ikt,content_3498_2784:()=>Pkt,content_3498_2786:()=>Bkt,content_3498_2788:()=>Okt,content_3498_2790:()=>Ukt,content_3498_2792:()=>Vkt,content_3498_2794:()=>Qkt,content_3498_2796:()=>Ykt,content_3498_2798:()=>Kkt,content_3498_28:()=>RZ,content_3498_280:()=>yW,content_3498_2800:()=>tyt,content_3498_2802:()=>eyt,content_3498_2804:()=>pyt,content_3498_2806:()=>syt,content_3498_2808:()=>iyt,content_3498_2810:()=>lyt,content_3498_2812:()=>myt,content_3498_2814:()=>hyt,content_3498_2816:()=>kyt,content_3498_2818:()=>Myt,content_3498_282:()=>DW,content_3498_2820:()=>_yt,content_3498_2822:()=>wyt,content_3498_2824:()=>Tyt,content_3498_2826:()=>Cyt,content_3498_2828:()=>Lyt,content_3498_2830:()=>byt,content_3498_2832:()=>zyt,content_3498_2834:()=>Wyt,content_3498_2836:()=>Iyt,content_3498_2838:()=>Pyt,content_3498_284:()=>XW,content_3498_2840:()=>Byt,content_3498_2842:()=>Oyt,content_3498_2844:()=>Uyt,content_3498_2846:()=>Vyt,content_3498_2848:()=>Qyt,content_3498_2850:()=>Yyt,content_3498_2852:()=>Kyt,content_3498_2854:()=>tMt,content_3498_2856:()=>eMt,content_3498_2858:()=>pMt,content_3498_286:()=>gW,content_3498_2860:()=>sMt,content_3498_2862:()=>iMt,content_3498_2864:()=>lMt,content_3498_2866:()=>mMt,content_3498_2868:()=>hMt,content_3498_2870:()=>kMt,content_3498_2872:()=>MMt,content_3498_2874:()=>_Mt,content_3498_2876:()=>wMt,content_3498_2878:()=>TMt,content_3498_288:()=>xW,content_3498_2880:()=>CMt,content_3498_2882:()=>LMt,content_3498_2884:()=>bMt,content_3498_2886:()=>zMt,content_3498_2888:()=>WMt,content_3498_2890:()=>IMt,content_3498_2892:()=>PMt,content_3498_2894:()=>BMt,content_3498_2896:()=>OMt,content_3498_2898:()=>UMt,content_3498_290:()=>vW,content_3498_2900:()=>VMt,content_3498_2902:()=>QMt,content_3498_2904:()=>YMt,content_3498_2906:()=>KMt,content_3498_2908:()=>tDt,content_3498_2910:()=>eDt,content_3498_2912:()=>pDt,content_3498_2914:()=>sDt,content_3498_2916:()=>iDt,content_3498_2918:()=>lDt,content_3498_292:()=>ZW,content_3498_2920:()=>mDt,content_3498_2922:()=>hDt,content_3498_2924:()=>kDt,content_3498_2926:()=>MDt,content_3498_2928:()=>_Dt,content_3498_2930:()=>wDt,content_3498_2932:()=>TDt,content_3498_2934:()=>CDt,content_3498_2936:()=>LDt,content_3498_2938:()=>bDt,content_3498_294:()=>NW,content_3498_2940:()=>zDt,content_3498_2942:()=>WDt,content_3498_2944:()=>IDt,content_3498_2946:()=>PDt,content_3498_2948:()=>BDt,content_3498_2950:()=>ODt,content_3498_2952:()=>UDt,content_3498_2954:()=>VDt,content_3498_2956:()=>QDt,content_3498_2958:()=>YDt,content_3498_296:()=>AW,content_3498_2960:()=>KDt,content_3498_2962:()=>t_t,content_3498_2964:()=>e_t,content_3498_2966:()=>p_t,content_3498_2968:()=>s_t,content_3498_2970:()=>i_t,content_3498_2972:()=>l_t,content_3498_2974:()=>m_t,content_3498_2976:()=>h_t,content_3498_2978:()=>k_t,content_3498_298:()=>RW,content_3498_2980:()=>M_t,content_3498_2982:()=>__t,content_3498_2984:()=>w_t,content_3498_2986:()=>T_t,content_3498_2988:()=>C_t,content_3498_2990:()=>L_t,content_3498_2992:()=>b_t,content_3498_2994:()=>z_t,content_3498_2996:()=>W_t,content_3498_2998:()=>I_t,content_3498_30:()=>SZ,content_3498_300:()=>SW,content_3498_3000:()=>P_t,content_3498_3002:()=>B_t,content_3498_3004:()=>O_t,content_3498_3006:()=>U_t,content_3498_3008:()=>V_t,content_3498_3010:()=>Q_t,content_3498_3012:()=>Y_t,content_3498_3014:()=>K_t,content_3498_3016:()=>tXt,content_3498_3018:()=>eXt,content_3498_302:()=>EW,content_3498_3020:()=>pXt,content_3498_3022:()=>sXt,content_3498_3024:()=>iXt,content_3498_3026:()=>lXt,content_3498_3028:()=>mXt,content_3498_3030:()=>hXt,content_3498_3032:()=>kXt,content_3498_3034:()=>MXt,content_3498_3036:()=>_Xt,content_3498_3038:()=>wXt,content_3498_304:()=>GW,content_3498_3040:()=>TXt,content_3498_3042:()=>CXt,content_3498_3044:()=>LXt,content_3498_3046:()=>bXt,content_3498_3048:()=>zXt,content_3498_3050:()=>WXt,content_3498_3052:()=>IXt,content_3498_3054:()=>PXt,content_3498_3056:()=>BXt,content_3498_3058:()=>OXt,content_3498_306:()=>FW,content_3498_3060:()=>UXt,content_3498_3062:()=>VXt,content_3498_3064:()=>QXt,content_3498_3066:()=>YXt,content_3498_3068:()=>KXt,content_3498_3070:()=>twt,content_3498_3072:()=>ewt,content_3498_3074:()=>pwt,content_3498_3076:()=>swt,content_3498_3078:()=>iwt,content_3498_308:()=>qW,content_3498_3080:()=>lwt,content_3498_3082:()=>mwt,content_3498_3084:()=>hwt,content_3498_3086:()=>kwt,content_3498_3088:()=>Mwt,content_3498_3090:()=>_wt,content_3498_3092:()=>wwt,content_3498_3094:()=>Twt,content_3498_3096:()=>Cwt,content_3498_3098:()=>Lwt,content_3498_310:()=>jW,content_3498_3100:()=>bwt,content_3498_3102:()=>zwt,content_3498_3104:()=>Wwt,content_3498_3106:()=>Iwt,content_3498_3108:()=>Pwt,content_3498_3110:()=>Bwt,content_3498_3112:()=>Owt,content_3498_3114:()=>Uwt,content_3498_3116:()=>Vwt,content_3498_3118:()=>Qwt,content_3498_312:()=>HW,content_3498_3120:()=>Ywt,content_3498_3122:()=>Kwt,content_3498_3124:()=>tgt,content_3498_3126:()=>egt,content_3498_3128:()=>pgt,content_3498_3130:()=>sgt,content_3498_3132:()=>igt,content_3498_3134:()=>lgt,content_3498_3136:()=>mgt,content_3498_3138:()=>hgt,content_3498_314:()=>$W,content_3498_3140:()=>kgt,content_3498_3142:()=>Mgt,content_3498_3144:()=>_gt,content_3498_3146:()=>wgt,content_3498_3148:()=>Tgt,content_3498_3150:()=>Cgt,content_3498_3152:()=>Lgt,content_3498_3154:()=>bgt,content_3498_3156:()=>zgt,content_3498_3158:()=>Wgt,content_3498_316:()=>JW,content_3498_3160:()=>Igt,content_3498_3162:()=>Pgt,content_3498_3164:()=>Bgt,content_3498_3166:()=>Ogt,content_3498_3168:()=>Ugt,content_3498_3170:()=>Vgt,content_3498_3172:()=>Qgt,content_3498_3174:()=>Ygt,content_3498_3176:()=>Kgt,content_3498_3178:()=>tTt,content_3498_318:()=>nR,content_3498_3180:()=>eTt,content_3498_3182:()=>pTt,content_3498_3184:()=>sTt,content_3498_3186:()=>iTt,content_3498_3188:()=>lTt,content_3498_3190:()=>mTt,content_3498_3192:()=>hTt,content_3498_3194:()=>kTt,content_3498_3196:()=>MTt,content_3498_3198:()=>_Tt,content_3498_32:()=>EZ,content_3498_320:()=>oR,content_3498_3200:()=>wTt,content_3498_3202:()=>TTt,content_3498_3204:()=>CTt,content_3498_3206:()=>LTt,content_3498_3208:()=>bTt,content_3498_3210:()=>zTt,content_3498_3212:()=>WTt,content_3498_3214:()=>ITt,content_3498_3216:()=>PTt,content_3498_3218:()=>BTt,content_3498_322:()=>rR,content_3498_3220:()=>OTt,content_3498_3222:()=>UTt,content_3498_3224:()=>VTt,content_3498_3226:()=>QTt,content_3498_3228:()=>YTt,content_3498_3230:()=>KTt,content_3498_3232:()=>txt,content_3498_3234:()=>ext,content_3498_3236:()=>pxt,content_3498_3238:()=>sxt,content_3498_324:()=>cR,content_3498_3240:()=>ixt,content_3498_3242:()=>lxt,content_3498_3244:()=>mxt,content_3498_3246:()=>hxt,content_3498_3248:()=>kxt,content_3498_3250:()=>Mxt,content_3498_3252:()=>_xt,content_3498_3254:()=>wxt,content_3498_3256:()=>Txt,content_3498_3258:()=>Cxt,content_3498_326:()=>aR,content_3498_3260:()=>Lxt,content_3498_3262:()=>bxt,content_3498_3264:()=>zxt,content_3498_3266:()=>Wxt,content_3498_3268:()=>Ixt,content_3498_3270:()=>Pxt,content_3498_3272:()=>Bxt,content_3498_3274:()=>Oxt,content_3498_3276:()=>Uxt,content_3498_3278:()=>Vxt,content_3498_328:()=>uR,content_3498_3280:()=>Qxt,content_3498_3282:()=>Yxt,content_3498_3284:()=>Kxt,content_3498_3286:()=>tCt,content_3498_3288:()=>eCt,content_3498_3290:()=>pCt,content_3498_3292:()=>sCt,content_3498_3294:()=>iCt,content_3498_3296:()=>lCt,content_3498_3298:()=>mCt,content_3498_330:()=>dR,content_3498_3300:()=>hCt,content_3498_3302:()=>kCt,content_3498_3304:()=>MCt,content_3498_3306:()=>_Ct,content_3498_3308:()=>wCt,content_3498_3310:()=>TCt,content_3498_3312:()=>CCt,content_3498_3314:()=>LCt,content_3498_3316:()=>bCt,content_3498_3318:()=>zCt,content_3498_332:()=>fR,content_3498_3320:()=>WCt,content_3498_3322:()=>ICt,content_3498_3324:()=>PCt,content_3498_3326:()=>BCt,content_3498_3328:()=>OCt,content_3498_3330:()=>UCt,content_3498_3332:()=>VCt,content_3498_3334:()=>QCt,content_3498_3336:()=>YCt,content_3498_3338:()=>KCt,content_3498_334:()=>yR,content_3498_3340:()=>tvt,content_3498_3342:()=>evt,content_3498_3344:()=>pvt,content_3498_3346:()=>svt,content_3498_3348:()=>ivt,content_3498_3350:()=>lvt,content_3498_3352:()=>mvt,content_3498_3354:()=>hvt,content_3498_3356:()=>kvt,content_3498_3358:()=>Mvt,content_3498_336:()=>DR,content_3498_3360:()=>_vt,content_3498_3362:()=>wvt,content_3498_3364:()=>Tvt,content_3498_3366:()=>Cvt,content_3498_3368:()=>Lvt,content_3498_3370:()=>bvt,content_3498_3372:()=>zvt,content_3498_3374:()=>Wvt,content_3498_3376:()=>Ivt,content_3498_3378:()=>Pvt,content_3498_338:()=>XR,content_3498_3380:()=>Bvt,content_3498_3382:()=>Ovt,content_3498_3384:()=>Uvt,content_3498_3386:()=>Vvt,content_3498_3388:()=>Qvt,content_3498_3390:()=>Yvt,content_3498_3392:()=>Kvt,content_3498_3394:()=>tLt,content_3498_3396:()=>eLt,content_3498_3398:()=>pLt,content_3498_34:()=>GZ,content_3498_340:()=>gR,content_3498_3400:()=>sLt,content_3498_3402:()=>iLt,content_3498_3404:()=>lLt,content_3498_3406:()=>mLt,content_3498_3408:()=>hLt,content_3498_3410:()=>kLt,content_3498_3412:()=>MLt,content_3498_3414:()=>_Lt,content_3498_3416:()=>wLt,content_3498_3418:()=>TLt,content_3498_342:()=>xR,content_3498_3420:()=>CLt,content_3498_3422:()=>LLt,content_3498_3424:()=>bLt,content_3498_3426:()=>zLt,content_3498_3428:()=>WLt,content_3498_3430:()=>ILt,content_3498_3432:()=>PLt,content_3498_3434:()=>BLt,content_3498_3436:()=>OLt,content_3498_3438:()=>ULt,content_3498_344:()=>vR,content_3498_3440:()=>VLt,content_3498_3442:()=>QLt,content_3498_3444:()=>YLt,content_3498_3446:()=>KLt,content_3498_3448:()=>tZt,content_3498_3450:()=>eZt,content_3498_3452:()=>pZt,content_3498_3454:()=>sZt,content_3498_3456:()=>iZt,content_3498_3458:()=>lZt,content_3498_346:()=>ZR,content_3498_3460:()=>mZt,content_3498_3462:()=>hZt,content_3498_3464:()=>kZt,content_3498_3466:()=>MZt,content_3498_3468:()=>_Zt,content_3498_3470:()=>wZt,content_3498_3472:()=>TZt,content_3498_3474:()=>CZt,content_3498_3476:()=>LZt,content_3498_3478:()=>bZt,content_3498_348:()=>NR,content_3498_3480:()=>zZt,content_3498_3482:()=>WZt,content_3498_3484:()=>IZt,content_3498_3486:()=>PZt,content_3498_3488:()=>BZt,content_3498_3490:()=>OZt,content_3498_3492:()=>UZt,content_3498_3494:()=>VZt,content_3498_3496:()=>QZt,content_3498_3498:()=>YZt,content_3498_350:()=>AR,content_3498_3500:()=>KZt,content_3498_3502:()=>tbt,content_3498_3504:()=>ebt,content_3498_3506:()=>pbt,content_3498_3508:()=>sbt,content_3498_3510:()=>ibt,content_3498_3512:()=>lbt,content_3498_3514:()=>mbt,content_3498_3516:()=>hbt,content_3498_3518:()=>kbt,content_3498_352:()=>RR,content_3498_3520:()=>Mbt,content_3498_3522:()=>_bt,content_3498_3524:()=>wbt,content_3498_3526:()=>Tbt,content_3498_3528:()=>Cbt,content_3498_3530:()=>Lbt,content_3498_3532:()=>bbt,content_3498_3534:()=>zbt,content_3498_3536:()=>Wbt,content_3498_3538:()=>Ibt,content_3498_354:()=>SR,content_3498_3540:()=>Pbt,content_3498_3542:()=>Bbt,content_3498_3544:()=>Obt,content_3498_3546:()=>Ubt,content_3498_3548:()=>Vbt,content_3498_3550:()=>Qbt,content_3498_3552:()=>Ybt,content_3498_3554:()=>Kbt,content_3498_3556:()=>tNt,content_3498_3558:()=>eNt,content_3498_356:()=>ER,content_3498_3560:()=>pNt,content_3498_3562:()=>sNt,content_3498_3564:()=>iNt,content_3498_3566:()=>lNt,content_3498_3568:()=>mNt,content_3498_3570:()=>hNt,content_3498_3572:()=>kNt,content_3498_3574:()=>MNt,content_3498_3576:()=>_Nt,content_3498_3578:()=>wNt,content_3498_358:()=>GR,content_3498_3580:()=>TNt,content_3498_3582:()=>CNt,content_3498_3584:()=>LNt,content_3498_3586:()=>bNt,content_3498_3588:()=>zNt,content_3498_3590:()=>WNt,content_3498_3592:()=>INt,content_3498_3594:()=>PNt,content_3498_3596:()=>BNt,content_3498_3598:()=>ONt,content_3498_36:()=>FZ,content_3498_360:()=>FR,content_3498_3600:()=>UNt,content_3498_3602:()=>VNt,content_3498_3604:()=>QNt,content_3498_3606:()=>YNt,content_3498_3608:()=>KNt,content_3498_3610:()=>tzt,content_3498_3612:()=>ezt,content_3498_3614:()=>pzt,content_3498_3616:()=>szt,content_3498_3618:()=>izt,content_3498_362:()=>qR,content_3498_3620:()=>lzt,content_3498_3622:()=>mzt,content_3498_3624:()=>hzt,content_3498_3626:()=>kzt,content_3498_3628:()=>Mzt,content_3498_3630:()=>_zt,content_3498_3632:()=>wzt,content_3498_3634:()=>Tzt,content_3498_3636:()=>Czt,content_3498_3638:()=>Lzt,content_3498_364:()=>jR,content_3498_3640:()=>bzt,content_3498_3642:()=>zzt,content_3498_3644:()=>Wzt,content_3498_3646:()=>Izt,content_3498_3648:()=>Pzt,content_3498_3650:()=>Bzt,content_3498_3652:()=>Ozt,content_3498_3654:()=>Uzt,content_3498_3656:()=>Vzt,content_3498_3658:()=>Qzt,content_3498_366:()=>HR,content_3498_3660:()=>Yzt,content_3498_3662:()=>Kzt,content_3498_3664:()=>tAt,content_3498_3666:()=>eAt,content_3498_3668:()=>pAt,content_3498_3670:()=>sAt,content_3498_3672:()=>iAt,content_3498_3674:()=>lAt,content_3498_3676:()=>mAt,content_3498_3678:()=>hAt,content_3498_368:()=>$R,content_3498_3680:()=>kAt,content_3498_3682:()=>MAt,content_3498_3684:()=>_At,content_3498_3686:()=>wAt,content_3498_3688:()=>TAt,content_3498_3690:()=>CAt,content_3498_3692:()=>LAt,content_3498_3694:()=>bAt,content_3498_3696:()=>zAt,content_3498_3698:()=>WAt,content_3498_370:()=>JR,content_3498_3700:()=>IAt,content_3498_3702:()=>PAt,content_3498_3704:()=>BAt,content_3498_3706:()=>OAt,content_3498_3708:()=>UAt,content_3498_3710:()=>VAt,content_3498_3712:()=>QAt,content_3498_3714:()=>YAt,content_3498_3716:()=>KAt,content_3498_3718:()=>tWt,content_3498_372:()=>nI,content_3498_3720:()=>eWt,content_3498_3722:()=>pWt,content_3498_3724:()=>sWt,content_3498_3726:()=>iWt,content_3498_3728:()=>lWt,content_3498_3730:()=>mWt,content_3498_3732:()=>hWt,content_3498_3734:()=>kWt,content_3498_3736:()=>MWt,content_3498_3738:()=>_Wt,content_3498_374:()=>oI,content_3498_3740:()=>wWt,content_3498_3742:()=>TWt,content_3498_3744:()=>CWt,content_3498_3746:()=>LWt,content_3498_3748:()=>bWt,content_3498_3750:()=>zWt,content_3498_3752:()=>WWt,content_3498_3754:()=>IWt,content_3498_3756:()=>PWt,content_3498_3758:()=>BWt,content_3498_376:()=>rI,content_3498_3760:()=>OWt,content_3498_3762:()=>UWt,content_3498_3764:()=>VWt,content_3498_3766:()=>QWt,content_3498_3768:()=>YWt,content_3498_3770:()=>KWt,content_3498_3772:()=>tRt,content_3498_3774:()=>eRt,content_3498_3776:()=>pRt,content_3498_3778:()=>sRt,content_3498_378:()=>cI,content_3498_3780:()=>iRt,content_3498_3782:()=>lRt,content_3498_3784:()=>mRt,content_3498_3786:()=>hRt,content_3498_3788:()=>kRt,content_3498_3790:()=>MRt,content_3498_3792:()=>_Rt,content_3498_3794:()=>wRt,content_3498_3796:()=>TRt,content_3498_3798:()=>CRt,content_3498_38:()=>qZ,content_3498_380:()=>aI,content_3498_3800:()=>LRt,content_3498_3802:()=>bRt,content_3498_3804:()=>zRt,content_3498_3806:()=>WRt,content_3498_3808:()=>IRt,content_3498_3810:()=>PRt,content_3498_3812:()=>BRt,content_3498_3814:()=>ORt,content_3498_3816:()=>URt,content_3498_3818:()=>VRt,content_3498_382:()=>uI,content_3498_3820:()=>QRt,content_3498_3822:()=>YRt,content_3498_3824:()=>KRt,content_3498_3826:()=>tIt,content_3498_3828:()=>eIt,content_3498_3830:()=>pIt,content_3498_3832:()=>sIt,content_3498_3834:()=>iIt,content_3498_3836:()=>lIt,content_3498_3838:()=>mIt,content_3498_384:()=>dI,content_3498_3840:()=>hIt,content_3498_3842:()=>kIt,content_3498_3844:()=>MIt,content_3498_3846:()=>_It,content_3498_3848:()=>wIt,content_3498_3850:()=>TIt,content_3498_3852:()=>CIt,content_3498_3854:()=>LIt,content_3498_3856:()=>bIt,content_3498_3858:()=>zIt,content_3498_386:()=>fI,content_3498_3860:()=>WIt,content_3498_3862:()=>IIt,content_3498_3864:()=>PIt,content_3498_3866:()=>BIt,content_3498_3868:()=>OIt,content_3498_3870:()=>UIt,content_3498_3872:()=>VIt,content_3498_3874:()=>QIt,content_3498_3876:()=>YIt,content_3498_3878:()=>KIt,content_3498_388:()=>yI,content_3498_3880:()=>tSt,content_3498_3882:()=>eSt,content_3498_3884:()=>pSt,content_3498_3886:()=>sSt,content_3498_3888:()=>iSt,content_3498_3890:()=>lSt,content_3498_3892:()=>mSt,content_3498_3894:()=>hSt,content_3498_3896:()=>kSt,content_3498_3898:()=>MSt,content_3498_390:()=>DI,content_3498_3900:()=>_St,content_3498_3902:()=>wSt,content_3498_3904:()=>TSt,content_3498_3906:()=>CSt,content_3498_3908:()=>LSt,content_3498_3910:()=>bSt,content_3498_3912:()=>zSt,content_3498_3914:()=>WSt,content_3498_3916:()=>ISt,content_3498_3918:()=>PSt,content_3498_392:()=>XI,content_3498_3920:()=>BSt,content_3498_3922:()=>OSt,content_3498_3924:()=>USt,content_3498_3926:()=>VSt,content_3498_3928:()=>QSt,content_3498_3930:()=>YSt,content_3498_3932:()=>KSt,content_3498_3934:()=>tPt,content_3498_3936:()=>ePt,content_3498_3938:()=>pPt,content_3498_394:()=>gI,content_3498_3940:()=>sPt,content_3498_3942:()=>iPt,content_3498_3944:()=>lPt,content_3498_3946:()=>mPt,content_3498_3948:()=>hPt,content_3498_3950:()=>kPt,content_3498_3952:()=>MPt,content_3498_3954:()=>_Pt,content_3498_3956:()=>wPt,content_3498_3958:()=>TPt,content_3498_396:()=>xI,content_3498_3960:()=>CPt,content_3498_3962:()=>LPt,content_3498_3964:()=>bPt,content_3498_3966:()=>zPt,content_3498_3968:()=>WPt,content_3498_3970:()=>IPt,content_3498_3972:()=>PPt,content_3498_3974:()=>BPt,content_3498_3976:()=>OPt,content_3498_3978:()=>UPt,content_3498_398:()=>vI,content_3498_3980:()=>VPt,content_3498_3982:()=>QPt,content_3498_3984:()=>YPt,content_3498_3986:()=>KPt,content_3498_3988:()=>tEt,content_3498_3990:()=>eEt,content_3498_3992:()=>pEt,content_3498_3994:()=>sEt,content_3498_3996:()=>iEt,content_3498_3998:()=>lEt,content_3498_4:()=>uZ,content_3498_40:()=>jZ,content_3498_400:()=>ZI,content_3498_4000:()=>mEt,content_3498_4002:()=>hEt,content_3498_4004:()=>kEt,content_3498_4006:()=>MEt,content_3498_4008:()=>_Et,content_3498_4010:()=>wEt,content_3498_4012:()=>TEt,content_3498_4014:()=>CEt,content_3498_4016:()=>LEt,content_3498_4018:()=>bEt,content_3498_402:()=>NI,content_3498_4020:()=>zEt,content_3498_4022:()=>WEt,content_3498_4024:()=>IEt,content_3498_4026:()=>PEt,content_3498_4028:()=>BEt,content_3498_4030:()=>OEt,content_3498_4032:()=>UEt,content_3498_4034:()=>VEt,content_3498_4036:()=>QEt,content_3498_4038:()=>YEt,content_3498_404:()=>AI,content_3498_4040:()=>KEt,content_3498_4042:()=>tBt,content_3498_4044:()=>eBt,content_3498_4046:()=>pBt,content_3498_4048:()=>sBt,content_3498_4050:()=>iBt,content_3498_4052:()=>lBt,content_3498_4054:()=>mBt,content_3498_4056:()=>hBt,content_3498_4058:()=>kBt,content_3498_406:()=>RI,content_3498_4060:()=>MBt,content_3498_4062:()=>_Bt,content_3498_4064:()=>wBt,content_3498_4066:()=>TBt,content_3498_4068:()=>CBt,content_3498_4070:()=>LBt,content_3498_4072:()=>bBt,content_3498_4074:()=>zBt,content_3498_4076:()=>WBt,content_3498_4078:()=>IBt,content_3498_408:()=>SI,content_3498_4080:()=>PBt,content_3498_4082:()=>BBt,content_3498_4084:()=>OBt,content_3498_4086:()=>UBt,content_3498_4088:()=>VBt,content_3498_4090:()=>QBt,content_3498_4092:()=>YBt,content_3498_4094:()=>KBt,content_3498_4096:()=>tGt,content_3498_4098:()=>eGt,content_3498_410:()=>EI,content_3498_4100:()=>pGt,content_3498_4102:()=>sGt,content_3498_4104:()=>iGt,content_3498_4106:()=>lGt,content_3498_4108:()=>mGt,content_3498_4110:()=>hGt,content_3498_4112:()=>kGt,content_3498_4114:()=>MGt,content_3498_4116:()=>_Gt,content_3498_4118:()=>wGt,content_3498_412:()=>GI,content_3498_4120:()=>TGt,content_3498_4122:()=>CGt,content_3498_4124:()=>LGt,content_3498_4126:()=>bGt,content_3498_4128:()=>zGt,content_3498_4130:()=>WGt,content_3498_4132:()=>IGt,content_3498_4134:()=>PGt,content_3498_4136:()=>BGt,content_3498_4138:()=>OGt,content_3498_414:()=>FI,content_3498_4140:()=>UGt,content_3498_4142:()=>VGt,content_3498_4144:()=>QGt,content_3498_4146:()=>YGt,content_3498_4148:()=>KGt,content_3498_4150:()=>tOt,content_3498_4152:()=>eOt,content_3498_4154:()=>pOt,content_3498_4156:()=>sOt,content_3498_4158:()=>iOt,content_3498_416:()=>qI,content_3498_4160:()=>lOt,content_3498_4162:()=>mOt,content_3498_4164:()=>hOt,content_3498_4166:()=>kOt,content_3498_4168:()=>MOt,content_3498_4170:()=>_Ot,content_3498_4172:()=>wOt,content_3498_4174:()=>TOt,content_3498_4176:()=>COt,content_3498_4178:()=>LOt,content_3498_418:()=>jI,content_3498_4180:()=>bOt,content_3498_4182:()=>zOt,content_3498_4184:()=>WOt,content_3498_4186:()=>IOt,content_3498_4188:()=>POt,content_3498_4190:()=>BOt,content_3498_4192:()=>OOt,content_3498_4194:()=>UOt,content_3498_4196:()=>VOt,content_3498_4198:()=>QOt,content_3498_42:()=>HZ,content_3498_420:()=>HI,content_3498_4200:()=>YOt,content_3498_4202:()=>KOt,content_3498_4204:()=>tFt,content_3498_4206:()=>eFt,content_3498_4208:()=>pFt,content_3498_4210:()=>sFt,content_3498_4212:()=>iFt,content_3498_4214:()=>lFt,content_3498_4216:()=>mFt,content_3498_4218:()=>hFt,content_3498_422:()=>$I,content_3498_4220:()=>kFt,content_3498_4222:()=>MFt,content_3498_4224:()=>_Ft,content_3498_4226:()=>wFt,content_3498_4228:()=>TFt,content_3498_4230:()=>CFt,content_3498_4232:()=>LFt,content_3498_4234:()=>bFt,content_3498_4236:()=>zFt,content_3498_4238:()=>WFt,content_3498_424:()=>JI,content_3498_4240:()=>IFt,content_3498_4242:()=>PFt,content_3498_4244:()=>BFt,content_3498_4246:()=>OFt,content_3498_4248:()=>UFt,content_3498_4250:()=>VFt,content_3498_4252:()=>QFt,content_3498_4254:()=>YFt,content_3498_4256:()=>KFt,content_3498_4258:()=>tUt,content_3498_426:()=>nS,content_3498_4260:()=>eUt,content_3498_4262:()=>pUt,content_3498_4264:()=>sUt,content_3498_4266:()=>iUt,content_3498_4268:()=>lUt,content_3498_4270:()=>mUt,content_3498_4272:()=>hUt,content_3498_4274:()=>kUt,content_3498_4276:()=>MUt,content_3498_4278:()=>_Ut,content_3498_428:()=>oS,content_3498_4280:()=>wUt,content_3498_4282:()=>TUt,content_3498_4284:()=>CUt,content_3498_4286:()=>LUt,content_3498_4288:()=>bUt,content_3498_4290:()=>zUt,content_3498_4292:()=>WUt,content_3498_4294:()=>IUt,content_3498_4296:()=>PUt,content_3498_4298:()=>BUt,content_3498_430:()=>rS,content_3498_4300:()=>OUt,content_3498_4302:()=>UUt,content_3498_4304:()=>VUt,content_3498_4306:()=>QUt,content_3498_4308:()=>YUt,content_3498_4310:()=>KUt,content_3498_4312:()=>tqt,content_3498_4314:()=>eqt,content_3498_4316:()=>pqt,content_3498_4318:()=>sqt,content_3498_432:()=>cS,content_3498_4320:()=>iqt,content_3498_4322:()=>lqt,content_3498_4324:()=>mqt,content_3498_4326:()=>hqt,content_3498_4328:()=>kqt,content_3498_4330:()=>Mqt,content_3498_4332:()=>_qt,content_3498_4334:()=>wqt,content_3498_4336:()=>Tqt,content_3498_4338:()=>Cqt,content_3498_434:()=>aS,content_3498_4340:()=>Lqt,content_3498_4342:()=>bqt,content_3498_4344:()=>zqt,content_3498_4346:()=>Wqt,content_3498_4348:()=>Iqt,content_3498_4350:()=>Pqt,content_3498_4352:()=>Bqt,content_3498_4354:()=>Oqt,content_3498_4356:()=>Uqt,content_3498_4358:()=>Vqt,content_3498_436:()=>uS,content_3498_4360:()=>Qqt,content_3498_4362:()=>Yqt,content_3498_4364:()=>Kqt,content_3498_4366:()=>tVt,content_3498_4368:()=>eVt,content_3498_4370:()=>pVt,content_3498_4372:()=>sVt,content_3498_4374:()=>iVt,content_3498_4376:()=>lVt,content_3498_4378:()=>mVt,content_3498_438:()=>dS,content_3498_4380:()=>hVt,content_3498_4382:()=>kVt,content_3498_4384:()=>MVt,content_3498_4386:()=>_Vt,content_3498_4388:()=>wVt,content_3498_4390:()=>TVt,content_3498_4392:()=>CVt,content_3498_4394:()=>LVt,content_3498_4396:()=>bVt,content_3498_4398:()=>zVt,content_3498_44:()=>$Z,content_3498_440:()=>fS,content_3498_4400:()=>WVt,content_3498_4402:()=>IVt,content_3498_4404:()=>PVt,content_3498_4406:()=>BVt,content_3498_4408:()=>OVt,content_3498_4410:()=>UVt,content_3498_4412:()=>VVt,content_3498_4414:()=>QVt,content_3498_4416:()=>YVt,content_3498_4418:()=>KVt,content_3498_442:()=>yS,content_3498_4420:()=>tjt,content_3498_4422:()=>ejt,content_3498_4424:()=>pjt,content_3498_4426:()=>sjt,content_3498_4428:()=>ijt,content_3498_4430:()=>ljt,content_3498_4432:()=>mjt,content_3498_4434:()=>hjt,content_3498_4436:()=>kjt,content_3498_4438:()=>Mjt,content_3498_444:()=>DS,content_3498_4440:()=>_jt,content_3498_4442:()=>wjt,content_3498_4444:()=>Tjt,content_3498_4446:()=>Cjt,content_3498_4448:()=>Ljt,content_3498_4450:()=>bjt,content_3498_4452:()=>zjt,content_3498_4454:()=>Wjt,content_3498_4456:()=>Ijt,content_3498_4458:()=>Pjt,content_3498_446:()=>XS,content_3498_4460:()=>Bjt,content_3498_4462:()=>Ojt,content_3498_4464:()=>Ujt,content_3498_4466:()=>Vjt,content_3498_4468:()=>Qjt,content_3498_4470:()=>Yjt,content_3498_4472:()=>Kjt,content_3498_4474:()=>tQt,content_3498_4476:()=>eQt,content_3498_4478:()=>pQt,content_3498_448:()=>gS,content_3498_4480:()=>sQt,content_3498_4482:()=>iQt,content_3498_4484:()=>lQt,content_3498_4486:()=>mQt,content_3498_4488:()=>hQt,content_3498_4490:()=>kQt,content_3498_4492:()=>MQt,content_3498_4494:()=>_Qt,content_3498_4496:()=>wQt,content_3498_4498:()=>TQt,content_3498_450:()=>xS,content_3498_4500:()=>CQt,content_3498_4502:()=>LQt,content_3498_4504:()=>bQt,content_3498_4506:()=>zQt,content_3498_4508:()=>WQt,content_3498_4510:()=>IQt,content_3498_4512:()=>PQt,content_3498_4514:()=>BQt,content_3498_4516:()=>OQt,content_3498_4518:()=>UQt,content_3498_452:()=>vS,content_3498_4520:()=>VQt,content_3498_4522:()=>QQt,content_3498_4524:()=>YQt,content_3498_4526:()=>KQt,content_3498_4528:()=>tHt,content_3498_4530:()=>eHt,content_3498_4532:()=>pHt,content_3498_4534:()=>sHt,content_3498_4536:()=>iHt,content_3498_4538:()=>lHt,content_3498_454:()=>ZS,content_3498_4540:()=>mHt,content_3498_4542:()=>hHt,content_3498_4544:()=>kHt,content_3498_4546:()=>MHt,content_3498_4548:()=>_Ht,content_3498_4550:()=>wHt,content_3498_4552:()=>THt,content_3498_4554:()=>CHt,content_3498_4556:()=>LHt,content_3498_4558:()=>bHt,content_3498_456:()=>NS,content_3498_4560:()=>zHt,content_3498_4562:()=>WHt,content_3498_4564:()=>IHt,content_3498_4566:()=>PHt,content_3498_4568:()=>BHt,content_3498_4570:()=>OHt,content_3498_4572:()=>UHt,content_3498_4574:()=>VHt,content_3498_4576:()=>QHt,content_3498_4578:()=>YHt,content_3498_458:()=>AS,content_3498_4580:()=>KHt,content_3498_4582:()=>tYt,content_3498_4584:()=>eYt,content_3498_4586:()=>pYt,content_3498_4588:()=>sYt,content_3498_4590:()=>iYt,content_3498_4592:()=>lYt,content_3498_4594:()=>mYt,content_3498_4596:()=>hYt,content_3498_4598:()=>kYt,content_3498_46:()=>JZ,content_3498_460:()=>RS,content_3498_4600:()=>MYt,content_3498_4602:()=>_Yt,content_3498_4604:()=>wYt,content_3498_4606:()=>TYt,content_3498_4608:()=>CYt,content_3498_4610:()=>LYt,content_3498_4612:()=>bYt,content_3498_4614:()=>zYt,content_3498_4616:()=>WYt,content_3498_4618:()=>IYt,content_3498_462:()=>SS,content_3498_4620:()=>PYt,content_3498_4622:()=>BYt,content_3498_4624:()=>OYt,content_3498_4626:()=>UYt,content_3498_4628:()=>VYt,content_3498_4630:()=>QYt,content_3498_4632:()=>YYt,content_3498_4634:()=>KYt,content_3498_4636:()=>t$t,content_3498_4638:()=>e$t,content_3498_464:()=>ES,content_3498_4640:()=>p$t,content_3498_4642:()=>s$t,content_3498_4644:()=>i$t,content_3498_4646:()=>l$t,content_3498_4648:()=>m$t,content_3498_4650:()=>h$t,content_3498_4652:()=>k$t,content_3498_4654:()=>M$t,content_3498_4656:()=>_$t,content_3498_4658:()=>w$t,content_3498_466:()=>GS,content_3498_4660:()=>T$t,content_3498_4662:()=>C$t,content_3498_4664:()=>L$t,content_3498_4666:()=>b$t,content_3498_4668:()=>z$t,content_3498_4670:()=>W$t,content_3498_4672:()=>I$t,content_3498_4674:()=>P$t,content_3498_4676:()=>B$t,content_3498_4678:()=>O$t,content_3498_468:()=>FS,content_3498_4680:()=>U$t,content_3498_4682:()=>V$t,content_3498_4684:()=>Q$t,content_3498_4686:()=>Y$t,content_3498_4688:()=>K$t,content_3498_4690:()=>tKt,content_3498_4692:()=>eKt,content_3498_4694:()=>pKt,content_3498_4696:()=>sKt,content_3498_4698:()=>iKt,content_3498_470:()=>qS,content_3498_4700:()=>lKt,content_3498_4702:()=>mKt,content_3498_4704:()=>hKt,content_3498_4706:()=>kKt,content_3498_4708:()=>MKt,content_3498_4710:()=>_Kt,content_3498_4712:()=>wKt,content_3498_4714:()=>TKt,content_3498_4716:()=>CKt,content_3498_4718:()=>LKt,content_3498_472:()=>jS,content_3498_4720:()=>bKt,content_3498_4722:()=>zKt,content_3498_4724:()=>WKt,content_3498_4726:()=>IKt,content_3498_4728:()=>PKt,content_3498_4730:()=>BKt,content_3498_4732:()=>OKt,content_3498_4734:()=>UKt,content_3498_4736:()=>VKt,content_3498_4738:()=>QKt,content_3498_474:()=>HS,content_3498_4740:()=>YKt,content_3498_4742:()=>KKt,content_3498_4744:()=>tJt,content_3498_4746:()=>eJt,content_3498_4748:()=>pJt,content_3498_4750:()=>sJt,content_3498_4752:()=>iJt,content_3498_4754:()=>lJt,content_3498_4756:()=>mJt,content_3498_4758:()=>hJt,content_3498_476:()=>$S,content_3498_4760:()=>kJt,content_3498_4762:()=>MJt,content_3498_4764:()=>_Jt,content_3498_4766:()=>wJt,content_3498_4768:()=>TJt,content_3498_4770:()=>CJt,content_3498_4772:()=>LJt,content_3498_4774:()=>bJt,content_3498_4776:()=>zJt,content_3498_4778:()=>WJt,content_3498_478:()=>JS,content_3498_4780:()=>IJt,content_3498_4782:()=>PJt,content_3498_4784:()=>BJt,content_3498_4786:()=>OJt,content_3498_4788:()=>UJt,content_3498_4790:()=>VJt,content_3498_4792:()=>QJt,content_3498_4794:()=>YJt,content_3498_4796:()=>KJt,content_3498_4798:()=>t0t,content_3498_48:()=>nb,content_3498_480:()=>nP,content_3498_4800:()=>e0t,content_3498_4802:()=>p0t,content_3498_4804:()=>s0t,content_3498_4806:()=>i0t,content_3498_4808:()=>l0t,content_3498_4810:()=>m0t,content_3498_4812:()=>h0t,content_3498_4814:()=>k0t,content_3498_4816:()=>M0t,content_3498_4818:()=>_0t,content_3498_482:()=>oP,content_3498_4820:()=>w0t,content_3498_4822:()=>T0t,content_3498_4824:()=>C0t,content_3498_4826:()=>L0t,content_3498_4828:()=>b0t,content_3498_4830:()=>z0t,content_3498_4832:()=>W0t,content_3498_4834:()=>I0t,content_3498_4836:()=>P0t,content_3498_4838:()=>B0t,content_3498_484:()=>rP,content_3498_4840:()=>O0t,content_3498_4842:()=>U0t,content_3498_4844:()=>V0t,content_3498_4846:()=>Q0t,content_3498_4848:()=>Y0t,content_3498_4850:()=>K0t,content_3498_4852:()=>t4t,content_3498_4854:()=>e4t,content_3498_4856:()=>p4t,content_3498_4858:()=>s4t,content_3498_486:()=>cP,content_3498_4860:()=>i4t,content_3498_4862:()=>l4t,content_3498_4864:()=>m4t,content_3498_4866:()=>h4t,content_3498_4868:()=>k4t,content_3498_4870:()=>M4t,content_3498_4872:()=>_4t,content_3498_4874:()=>w4t,content_3498_4876:()=>T4t,content_3498_4878:()=>C4t,content_3498_488:()=>aP,content_3498_4880:()=>L4t,content_3498_4882:()=>b4t,content_3498_4884:()=>z4t,content_3498_4886:()=>W4t,content_3498_4888:()=>I4t,content_3498_4890:()=>P4t,content_3498_4892:()=>B4t,content_3498_4894:()=>O4t,content_3498_4896:()=>U4t,content_3498_4898:()=>V4t,content_3498_490:()=>uP,content_3498_4900:()=>Q4t,content_3498_4902:()=>Y4t,content_3498_4904:()=>K4t,content_3498_4906:()=>t8t,content_3498_4908:()=>e8t,content_3498_4910:()=>p8t,content_3498_4912:()=>s8t,content_3498_4914:()=>i8t,content_3498_4916:()=>l8t,content_3498_4918:()=>m8t,content_3498_492:()=>dP,content_3498_4920:()=>h8t,content_3498_4922:()=>k8t,content_3498_4924:()=>M8t,content_3498_4926:()=>_8t,content_3498_4928:()=>w8t,content_3498_4930:()=>T8t,content_3498_4932:()=>C8t,content_3498_4934:()=>L8t,content_3498_4936:()=>b8t,content_3498_4938:()=>z8t,content_3498_494:()=>fP,content_3498_4940:()=>W8t,content_3498_4942:()=>I8t,content_3498_4944:()=>P8t,content_3498_4946:()=>B8t,content_3498_4948:()=>O8t,content_3498_4950:()=>U8t,content_3498_4952:()=>V8t,content_3498_4954:()=>Q8t,content_3498_4956:()=>Y8t,content_3498_4958:()=>K8t,content_3498_496:()=>yP,content_3498_4960:()=>t3t,content_3498_4962:()=>e3t,content_3498_4964:()=>p3t,content_3498_4966:()=>s3t,content_3498_4968:()=>i3t,content_3498_4970:()=>l3t,content_3498_4972:()=>m3t,content_3498_4974:()=>h3t,content_3498_4976:()=>k3t,content_3498_4978:()=>M3t,content_3498_498:()=>DP,content_3498_4980:()=>_3t,content_3498_4982:()=>w3t,content_3498_4984:()=>T3t,content_3498_4986:()=>C3t,content_3498_4988:()=>L3t,content_3498_4990:()=>b3t,content_3498_4992:()=>z3t,content_3498_4994:()=>W3t,content_3498_4996:()=>I3t,content_3498_4998:()=>P3t,content_3498_50:()=>ob,content_3498_500:()=>XP,content_3498_5000:()=>B3t,content_3498_5002:()=>O3t,content_3498_5004:()=>U3t,content_3498_5006:()=>V3t,content_3498_5008:()=>Q3t,content_3498_5010:()=>Y3t,content_3498_5012:()=>K3t,content_3498_5014:()=>t9t,content_3498_5016:()=>e9t,content_3498_5018:()=>p9t,content_3498_502:()=>gP,content_3498_5020:()=>s9t,content_3498_5022:()=>i9t,content_3498_5024:()=>l9t,content_3498_5026:()=>m9t,content_3498_5028:()=>h9t,content_3498_5030:()=>k9t,content_3498_5032:()=>M9t,content_3498_5034:()=>_9t,content_3498_5036:()=>w9t,content_3498_5038:()=>T9t,content_3498_504:()=>xP,content_3498_5040:()=>C9t,content_3498_5042:()=>L9t,content_3498_5044:()=>b9t,content_3498_5046:()=>z9t,content_3498_5048:()=>W9t,content_3498_5050:()=>I9t,content_3498_5052:()=>P9t,content_3498_5054:()=>B9t,content_3498_5056:()=>O9t,content_3498_5058:()=>U9t,content_3498_506:()=>vP,content_3498_5060:()=>V9t,content_3498_5062:()=>Q9t,content_3498_5064:()=>Y9t,content_3498_5066:()=>K9t,content_3498_5068:()=>t2t,content_3498_5070:()=>e2t,content_3498_5072:()=>p2t,content_3498_5074:()=>s2t,content_3498_5076:()=>i2t,content_3498_5078:()=>l2t,content_3498_508:()=>ZP,content_3498_5080:()=>m2t,content_3498_5082:()=>h2t,content_3498_5084:()=>k2t,content_3498_5086:()=>M2t,content_3498_5088:()=>_2t,content_3498_5090:()=>w2t,content_3498_5092:()=>T2t,content_3498_5094:()=>C2t,content_3498_5096:()=>L2t,content_3498_5098:()=>b2t,content_3498_510:()=>NP,content_3498_5100:()=>z2t,content_3498_5102:()=>W2t,content_3498_5104:()=>I2t,content_3498_5106:()=>P2t,content_3498_5108:()=>B2t,content_3498_5110:()=>O2t,content_3498_5112:()=>U2t,content_3498_5114:()=>V2t,content_3498_5116:()=>Q2t,content_3498_5118:()=>Y2t,content_3498_512:()=>AP,content_3498_5120:()=>K2t,content_3498_5122:()=>t1t,content_3498_5124:()=>e1t,content_3498_5126:()=>p1t,content_3498_5128:()=>s1t,content_3498_5130:()=>i1t,content_3498_5132:()=>l1t,content_3498_5134:()=>m1t,content_3498_5136:()=>h1t,content_3498_5138:()=>k1t,content_3498_514:()=>RP,content_3498_5140:()=>M1t,content_3498_5142:()=>_1t,content_3498_5144:()=>w1t,content_3498_5146:()=>T1t,content_3498_5148:()=>C1t,content_3498_5150:()=>L1t,content_3498_5152:()=>b1t,content_3498_5154:()=>z1t,content_3498_5156:()=>W1t,content_3498_5158:()=>I1t,content_3498_516:()=>SP,content_3498_5160:()=>P1t,content_3498_5162:()=>B1t,content_3498_5164:()=>O1t,content_3498_5166:()=>U1t,content_3498_5168:()=>V1t,content_3498_5170:()=>Q1t,content_3498_5172:()=>Y1t,content_3498_5174:()=>K1t,content_3498_5176:()=>t6t,content_3498_5178:()=>e6t,content_3498_518:()=>EP,content_3498_5180:()=>p6t,content_3498_5182:()=>s6t,content_3498_5184:()=>i6t,content_3498_5186:()=>l6t,content_3498_5188:()=>m6t,content_3498_5190:()=>h6t,content_3498_5192:()=>k6t,content_3498_5194:()=>M6t,content_3498_5196:()=>_6t,content_3498_5198:()=>w6t,content_3498_52:()=>rb,content_3498_520:()=>GP,content_3498_5200:()=>T6t,content_3498_5202:()=>C6t,content_3498_5204:()=>L6t,content_3498_5206:()=>b6t,content_3498_5208:()=>z6t,content_3498_5210:()=>W6t,content_3498_5212:()=>I6t,content_3498_5214:()=>P6t,content_3498_5216:()=>B6t,content_3498_5218:()=>O6t,content_3498_522:()=>FP,content_3498_5220:()=>U6t,content_3498_5222:()=>V6t,content_3498_5224:()=>Q6t,content_3498_5226:()=>Y6t,content_3498_5228:()=>K6t,content_3498_5230:()=>t5t,content_3498_5232:()=>e5t,content_3498_5234:()=>p5t,content_3498_5236:()=>s5t,content_3498_5238:()=>i5t,content_3498_524:()=>qP,content_3498_5240:()=>l5t,content_3498_5242:()=>m5t,content_3498_5244:()=>h5t,content_3498_5246:()=>k5t,content_3498_5248:()=>M5t,content_3498_5250:()=>_5t,content_3498_5252:()=>w5t,content_3498_5254:()=>T5t,content_3498_5256:()=>C5t,content_3498_5258:()=>L5t,content_3498_526:()=>jP,content_3498_5260:()=>b5t,content_3498_5262:()=>z5t,content_3498_5264:()=>W5t,content_3498_5266:()=>I5t,content_3498_5268:()=>P5t,content_3498_5270:()=>B5t,content_3498_5272:()=>O5t,content_3498_5274:()=>U5t,content_3498_5276:()=>V5t,content_3498_5278:()=>Q5t,content_3498_528:()=>HP,content_3498_5280:()=>Y5t,content_3498_5282:()=>K5t,content_3498_5284:()=>t7t,content_3498_5286:()=>e7t,content_3498_5288:()=>p7t,content_3498_5290:()=>s7t,content_3498_5292:()=>i7t,content_3498_5294:()=>l7t,content_3498_5296:()=>m7t,content_3498_5298:()=>h7t,content_3498_530:()=>$P,content_3498_5300:()=>k7t,content_3498_5302:()=>M7t,content_3498_5304:()=>_7t,content_3498_5306:()=>w7t,content_3498_5308:()=>T7t,content_3498_5310:()=>C7t,content_3498_5312:()=>L7t,content_3498_5314:()=>b7t,content_3498_5316:()=>z7t,content_3498_5318:()=>W7t,content_3498_532:()=>JP,content_3498_5320:()=>I7t,content_3498_5322:()=>P7t,content_3498_5324:()=>B7t,content_3498_5326:()=>O7t,content_3498_5328:()=>U7t,content_3498_5330:()=>V7t,content_3498_5332:()=>Q7t,content_3498_5334:()=>Y7t,content_3498_5336:()=>K7t,content_3498_5338:()=>ttn,content_3498_534:()=>nE,content_3498_5340:()=>etn,content_3498_5342:()=>ptn,content_3498_5344:()=>stn,content_3498_5346:()=>itn,content_3498_5348:()=>ltn,content_3498_5350:()=>mtn,content_3498_5352:()=>htn,content_3498_5354:()=>ktn,content_3498_5356:()=>Mtn,content_3498_5358:()=>_tn,content_3498_536:()=>oE,content_3498_5360:()=>wtn,content_3498_5362:()=>Ttn,content_3498_5364:()=>Ctn,content_3498_5366:()=>Ltn,content_3498_5368:()=>btn,content_3498_5370:()=>ztn,content_3498_5372:()=>Wtn,content_3498_5374:()=>Itn,content_3498_5376:()=>Ptn,content_3498_5378:()=>Btn,content_3498_538:()=>rE,content_3498_5380:()=>Otn,content_3498_5382:()=>Utn,content_3498_5384:()=>Vtn,content_3498_5386:()=>Qtn,content_3498_5388:()=>Ytn,content_3498_5390:()=>Ktn,content_3498_5392:()=>tnn,content_3498_5394:()=>enn,content_3498_5396:()=>pnn,content_3498_5398:()=>snn,content_3498_54:()=>cb,content_3498_540:()=>cE,content_3498_5400:()=>inn,content_3498_5402:()=>lnn,content_3498_5404:()=>mnn,content_3498_5406:()=>hnn,content_3498_5408:()=>knn,content_3498_5410:()=>Mnn,content_3498_5412:()=>_nn,content_3498_5414:()=>wnn,content_3498_5416:()=>Tnn,content_3498_5418:()=>Cnn,content_3498_542:()=>aE,content_3498_5420:()=>Lnn,content_3498_5422:()=>bnn,content_3498_5424:()=>znn,content_3498_5426:()=>Wnn,content_3498_5428:()=>Inn,content_3498_5430:()=>Pnn,content_3498_5432:()=>Bnn,content_3498_5434:()=>Onn,content_3498_5436:()=>Unn,content_3498_5438:()=>Vnn,content_3498_544:()=>uE,content_3498_5440:()=>Qnn,content_3498_5442:()=>Ynn,content_3498_5444:()=>Knn,content_3498_5446:()=>ten,content_3498_5448:()=>een,content_3498_5450:()=>pen,content_3498_5452:()=>sen,content_3498_5454:()=>ien,content_3498_5456:()=>len,content_3498_5458:()=>men,content_3498_546:()=>dE,content_3498_5460:()=>hen,content_3498_5462:()=>ken,content_3498_5464:()=>Men,content_3498_5466:()=>_en,content_3498_5468:()=>wen,content_3498_5470:()=>Ten,content_3498_5472:()=>Cen,content_3498_5474:()=>Len,content_3498_5476:()=>ben,content_3498_5478:()=>zen,content_3498_548:()=>fE,content_3498_5480:()=>Wen,content_3498_5482:()=>Ien,content_3498_5484:()=>Pen,content_3498_5486:()=>Ben,content_3498_5488:()=>Oen,content_3498_5490:()=>Uen,content_3498_5492:()=>Ven,content_3498_5494:()=>Qen,content_3498_5496:()=>Yen,content_3498_5498:()=>Ken,content_3498_550:()=>yE,content_3498_5500:()=>ton,content_3498_5502:()=>eon,content_3498_5504:()=>pon,content_3498_5506:()=>son,content_3498_5508:()=>ion,content_3498_5510:()=>lon,content_3498_5512:()=>mon,content_3498_5514:()=>hon,content_3498_5516:()=>kon,content_3498_5518:()=>Mon,content_3498_552:()=>DE,content_3498_5520:()=>_on,content_3498_5522:()=>won,content_3498_5524:()=>Ton,content_3498_5526:()=>Con,content_3498_5528:()=>Lon,content_3498_5530:()=>bon,content_3498_5532:()=>zon,content_3498_5534:()=>Won,content_3498_5536:()=>Ion,content_3498_5538:()=>Pon,content_3498_554:()=>XE,content_3498_5540:()=>Bon,content_3498_5542:()=>Oon,content_3498_5544:()=>Uon,content_3498_5546:()=>Von,content_3498_5548:()=>Qon,content_3498_5550:()=>Yon,content_3498_5552:()=>Kon,content_3498_5554:()=>tpn,content_3498_5556:()=>epn,content_3498_5558:()=>ppn,content_3498_556:()=>gE,content_3498_5560:()=>spn,content_3498_5562:()=>ipn,content_3498_5564:()=>lpn,content_3498_5566:()=>mpn,content_3498_5568:()=>hpn,content_3498_5570:()=>kpn,content_3498_5572:()=>Mpn,content_3498_5574:()=>_pn,content_3498_5576:()=>wpn,content_3498_5578:()=>Tpn,content_3498_558:()=>xE,content_3498_5580:()=>Cpn,content_3498_5582:()=>Lpn,content_3498_5584:()=>bpn,content_3498_5586:()=>zpn,content_3498_5588:()=>Wpn,content_3498_5590:()=>Ipn,content_3498_5592:()=>Ppn,content_3498_5594:()=>Bpn,content_3498_5596:()=>Opn,content_3498_5598:()=>Upn,content_3498_56:()=>ab,content_3498_560:()=>vE,content_3498_5600:()=>Vpn,content_3498_5602:()=>Qpn,content_3498_5604:()=>Ypn,content_3498_5606:()=>Kpn,content_3498_5608:()=>trn,content_3498_5610:()=>ern,content_3498_5612:()=>prn,content_3498_5614:()=>srn,content_3498_5616:()=>irn,content_3498_5618:()=>lrn,content_3498_562:()=>ZE,content_3498_5620:()=>mrn,content_3498_5622:()=>hrn,content_3498_5624:()=>krn,content_3498_5626:()=>Mrn,content_3498_5628:()=>_rn,content_3498_5630:()=>wrn,content_3498_5632:()=>Trn,content_3498_5634:()=>Crn,content_3498_5636:()=>Lrn,content_3498_5638:()=>brn,content_3498_564:()=>NE,content_3498_5640:()=>zrn,content_3498_5642:()=>Wrn,content_3498_5644:()=>Irn,content_3498_5646:()=>Prn,content_3498_5648:()=>Brn,content_3498_5650:()=>Orn,content_3498_5652:()=>Urn,content_3498_5654:()=>Vrn,content_3498_5656:()=>Qrn,content_3498_5658:()=>Yrn,content_3498_566:()=>AE,content_3498_5660:()=>Krn,content_3498_5662:()=>tsn,content_3498_5664:()=>esn,content_3498_5666:()=>psn,content_3498_5668:()=>ssn,content_3498_5670:()=>isn,content_3498_5672:()=>lsn,content_3498_5674:()=>msn,content_3498_5676:()=>hsn,content_3498_5678:()=>ksn,content_3498_568:()=>RE,content_3498_5680:()=>Msn,content_3498_5682:()=>_sn,content_3498_5684:()=>wsn,content_3498_5686:()=>Tsn,content_3498_5688:()=>Csn,content_3498_5690:()=>Lsn,content_3498_5692:()=>bsn,content_3498_5694:()=>zsn,content_3498_5696:()=>Wsn,content_3498_5698:()=>Isn,content_3498_570:()=>SE,content_3498_5700:()=>Psn,content_3498_5702:()=>Bsn,content_3498_5704:()=>Osn,content_3498_5706:()=>Usn,content_3498_5708:()=>Vsn,content_3498_5710:()=>Qsn,content_3498_5712:()=>Ysn,content_3498_5714:()=>Ksn,content_3498_5716:()=>tcn,content_3498_5718:()=>ecn,content_3498_572:()=>EE,content_3498_5720:()=>pcn,content_3498_5722:()=>scn,content_3498_5724:()=>icn,content_3498_5726:()=>lcn,content_3498_5728:()=>mcn,content_3498_5730:()=>hcn,content_3498_5732:()=>kcn,content_3498_5734:()=>Mcn,content_3498_5736:()=>_cn,content_3498_5738:()=>wcn,content_3498_574:()=>GE,content_3498_5740:()=>Tcn,content_3498_5742:()=>Ccn,content_3498_5744:()=>Lcn,content_3498_5746:()=>bcn,content_3498_5748:()=>zcn,content_3498_5750:()=>Wcn,content_3498_5752:()=>Icn,content_3498_5754:()=>Pcn,content_3498_5756:()=>Bcn,content_3498_5758:()=>Ocn,content_3498_576:()=>FE,content_3498_5760:()=>Ucn,content_3498_5762:()=>Vcn,content_3498_5764:()=>Qcn,content_3498_5766:()=>Ycn,content_3498_5768:()=>Kcn,content_3498_5770:()=>tin,content_3498_5772:()=>ein,content_3498_5774:()=>pin,content_3498_5776:()=>sin,content_3498_5778:()=>iin,content_3498_578:()=>qE,content_3498_5780:()=>lin,content_3498_5782:()=>min,content_3498_5784:()=>hin,content_3498_5786:()=>kin,content_3498_5788:()=>Min,content_3498_5790:()=>_in,content_3498_5792:()=>win,content_3498_5794:()=>Tin,content_3498_5796:()=>Cin,content_3498_5798:()=>Lin,content_3498_58:()=>ub,content_3498_580:()=>jE,content_3498_5800:()=>bin,content_3498_5802:()=>zin,content_3498_5804:()=>Win,content_3498_5806:()=>Iin,content_3498_5808:()=>Pin,content_3498_5810:()=>Bin,content_3498_5812:()=>Oin,content_3498_5814:()=>Uin,content_3498_5816:()=>Vin,content_3498_5818:()=>Qin,content_3498_582:()=>HE,content_3498_5820:()=>Yin,content_3498_5822:()=>Kin,content_3498_5824:()=>tan,content_3498_5826:()=>ean,content_3498_5828:()=>pan,content_3498_5830:()=>san,content_3498_5832:()=>ian,content_3498_5834:()=>lan,content_3498_5836:()=>man,content_3498_5838:()=>han,content_3498_584:()=>$E,content_3498_5840:()=>kan,content_3498_5842:()=>Man,content_3498_5844:()=>_an,content_3498_5846:()=>wan,content_3498_5848:()=>Tan,content_3498_5850:()=>Can,content_3498_5852:()=>Lan,content_3498_5854:()=>ban,content_3498_5856:()=>zan,content_3498_5858:()=>Wan,content_3498_586:()=>JE,content_3498_5860:()=>Ian,content_3498_5862:()=>Pan,content_3498_5864:()=>Ban,content_3498_5866:()=>Oan,content_3498_5868:()=>Uan,content_3498_5870:()=>Van,content_3498_5872:()=>Qan,content_3498_5874:()=>Yan,content_3498_5876:()=>Kan,content_3498_5878:()=>tln,content_3498_588:()=>nB,content_3498_5880:()=>eln,content_3498_5882:()=>pln,content_3498_5884:()=>sln,content_3498_5886:()=>iln,content_3498_5888:()=>lln,content_3498_5890:()=>mln,content_3498_5892:()=>hln,content_3498_5894:()=>kln,content_3498_5896:()=>Mln,content_3498_5898:()=>_ln,content_3498_590:()=>oB,content_3498_5900:()=>wln,content_3498_5902:()=>Tln,content_3498_5904:()=>Cln,content_3498_5906:()=>Lln,content_3498_5908:()=>bln,content_3498_5910:()=>zln,content_3498_5912:()=>Wln,content_3498_5914:()=>Iln,content_3498_5916:()=>Pln,content_3498_5918:()=>Bln,content_3498_592:()=>rB,content_3498_5920:()=>Oln,content_3498_5922:()=>Uln,content_3498_5924:()=>Vln,content_3498_5926:()=>Qln,content_3498_5928:()=>Yln,content_3498_5930:()=>Kln,content_3498_5932:()=>tun,content_3498_5934:()=>eun,content_3498_5936:()=>pun,content_3498_5938:()=>sun,content_3498_594:()=>cB,content_3498_5940:()=>iun,content_3498_5942:()=>lun,content_3498_5944:()=>mun,content_3498_5946:()=>hun,content_3498_5948:()=>kun,content_3498_5950:()=>Mun,content_3498_5952:()=>_un,content_3498_5954:()=>wun,content_3498_5956:()=>Tun,content_3498_5958:()=>Cun,content_3498_596:()=>aB,content_3498_5960:()=>Lun,content_3498_5962:()=>bun,content_3498_5964:()=>zun,content_3498_5966:()=>Wun,content_3498_5968:()=>Iun,content_3498_5970:()=>Pun,content_3498_5972:()=>Bun,content_3498_5974:()=>Oun,content_3498_5976:()=>Uun,content_3498_5978:()=>Vun,content_3498_598:()=>uB,content_3498_5980:()=>Qun,content_3498_5982:()=>Yun,content_3498_5984:()=>Kun,content_3498_5986:()=>tmn,content_3498_5988:()=>emn,content_3498_5990:()=>pmn,content_3498_5992:()=>smn,content_3498_5994:()=>imn,content_3498_5996:()=>lmn,content_3498_5998:()=>mmn,content_3498_6:()=>dZ,content_3498_60:()=>db,content_3498_600:()=>dB,content_3498_6000:()=>hmn,content_3498_6002:()=>kmn,content_3498_6004:()=>Mmn,content_3498_6006:()=>_mn,content_3498_6008:()=>wmn,content_3498_6010:()=>Tmn,content_3498_6012:()=>Cmn,content_3498_6014:()=>Lmn,content_3498_6016:()=>bmn,content_3498_6018:()=>zmn,content_3498_602:()=>fB,content_3498_6020:()=>Wmn,content_3498_6022:()=>Imn,content_3498_6024:()=>Pmn,content_3498_6026:()=>Bmn,content_3498_6028:()=>Omn,content_3498_6030:()=>Umn,content_3498_6032:()=>Vmn,content_3498_6034:()=>Qmn,content_3498_6036:()=>Ymn,content_3498_6038:()=>Kmn,content_3498_604:()=>yB,content_3498_6040:()=>tdn,content_3498_6042:()=>edn,content_3498_6044:()=>pdn,content_3498_6046:()=>sdn,content_3498_6048:()=>idn,content_3498_6050:()=>ldn,content_3498_6052:()=>mdn,content_3498_6054:()=>hdn,content_3498_6056:()=>kdn,content_3498_6058:()=>Mdn,content_3498_606:()=>DB,content_3498_6060:()=>_dn,content_3498_6062:()=>wdn,content_3498_6064:()=>Tdn,content_3498_6066:()=>Cdn,content_3498_6068:()=>Ldn,content_3498_6070:()=>bdn,content_3498_6072:()=>zdn,content_3498_6074:()=>Wdn,content_3498_6076:()=>Idn,content_3498_6078:()=>Pdn,content_3498_608:()=>XB,content_3498_6080:()=>Bdn,content_3498_6082:()=>Odn,content_3498_6084:()=>Udn,content_3498_6086:()=>Vdn,content_3498_6088:()=>Qdn,content_3498_6090:()=>Ydn,content_3498_6092:()=>Kdn,content_3498_6094:()=>thn,content_3498_6096:()=>ehn,content_3498_6098:()=>phn,content_3498_610:()=>gB,content_3498_6100:()=>shn,content_3498_6102:()=>ihn,content_3498_6104:()=>lhn,content_3498_6106:()=>mhn,content_3498_6108:()=>hhn,content_3498_6110:()=>khn,content_3498_6112:()=>Mhn,content_3498_6114:()=>_hn,content_3498_6116:()=>whn,content_3498_6118:()=>Thn,content_3498_612:()=>xB,content_3498_6120:()=>Chn,content_3498_6122:()=>Lhn,content_3498_6124:()=>bhn,content_3498_6126:()=>zhn,content_3498_6128:()=>Whn,content_3498_6130:()=>Ihn,content_3498_6132:()=>Phn,content_3498_6134:()=>Bhn,content_3498_6136:()=>Ohn,content_3498_6138:()=>Uhn,content_3498_614:()=>vB,content_3498_6140:()=>Vhn,content_3498_6142:()=>Qhn,content_3498_6144:()=>Yhn,content_3498_6146:()=>Khn,content_3498_6148:()=>tfn,content_3498_6150:()=>efn,content_3498_6152:()=>pfn,content_3498_6154:()=>sfn,content_3498_6156:()=>ifn,content_3498_6158:()=>lfn,content_3498_616:()=>ZB,content_3498_6160:()=>mfn,content_3498_6162:()=>hfn,content_3498_6164:()=>kfn,content_3498_6166:()=>Mfn,content_3498_6168:()=>_fn,content_3498_6170:()=>wfn,content_3498_6172:()=>Tfn,content_3498_6174:()=>Cfn,content_3498_6176:()=>Lfn,content_3498_6178:()=>bfn,content_3498_618:()=>NB,content_3498_6180:()=>zfn,content_3498_6182:()=>Wfn,content_3498_6184:()=>Ifn,content_3498_6186:()=>Pfn,content_3498_6188:()=>Bfn,content_3498_6190:()=>Ofn,content_3498_6192:()=>Ufn,content_3498_6194:()=>Vfn,content_3498_6196:()=>Qfn,content_3498_6198:()=>Yfn,content_3498_62:()=>fb,content_3498_620:()=>AB,content_3498_6200:()=>Kfn,content_3498_6202:()=>tkn,content_3498_6204:()=>ekn,content_3498_6206:()=>pkn,content_3498_6208:()=>skn,content_3498_6210:()=>ikn,content_3498_6212:()=>lkn,content_3498_6214:()=>mkn,content_3498_6216:()=>hkn,content_3498_6218:()=>kkn,content_3498_622:()=>RB,content_3498_6220:()=>Mkn,content_3498_6222:()=>_kn,content_3498_6224:()=>wkn,content_3498_6226:()=>Tkn,content_3498_6228:()=>Ckn,content_3498_6230:()=>Lkn,content_3498_6232:()=>bkn,content_3498_6234:()=>zkn,content_3498_6236:()=>Wkn,content_3498_6238:()=>Ikn,content_3498_624:()=>SB,content_3498_6240:()=>Pkn,content_3498_6242:()=>Bkn,content_3498_6244:()=>Okn,content_3498_6246:()=>Ukn,content_3498_6248:()=>Vkn,content_3498_6250:()=>Qkn,content_3498_6252:()=>Ykn,content_3498_6254:()=>Kkn,content_3498_6256:()=>tyn,content_3498_6258:()=>eyn,content_3498_626:()=>EB,content_3498_6260:()=>pyn,content_3498_6262:()=>syn,content_3498_6264:()=>iyn,content_3498_6266:()=>lyn,content_3498_6268:()=>myn,content_3498_6270:()=>hyn,content_3498_6272:()=>kyn,content_3498_6274:()=>Myn,content_3498_6276:()=>_yn,content_3498_6278:()=>wyn,content_3498_628:()=>GB,content_3498_6280:()=>Tyn,content_3498_6282:()=>Cyn,content_3498_6284:()=>Lyn,content_3498_6286:()=>byn,content_3498_6288:()=>zyn,content_3498_6290:()=>Wyn,content_3498_6292:()=>Iyn,content_3498_6294:()=>Pyn,content_3498_6296:()=>Byn,content_3498_6298:()=>Oyn,content_3498_630:()=>FB,content_3498_6300:()=>Uyn,content_3498_6302:()=>Vyn,content_3498_6304:()=>Qyn,content_3498_6306:()=>Yyn,content_3498_6308:()=>Kyn,content_3498_6310:()=>tMn,content_3498_6312:()=>eMn,content_3498_6314:()=>pMn,content_3498_6316:()=>sMn,content_3498_6318:()=>iMn,content_3498_632:()=>qB,content_3498_6320:()=>lMn,content_3498_6322:()=>mMn,content_3498_6324:()=>hMn,content_3498_6326:()=>kMn,content_3498_6328:()=>MMn,content_3498_6330:()=>_Mn,content_3498_6332:()=>wMn,content_3498_6334:()=>TMn,content_3498_6336:()=>CMn,content_3498_6338:()=>LMn,content_3498_634:()=>jB,content_3498_6340:()=>bMn,content_3498_6342:()=>zMn,content_3498_6344:()=>WMn,content_3498_6346:()=>IMn,content_3498_6348:()=>PMn,content_3498_6350:()=>BMn,content_3498_6352:()=>OMn,content_3498_6354:()=>UMn,content_3498_6356:()=>VMn,content_3498_6358:()=>QMn,content_3498_636:()=>HB,content_3498_6360:()=>YMn,content_3498_6362:()=>KMn,content_3498_6364:()=>tDn,content_3498_6366:()=>eDn,content_3498_6368:()=>pDn,content_3498_6370:()=>sDn,content_3498_6372:()=>iDn,content_3498_6374:()=>lDn,content_3498_6376:()=>mDn,content_3498_6378:()=>hDn,content_3498_638:()=>$B,content_3498_6380:()=>kDn,content_3498_6382:()=>MDn,content_3498_6384:()=>_Dn,content_3498_6386:()=>wDn,content_3498_6388:()=>TDn,content_3498_6390:()=>CDn,content_3498_6392:()=>LDn,content_3498_6394:()=>bDn,content_3498_6396:()=>zDn,content_3498_6398:()=>WDn,content_3498_64:()=>yb,content_3498_640:()=>JB,content_3498_6400:()=>IDn,content_3498_6402:()=>PDn,content_3498_6404:()=>BDn,content_3498_6406:()=>ODn,content_3498_6408:()=>UDn,content_3498_6410:()=>VDn,content_3498_6412:()=>QDn,content_3498_6414:()=>YDn,content_3498_6416:()=>KDn,content_3498_6418:()=>t_n,content_3498_642:()=>nG,content_3498_6420:()=>e_n,content_3498_6422:()=>p_n,content_3498_6424:()=>s_n,content_3498_6426:()=>i_n,content_3498_6428:()=>l_n,content_3498_6430:()=>m_n,content_3498_6432:()=>h_n,content_3498_6434:()=>k_n,content_3498_6436:()=>M_n,content_3498_6438:()=>__n,content_3498_644:()=>oG,content_3498_6440:()=>w_n,content_3498_6442:()=>T_n,content_3498_6444:()=>C_n,content_3498_6446:()=>L_n,content_3498_6448:()=>b_n,content_3498_6450:()=>z_n,content_3498_6452:()=>W_n,content_3498_6454:()=>I_n,content_3498_6456:()=>P_n,content_3498_6458:()=>B_n,content_3498_646:()=>rG,content_3498_6460:()=>O_n,content_3498_6462:()=>U_n,content_3498_6464:()=>V_n,content_3498_6466:()=>Q_n,content_3498_6468:()=>Y_n,content_3498_6470:()=>K_n,content_3498_6472:()=>tXn,content_3498_6474:()=>eXn,content_3498_6476:()=>pXn,content_3498_6478:()=>sXn,content_3498_648:()=>cG,content_3498_6480:()=>iXn,content_3498_6482:()=>lXn,content_3498_6484:()=>mXn,content_3498_6486:()=>hXn,content_3498_6488:()=>kXn,content_3498_6490:()=>MXn,content_3498_6492:()=>_Xn,content_3498_6494:()=>wXn,content_3498_6496:()=>TXn,content_3498_6498:()=>CXn,content_3498_650:()=>aG,content_3498_6500:()=>LXn,content_3498_6502:()=>bXn,content_3498_6504:()=>zXn,content_3498_6506:()=>WXn,content_3498_6508:()=>IXn,content_3498_6510:()=>PXn,content_3498_6512:()=>BXn,content_3498_6514:()=>OXn,content_3498_6516:()=>UXn,content_3498_6518:()=>VXn,content_3498_652:()=>uG,content_3498_6520:()=>QXn,content_3498_6522:()=>YXn,content_3498_6524:()=>KXn,content_3498_6526:()=>twn,content_3498_6528:()=>ewn,content_3498_6530:()=>pwn,content_3498_6532:()=>swn,content_3498_6534:()=>iwn,content_3498_6536:()=>lwn,content_3498_6538:()=>mwn,content_3498_654:()=>dG,content_3498_6540:()=>hwn,content_3498_6542:()=>kwn,content_3498_6544:()=>Mwn,content_3498_6546:()=>_wn,content_3498_6548:()=>wwn,content_3498_6550:()=>Twn,content_3498_6552:()=>Cwn,content_3498_6554:()=>Lwn,content_3498_6556:()=>bwn,content_3498_6558:()=>zwn,content_3498_656:()=>fG,content_3498_6560:()=>Wwn,content_3498_6562:()=>Iwn,content_3498_6564:()=>Pwn,content_3498_6566:()=>Bwn,content_3498_6568:()=>Own,content_3498_6570:()=>Uwn,content_3498_6572:()=>Vwn,content_3498_6574:()=>Qwn,content_3498_6576:()=>Ywn,content_3498_6578:()=>Kwn,content_3498_658:()=>yG,content_3498_6580:()=>tgn,content_3498_6582:()=>egn,content_3498_6584:()=>pgn,content_3498_6586:()=>sgn,content_3498_6588:()=>ign,content_3498_6590:()=>lgn,content_3498_6592:()=>mgn,content_3498_6594:()=>hgn,content_3498_6596:()=>kgn,content_3498_6598:()=>Mgn,content_3498_66:()=>Db,content_3498_660:()=>DG,content_3498_6600:()=>_gn,content_3498_6602:()=>wgn,content_3498_6604:()=>Tgn,content_3498_6606:()=>Cgn,content_3498_6608:()=>Lgn,content_3498_6610:()=>bgn,content_3498_6612:()=>zgn,content_3498_6614:()=>Wgn,content_3498_6616:()=>Ign,content_3498_6618:()=>Pgn,content_3498_662:()=>XG,content_3498_6620:()=>Bgn,content_3498_6622:()=>Ogn,content_3498_6624:()=>Ugn,content_3498_6626:()=>Vgn,content_3498_6628:()=>Qgn,content_3498_6630:()=>Ygn,content_3498_6632:()=>Kgn,content_3498_6634:()=>tTn,content_3498_6636:()=>eTn,content_3498_6638:()=>pTn,content_3498_664:()=>gG,content_3498_6640:()=>sTn,content_3498_6642:()=>iTn,content_3498_6644:()=>lTn,content_3498_6646:()=>mTn,content_3498_6648:()=>hTn,content_3498_6650:()=>kTn,content_3498_6652:()=>MTn,content_3498_6654:()=>_Tn,content_3498_6656:()=>wTn,content_3498_6658:()=>TTn,content_3498_666:()=>xG,content_3498_6660:()=>CTn,content_3498_6662:()=>LTn,content_3498_6664:()=>bTn,content_3498_6666:()=>zTn,content_3498_6668:()=>WTn,content_3498_6670:()=>ITn,content_3498_6672:()=>PTn,content_3498_6674:()=>BTn,content_3498_6676:()=>OTn,content_3498_6678:()=>UTn,content_3498_668:()=>vG,content_3498_6680:()=>VTn,content_3498_6682:()=>QTn,content_3498_6684:()=>YTn,content_3498_6686:()=>KTn,content_3498_6688:()=>txn,content_3498_6690:()=>exn,content_3498_6692:()=>pxn,content_3498_6694:()=>sxn,content_3498_6696:()=>ixn,content_3498_6698:()=>lxn,content_3498_670:()=>ZG,content_3498_6700:()=>mxn,content_3498_6702:()=>hxn,content_3498_6704:()=>kxn,content_3498_6706:()=>Mxn,content_3498_6708:()=>_xn,content_3498_6710:()=>wxn,content_3498_6712:()=>Txn,content_3498_6714:()=>Cxn,content_3498_6716:()=>Lxn,content_3498_6718:()=>bxn,content_3498_672:()=>NG,content_3498_6720:()=>zxn,content_3498_6722:()=>Wxn,content_3498_6724:()=>Ixn,content_3498_6726:()=>Pxn,content_3498_6728:()=>Bxn,content_3498_6730:()=>Oxn,content_3498_6732:()=>Uxn,content_3498_6734:()=>Vxn,content_3498_6736:()=>Qxn,content_3498_6738:()=>Yxn,content_3498_674:()=>AG,content_3498_6740:()=>Kxn,content_3498_6742:()=>tCn,content_3498_6744:()=>eCn,content_3498_6746:()=>pCn,content_3498_6748:()=>sCn,content_3498_6750:()=>iCn,content_3498_6752:()=>lCn,content_3498_6754:()=>mCn,content_3498_6756:()=>hCn,content_3498_6758:()=>kCn,content_3498_676:()=>RG,content_3498_6760:()=>MCn,content_3498_6762:()=>_Cn,content_3498_6764:()=>wCn,content_3498_6766:()=>TCn,content_3498_6768:()=>CCn,content_3498_6770:()=>LCn,content_3498_6772:()=>bCn,content_3498_6774:()=>zCn,content_3498_6776:()=>WCn,content_3498_6778:()=>ICn,content_3498_678:()=>SG,content_3498_6780:()=>PCn,content_3498_6782:()=>BCn,content_3498_6784:()=>OCn,content_3498_6786:()=>UCn,content_3498_6788:()=>VCn,content_3498_6790:()=>QCn,content_3498_6792:()=>YCn,content_3498_6794:()=>KCn,content_3498_6796:()=>tvn,content_3498_6798:()=>evn,content_3498_68:()=>Xb,content_3498_680:()=>EG,content_3498_6800:()=>pvn,content_3498_6802:()=>svn,content_3498_6804:()=>ivn,content_3498_6806:()=>lvn,content_3498_6808:()=>mvn,content_3498_6810:()=>hvn,content_3498_6812:()=>kvn,content_3498_6814:()=>Mvn,content_3498_6816:()=>_vn,content_3498_6818:()=>wvn,content_3498_682:()=>GG,content_3498_6820:()=>Tvn,content_3498_6822:()=>Cvn,content_3498_6824:()=>Lvn,content_3498_6826:()=>bvn,content_3498_6828:()=>zvn,content_3498_6830:()=>Wvn,content_3498_6832:()=>Ivn,content_3498_6834:()=>Pvn,content_3498_6836:()=>Bvn,content_3498_6838:()=>Ovn,content_3498_684:()=>FG,content_3498_6840:()=>Uvn,content_3498_6842:()=>Vvn,content_3498_6844:()=>Qvn,content_3498_6846:()=>Yvn,content_3498_6848:()=>Kvn,content_3498_6850:()=>tLn,content_3498_6852:()=>eLn,content_3498_6854:()=>pLn,content_3498_6856:()=>sLn,content_3498_6858:()=>iLn,content_3498_686:()=>qG,content_3498_6860:()=>lLn,content_3498_6862:()=>mLn,content_3498_6864:()=>hLn,content_3498_6866:()=>kLn,content_3498_6868:()=>MLn,content_3498_6870:()=>_Ln,content_3498_6872:()=>wLn,content_3498_6874:()=>TLn,content_3498_6876:()=>CLn,content_3498_6878:()=>LLn,content_3498_688:()=>jG,content_3498_6880:()=>bLn,content_3498_6882:()=>zLn,content_3498_6884:()=>WLn,content_3498_6886:()=>ILn,content_3498_6888:()=>PLn,content_3498_6890:()=>BLn,content_3498_6892:()=>OLn,content_3498_6894:()=>ULn,content_3498_6896:()=>VLn,content_3498_6898:()=>QLn,content_3498_690:()=>HG,content_3498_6900:()=>YLn,content_3498_6902:()=>KLn,content_3498_6904:()=>tZn,content_3498_6906:()=>eZn,content_3498_6908:()=>pZn,content_3498_6910:()=>sZn,content_3498_6912:()=>iZn,content_3498_6914:()=>lZn,content_3498_6916:()=>mZn,content_3498_6918:()=>hZn,content_3498_692:()=>$G,content_3498_6920:()=>kZn,content_3498_6922:()=>MZn,content_3498_6924:()=>_Zn,content_3498_6926:()=>wZn,content_3498_6928:()=>TZn,content_3498_6930:()=>CZn,content_3498_6932:()=>LZn,content_3498_6934:()=>bZn,content_3498_6936:()=>zZn,content_3498_6938:()=>WZn,content_3498_694:()=>JG,content_3498_6940:()=>IZn,content_3498_6942:()=>PZn,content_3498_6944:()=>BZn,content_3498_6946:()=>OZn,content_3498_6948:()=>UZn,content_3498_6950:()=>VZn,content_3498_6952:()=>QZn,content_3498_6954:()=>YZn,content_3498_6956:()=>KZn,content_3498_6958:()=>tbn,content_3498_696:()=>nO,content_3498_6960:()=>ebn,content_3498_6962:()=>pbn,content_3498_6964:()=>sbn,content_3498_6966:()=>ibn,content_3498_6968:()=>lbn,content_3498_6970:()=>mbn,content_3498_6972:()=>hbn,content_3498_6974:()=>kbn,content_3498_6976:()=>Mbn,content_3498_6978:()=>_bn,content_3498_698:()=>oO,content_3498_6980:()=>wbn,content_3498_6982:()=>Tbn,content_3498_6984:()=>Cbn,content_3498_6986:()=>Lbn,content_3498_6988:()=>bbn,content_3498_6990:()=>zbn,content_3498_6992:()=>Wbn,content_3498_6994:()=>Ibn,content_3498_6996:()=>Pbn,content_3498_6998:()=>Bbn,content_3498_70:()=>gb,content_3498_700:()=>rO,content_3498_7000:()=>Obn,content_3498_7002:()=>Ubn,content_3498_7004:()=>Vbn,content_3498_7006:()=>Qbn,content_3498_7008:()=>Ybn,content_3498_7010:()=>Kbn,content_3498_7012:()=>tNn,content_3498_7014:()=>eNn,content_3498_7016:()=>pNn,content_3498_7018:()=>sNn,content_3498_702:()=>cO,content_3498_7020:()=>iNn,content_3498_7022:()=>lNn,content_3498_7024:()=>mNn,content_3498_7026:()=>hNn,content_3498_7028:()=>kNn,content_3498_7030:()=>MNn,content_3498_7032:()=>_Nn,content_3498_7034:()=>wNn,content_3498_7036:()=>TNn,content_3498_7038:()=>CNn,content_3498_704:()=>aO,content_3498_7040:()=>LNn,content_3498_7042:()=>bNn,content_3498_7044:()=>zNn,content_3498_7046:()=>WNn,content_3498_7048:()=>INn,content_3498_7050:()=>PNn,content_3498_7052:()=>BNn,content_3498_7054:()=>ONn,content_3498_7056:()=>UNn,content_3498_7058:()=>VNn,content_3498_706:()=>uO,content_3498_7060:()=>QNn,content_3498_7062:()=>YNn,content_3498_7064:()=>KNn,content_3498_7066:()=>tzn,content_3498_7068:()=>ezn,content_3498_7070:()=>pzn,content_3498_7072:()=>szn,content_3498_7074:()=>izn,content_3498_7076:()=>lzn,content_3498_7078:()=>mzn,content_3498_708:()=>dO,content_3498_7080:()=>hzn,content_3498_7082:()=>kzn,content_3498_7084:()=>Mzn,content_3498_7086:()=>_zn,content_3498_7088:()=>wzn,content_3498_7090:()=>Tzn,content_3498_7092:()=>Czn,content_3498_7094:()=>Lzn,content_3498_7096:()=>bzn,content_3498_7098:()=>zzn,content_3498_710:()=>fO,content_3498_7100:()=>Wzn,content_3498_7102:()=>Izn,content_3498_7104:()=>Pzn,content_3498_7106:()=>Bzn,content_3498_7108:()=>Ozn,content_3498_7110:()=>Uzn,content_3498_7112:()=>Vzn,content_3498_7114:()=>Qzn,content_3498_7116:()=>Yzn,content_3498_7118:()=>Kzn,content_3498_712:()=>yO,content_3498_7120:()=>tAn,content_3498_7122:()=>eAn,content_3498_7124:()=>pAn,content_3498_7126:()=>sAn,content_3498_7128:()=>iAn,content_3498_7130:()=>lAn,content_3498_7132:()=>mAn,content_3498_7134:()=>hAn,content_3498_7136:()=>kAn,content_3498_7138:()=>MAn,content_3498_714:()=>DO,content_3498_7140:()=>_An,content_3498_7142:()=>wAn,content_3498_7144:()=>TAn,content_3498_7146:()=>CAn,content_3498_7148:()=>LAn,content_3498_7150:()=>bAn,content_3498_7152:()=>zAn,content_3498_7154:()=>WAn,content_3498_7156:()=>IAn,content_3498_7158:()=>PAn,content_3498_716:()=>XO,content_3498_7160:()=>BAn,content_3498_7162:()=>OAn,content_3498_7164:()=>UAn,content_3498_7166:()=>VAn,content_3498_7168:()=>QAn,content_3498_7170:()=>YAn,content_3498_7172:()=>KAn,content_3498_7174:()=>tWn,content_3498_718:()=>gO,content_3498_72:()=>xb,content_3498_720:()=>xO,content_3498_722:()=>vO,content_3498_724:()=>ZO,content_3498_726:()=>NO,content_3498_728:()=>AO,content_3498_730:()=>RO,content_3498_732:()=>SO,content_3498_734:()=>EO,content_3498_736:()=>GO,content_3498_738:()=>FO,content_3498_74:()=>vb,content_3498_740:()=>qO,content_3498_742:()=>jO,content_3498_744:()=>HO,content_3498_746:()=>$O,content_3498_748:()=>JO,content_3498_750:()=>nF,content_3498_752:()=>oF,content_3498_754:()=>rF,content_3498_756:()=>cF,content_3498_758:()=>aF,content_3498_76:()=>Zb,content_3498_760:()=>uF,content_3498_762:()=>dF,content_3498_764:()=>fF,content_3498_766:()=>yF,content_3498_768:()=>DF,content_3498_770:()=>XF,content_3498_772:()=>gF,content_3498_774:()=>xF,content_3498_776:()=>vF,content_3498_778:()=>ZF,content_3498_78:()=>Nb,content_3498_780:()=>NF,content_3498_782:()=>AF,content_3498_784:()=>RF,content_3498_786:()=>SF,content_3498_788:()=>EF,content_3498_790:()=>GF,content_3498_792:()=>FF,content_3498_794:()=>qF,content_3498_796:()=>jF,content_3498_798:()=>HF,content_3498_8:()=>fZ,content_3498_80:()=>Ab,content_3498_800:()=>$F,content_3498_802:()=>JF,content_3498_804:()=>nU,content_3498_806:()=>oU,content_3498_808:()=>rU,content_3498_810:()=>cU,content_3498_812:()=>aU,content_3498_814:()=>uU,content_3498_816:()=>dU,content_3498_818:()=>fU,content_3498_82:()=>Rb,content_3498_820:()=>yU,content_3498_822:()=>DU,content_3498_824:()=>XU,content_3498_826:()=>gU,content_3498_828:()=>xU,content_3498_830:()=>vU,content_3498_832:()=>ZU,content_3498_834:()=>NU,content_3498_836:()=>AU,content_3498_838:()=>RU,content_3498_84:()=>Sb,content_3498_840:()=>SU,content_3498_842:()=>EU,content_3498_844:()=>GU,content_3498_846:()=>FU,content_3498_848:()=>qU,content_3498_850:()=>jU,content_3498_852:()=>HU,content_3498_854:()=>$U,content_3498_856:()=>JU,content_3498_858:()=>nq,content_3498_86:()=>Eb,content_3498_860:()=>oq,content_3498_862:()=>rq,content_3498_864:()=>cq,content_3498_866:()=>aq,content_3498_868:()=>uq,content_3498_870:()=>dq,content_3498_872:()=>fq,content_3498_874:()=>yq,content_3498_876:()=>Dq,content_3498_878:()=>Xq,content_3498_88:()=>Gb,content_3498_880:()=>gq,content_3498_882:()=>xq,content_3498_884:()=>vq,content_3498_886:()=>Zq,content_3498_888:()=>Nq,content_3498_890:()=>Aq,content_3498_892:()=>Rq,content_3498_894:()=>Sq,content_3498_896:()=>Eq,content_3498_898:()=>Gq,content_3498_90:()=>Fb,content_3498_900:()=>Fq,content_3498_902:()=>qq,content_3498_904:()=>jq,content_3498_906:()=>Hq,content_3498_908:()=>$q,content_3498_910:()=>Jq,content_3498_912:()=>nV,content_3498_914:()=>oV,content_3498_916:()=>rV,content_3498_918:()=>cV,content_3498_92:()=>qb,content_3498_920:()=>aV,content_3498_922:()=>uV,content_3498_924:()=>dV,content_3498_926:()=>fV,content_3498_928:()=>yV,content_3498_930:()=>DV,content_3498_932:()=>XV,content_3498_934:()=>gV,content_3498_936:()=>xV,content_3498_938:()=>vV,content_3498_94:()=>jb,content_3498_940:()=>ZV,content_3498_942:()=>NV,content_3498_944:()=>AV,content_3498_946:()=>RV,content_3498_948:()=>SV,content_3498_950:()=>EV,content_3498_952:()=>GV,content_3498_954:()=>FV,content_3498_956:()=>qV,content_3498_958:()=>jV,content_3498_96:()=>Hb,content_3498_960:()=>HV,content_3498_962:()=>$V,content_3498_964:()=>JV,content_3498_966:()=>nj,content_3498_968:()=>oj,content_3498_970:()=>rj,content_3498_972:()=>cj,content_3498_974:()=>aj,content_3498_976:()=>uj,content_3498_978:()=>dj,content_3498_98:()=>$b,content_3498_980:()=>fj,content_3498_982:()=>yj,content_3498_984:()=>Dj,content_3498_986:()=>Xj,content_3498_988:()=>gj,content_3498_990:()=>xj,content_3498_992:()=>vj,content_3498_994:()=>Zj,content_3498_996:()=>Nj,content_3498_998:()=>Aj});var p=e(2784),r=e(7896),s=e(876);const c={toc:[]};function i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const f={toc:[]};function k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}k.isMDXComponent=!0;const y={toc:[]};function M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}w.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}I.isMDXComponent=!0;const S={toc:[]};function P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}P.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}O.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}U.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}V.isMDXComponent=!0;const j={toc:[]};function Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}Q.isMDXComponent=!0;const H={toc:[]};function Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Y.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const ft={toc:[]};function kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}kt.isMDXComponent=!0;const yt={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}It.isMDXComponent=!0;const St={toc:[]};function Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Pt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ot.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ut.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Qt.isMDXComponent=!0;const Ht={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Yt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}fn.isMDXComponent=!0;const kn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}yn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}Xn.isMDXComponent=!0;const wn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}Rn.isMDXComponent=!0;const In={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Sn.isMDXComponent=!0;const Pn={toc:[]};function En(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Gn.isMDXComponent=!0;const On={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}))}Fn.isMDXComponent=!0;const Un={toc:[]};function qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}jn.isMDXComponent=!0;const Qn={toc:[]};function Hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}Hn.isMDXComponent=!0;const Yn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Jn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}re.isMDXComponent=!0;const se={toc:[]};function ce(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}ce.isMDXComponent=!0;const ie={toc:[]};function ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ae.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}de.isMDXComponent=!0;const he={toc:[]};function fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}fe.isMDXComponent=!0;const ke={toc:[]};function ye(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ye.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}De.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Xe.isMDXComponent=!0;const we={toc:[]};function ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ge.isMDXComponent=!0;const Te={toc:[]};function xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}xe.isMDXComponent=!0;const Ce={toc:[]};function ve(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ve.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ze.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ne.isMDXComponent=!0;const ze={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ae.isMDXComponent=!0;const We={toc:[]};function Re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Re.isMDXComponent=!0;const Ie={toc:[]};function Se(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Se.isMDXComponent=!0;const Pe={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}qe.isMDXComponent=!0;const Ve={toc:[]};function je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}je.isMDXComponent=!0;const Qe={toc:[]};function He(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}He.isMDXComponent=!0;const Ye={toc:[]};function $e(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$e.isMDXComponent=!0;const Ke={toc:[]};function Je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Je.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const fo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ko.isMDXComponent=!0;const yo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}wo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Io.isMDXComponent=!0;const So={toc:[]};function Po(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Po.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Oo.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Uo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Qo.isMDXComponent=!0;const Ho={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Yo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const fp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}kp.isMDXComponent=!0;const yp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}wp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ip.isMDXComponent=!0;const Sp={toc:[]};function Pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Pp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Op.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Up.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Qp.isMDXComponent=!0;const Hp={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Yp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const fr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}kr.isMDXComponent=!0;const yr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}wr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ir.isMDXComponent=!0;const Sr={toc:[]};function Pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Pr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Or.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ur.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Vr.isMDXComponent=!0;const jr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Qr.isMDXComponent=!0;const Hr={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Yr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const fs={toc:[]};function ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ks.isMDXComponent=!0;const ys={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ws.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Is.isMDXComponent=!0;const Ss={toc:[]};function Ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ps.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Os.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Us.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Vs.isMDXComponent=!0;const js={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Qs.isMDXComponent=!0;const Hs={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ys.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const fc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}kc.isMDXComponent=!0;const yc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}wc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ic.isMDXComponent=!0;const Sc={toc:[]};function Pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Pc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Oc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Uc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Qc.isMDXComponent=!0;const Hc={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const fi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ki.isMDXComponent=!0;const yi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}wi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ii.isMDXComponent=!0;const Si={toc:[]};function Pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Pi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Oi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ui.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Qi.isMDXComponent=!0;const Hi={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const fa={toc:[]};function ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ka.isMDXComponent=!0;const ya={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ia.isMDXComponent=!0;const Sa={toc:[]};function Pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Pa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Oa.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Ua.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Va.isMDXComponent=!0;const ja={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Qa.isMDXComponent=!0;const Ha={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ha,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ya.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const fl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}kl.isMDXComponent=!0;const yl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}wl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Il.isMDXComponent=!0;const Sl={toc:[]};function Pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Pl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Ol.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ul.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ql.isMDXComponent=!0;const Hl={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const fu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ku.isMDXComponent=!0;const yu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}wu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Iu.isMDXComponent=!0;const Su={toc:[]};function Pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Pu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ou.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Uu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Qu.isMDXComponent=!0;const Hu={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Yu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const fm={toc:[]};function km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}km.isMDXComponent=!0;const ym={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}wm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Im.isMDXComponent=!0;const Sm={toc:[]};function Pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Om.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Um.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Qm.isMDXComponent=!0;const Hm={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ym.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const fd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}kd.isMDXComponent=!0;const yd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}wd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Id.isMDXComponent=!0;const Sd={toc:[]};function Pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Od.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ud.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Qd.isMDXComponent=!0;const Hd={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const fh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kh.isMDXComponent=!0;const yh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}wh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ih.isMDXComponent=!0;const Sh={toc:[]};function Ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ph.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Oh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Uh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Qh.isMDXComponent=!0;const Hh={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Yh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}ff.isMDXComponent=!0;const kf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}Xf.isMDXComponent=!0;const wf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Rf.isMDXComponent=!0;const If={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Sf.isMDXComponent=!0;const Pf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Gf.isMDXComponent=!0;const Of={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}jf.isMDXComponent=!0;const Qf={toc:[]};function Hf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Hf.isMDXComponent=!0;const Yf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Jf.isMDXComponent=!0;const tk={toc:[]};function nk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}nk.isMDXComponent=!0;const ek={toc:[]};function ok(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ek,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ok.isMDXComponent=!0;const pk={toc:[]};function rk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}rk.isMDXComponent=!0;const sk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ck.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Xk.isMDXComponent=!0;const wk={toc:[]};function gk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gk.isMDXComponent=!0;const Tk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}xk.isMDXComponent=!0;const Ck={toc:[]};function vk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zk.isMDXComponent=!0;const bk={toc:[]};function Nk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ak.isMDXComponent=!0;const Wk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Rk.isMDXComponent=!0;const Ik={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Sk.isMDXComponent=!0;const Pk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ek.isMDXComponent=!0;const Bk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Gk.isMDXComponent=!0;const Ok={toc:[]};function Fk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Fk.isMDXComponent=!0;const Uk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qk.isMDXComponent=!0;const Vk={toc:[]};function jk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jk.isMDXComponent=!0;const Qk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Hk.isMDXComponent=!0;const Yk={toc:[]};function $k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$k.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jk.isMDXComponent=!0;const ty={toc:[]};function ny(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ny.isMDXComponent=!0;const ey={toc:[]};function oy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ey,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const My={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Dy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Xy.isMDXComponent=!0;const wy={toc:[]};function gy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function xy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}xy.isMDXComponent=!0;const Cy={toc:[]};function vy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ry.isMDXComponent=!0;const Iy={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Sy.isMDXComponent=!0;const Py={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Ey.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function Fy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Fy.isMDXComponent=!0;const Uy={toc:[]};function qy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}qy.isMDXComponent=!0;const Vy={toc:[]};function jy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Qy={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Hy.isMDXComponent=!0;const Yy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}fM.isMDXComponent=!0;const kM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}XM.isMDXComponent=!0;const wM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}RM.isMDXComponent=!0;const IM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}SM.isMDXComponent=!0;const PM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}GM.isMDXComponent=!0;const OM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}FM.isMDXComponent=!0;const UM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jM.isMDXComponent=!0;const QM={toc:[]};function HM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}HM.isMDXComponent=!0;const YM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}fD.isMDXComponent=!0;const kD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}yD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}XD.isMDXComponent=!0;const wD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}RD.isMDXComponent=!0;const ID={toc:[]};function SD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}SD.isMDXComponent=!0;const PD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}GD.isMDXComponent=!0;const OD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}FD.isMDXComponent=!0;const UD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}jD.isMDXComponent=!0;const QD={toc:[]};function HD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}HD.isMDXComponent=!0;const YD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}JD.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}f_.isMDXComponent=!0;const k_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}y_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}X_.isMDXComponent=!0;const w_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}R_.isMDXComponent=!0;const I_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}S_.isMDXComponent=!0;const P_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}G_.isMDXComponent=!0;const O_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}F_.isMDXComponent=!0;const U_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}j_.isMDXComponent=!0;const Q_={toc:[]};function H_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}H_.isMDXComponent=!0;const Y_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}J_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}fX.isMDXComponent=!0;const kX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}yX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}XX.isMDXComponent=!0;const wX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}RX.isMDXComponent=!0;const IX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}SX.isMDXComponent=!0;const PX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}GX.isMDXComponent=!0;const OX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}FX.isMDXComponent=!0;const UX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}jX.isMDXComponent=!0;const QX={toc:[]};function HX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}HX.isMDXComponent=!0;const YX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}JX.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}fw.isMDXComponent=!0;const kw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}yw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Xw.isMDXComponent=!0;const ww={toc:[]};function gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}Sw.isMDXComponent=!0;const Pw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}jw.isMDXComponent=!0;const Qw={toc:[]};function Hw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Hw.isMDXComponent=!0;const Yw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}Jw.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}fg.isMDXComponent=!0;const kg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}yg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Xg.isMDXComponent=!0;const wg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Sg.isMDXComponent=!0;const Pg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Gg.isMDXComponent=!0;const Og={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}jg.isMDXComponent=!0;const Qg={toc:[]};function Hg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}Hg.isMDXComponent=!0;const Yg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Jg.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}fT.isMDXComponent=!0;const kT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}yT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}XT.isMDXComponent=!0;const wT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}RT.isMDXComponent=!0;const IT={toc:[]};function ST(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}ST.isMDXComponent=!0;const PT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}GT.isMDXComponent=!0;const OT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}FT.isMDXComponent=!0;const UT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}jT.isMDXComponent=!0;const QT={toc:[]};function HT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}HT.isMDXComponent=!0;const YT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}JT.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}fx.isMDXComponent=!0;const kx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}yx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Xx.isMDXComponent=!0;const wx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Sx.isMDXComponent=!0;const Px={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}jx.isMDXComponent=!0;const Qx={toc:[]};function Hx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}Hx.isMDXComponent=!0;const Yx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Jx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}fC.isMDXComponent=!0;const kC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}yC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}XC.isMDXComponent=!0;const wC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}RC.isMDXComponent=!0;const IC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}SC.isMDXComponent=!0;const PC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}GC.isMDXComponent=!0;const OC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}FC.isMDXComponent=!0;const UC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}jC.isMDXComponent=!0;const QC={toc:[]};function HC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}HC.isMDXComponent=!0;const YC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}JC.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}fv.isMDXComponent=!0;const kv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}yv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}Xv.isMDXComponent=!0;const wv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}Sv.isMDXComponent=!0;const Pv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}jv.isMDXComponent=!0;const Qv={toc:[]};function Hv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Hv.isMDXComponent=!0;const Yv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}Jv.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}fL.isMDXComponent=!0;const kL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}yL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}XL.isMDXComponent=!0;const wL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}RL.isMDXComponent=!0;const IL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}SL.isMDXComponent=!0;const PL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}GL.isMDXComponent=!0;const OL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}FL.isMDXComponent=!0;const UL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}jL.isMDXComponent=!0;const QL={toc:[]};function HL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}HL.isMDXComponent=!0;const YL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}JL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fZ.isMDXComponent=!0;const kZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}SZ.isMDXComponent=!0;const PZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}GZ.isMDXComponent=!0;const OZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}jZ.isMDXComponent=!0;const QZ={toc:[]};function HZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}HZ.isMDXComponent=!0;const YZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}JZ.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}fb.isMDXComponent=!0;const kb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}yb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xb.isMDXComponent=!0;const wb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Sb.isMDXComponent=!0;const Pb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}jb.isMDXComponent=!0;const Qb={toc:[]};function Hb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hb.isMDXComponent=!0;const Yb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Jb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fN.isMDXComponent=!0;const kN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}yN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}XN.isMDXComponent=!0;const wN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}RN.isMDXComponent=!0;const IN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}SN.isMDXComponent=!0;const PN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}GN.isMDXComponent=!0;const ON={toc:[]};function FN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}FN.isMDXComponent=!0;const UN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}jN.isMDXComponent=!0;const QN={toc:[]};function HN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}HN.isMDXComponent=!0;const YN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}JN.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fz.isMDXComponent=!0;const kz={toc:[]};function yz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}yz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xz.isMDXComponent=!0;const wz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Sz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Sz.isMDXComponent=!0;const Pz={toc:[]};function Ez(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jz.isMDXComponent=!0;const Qz={toc:[]};function Hz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Hz.isMDXComponent=!0;const Yz={toc:[]};function $z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Jz.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fA.isMDXComponent=!0;const kA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}yA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}XA.isMDXComponent=!0;const wA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RA.isMDXComponent=!0;const IA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}SA.isMDXComponent=!0;const PA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}GA.isMDXComponent=!0;const OA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}FA.isMDXComponent=!0;const UA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jA.isMDXComponent=!0;const QA={toc:[]};function HA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HA.isMDXComponent=!0;const YA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}JA.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fW.isMDXComponent=!0;const kW={toc:[]};function yW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_W,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}XW.isMDXComponent=!0;const wW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}RW.isMDXComponent=!0;const IW={toc:[]};function SW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}SW.isMDXComponent=!0;const PW={toc:[]};function EW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GW.isMDXComponent=!0;const OW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}FW.isMDXComponent=!0;const UW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jW.isMDXComponent=!0;const QW={toc:[]};function HW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}HW.isMDXComponent=!0;const YW={toc:[]};function $W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}JW.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}fR.isMDXComponent=!0;const kR={toc:[]};function yR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}yR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}XR.isMDXComponent=!0;const wR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RR.isMDXComponent=!0;const IR={toc:[]};function SR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}SR.isMDXComponent=!0;const PR={toc:[]};function ER(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}GR.isMDXComponent=!0;const OR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}FR.isMDXComponent=!0;const UR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jR.isMDXComponent=!0;const QR={toc:[]};function HR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}HR.isMDXComponent=!0;const YR={toc:[]};function $R(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}JR.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}fI.isMDXComponent=!0;const kI={toc:[]};function yI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_I,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}XI.isMDXComponent=!0;const wI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}RI.isMDXComponent=!0;const II={toc:[]};function SI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}SI.isMDXComponent=!0;const PI={toc:[]};function EI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GI.isMDXComponent=!0;const OI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}FI.isMDXComponent=!0;const UI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}jI.isMDXComponent=!0;const QI={toc:[]};function HI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}HI.isMDXComponent=!0;const YI={toc:[]};function $I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}JI.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}fS.isMDXComponent=!0;const kS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}XS.isMDXComponent=!0;const wS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RS.isMDXComponent=!0;const IS={toc:[]};function SS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SS.isMDXComponent=!0;const PS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}GS.isMDXComponent=!0;const OS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}FS.isMDXComponent=!0;const US={toc:[]};function qS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jS.isMDXComponent=!0;const QS={toc:[]};function HS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}HS.isMDXComponent=!0;const YS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}JS.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}fP.isMDXComponent=!0;const kP={toc:[]};function yP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}yP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}XP.isMDXComponent=!0;const wP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}RP.isMDXComponent=!0;const IP={toc:[]};function SP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}SP.isMDXComponent=!0;const PP={toc:[]};function EP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}GP.isMDXComponent=!0;const OP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}FP.isMDXComponent=!0;const UP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jP.isMDXComponent=!0;const QP={toc:[]};function HP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}HP.isMDXComponent=!0;const YP={toc:[]};function $P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}JP.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fE.isMDXComponent=!0;const kE={toc:[]};function yE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}yE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}XE.isMDXComponent=!0;const wE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}RE.isMDXComponent=!0;const IE={toc:[]};function SE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}SE.isMDXComponent=!0;const PE={toc:[]};function EE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}GE.isMDXComponent=!0;const OE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}FE.isMDXComponent=!0;const UE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jE.isMDXComponent=!0;const QE={toc:[]};function HE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}HE.isMDXComponent=!0;const YE={toc:[]};function $E(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JE.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}fB.isMDXComponent=!0;const kB={toc:[]};function yB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}yB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}DB.isMDXComponent=!0;const _B={toc:[]};function XB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_B,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}XB.isMDXComponent=!0;const wB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RB.isMDXComponent=!0;const IB={toc:[]};function SB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}SB.isMDXComponent=!0;const PB={toc:[]};function EB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}GB.isMDXComponent=!0;const OB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}FB.isMDXComponent=!0;const UB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}jB.isMDXComponent=!0;const QB={toc:[]};function HB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HB.isMDXComponent=!0;const YB={toc:[]};function $B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}JB.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}fG.isMDXComponent=!0;const kG={toc:[]};function yG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}yG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}XG.isMDXComponent=!0;const wG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}RG.isMDXComponent=!0;const IG={toc:[]};function SG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SG.isMDXComponent=!0;const PG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}GG.isMDXComponent=!0;const OG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FG.isMDXComponent=!0;const UG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jG.isMDXComponent=!0;const QG={toc:[]};function HG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}HG.isMDXComponent=!0;const YG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}JG.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}fO.isMDXComponent=!0;const kO={toc:[]};function yO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}yO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_O,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}XO.isMDXComponent=!0;const wO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}RO.isMDXComponent=!0;const IO={toc:[]};function SO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}SO.isMDXComponent=!0;const PO={toc:[]};function EO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}GO.isMDXComponent=!0;const OO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}FO.isMDXComponent=!0;const UO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jO.isMDXComponent=!0;const QO={toc:[]};function HO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}HO.isMDXComponent=!0;const YO={toc:[]};function $O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}JO.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fF.isMDXComponent=!0;const kF={toc:[]};function yF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XF.isMDXComponent=!0;const wF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}RF.isMDXComponent=!0;const IF={toc:[]};function SF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}SF.isMDXComponent=!0;const PF={toc:[]};function EF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GF.isMDXComponent=!0;const OF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FF.isMDXComponent=!0;const UF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}jF.isMDXComponent=!0;const QF={toc:[]};function HF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}HF.isMDXComponent=!0;const YF={toc:[]};function $F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fU.isMDXComponent=!0;const kU={toc:[]};function yU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}yU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}XU.isMDXComponent=!0;const wU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RU.isMDXComponent=!0;const IU={toc:[]};function SU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}SU.isMDXComponent=!0;const PU={toc:[]};function EU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}GU.isMDXComponent=!0;const OU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FU.isMDXComponent=!0;const UU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}jU.isMDXComponent=!0;const QU={toc:[]};function HU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}HU.isMDXComponent=!0;const YU={toc:[]};function $U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JU.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}fq.isMDXComponent=!0;const kq={toc:[]};function yq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}yq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Xq.isMDXComponent=!0;const wq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Sq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Sq.isMDXComponent=!0;const Pq={toc:[]};function Eq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}jq.isMDXComponent=!0;const Qq={toc:[]};function Hq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Hq.isMDXComponent=!0;const Yq={toc:[]};function $q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Jq.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fV.isMDXComponent=!0;const kV={toc:[]};function yV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}DV.isMDXComponent=!0;const _V={toc:[]};function XV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_V,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XV.isMDXComponent=!0;const wV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RV.isMDXComponent=!0;const IV={toc:[]};function SV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}SV.isMDXComponent=!0;const PV={toc:[]};function EV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GV.isMDXComponent=!0;const OV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}FV.isMDXComponent=!0;const UV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jV.isMDXComponent=!0;const QV={toc:[]};function HV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HV.isMDXComponent=!0;const YV={toc:[]};function $V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}JV.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}fj.isMDXComponent=!0;const kj={toc:[]};function yj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}yj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xj.isMDXComponent=!0;const wj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Sj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Sj.isMDXComponent=!0;const Pj={toc:[]};function Ej(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jj.isMDXComponent=!0;const Qj={toc:[]};function Hj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hj.isMDXComponent=!0;const Yj={toc:[]};function $j(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jj.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}fQ.isMDXComponent=!0;const kQ={toc:[]};function yQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}yQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}DQ.isMDXComponent=!0;const _Q={toc:[]};function XQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}XQ.isMDXComponent=!0;const wQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function SQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}SQ.isMDXComponent=!0;const PQ={toc:[]};function EQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jQ.isMDXComponent=!0;const QQ={toc:[]};function HQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}HQ.isMDXComponent=!0;const YQ={toc:[]};function $Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}JQ.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}fH.isMDXComponent=!0;const kH={toc:[]};function yH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}yH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}DH.isMDXComponent=!0;const _H={toc:[]};function XH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}XH.isMDXComponent=!0;const wH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RH.isMDXComponent=!0;const IH={toc:[]};function SH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SH.isMDXComponent=!0;const PH={toc:[]};function EH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}GH.isMDXComponent=!0;const OH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}FH.isMDXComponent=!0;const UH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jH.isMDXComponent=!0;const QH={toc:[]};function HH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}HH.isMDXComponent=!0;const YH={toc:[]};function $H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JH.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}fY.isMDXComponent=!0;const kY={toc:[]};function yY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}yY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}DY.isMDXComponent=!0;const _Y={toc:[]};function XY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}XY.isMDXComponent=!0;const wY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RY.isMDXComponent=!0;const IY={toc:[]};function SY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}SY.isMDXComponent=!0;const PY={toc:[]};function EY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}GY.isMDXComponent=!0;const OY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FY.isMDXComponent=!0;const UY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jY.isMDXComponent=!0;const QY={toc:[]};function HY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}HY.isMDXComponent=!0;const YY={toc:[]};function $Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}JY.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}f$.isMDXComponent=!0;const k$={toc:[]};function y$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}y$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}D$.isMDXComponent=!0;const _$={toc:[]};function X$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}X$.isMDXComponent=!0;const w$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}R$.isMDXComponent=!0;const I$={toc:[]};function S$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}S$.isMDXComponent=!0;const P$={toc:[]};function E$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}G$.isMDXComponent=!0;const O$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}F$.isMDXComponent=!0;const U$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}j$.isMDXComponent=!0;const Q$={toc:[]};function H$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}H$.isMDXComponent=!0;const Y$={toc:[]};function $$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}J$.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}fK.isMDXComponent=!0;const kK={toc:[]};function yK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}yK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}DK.isMDXComponent=!0;const _K={toc:[]};function XK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_K,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}XK.isMDXComponent=!0;const wK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RK.isMDXComponent=!0;const IK={toc:[]};function SK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}SK.isMDXComponent=!0;const PK={toc:[]};function EK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GK.isMDXComponent=!0;const OK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}FK.isMDXComponent=!0;const UK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}jK.isMDXComponent=!0;const QK={toc:[]};function HK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}HK.isMDXComponent=!0;const YK={toc:[]};function $K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}JK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}fJ.isMDXComponent=!0;const kJ={toc:[]};function yJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}yJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}DJ.isMDXComponent=!0;const _J={toc:[]};function XJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}XJ.isMDXComponent=!0;const wJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function SJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}SJ.isMDXComponent=!0;const PJ={toc:[]};function EJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}GJ.isMDXComponent=!0;const OJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FJ.isMDXComponent=!0;const UJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}jJ.isMDXComponent=!0;const QJ={toc:[]};function HJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}HJ.isMDXComponent=!0;const YJ={toc:[]};function $J(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}JJ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}f0.isMDXComponent=!0;const k0={toc:[]};function y0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}y0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}D0.isMDXComponent=!0;const _0={toc:[]};function X0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}X0.isMDXComponent=!0;const w0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}R0.isMDXComponent=!0;const I0={toc:[]};function S0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}S0.isMDXComponent=!0;const P0={toc:[]};function E0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}G0.isMDXComponent=!0;const O0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}F0.isMDXComponent=!0;const U0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}j0.isMDXComponent=!0;const Q0={toc:[]};function H0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}H0.isMDXComponent=!0;const Y0={toc:[]};function $0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}J0.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}f4.isMDXComponent=!0;const k4={toc:[]};function y4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}y4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}D4.isMDXComponent=!0;const _4={toc:[]};function X4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}X4.isMDXComponent=!0;const w4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}R4.isMDXComponent=!0;const I4={toc:[]};function S4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}S4.isMDXComponent=!0;const P4={toc:[]};function E4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}G4.isMDXComponent=!0;const O4={toc:[]};function F4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}F4.isMDXComponent=!0;const U4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}j4.isMDXComponent=!0;const Q4={toc:[]};function H4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}H4.isMDXComponent=!0;const Y4={toc:[]};function $4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}J4.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}f8.isMDXComponent=!0;const k8={toc:[]};function y8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}y8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}D8.isMDXComponent=!0;const _8={toc:[]};function X8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}X8.isMDXComponent=!0;const w8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}R8.isMDXComponent=!0;const I8={toc:[]};function S8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}S8.isMDXComponent=!0;const P8={toc:[]};function E8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}G8.isMDXComponent=!0;const O8={toc:[]};function F8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F8.isMDXComponent=!0;const U8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}j8.isMDXComponent=!0;const Q8={toc:[]};function H8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}H8.isMDXComponent=!0;const Y8={toc:[]};function $8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}J8.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}f3.isMDXComponent=!0;const k3={toc:[]};function y3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}y3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}D3.isMDXComponent=!0;const _3={toc:[]};function X3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X3.isMDXComponent=!0;const w3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}R3.isMDXComponent=!0;const I3={toc:[]};function S3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}S3.isMDXComponent=!0;const P3={toc:[]};function E3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}G3.isMDXComponent=!0;const O3={toc:[]};function F3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F3.isMDXComponent=!0;const U3={toc:[]};function q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}j3.isMDXComponent=!0;const Q3={toc:[]};function H3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}H3.isMDXComponent=!0;const Y3={toc:[]};function $3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}J3.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}f9.isMDXComponent=!0;const k9={toc:[]};function y9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}y9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}D9.isMDXComponent=!0;const _9={toc:[]};function X9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}X9.isMDXComponent=!0;const w9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}R9.isMDXComponent=!0;const I9={toc:[]};function S9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}S9.isMDXComponent=!0;const P9={toc:[]};function E9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}G9.isMDXComponent=!0;const O9={toc:[]};function F9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}F9.isMDXComponent=!0;const U9={toc:[]};function q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}j9.isMDXComponent=!0;const Q9={toc:[]};function H9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}H9.isMDXComponent=!0;const Y9={toc:[]};function $9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}J9.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}f2.isMDXComponent=!0;const k2={toc:[]};function y2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}y2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}D2.isMDXComponent=!0;const _2={toc:[]};function X2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}X2.isMDXComponent=!0;const w2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}R2.isMDXComponent=!0;const I2={toc:[]};function S2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}S2.isMDXComponent=!0;const P2={toc:[]};function E2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}G2.isMDXComponent=!0;const O2={toc:[]};function F2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}F2.isMDXComponent=!0;const U2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}j2.isMDXComponent=!0;const Q2={toc:[]};function H2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}H2.isMDXComponent=!0;const Y2={toc:[]};function $2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}J2.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}f1.isMDXComponent=!0;const k1={toc:[]};function y1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}y1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}D1.isMDXComponent=!0;const _1={toc:[]};function X1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}X1.isMDXComponent=!0;const w1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}R1.isMDXComponent=!0;const I1={toc:[]};function S1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}S1.isMDXComponent=!0;const P1={toc:[]};function E1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}G1.isMDXComponent=!0;const O1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}F1.isMDXComponent=!0;const U1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}j1.isMDXComponent=!0;const Q1={toc:[]};function H1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}H1.isMDXComponent=!0;const Y1={toc:[]};function $1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}J1.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}f6.isMDXComponent=!0;const k6={toc:[]};function y6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}y6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}D6.isMDXComponent=!0;const _6={toc:[]};function X6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}X6.isMDXComponent=!0;const w6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}R6.isMDXComponent=!0;const I6={toc:[]};function S6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}S6.isMDXComponent=!0;const P6={toc:[]};function E6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}G6.isMDXComponent=!0;const O6={toc:[]};function F6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}F6.isMDXComponent=!0;const U6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}j6.isMDXComponent=!0;const Q6={toc:[]};function H6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}H6.isMDXComponent=!0;const Y6={toc:[]};function $6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}J6.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}f5.isMDXComponent=!0;const k5={toc:[]};function y5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}y5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}D5.isMDXComponent=!0;const _5={toc:[]};function X5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}X5.isMDXComponent=!0;const w5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}R5.isMDXComponent=!0;const I5={toc:[]};function S5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}S5.isMDXComponent=!0;const P5={toc:[]};function E5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}G5.isMDXComponent=!0;const O5={toc:[]};function F5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}F5.isMDXComponent=!0;const U5={toc:[]};function q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}j5.isMDXComponent=!0;const Q5={toc:[]};function H5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}H5.isMDXComponent=!0;const Y5={toc:[]};function $5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}J5.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}f7.isMDXComponent=!0;const k7={toc:[]};function y7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}y7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}D7.isMDXComponent=!0;const _7={toc:[]};function X7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}X7.isMDXComponent=!0;const w7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}R7.isMDXComponent=!0;const I7={toc:[]};function S7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}S7.isMDXComponent=!0;const P7={toc:[]};function E7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}G7.isMDXComponent=!0;const O7={toc:[]};function F7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F7.isMDXComponent=!0;const U7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}j7.isMDXComponent=!0;const Q7={toc:[]};function H7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}H7.isMDXComponent=!0;const Y7={toc:[]};function $7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}J7.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}ftt.isMDXComponent=!0;const ktt={toc:[]};function ytt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}ytt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Dtt.isMDXComponent=!0;const _tt={toc:[]};function Xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Xtt.isMDXComponent=!0;const wtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Stt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Stt.isMDXComponent=!0;const Ptt={toc:[]};function Ett(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ftt.isMDXComponent=!0;const Utt={toc:[]};function qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}jtt.isMDXComponent=!0;const Qtt={toc:[]};function Htt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Htt.isMDXComponent=!0;const Ytt={toc:[]};function $tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Jtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ont.isMDXComponent=!0;const pnt={toc:[]};function rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}rnt.isMDXComponent=!0;const snt={toc:[]};function cnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cnt.isMDXComponent=!0;const int={toc:[]};function ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ant.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}fnt.isMDXComponent=!0;const knt={toc:[]};function ynt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ynt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Dnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Xnt.isMDXComponent=!0;const wnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gnt.isMDXComponent=!0;const Tnt={toc:[]};function xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}vnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Znt.isMDXComponent=!0;const bnt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Nnt.isMDXComponent=!0;const znt={toc:[]};function Ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},znt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ant.isMDXComponent=!0;const Wnt={toc:[]};function Rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Rnt.isMDXComponent=!0;const Int={toc:[]};function Snt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Snt.isMDXComponent=!0;const Pnt={toc:[]};function Ent(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function Fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Fnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}jnt.isMDXComponent=!0;const Qnt={toc:[]};function Hnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Hnt.isMDXComponent=!0;const Ynt={toc:[]};function $nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ynt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$nt.isMDXComponent=!0;const Knt={toc:[]};function Jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Jnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}het.isMDXComponent=!0;const fet={toc:[]};function ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ket.isMDXComponent=!0;const yet={toc:[]};function Met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Met.isMDXComponent=!0;const Det={toc:[]};function _et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}_et.isMDXComponent=!0;const Xet={toc:[]};function wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}wet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Iet.isMDXComponent=!0;const Set={toc:[]};function Pet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Oet.isMDXComponent=!0;const Fet={toc:[]};function Uet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Uet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Qet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Qet.isMDXComponent=!0;const Het={toc:[]};function Yet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Het,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hot.isMDXComponent=!0;const fot={toc:[]};function kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kot.isMDXComponent=!0;const yot={toc:[]};function Mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function _ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_ot.isMDXComponent=!0;const Xot={toc:[]};function wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Iot.isMDXComponent=!0;const Sot={toc:[]};function Pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Pot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Oot.isMDXComponent=!0;const Fot={toc:[]};function Uot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Uot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Qot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Qot.isMDXComponent=!0;const Hot={toc:[]};function Yot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Yot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kpt.isMDXComponent=!0;const ypt={toc:[]};function Mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function _pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}_pt.isMDXComponent=!0;const Xpt={toc:[]};function wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}wpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Ipt.isMDXComponent=!0;const Spt={toc:[]};function Ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Ppt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Opt.isMDXComponent=!0;const Fpt={toc:[]};function Upt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Upt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Qpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Qpt.isMDXComponent=!0;const Hpt={toc:[]};function Ypt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ypt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}trt.isMDXComponent=!0;const nrt={toc:[]};function ert(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}ert.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}hrt.isMDXComponent=!0;const frt={toc:[]};function krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}krt.isMDXComponent=!0;const yrt={toc:[]};function Mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function _rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}_rt.isMDXComponent=!0;const Xrt={toc:[]};function wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}wrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Irt.isMDXComponent=!0;const Srt={toc:[]};function Prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Prt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Ort.isMDXComponent=!0;const Frt={toc:[]};function Urt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Urt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Qrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Qrt.isMDXComponent=!0;const Hrt={toc:[]};function Yrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Yrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}tst.isMDXComponent=!0;const nst={toc:[]};function est(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}est.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}hst.isMDXComponent=!0;const fst={toc:[]};function kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kst.isMDXComponent=!0;const yst={toc:[]};function Mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function _st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}_st.isMDXComponent=!0;const Xst={toc:[]};function wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ist.isMDXComponent=!0;const Sst={toc:[]};function Pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Pst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Ost.isMDXComponent=!0;const Fst={toc:[]};function Ust(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ust.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Qst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Qst.isMDXComponent=!0;const Hst={toc:[]};function Yst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Yst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}tct.isMDXComponent=!0;const nct={toc:[]};function ect(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ect.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}hct.isMDXComponent=!0;const fct={toc:[]};function kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}kct.isMDXComponent=!0;const yct={toc:[]};function Mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function _ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}_ct.isMDXComponent=!0;const Xct={toc:[]};function wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}wct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ict.isMDXComponent=!0;const Sct={toc:[]};function Pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Pct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Oct.isMDXComponent=!0;const Fct={toc:[]};function Uct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Uct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Qct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Qct.isMDXComponent=!0;const Hct={toc:[]};function Yct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Yct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}tit.isMDXComponent=!0;const nit={toc:[]};function eit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}eit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hit.isMDXComponent=!0;const fit={toc:[]};function kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kit.isMDXComponent=!0;const yit={toc:[]};function Mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function _it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}_it.isMDXComponent=!0;const Xit={toc:[]};function wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Iit.isMDXComponent=!0;const Sit={toc:[]};function Pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Pit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Oit.isMDXComponent=!0;const Fit={toc:[]};function Uit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Uit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Vit.isMDXComponent=!0;const jit={toc:[]};function Qit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qit.isMDXComponent=!0;const Hit={toc:[]};function Yit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Yit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}tat.isMDXComponent=!0;const nat={toc:[]};function eat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hat.isMDXComponent=!0;const fat={toc:[]};function kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kat.isMDXComponent=!0;const yat={toc:[]};function Mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function _at(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_at.isMDXComponent=!0;const Xat={toc:[]};function wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Iat.isMDXComponent=!0;const Sat={toc:[]};function Pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Pat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Oat.isMDXComponent=!0;const Fat={toc:[]};function Uat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Uat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Qat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qat.isMDXComponent=!0;const Hat={toc:[]};function Yat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}tlt.isMDXComponent=!0;const nlt={toc:[]};function elt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}elt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}hlt.isMDXComponent=!0;const flt={toc:[]};function klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}klt.isMDXComponent=!0;const ylt={toc:[]};function Mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function _lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_lt.isMDXComponent=!0;const Xlt={toc:[]};function wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ilt.isMDXComponent=!0;const Slt={toc:[]};function Plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Slt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Plt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Olt.isMDXComponent=!0;const Flt={toc:[]};function Ult(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ult.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Qlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qlt.isMDXComponent=!0;const Hlt={toc:[]};function Ylt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Ylt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tut.isMDXComponent=!0;const nut={toc:[]};function eut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hut.isMDXComponent=!0;const fut={toc:[]};function kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}kut.isMDXComponent=!0;const yut={toc:[]};function Mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function _ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_ut.isMDXComponent=!0;const Xut={toc:[]};function wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Iut.isMDXComponent=!0;const Sut={toc:[]};function Put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Put.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Out.isMDXComponent=!0;const Fut={toc:[]};function Uut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Uut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Qut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qut.isMDXComponent=!0;const Hut={toc:[]};function Yut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Yut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}tmt.isMDXComponent=!0;const nmt={toc:[]};function emt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}emt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hmt.isMDXComponent=!0;const fmt={toc:[]};function kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kmt.isMDXComponent=!0;const ymt={toc:[]};function Mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function _mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_mt.isMDXComponent=!0;const Xmt={toc:[]};function wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Imt.isMDXComponent=!0;const Smt={toc:[]};function Pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Pmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Omt.isMDXComponent=!0;const Fmt={toc:[]};function Umt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Umt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Qmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Qmt.isMDXComponent=!0;const Hmt={toc:[]};function Ymt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ymt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}tdt.isMDXComponent=!0;const ndt={toc:[]};function edt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}edt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kdt.isMDXComponent=!0;const ydt={toc:[]};function Mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function _dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_dt.isMDXComponent=!0;const Xdt={toc:[]};function wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Idt.isMDXComponent=!0;const Sdt={toc:[]};function Pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Pdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Odt.isMDXComponent=!0;const Fdt={toc:[]};function Udt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Udt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Qdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Qdt.isMDXComponent=!0;const Hdt={toc:[]};function Ydt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ydt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}tht.isMDXComponent=!0;const nht={toc:[]};function eht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hht.isMDXComponent=!0;const fht={toc:[]};function kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kht.isMDXComponent=!0;const yht={toc:[]};function Mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function _ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_ht.isMDXComponent=!0;const Xht={toc:[]};function wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Iht.isMDXComponent=!0;const Sht={toc:[]};function Pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Pht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Oht.isMDXComponent=!0;const Fht={toc:[]};function Uht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Uht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Qht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qht.isMDXComponent=!0;const Hht={toc:[]};function Yht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Yht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tft.isMDXComponent=!0;const nft={toc:[]};function eft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hft.isMDXComponent=!0;const fft={toc:[]};function kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kft.isMDXComponent=!0;const yft={toc:[]};function Mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function _ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_ft.isMDXComponent=!0;const Xft={toc:[]};function wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ift.isMDXComponent=!0;const Sft={toc:[]};function Pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Pft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Oft.isMDXComponent=!0;const Fft={toc:[]};function Uft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Uft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Qft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Qft.isMDXComponent=!0;const Hft={toc:[]};function Yft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Yft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}tkt.isMDXComponent=!0;const nkt={toc:[]};function ekt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ekt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kkt.isMDXComponent=!0;const ykt={toc:[]};function Mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function _kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}_kt.isMDXComponent=!0;const Xkt={toc:[]};function wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ikt.isMDXComponent=!0;const Skt={toc:[]};function Pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Pkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Okt.isMDXComponent=!0;const Fkt={toc:[]};function Ukt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ukt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Qkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Qkt.isMDXComponent=!0;const Hkt={toc:[]};function Ykt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ykt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tyt.isMDXComponent=!0;const nyt={toc:[]};function eyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}eyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hyt.isMDXComponent=!0;const fyt={toc:[]};function kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}kyt.isMDXComponent=!0;const yyt={toc:[]};function Myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function _yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}_yt.isMDXComponent=!0;const Xyt={toc:[]};function wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}wyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Iyt.isMDXComponent=!0;const Syt={toc:[]};function Pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Oyt.isMDXComponent=!0;const Fyt={toc:[]};function Uyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Uyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Qyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Qyt.isMDXComponent=!0;const Hyt={toc:[]};function Yyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Yyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}tMt.isMDXComponent=!0;const nMt={toc:[]};function eMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function kMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kMt.isMDXComponent=!0;const yMt={toc:[]};function MMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function _Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_Mt.isMDXComponent=!0;const XMt={toc:[]};function wMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}IMt.isMDXComponent=!0;const SMt={toc:[]};function PMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OMt.isMDXComponent=!0;const FMt={toc:[]};function UMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}UMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function QMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QMt.isMDXComponent=!0;const HMt={toc:[]};function YMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}YMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}tDt.isMDXComponent=!0;const nDt={toc:[]};function eDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}eDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function kDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kDt.isMDXComponent=!0;const yDt={toc:[]};function MDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function _Dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_Dt.isMDXComponent=!0;const XDt={toc:[]};function wDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}IDt.isMDXComponent=!0;const SDt={toc:[]};function PDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ODt.isMDXComponent=!0;const FDt={toc:[]};function UDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}UDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function QDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QDt.isMDXComponent=!0;const HDt={toc:[]};function YDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function t_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}t_t.isMDXComponent=!0;const n_t={toc:[]};function e_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}e_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function k_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k_t.isMDXComponent=!0;const y_t={toc:[]};function M_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function __t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}__t.isMDXComponent=!0;const X_t={toc:[]};function w_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}w_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}I_t.isMDXComponent=!0;const S_t={toc:[]};function P_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}P_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}O_t.isMDXComponent=!0;const F_t={toc:[]};function U_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}U_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function Q_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Q_t.isMDXComponent=!0;const H_t={toc:[]};function Y_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Y_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}tXt.isMDXComponent=!0;const nXt={toc:[]};function eXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}eXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function kXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kXt.isMDXComponent=!0;const yXt={toc:[]};function MXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function _Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_Xt.isMDXComponent=!0;const XXt={toc:[]};function wXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}IXt.isMDXComponent=!0;const SXt={toc:[]};function PXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}OXt.isMDXComponent=!0;const FXt={toc:[]};function UXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}UXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}VXt.isMDXComponent=!0;const jXt={toc:[]};function QXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}QXt.isMDXComponent=!0;const HXt={toc:[]};function YXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KXt.isMDXComponent=!0;const JXt={toc:[]};function twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}twt.isMDXComponent=!0;const nwt={toc:[]};function ewt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}ewt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kwt.isMDXComponent=!0;const ywt={toc:[]};function Mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function _wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_wt.isMDXComponent=!0;const Xwt={toc:[]};function wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Iwt.isMDXComponent=!0;const Swt={toc:[]};function Pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Owt.isMDXComponent=!0;const Fwt={toc:[]};function Uwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Uwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Qwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Qwt.isMDXComponent=!0;const Hwt={toc:[]};function Ywt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ywt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}tgt.isMDXComponent=!0;const ngt={toc:[]};function egt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}egt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}kgt.isMDXComponent=!0;const ygt={toc:[]};function Mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function _gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_gt.isMDXComponent=!0;const Xgt={toc:[]};function wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Igt.isMDXComponent=!0;const Sgt={toc:[]};function Pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Pgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ogt.isMDXComponent=!0;const Fgt={toc:[]};function Ugt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ugt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Qgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qgt.isMDXComponent=!0;const Hgt={toc:[]};function Ygt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Ygt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tTt.isMDXComponent=!0;const nTt={toc:[]};function eTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function kTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kTt.isMDXComponent=!0;const yTt={toc:[]};function MTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function _Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_Tt.isMDXComponent=!0;const XTt={toc:[]};function wTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ITt.isMDXComponent=!0;const STt={toc:[]};function PTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}PTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}OTt.isMDXComponent=!0;const FTt={toc:[]};function UTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}UTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function QTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}QTt.isMDXComponent=!0;const HTt={toc:[]};function YTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}YTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}txt.isMDXComponent=!0;const nxt={toc:[]};function ext(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ext.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kxt.isMDXComponent=!0;const yxt={toc:[]};function Mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function _xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_xt.isMDXComponent=!0;const Xxt={toc:[]};function wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}Ixt.isMDXComponent=!0;const Sxt={toc:[]};function Pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Pxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Oxt.isMDXComponent=!0;const Fxt={toc:[]};function Uxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Uxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Qxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Qxt.isMDXComponent=!0;const Hxt={toc:[]};function Yxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Yxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}tCt.isMDXComponent=!0;const nCt={toc:[]};function eCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}hCt.isMDXComponent=!0;const fCt={toc:[]};function kCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kCt.isMDXComponent=!0;const yCt={toc:[]};function MCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function _Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_Ct.isMDXComponent=!0;const XCt={toc:[]};function wCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ICt.isMDXComponent=!0;const SCt={toc:[]};function PCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}OCt.isMDXComponent=!0;const FCt={toc:[]};function UCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}UCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function QCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}QCt.isMDXComponent=!0;const HCt={toc:[]};function YCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}YCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tvt.isMDXComponent=!0;const nvt={toc:[]};function evt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}evt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kvt.isMDXComponent=!0;const yvt={toc:[]};function Mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function _vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}_vt.isMDXComponent=!0;const Xvt={toc:[]};function wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Ivt.isMDXComponent=!0;const Svt={toc:[]};function Pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Svt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ovt.isMDXComponent=!0;const Fvt={toc:[]};function Uvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Uvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Qvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Qvt.isMDXComponent=!0;const Hvt={toc:[]};function Yvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Yvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}tLt.isMDXComponent=!0;const nLt={toc:[]};function eLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function kLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}kLt.isMDXComponent=!0;const yLt={toc:[]};function MLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function _Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}_Lt.isMDXComponent=!0;const XLt={toc:[]};function wLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ILt.isMDXComponent=!0;const SLt={toc:[]};function PLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}PLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}OLt.isMDXComponent=!0;const FLt={toc:[]};function ULt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}ULt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function QLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QLt.isMDXComponent=!0;const HLt={toc:[]};function YLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tZt.isMDXComponent=!0;const nZt={toc:[]};function eZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function kZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}kZt.isMDXComponent=!0;const yZt={toc:[]};function MZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function _Zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_Zt.isMDXComponent=!0;const XZt={toc:[]};function wZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}IZt.isMDXComponent=!0;const SZt={toc:[]};function PZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}PZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}OZt.isMDXComponent=!0;const FZt={toc:[]};function UZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function QZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}QZt.isMDXComponent=!0;const HZt={toc:[]};function YZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tbt.isMDXComponent=!0;const nbt={toc:[]};function ebt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ebt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kbt.isMDXComponent=!0;const ybt={toc:[]};function Mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function _bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}_bt.isMDXComponent=!0;const Xbt={toc:[]};function wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ibt.isMDXComponent=!0;const Sbt={toc:[]};function Pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Obt.isMDXComponent=!0;const Fbt={toc:[]};function Ubt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ubt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Qbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}Qbt.isMDXComponent=!0;const Hbt={toc:[]};function Ybt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}Ybt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tNt.isMDXComponent=!0;const nNt={toc:[]};function eNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}eNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function kNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kNt.isMDXComponent=!0;const yNt={toc:[]};function MNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function _Nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_Nt.isMDXComponent=!0;const XNt={toc:[]};function wNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}INt.isMDXComponent=!0;const SNt={toc:[]};function PNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ONt.isMDXComponent=!0;const FNt={toc:[]};function UNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}UNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}VNt.isMDXComponent=!0;const jNt={toc:[]};function QNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}QNt.isMDXComponent=!0;const HNt={toc:[]};function YNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}YNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}tzt.isMDXComponent=!0;const nzt={toc:[]};function ezt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ezt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kzt.isMDXComponent=!0;const yzt={toc:[]};function Mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function _zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}_zt.isMDXComponent=!0;const Xzt={toc:[]};function wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Izt.isMDXComponent=!0;const Szt={toc:[]};function Pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Szt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Pzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Ozt.isMDXComponent=!0;const Fzt={toc:[]};function Uzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Uzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Qzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qzt.isMDXComponent=!0;const Hzt={toc:[]};function Yzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Yzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}tAt.isMDXComponent=!0;const nAt={toc:[]};function eAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function kAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kAt.isMDXComponent=!0;const yAt={toc:[]};function MAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function _At(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}_At.isMDXComponent=!0;const XAt={toc:[]};function wAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IAt.isMDXComponent=!0;const SAt={toc:[]};function PAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}PAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}OAt.isMDXComponent=!0;const FAt={toc:[]};function UAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function QAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}QAt.isMDXComponent=!0;const HAt={toc:[]};function YAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}YAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}tWt.isMDXComponent=!0;const nWt={toc:[]};function eWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}hWt.isMDXComponent=!0;const fWt={toc:[]};function kWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kWt.isMDXComponent=!0;const yWt={toc:[]};function MWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function _Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_Wt.isMDXComponent=!0;const XWt={toc:[]};function wWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}IWt.isMDXComponent=!0;const SWt={toc:[]};function PWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}OWt.isMDXComponent=!0;const FWt={toc:[]};function UWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}UWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function QWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QWt.isMDXComponent=!0;const HWt={toc:[]};function YWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}tRt.isMDXComponent=!0;const nRt={toc:[]};function eRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function kRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kRt.isMDXComponent=!0;const yRt={toc:[]};function MRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function _Rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_Rt.isMDXComponent=!0;const XRt={toc:[]};function wRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}IRt.isMDXComponent=!0;const SRt={toc:[]};function PRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ORt.isMDXComponent=!0;const FRt={toc:[]};function URt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}URt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function QRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}QRt.isMDXComponent=!0;const HRt={toc:[]};function YRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}YRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}tIt.isMDXComponent=!0;const nIt={toc:[]};function eIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}eIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function kIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kIt.isMDXComponent=!0;const yIt={toc:[]};function MIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function _It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_It.isMDXComponent=!0;const XIt={toc:[]};function wIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}IIt.isMDXComponent=!0;const SIt={toc:[]};function PIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}OIt.isMDXComponent=!0;const FIt={toc:[]};function UIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}UIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function QIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}QIt.isMDXComponent=!0;const HIt={toc:[]};function YIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}YIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}tSt.isMDXComponent=!0;const nSt={toc:[]};function eSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function kSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kSt.isMDXComponent=!0;const ySt={toc:[]};function MSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function _St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_St.isMDXComponent=!0;const XSt={toc:[]};function wSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ISt.isMDXComponent=!0;const SSt={toc:[]};function PSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}OSt.isMDXComponent=!0;const FSt={toc:[]};function USt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}USt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function QSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}QSt.isMDXComponent=!0;const HSt={toc:[]};function YSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}YSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}tPt.isMDXComponent=!0;const nPt={toc:[]};function ePt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ePt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function kPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}kPt.isMDXComponent=!0;const yPt={toc:[]};function MPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function _Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_Pt.isMDXComponent=!0;const XPt={toc:[]};function wPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}IPt.isMDXComponent=!0;const SPt={toc:[]};function PPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}PPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}OPt.isMDXComponent=!0;const FPt={toc:[]};function UPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}UPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function QPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}QPt.isMDXComponent=!0;const HPt={toc:[]};function YPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tEt.isMDXComponent=!0;const nEt={toc:[]};function eEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function kEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}kEt.isMDXComponent=!0;const yEt={toc:[]};function MEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function _Et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}_Et.isMDXComponent=!0;const XEt={toc:[]};function wEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}IEt.isMDXComponent=!0;const SEt={toc:[]};function PEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}OEt.isMDXComponent=!0;const FEt={toc:[]};function UEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}UEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function QEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}QEt.isMDXComponent=!0;const HEt={toc:[]};function YEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}YEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tBt.isMDXComponent=!0;const nBt={toc:[]};function eBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}eBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function kBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kBt.isMDXComponent=!0;const yBt={toc:[]};function MBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function _Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_Bt.isMDXComponent=!0;const XBt={toc:[]};function wBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}IBt.isMDXComponent=!0;const SBt={toc:[]};function PBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}PBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}OBt.isMDXComponent=!0;const FBt={toc:[]};function UBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function QBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}QBt.isMDXComponent=!0;const HBt={toc:[]};function YBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tGt.isMDXComponent=!0;const nGt={toc:[]};function eGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}eGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function kGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kGt.isMDXComponent=!0;const yGt={toc:[]};function MGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function _Gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_Gt.isMDXComponent=!0;const XGt={toc:[]};function wGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}IGt.isMDXComponent=!0;const SGt={toc:[]};function PGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}OGt.isMDXComponent=!0;const FGt={toc:[]};function UGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}UGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function QGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}QGt.isMDXComponent=!0;const HGt={toc:[]};function YGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}YGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tOt.isMDXComponent=!0;const nOt={toc:[]};function eOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}hOt.isMDXComponent=!0;const fOt={toc:[]};function kOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kOt.isMDXComponent=!0;const yOt={toc:[]};function MOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function _Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_Ot.isMDXComponent=!0;const XOt={toc:[]};function wOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IOt.isMDXComponent=!0;const SOt={toc:[]};function POt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}POt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OOt.isMDXComponent=!0;const FOt={toc:[]};function UOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}UOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function QOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QOt.isMDXComponent=!0;const HOt={toc:[]};function YOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}YOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tFt.isMDXComponent=!0;const nFt={toc:[]};function eFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}eFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function kFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kFt.isMDXComponent=!0;const yFt={toc:[]};function MFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function _Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_Ft.isMDXComponent=!0;const XFt={toc:[]};function wFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}IFt.isMDXComponent=!0;const SFt={toc:[]};function PFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}PFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}OFt.isMDXComponent=!0;const FFt={toc:[]};function UFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}UFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function QFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}QFt.isMDXComponent=!0;const HFt={toc:[]};function YFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}YFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}tUt.isMDXComponent=!0;const nUt={toc:[]};function eUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function kUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kUt.isMDXComponent=!0;const yUt={toc:[]};function MUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function _Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}_Ut.isMDXComponent=!0;const XUt={toc:[]};function wUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}IUt.isMDXComponent=!0;const SUt={toc:[]};function PUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}PUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}OUt.isMDXComponent=!0;const FUt={toc:[]};function UUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}UUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function QUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}QUt.isMDXComponent=!0;const HUt={toc:[]};function YUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}YUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}tqt.isMDXComponent=!0;const nqt={toc:[]};function eqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}eqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kqt.isMDXComponent=!0;const yqt={toc:[]};function Mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function _qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}_qt.isMDXComponent=!0;const Xqt={toc:[]};function wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Iqt.isMDXComponent=!0;const Sqt={toc:[]};function Pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Oqt.isMDXComponent=!0;const Fqt={toc:[]};function Uqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Uqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Qqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Qqt.isMDXComponent=!0;const Hqt={toc:[]};function Yqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Yqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}tVt.isMDXComponent=!0;const nVt={toc:[]};function eVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function kVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kVt.isMDXComponent=!0;const yVt={toc:[]};function MVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function _Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_Vt.isMDXComponent=!0;const XVt={toc:[]};function wVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IVt.isMDXComponent=!0;const SVt={toc:[]};function PVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}PVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}OVt.isMDXComponent=!0;const FVt={toc:[]};function UVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}UVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function QVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QVt.isMDXComponent=!0;const HVt={toc:[]};function YVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}YVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}tjt.isMDXComponent=!0;const njt={toc:[]};function ejt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ejt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kjt.isMDXComponent=!0;const yjt={toc:[]};function Mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function _jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_jt.isMDXComponent=!0;const Xjt={toc:[]};function wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Ijt.isMDXComponent=!0;const Sjt={toc:[]};function Pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Pjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ojt.isMDXComponent=!0;const Fjt={toc:[]};function Ujt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ujt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Qjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Qjt.isMDXComponent=!0;const Hjt={toc:[]};function Yjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Yjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tQt.isMDXComponent=!0;const nQt={toc:[]};function eQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}eQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hQt.isMDXComponent=!0;const fQt={toc:[]};function kQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}kQt.isMDXComponent=!0;const yQt={toc:[]};function MQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}MQt.isMDXComponent=!0;const DQt={toc:[]};function _Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}_Qt.isMDXComponent=!0;const XQt={toc:[]};function wQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}IQt.isMDXComponent=!0;const SQt={toc:[]};function PQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}PQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}OQt.isMDXComponent=!0;const FQt={toc:[]};function UQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}UQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function QQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QQt.isMDXComponent=!0;const HQt={toc:[]};function YQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}YQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}tHt.isMDXComponent=!0;const nHt={toc:[]};function eHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}eHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function kHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kHt.isMDXComponent=!0;const yHt={toc:[]};function MHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function _Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_Ht.isMDXComponent=!0;const XHt={toc:[]};function wHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}IHt.isMDXComponent=!0;const SHt={toc:[]};function PHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}PHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}OHt.isMDXComponent=!0;const FHt={toc:[]};function UHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function QHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QHt.isMDXComponent=!0;const HHt={toc:[]};function YHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}tYt.isMDXComponent=!0;const nYt={toc:[]};function eYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}eYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function kYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kYt.isMDXComponent=!0;const yYt={toc:[]};function MYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function _Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}_Yt.isMDXComponent=!0;const XYt={toc:[]};function wYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}IYt.isMDXComponent=!0;const SYt={toc:[]};function PYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}PYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}OYt.isMDXComponent=!0;const FYt={toc:[]};function UYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}UYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function QYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}QYt.isMDXComponent=!0;const HYt={toc:[]};function YYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}YYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function t$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}t$t.isMDXComponent=!0;const n$t={toc:[]};function e$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}e$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}h$t.isMDXComponent=!0;const f$t={toc:[]};function k$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}k$t.isMDXComponent=!0;const y$t={toc:[]};function M$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}M$t.isMDXComponent=!0;const D$t={toc:[]};function _$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}_$t.isMDXComponent=!0;const X$t={toc:[]};function w$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}w$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}I$t.isMDXComponent=!0;const S$t={toc:[]};function P$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}P$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}O$t.isMDXComponent=!0;const F$t={toc:[]};function U$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}U$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function Q$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Q$t.isMDXComponent=!0;const H$t={toc:[]};function Y$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Y$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tKt.isMDXComponent=!0;const nKt={toc:[]};function eKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}eKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function kKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kKt.isMDXComponent=!0;const yKt={toc:[]};function MKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function _Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_Kt.isMDXComponent=!0;const XKt={toc:[]};function wKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}IKt.isMDXComponent=!0;const SKt={toc:[]};function PKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}PKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}OKt.isMDXComponent=!0;const FKt={toc:[]};function UKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}UKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}VKt.isMDXComponent=!0;const jKt={toc:[]};function QKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QKt.isMDXComponent=!0;const HKt={toc:[]};function YKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tJt.isMDXComponent=!0;const nJt={toc:[]};function eJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function kJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kJt.isMDXComponent=!0;const yJt={toc:[]};function MJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MJt.isMDXComponent=!0;const DJt={toc:[]};function _Jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}_Jt.isMDXComponent=!0;const XJt={toc:[]};function wJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}IJt.isMDXComponent=!0;const SJt={toc:[]};function PJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}OJt.isMDXComponent=!0;const FJt={toc:[]};function UJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}UJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function QJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QJt.isMDXComponent=!0;const HJt={toc:[]};function YJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}t0t.isMDXComponent=!0;const n0t={toc:[]};function e0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}e0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function k0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}k0t.isMDXComponent=!0;const y0t={toc:[]};function M0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}M0t.isMDXComponent=!0;const D0t={toc:[]};function _0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_0t.isMDXComponent=!0;const X0t={toc:[]};function w0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}w0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}I0t.isMDXComponent=!0;const S0t={toc:[]};function P0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}O0t.isMDXComponent=!0;const F0t={toc:[]};function U0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}U0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}V0t.isMDXComponent=!0;const j0t={toc:[]};function Q0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Q0t.isMDXComponent=!0;const H0t={toc:[]};function Y0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Y0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}t4t.isMDXComponent=!0;const n4t={toc:[]};function e4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}e4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function k4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}k4t.isMDXComponent=!0;const y4t={toc:[]};function M4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function _4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_4t.isMDXComponent=!0;const X4t={toc:[]};function w4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}w4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}I4t.isMDXComponent=!0;const S4t={toc:[]};function P4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}P4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}O4t.isMDXComponent=!0;const F4t={toc:[]};function U4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}U4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function Q4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Q4t.isMDXComponent=!0;const H4t={toc:[]};function Y4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Y4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}t8t.isMDXComponent=!0;const n8t={toc:[]};function e8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}e8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function k8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}k8t.isMDXComponent=!0;const y8t={toc:[]};function M8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function _8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}_8t.isMDXComponent=!0;const X8t={toc:[]};function w8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}w8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}I8t.isMDXComponent=!0;const S8t={toc:[]};function P8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}P8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}O8t.isMDXComponent=!0;const F8t={toc:[]};function U8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}U8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function Q8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Q8t.isMDXComponent=!0;const H8t={toc:[]};function Y8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Y8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}t3t.isMDXComponent=!0;const n3t={toc:[]};function e3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}e3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function k3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}k3t.isMDXComponent=!0;const y3t={toc:[]};function M3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function _3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_3t.isMDXComponent=!0;const X3t={toc:[]};function w3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}w3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}I3t.isMDXComponent=!0;const S3t={toc:[]};function P3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}P3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}O3t.isMDXComponent=!0;const F3t={toc:[]};function U3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}U3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}V3t.isMDXComponent=!0;const j3t={toc:[]};function Q3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Q3t.isMDXComponent=!0;const H3t={toc:[]};function Y3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Y3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}t9t.isMDXComponent=!0;const n9t={toc:[]};function e9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function k9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}k9t.isMDXComponent=!0;const y9t={toc:[]};function M9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function _9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}_9t.isMDXComponent=!0;const X9t={toc:[]};function w9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}w9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}I9t.isMDXComponent=!0;const S9t={toc:[]};function P9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}P9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O9t.isMDXComponent=!0;const F9t={toc:[]};function U9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}U9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function Q9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Q9t.isMDXComponent=!0;const H9t={toc:[]};function Y9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Y9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function t2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}t2t.isMDXComponent=!0;const n2t={toc:[]};function e2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function k2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}k2t.isMDXComponent=!0;const y2t={toc:[]};function M2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}M2t.isMDXComponent=!0;const D2t={toc:[]};function _2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}_2t.isMDXComponent=!0;const X2t={toc:[]};function w2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}w2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}I2t.isMDXComponent=!0;const S2t={toc:[]};function P2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}P2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}O2t.isMDXComponent=!0;const F2t={toc:[]};function U2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}U2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function Q2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Q2t.isMDXComponent=!0;const H2t={toc:[]};function Y2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Y2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}t1t.isMDXComponent=!0;const n1t={toc:[]};function e1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}e1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function k1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}k1t.isMDXComponent=!0;const y1t={toc:[]};function M1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function _1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_1t.isMDXComponent=!0;const X1t={toc:[]};function w1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}w1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}I1t.isMDXComponent=!0;const S1t={toc:[]};function P1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}P1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}O1t.isMDXComponent=!0;const F1t={toc:[]};function U1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}U1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function Q1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q1t.isMDXComponent=!0;const H1t={toc:[]};function Y1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Y1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}t6t.isMDXComponent=!0;const n6t={toc:[]};function e6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}e6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function k6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}k6t.isMDXComponent=!0;const y6t={toc:[]};function M6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function _6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_6t.isMDXComponent=!0;const X6t={toc:[]};function w6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}I6t.isMDXComponent=!0;const S6t={toc:[]};function P6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}P6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}O6t.isMDXComponent=!0;const F6t={toc:[]};function U6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}U6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function Q6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q6t.isMDXComponent=!0;const H6t={toc:[]};function Y6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Y6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}t5t.isMDXComponent=!0;const n5t={toc:[]};function e5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}e5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}h5t.isMDXComponent=!0;const f5t={toc:[]};function k5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}k5t.isMDXComponent=!0;const y5t={toc:[]};function M5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function _5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_5t.isMDXComponent=!0;const X5t={toc:[]};function w5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}w5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}I5t.isMDXComponent=!0;const S5t={toc:[]};function P5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}P5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}O5t.isMDXComponent=!0;const F5t={toc:[]};function U5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}U5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function Q5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Q5t.isMDXComponent=!0;const H5t={toc:[]};function Y5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Y5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t7t.isMDXComponent=!0;const n7t={toc:[]};function e7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}e7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function k7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k7t.isMDXComponent=!0;const y7t={toc:[]};function M7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function _7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_7t.isMDXComponent=!0;const X7t={toc:[]};function w7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}w7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}I7t.isMDXComponent=!0;const S7t={toc:[]};function P7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}O7t.isMDXComponent=!0;const F7t={toc:[]};function U7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}U7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function Q7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Q7t.isMDXComponent=!0;const H7t={toc:[]};function Y7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ttn.isMDXComponent=!0;const ntn={toc:[]};function etn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}etn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}htn.isMDXComponent=!0;const ftn={toc:[]};function ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ktn.isMDXComponent=!0;const ytn={toc:[]};function Mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mtn.isMDXComponent=!0;const Dtn={toc:[]};function _tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_tn.isMDXComponent=!0;const Xtn={toc:[]};function wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wtn.isMDXComponent=!0;const gtn={toc:[]};function Ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ttn.isMDXComponent=!0;const xtn={toc:[]};function Ctn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ctn.isMDXComponent=!0;const vtn={toc:[]};function Ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]};function btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ztn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}btn.isMDXComponent=!0;const Ntn={toc:[]};function ztn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ztn.isMDXComponent=!0;const Atn={toc:[]};function Wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wtn.isMDXComponent=!0;const Rtn={toc:[]};function Itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Itn.isMDXComponent=!0;const Stn={toc:[]};function Ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ptn.isMDXComponent=!0;const Etn={toc:[]};function Btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Etn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Btn.isMDXComponent=!0;const Gtn={toc:[]};function Otn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Otn.isMDXComponent=!0;const Ftn={toc:[]};function Utn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Utn.isMDXComponent=!0;const qtn={toc:[]};function Vtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Vtn.isMDXComponent=!0;const jtn={toc:[]};function Qtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Qtn.isMDXComponent=!0;const Htn={toc:[]};function Ytn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ytn.isMDXComponent=!0;const $tn={toc:[]};function Ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]};function tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tnn.isMDXComponent=!0;const nnn={toc:[]};function enn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}enn.isMDXComponent=!0;const onn={toc:[]};function pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},onn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pnn.isMDXComponent=!0;const rnn={toc:[]};function snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}snn.isMDXComponent=!0;const cnn={toc:[]};function inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}inn.isMDXComponent=!0;const ann={toc:[]};function lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}lnn.isMDXComponent=!0;const unn={toc:[]};function mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}mnn.isMDXComponent=!0;const dnn={toc:[]};function hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hnn.isMDXComponent=!0;const fnn={toc:[]};function knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}knn.isMDXComponent=!0;const ynn={toc:[]};function Mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mnn.isMDXComponent=!0;const Dnn={toc:[]};function _nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_nn.isMDXComponent=!0;const Xnn={toc:[]};function wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wnn.isMDXComponent=!0;const gnn={toc:[]};function Tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tnn.isMDXComponent=!0;const xnn={toc:[]};function Cnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Cnn.isMDXComponent=!0;const vnn={toc:[]};function Lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Lnn.isMDXComponent=!0;const Znn={toc:[]};function bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}bnn.isMDXComponent=!0;const Nnn={toc:[]};function znn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}znn.isMDXComponent=!0;const Ann={toc:[]};function Wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wnn.isMDXComponent=!0;const Rnn={toc:[]};function Inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Inn.isMDXComponent=!0;const Snn={toc:[]};function Pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Pnn.isMDXComponent=!0;const Enn={toc:[]};function Bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Enn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Bnn.isMDXComponent=!0;const Gnn={toc:[]};function Onn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Onn.isMDXComponent=!0;const Fnn={toc:[]};function Unn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Unn.isMDXComponent=!0;const qnn={toc:[]};function Vnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Vnn.isMDXComponent=!0;const jnn={toc:[]};function Qnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Qnn.isMDXComponent=!0;const Hnn={toc:[]};function Ynn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Ynn.isMDXComponent=!0;const $nn={toc:[]};function Knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Knn.isMDXComponent=!0;const Jnn={toc:[]};function ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ten.isMDXComponent=!0;const nen={toc:[]};function een(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}een.isMDXComponent=!0;const oen={toc:[]};function pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pen.isMDXComponent=!0;const ren={toc:[]};function sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}sen.isMDXComponent=!0;const cen={toc:[]};function ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ien.isMDXComponent=!0;const aen={toc:[]};function len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}len.isMDXComponent=!0;const uen={toc:[]};function men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}men.isMDXComponent=!0;const den={toc:[]};function hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}hen.isMDXComponent=!0;const fen={toc:[]};function ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}ken.isMDXComponent=!0;const yen={toc:[]};function Men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Men.isMDXComponent=!0;const Den={toc:[]};function _en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}_en.isMDXComponent=!0;const Xen={toc:[]};function wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}wen.isMDXComponent=!0;const gen={toc:[]};function Ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Ten.isMDXComponent=!0;const xen={toc:[]};function Cen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}Cen.isMDXComponent=!0;const ven={toc:[]};function Len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ven,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Len.isMDXComponent=!0;const Zen={toc:[]};function ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}ben.isMDXComponent=!0;const Nen={toc:[]};function zen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zen.isMDXComponent=!0;const Aen={toc:[]};function Wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wen.isMDXComponent=!0;const Ren={toc:[]};function Ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ien.isMDXComponent=!0;const Sen={toc:[]};function Pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pen.isMDXComponent=!0;const Een={toc:[]};function Ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Een,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Ben.isMDXComponent=!0;const Gen={toc:[]};function Oen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Oen.isMDXComponent=!0;const Fen={toc:[]};function Uen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Uen.isMDXComponent=!0;const qen={toc:[]};function Ven(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ven.isMDXComponent=!0;const jen={toc:[]};function Qen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Qen.isMDXComponent=!0;const Hen={toc:[]};function Yen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yen.isMDXComponent=!0;const $en={toc:[]};function Ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$en,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ken.isMDXComponent=!0;const Jen={toc:[]};function ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ton.isMDXComponent=!0;const non={toc:[]};function eon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eon.isMDXComponent=!0;const oon={toc:[]};function pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pon.isMDXComponent=!0;const ron={toc:[]};function son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}son.isMDXComponent=!0;const con={toc:[]};function ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},con,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ion.isMDXComponent=!0;const aon={toc:[]};function lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lon.isMDXComponent=!0;const uon={toc:[]};function mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mon.isMDXComponent=!0;const don={toc:[]};function hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}hon.isMDXComponent=!0;const fon={toc:[]};function kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kon.isMDXComponent=!0;const yon={toc:[]};function Mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Mon.isMDXComponent=!0;const Don={toc:[]};function _on(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_on.isMDXComponent=!0;const Xon={toc:[]};function won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}won.isMDXComponent=!0;const gon={toc:[]};function Ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ton.isMDXComponent=!0;const xon={toc:[]};function Con(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Con.isMDXComponent=!0;const von={toc:[]};function Lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},von,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lon.isMDXComponent=!0;const Zon={toc:[]};function bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bon.isMDXComponent=!0;const Non={toc:[]};function zon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zon.isMDXComponent=!0;const Aon={toc:[]};function Won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Won.isMDXComponent=!0;const Ron={toc:[]};function Ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ion.isMDXComponent=!0;const Son={toc:[]};function Pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Son,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Pon.isMDXComponent=!0;const Eon={toc:[]};function Bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bon.isMDXComponent=!0;const Gon={toc:[]};function Oon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Oon.isMDXComponent=!0;const Fon={toc:[]};function Uon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Uon.isMDXComponent=!0;const qon={toc:[]};function Von(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Von.isMDXComponent=!0;const jon={toc:[]};function Qon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Qon.isMDXComponent=!0;const Hon={toc:[]};function Yon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Yon.isMDXComponent=!0;const $on={toc:[]};function Kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Kon.isMDXComponent=!0;const Jon={toc:[]};function tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tpn.isMDXComponent=!0;const npn={toc:[]};function epn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}epn.isMDXComponent=!0;const opn={toc:[]};function ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ppn.isMDXComponent=!0;const rpn={toc:[]};function spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}spn.isMDXComponent=!0;const cpn={toc:[]};function ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ipn.isMDXComponent=!0;const apn={toc:[]};function lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lpn.isMDXComponent=!0;const upn={toc:[]};function mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mpn.isMDXComponent=!0;const dpn={toc:[]};function hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}hpn.isMDXComponent=!0;const fpn={toc:[]};function kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kpn.isMDXComponent=!0;const ypn={toc:[]};function Mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mpn.isMDXComponent=!0;const Dpn={toc:[]};function _pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_pn.isMDXComponent=!0;const Xpn={toc:[]};function wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wpn.isMDXComponent=!0;const gpn={toc:[]};function Tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tpn.isMDXComponent=!0;const xpn={toc:[]};function Cpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cpn.isMDXComponent=!0;const vpn={toc:[]};function Lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]};function bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bpn.isMDXComponent=!0;const Npn={toc:[]};function zpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zpn.isMDXComponent=!0;const Apn={toc:[]};function Wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wpn.isMDXComponent=!0;const Rpn={toc:[]};function Ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ipn.isMDXComponent=!0;const Spn={toc:[]};function Ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Spn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ppn.isMDXComponent=!0;const Epn={toc:[]};function Bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Bpn.isMDXComponent=!0;const Gpn={toc:[]};function Opn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Opn.isMDXComponent=!0;const Fpn={toc:[]};function Upn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Upn.isMDXComponent=!0;const qpn={toc:[]};function Vpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vpn.isMDXComponent=!0;const jpn={toc:[]};function Qpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Qpn.isMDXComponent=!0;const Hpn={toc:[]};function Ypn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ypn.isMDXComponent=!0;const $pn={toc:[]};function Kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]};function trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}trn.isMDXComponent=!0;const nrn={toc:[]};function ern(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ern.isMDXComponent=!0;const orn={toc:[]};function prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},orn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}prn.isMDXComponent=!0;const rrn={toc:[]};function srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}srn.isMDXComponent=!0;const crn={toc:[]};function irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}irn.isMDXComponent=!0;const arn={toc:[]};function lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lrn.isMDXComponent=!0;const urn={toc:[]};function mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mrn.isMDXComponent=!0;const drn={toc:[]};function hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hrn.isMDXComponent=!0;const frn={toc:[]};function krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}krn.isMDXComponent=!0;const yrn={toc:[]};function Mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Mrn.isMDXComponent=!0;const Drn={toc:[]};function _rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_rn.isMDXComponent=!0;const Xrn={toc:[]};function wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wrn.isMDXComponent=!0;const grn={toc:[]};function Trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Trn.isMDXComponent=!0;const xrn={toc:[]};function Crn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Crn.isMDXComponent=!0;const vrn={toc:[]};function Lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]};function brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}brn.isMDXComponent=!0;const Nrn={toc:[]};function zrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zrn.isMDXComponent=!0;const Arn={toc:[]};function Wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wrn.isMDXComponent=!0;const Rrn={toc:[]};function Irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Irn.isMDXComponent=!0;const Srn={toc:[]};function Prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Srn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Prn.isMDXComponent=!0;const Ern={toc:[]};function Brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ern,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Brn.isMDXComponent=!0;const Grn={toc:[]};function Orn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Orn.isMDXComponent=!0;const Frn={toc:[]};function Urn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Urn.isMDXComponent=!0;const qrn={toc:[]};function Vrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Vrn.isMDXComponent=!0;const jrn={toc:[]};function Qrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Qrn.isMDXComponent=!0;const Hrn={toc:[]};function Yrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Yrn.isMDXComponent=!0;const $rn={toc:[]};function Krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Krn.isMDXComponent=!0;const Jrn={toc:[]};function tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}tsn.isMDXComponent=!0;const nsn={toc:[]};function esn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}esn.isMDXComponent=!0;const osn={toc:[]};function psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},osn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}psn.isMDXComponent=!0;const rsn={toc:[]};function ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ssn.isMDXComponent=!0;const csn={toc:[]};function isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},csn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}isn.isMDXComponent=!0;const asn={toc:[]};function lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lsn.isMDXComponent=!0;const usn={toc:[]};function msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}msn.isMDXComponent=!0;const dsn={toc:[]};function hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hsn.isMDXComponent=!0;const fsn={toc:[]};function ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ksn.isMDXComponent=!0;const ysn={toc:[]};function Msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ysn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Msn.isMDXComponent=!0;const Dsn={toc:[]};function _sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_sn.isMDXComponent=!0;const Xsn={toc:[]};function wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wsn.isMDXComponent=!0;const gsn={toc:[]};function Tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Tsn.isMDXComponent=!0;const xsn={toc:[]};function Csn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Csn.isMDXComponent=!0;const vsn={toc:[]};function Lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]};function bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bsn.isMDXComponent=!0;const Nsn={toc:[]};function zsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}zsn.isMDXComponent=!0;const Asn={toc:[]};function Wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Wsn.isMDXComponent=!0;const Rsn={toc:[]};function Isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Isn.isMDXComponent=!0;const Ssn={toc:[]};function Psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ssn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Psn.isMDXComponent=!0;const Esn={toc:[]};function Bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Esn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Bsn.isMDXComponent=!0;const Gsn={toc:[]};function Osn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Osn.isMDXComponent=!0;const Fsn={toc:[]};function Usn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Usn.isMDXComponent=!0;const qsn={toc:[]};function Vsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Vsn.isMDXComponent=!0;const jsn={toc:[]};function Qsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Qsn.isMDXComponent=!0;const Hsn={toc:[]};function Ysn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ysn.isMDXComponent=!0;const $sn={toc:[]};function Ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]};function tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}tcn.isMDXComponent=!0;const ncn={toc:[]};function ecn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ecn.isMDXComponent=!0;const ocn={toc:[]};function pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ocn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pcn.isMDXComponent=!0;const rcn={toc:[]};function scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}scn.isMDXComponent=!0;const ccn={toc:[]};function icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ccn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}icn.isMDXComponent=!0;const acn={toc:[]};function lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lcn.isMDXComponent=!0;const ucn={toc:[]};function mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mcn.isMDXComponent=!0;const dcn={toc:[]};function hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}hcn.isMDXComponent=!0;const fcn={toc:[]};function kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kcn.isMDXComponent=!0;const ycn={toc:[]};function Mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ycn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Mcn.isMDXComponent=!0;const Dcn={toc:[]};function _cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}_cn.isMDXComponent=!0;const Xcn={toc:[]};function wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wcn.isMDXComponent=!0;const gcn={toc:[]};function Tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Tcn.isMDXComponent=!0;const xcn={toc:[]};function Ccn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Ccn.isMDXComponent=!0;const vcn={toc:[]};function Lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Lcn.isMDXComponent=!0;const Zcn={toc:[]};function bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}bcn.isMDXComponent=!0;const Ncn={toc:[]};function zcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}zcn.isMDXComponent=!0;const Acn={toc:[]};function Wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wcn.isMDXComponent=!0;const Rcn={toc:[]};function Icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Icn.isMDXComponent=!0;const Scn={toc:[]};function Pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Scn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pcn.isMDXComponent=!0;const Ecn={toc:[]};function Bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ecn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Bcn.isMDXComponent=!0;const Gcn={toc:[]};function Ocn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ocn.isMDXComponent=!0;const Fcn={toc:[]};function Ucn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ucn.isMDXComponent=!0;const qcn={toc:[]};function Vcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Vcn.isMDXComponent=!0;const jcn={toc:[]};function Qcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Qcn.isMDXComponent=!0;const Hcn={toc:[]};function Ycn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Ycn.isMDXComponent=!0;const $cn={toc:[]};function Kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Kcn.isMDXComponent=!0;const Jcn={toc:[]};function tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}tin.isMDXComponent=!0;const nin={toc:[]};function ein(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ein.isMDXComponent=!0;const oin={toc:[]};function pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pin.isMDXComponent=!0;const rin={toc:[]};function sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sin.isMDXComponent=!0;const cin={toc:[]};function iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}iin.isMDXComponent=!0;const ain={toc:[]};function lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lin.isMDXComponent=!0;const uin={toc:[]};function min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}min.isMDXComponent=!0;const din={toc:[]};function hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}hin.isMDXComponent=!0;const fin={toc:[]};function kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kin.isMDXComponent=!0;const yin={toc:[]};function Min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Min.isMDXComponent=!0;const Din={toc:[]};function _in(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}_in.isMDXComponent=!0;const Xin={toc:[]};function win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}win.isMDXComponent=!0;const gin={toc:[]};function Tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Tin.isMDXComponent=!0;const xin={toc:[]};function Cin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Cin.isMDXComponent=!0;const vin={toc:[]};function Lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Lin.isMDXComponent=!0;const Zin={toc:[]};function bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bin.isMDXComponent=!0;const Nin={toc:[]};function zin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zin.isMDXComponent=!0;const Ain={toc:[]};function Win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Win.isMDXComponent=!0;const Rin={toc:[]};function Iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Iin.isMDXComponent=!0;const Sin={toc:[]};function Pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Pin.isMDXComponent=!0;const Ein={toc:[]};function Bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ein,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Bin.isMDXComponent=!0;const Gin={toc:[]};function Oin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Oin.isMDXComponent=!0;const Fin={toc:[]};function Uin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Uin.isMDXComponent=!0;const qin={toc:[]};function Vin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Vin.isMDXComponent=!0;const jin={toc:[]};function Qin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Qin.isMDXComponent=!0;const Hin={toc:[]};function Yin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Yin.isMDXComponent=!0;const $in={toc:[]};function Kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$in,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kin.isMDXComponent=!0;const Jin={toc:[]};function tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}tan.isMDXComponent=!0;const nan={toc:[]};function ean(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ean.isMDXComponent=!0;const oan={toc:[]};function pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pan.isMDXComponent=!0;const ran={toc:[]};function san(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}san.isMDXComponent=!0;const can={toc:[]};function ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},can,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ian.isMDXComponent=!0;const aan={toc:[]};function lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lan.isMDXComponent=!0;const uan={toc:[]};function man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}man.isMDXComponent=!0;const dan={toc:[]};function han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}han.isMDXComponent=!0;const fan={toc:[]};function kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kan.isMDXComponent=!0;const yan={toc:[]};function Man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Man.isMDXComponent=!0;const Dan={toc:[]};function _an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}_an.isMDXComponent=!0;const Xan={toc:[]};function wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wan.isMDXComponent=!0;const gan={toc:[]};function Tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Tan.isMDXComponent=!0;const xan={toc:[]};function Can(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Can.isMDXComponent=!0;const van={toc:[]};function Lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},van,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Lan.isMDXComponent=!0;const Zan={toc:[]};function ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ban.isMDXComponent=!0;const Nan={toc:[]};function zan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}zan.isMDXComponent=!0;const Aan={toc:[]};function Wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Wan.isMDXComponent=!0;const Ran={toc:[]};function Ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ian.isMDXComponent=!0;const San={toc:[]};function Pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},San,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Pan.isMDXComponent=!0;const Ean={toc:[]};function Ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ean,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Ban.isMDXComponent=!0;const Gan={toc:[]};function Oan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Oan.isMDXComponent=!0;const Fan={toc:[]};function Uan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Uan.isMDXComponent=!0;const qan={toc:[]};function Van(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Van.isMDXComponent=!0;const jan={toc:[]};function Qan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Qan.isMDXComponent=!0;const Han={toc:[]};function Yan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Han,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yan.isMDXComponent=!0;const $an={toc:[]};function Kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$an,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Kan.isMDXComponent=!0;const Jan={toc:[]};function tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}tln.isMDXComponent=!0;const nln={toc:[]};function eln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eln.isMDXComponent=!0;const oln={toc:[]};function pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pln.isMDXComponent=!0;const rln={toc:[]};function sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sln.isMDXComponent=!0;const cln={toc:[]};function iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}iln.isMDXComponent=!0;const aln={toc:[]};function lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}lln.isMDXComponent=!0;const uln={toc:[]};function mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}mln.isMDXComponent=!0;const dln={toc:[]};function hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hln.isMDXComponent=!0;const fln={toc:[]};function kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kln.isMDXComponent=!0;const yln={toc:[]};function Mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mln.isMDXComponent=!0;const Dln={toc:[]};function _ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}_ln.isMDXComponent=!0;const Xln={toc:[]};function wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wln.isMDXComponent=!0;const gln={toc:[]};function Tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Tln.isMDXComponent=!0;const xln={toc:[]};function Cln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Cln.isMDXComponent=!0;const vln={toc:[]};function Lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Lln.isMDXComponent=!0;const Zln={toc:[]};function bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}bln.isMDXComponent=!0;const Nln={toc:[]};function zln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}zln.isMDXComponent=!0;const Aln={toc:[]};function Wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Wln.isMDXComponent=!0;const Rln={toc:[]};function Iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Iln.isMDXComponent=!0;const Sln={toc:[]};function Pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Pln.isMDXComponent=!0;const Eln={toc:[]};function Bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Bln.isMDXComponent=!0;const Gln={toc:[]};function Oln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Oln.isMDXComponent=!0;const Fln={toc:[]};function Uln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Uln.isMDXComponent=!0;const qln={toc:[]};function Vln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Vln.isMDXComponent=!0;const jln={toc:[]};function Qln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qln.isMDXComponent=!0;const Hln={toc:[]};function Yln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Yln.isMDXComponent=!0;const $ln={toc:[]};function Kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Kln.isMDXComponent=!0;const Jln={toc:[]};function tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}tun.isMDXComponent=!0;const nun={toc:[]};function eun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eun.isMDXComponent=!0;const oun={toc:[]};function pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}pun.isMDXComponent=!0;const run={toc:[]};function sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}sun.isMDXComponent=!0;const cun={toc:[]};function iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}iun.isMDXComponent=!0;const aun={toc:[]};function lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lun.isMDXComponent=!0;const uun={toc:[]};function mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}mun.isMDXComponent=!0;const dun={toc:[]};function hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}hun.isMDXComponent=!0;const fun={toc:[]};function kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kun.isMDXComponent=!0;const yun={toc:[]};function Mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mun.isMDXComponent=!0;const Dun={toc:[]};function _un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}_un.isMDXComponent=!0;const Xun={toc:[]};function wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}wun.isMDXComponent=!0;const gun={toc:[]};function Tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Tun.isMDXComponent=!0;const xun={toc:[]};function Cun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Cun.isMDXComponent=!0;const vun={toc:[]};function Lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lun.isMDXComponent=!0;const Zun={toc:[]};function bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bun.isMDXComponent=!0;const Nun={toc:[]};function zun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zun.isMDXComponent=!0;const Aun={toc:[]};function Wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wun.isMDXComponent=!0;const Run={toc:[]};function Iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Iun.isMDXComponent=!0;const Sun={toc:[]};function Pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Pun.isMDXComponent=!0;const Eun={toc:[]};function Bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bun.isMDXComponent=!0;const Gun={toc:[]};function Oun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Oun.isMDXComponent=!0;const Fun={toc:[]};function Uun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Uun.isMDXComponent=!0;const qun={toc:[]};function Vun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Vun.isMDXComponent=!0;const jun={toc:[]};function Qun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Qun.isMDXComponent=!0;const Hun={toc:[]};function Yun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Yun.isMDXComponent=!0;const $un={toc:[]};function Kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kun.isMDXComponent=!0;const Jun={toc:[]};function tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}tmn.isMDXComponent=!0;const nmn={toc:[]};function emn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}emn.isMDXComponent=!0;const omn={toc:[]};function pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pmn.isMDXComponent=!0;const rmn={toc:[]};function smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}smn.isMDXComponent=!0;const cmn={toc:[]};function imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}imn.isMDXComponent=!0;const amn={toc:[]};function lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lmn.isMDXComponent=!0;const umn={toc:[]};function mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mmn.isMDXComponent=!0;const dmn={toc:[]};function hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hmn.isMDXComponent=!0;const fmn={toc:[]};function kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kmn.isMDXComponent=!0;const ymn={toc:[]};function Mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Mmn.isMDXComponent=!0;const Dmn={toc:[]};function _mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}_mn.isMDXComponent=!0;const Xmn={toc:[]};function wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}wmn.isMDXComponent=!0;const gmn={toc:[]};function Tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Tmn.isMDXComponent=!0;const xmn={toc:[]};function Cmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}Cmn.isMDXComponent=!0;const vmn={toc:[]};function Lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]};function bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bmn.isMDXComponent=!0;const Nmn={toc:[]};function zmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zmn.isMDXComponent=!0;const Amn={toc:[]};function Wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wmn.isMDXComponent=!0;const Rmn={toc:[]};function Imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Imn.isMDXComponent=!0;const Smn={toc:[]};function Pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Smn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Pmn.isMDXComponent=!0;const Emn={toc:[]};function Bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bmn.isMDXComponent=!0;const Gmn={toc:[]};function Omn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Omn.isMDXComponent=!0;const Fmn={toc:[]};function Umn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Umn.isMDXComponent=!0;const qmn={toc:[]};function Vmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Vmn.isMDXComponent=!0;const jmn={toc:[]};function Qmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qmn.isMDXComponent=!0;const Hmn={toc:[]};function Ymn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ymn.isMDXComponent=!0;const $mn={toc:[]};function Kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]};function tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}tdn.isMDXComponent=!0;const ndn={toc:[]};function edn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}edn.isMDXComponent=!0;const odn={toc:[]};function pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pdn.isMDXComponent=!0;const rdn={toc:[]};function sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sdn.isMDXComponent=!0;const cdn={toc:[]};function idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}idn.isMDXComponent=!0;const adn={toc:[]};function ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ldn.isMDXComponent=!0;const udn={toc:[]};function mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mdn.isMDXComponent=!0;const ddn={toc:[]};function hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}hdn.isMDXComponent=!0;const fdn={toc:[]};function kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kdn.isMDXComponent=!0;const ydn={toc:[]};function Mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mdn.isMDXComponent=!0;const Ddn={toc:[]};function _dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}_dn.isMDXComponent=!0;const Xdn={toc:[]};function wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wdn.isMDXComponent=!0;const gdn={toc:[]};function Tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Tdn.isMDXComponent=!0;const xdn={toc:[]};function Cdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Cdn.isMDXComponent=!0;const vdn={toc:[]};function Ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]};function bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bdn.isMDXComponent=!0;const Ndn={toc:[]};function zdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zdn.isMDXComponent=!0;const Adn={toc:[]};function Wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wdn.isMDXComponent=!0;const Rdn={toc:[]};function Idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Idn.isMDXComponent=!0;const Sdn={toc:[]};function Pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pdn.isMDXComponent=!0;const Edn={toc:[]};function Bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bdn.isMDXComponent=!0;const Gdn={toc:[]};function Odn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Odn.isMDXComponent=!0;const Fdn={toc:[]};function Udn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Udn.isMDXComponent=!0;const qdn={toc:[]};function Vdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Vdn.isMDXComponent=!0;const jdn={toc:[]};function Qdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Qdn.isMDXComponent=!0;const Hdn={toc:[]};function Ydn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ydn.isMDXComponent=!0;const $dn={toc:[]};function Kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]};function thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}thn.isMDXComponent=!0;const nhn={toc:[]};function ehn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ehn.isMDXComponent=!0;const ohn={toc:[]};function phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}phn.isMDXComponent=!0;const rhn={toc:[]};function shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}shn.isMDXComponent=!0;const chn={toc:[]};function ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},chn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ihn.isMDXComponent=!0;const ahn={toc:[]};function lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lhn.isMDXComponent=!0;const uhn={toc:[]};function mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhn.isMDXComponent=!0;const dhn={toc:[]};function hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hhn.isMDXComponent=!0;const fhn={toc:[]};function khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}khn.isMDXComponent=!0;const yhn={toc:[]};function Mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Mhn.isMDXComponent=!0;const Dhn={toc:[]};function _hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_hn.isMDXComponent=!0;const Xhn={toc:[]};function whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}whn.isMDXComponent=!0;const ghn={toc:[]};function Thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Thn.isMDXComponent=!0;const xhn={toc:[]};function Chn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Chn.isMDXComponent=!0;const vhn={toc:[]};function Lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]};function bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}bhn.isMDXComponent=!0;const Nhn={toc:[]};function zhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zhn.isMDXComponent=!0;const Ahn={toc:[]};function Whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Whn.isMDXComponent=!0;const Rhn={toc:[]};function Ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ihn.isMDXComponent=!0;const Shn={toc:[]};function Phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Shn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Phn.isMDXComponent=!0;const Ehn={toc:[]};function Bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhn.isMDXComponent=!0;const Ghn={toc:[]};function Ohn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ohn.isMDXComponent=!0;const Fhn={toc:[]};function Uhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uhn.isMDXComponent=!0;const qhn={toc:[]};function Vhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Vhn.isMDXComponent=!0;const jhn={toc:[]};function Qhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qhn.isMDXComponent=!0;const Hhn={toc:[]};function Yhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Yhn.isMDXComponent=!0;const $hn={toc:[]};function Khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Khn.isMDXComponent=!0;const Jhn={toc:[]};function tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}tfn.isMDXComponent=!0;const nfn={toc:[]};function efn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}efn.isMDXComponent=!0;const ofn={toc:[]};function pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pfn.isMDXComponent=!0;const rfn={toc:[]};function sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sfn.isMDXComponent=!0;const cfn={toc:[]};function ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ifn.isMDXComponent=!0;const afn={toc:[]};function lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lfn.isMDXComponent=!0;const ufn={toc:[]};function mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}mfn.isMDXComponent=!0;const dfn={toc:[]};function hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hfn.isMDXComponent=!0;const ffn={toc:[]};function kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kfn.isMDXComponent=!0;const yfn={toc:[]};function Mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mfn.isMDXComponent=!0;const Dfn={toc:[]};function _fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_fn.isMDXComponent=!0;const Xfn={toc:[]};function wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wfn.isMDXComponent=!0;const gfn={toc:[]};function Tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tfn.isMDXComponent=!0;const xfn={toc:[]};function Cfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cfn.isMDXComponent=!0;const vfn={toc:[]};function Lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]};function bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bfn.isMDXComponent=!0;const Nfn={toc:[]};function zfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zfn.isMDXComponent=!0;const Afn={toc:[]};function Wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wfn.isMDXComponent=!0;const Rfn={toc:[]};function Ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ifn.isMDXComponent=!0;const Sfn={toc:[]};function Pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pfn.isMDXComponent=!0;const Efn={toc:[]};function Bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bfn.isMDXComponent=!0;const Gfn={toc:[]};function Ofn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ofn.isMDXComponent=!0;const Ffn={toc:[]};function Ufn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ufn.isMDXComponent=!0;const qfn={toc:[]};function Vfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vfn.isMDXComponent=!0;const jfn={toc:[]};function Qfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Qfn.isMDXComponent=!0;const Hfn={toc:[]};function Yfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Yfn.isMDXComponent=!0;const $fn={toc:[]};function Kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]};function tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tkn.isMDXComponent=!0;const nkn={toc:[]};function ekn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ekn.isMDXComponent=!0;const okn={toc:[]};function pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pkn.isMDXComponent=!0;const rkn={toc:[]};function skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}skn.isMDXComponent=!0;const ckn={toc:[]};function ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ikn.isMDXComponent=!0;const akn={toc:[]};function lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lkn.isMDXComponent=!0;const ukn={toc:[]};function mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}mkn.isMDXComponent=!0;const dkn={toc:[]};function hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}hkn.isMDXComponent=!0;const fkn={toc:[]};function kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}kkn.isMDXComponent=!0;const ykn={toc:[]};function Mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Mkn.isMDXComponent=!0;const Dkn={toc:[]};function _kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}_kn.isMDXComponent=!0;const Xkn={toc:[]};function wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}wkn.isMDXComponent=!0;const gkn={toc:[]};function Tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tkn.isMDXComponent=!0;const xkn={toc:[]};function Ckn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ckn.isMDXComponent=!0;const vkn={toc:[]};function Lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Lkn.isMDXComponent=!0;const Zkn={toc:[]};function bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}bkn.isMDXComponent=!0;const Nkn={toc:[]};function zkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zkn.isMDXComponent=!0;const Akn={toc:[]};function Wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wkn.isMDXComponent=!0;const Rkn={toc:[]};function Ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Ikn.isMDXComponent=!0;const Skn={toc:[]};function Pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Skn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Pkn.isMDXComponent=!0;const Ekn={toc:[]};function Bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Bkn.isMDXComponent=!0;const Gkn={toc:[]};function Okn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Okn.isMDXComponent=!0;const Fkn={toc:[]};function Ukn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Ukn.isMDXComponent=!0;const qkn={toc:[]};function Vkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vkn.isMDXComponent=!0;const jkn={toc:[]};function Qkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qkn.isMDXComponent=!0;const Hkn={toc:[]};function Ykn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ykn.isMDXComponent=!0;const $kn={toc:[]};function Kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]};function tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tyn.isMDXComponent=!0;const nyn={toc:[]};function eyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eyn.isMDXComponent=!0;const oyn={toc:[]};function pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}pyn.isMDXComponent=!0;const ryn={toc:[]};function syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}syn.isMDXComponent=!0;const cyn={toc:[]};function iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iyn.isMDXComponent=!0;const ayn={toc:[]};function lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lyn.isMDXComponent=!0;const uyn={toc:[]};function myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}myn.isMDXComponent=!0;const dyn={toc:[]};function hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hyn.isMDXComponent=!0;const fyn={toc:[]};function kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kyn.isMDXComponent=!0;const yyn={toc:[]};function Myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Myn.isMDXComponent=!0;const Dyn={toc:[]};function _yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_yn.isMDXComponent=!0;const Xyn={toc:[]};function wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wyn.isMDXComponent=!0;const gyn={toc:[]};function Tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tyn.isMDXComponent=!0;const xyn={toc:[]};function Cyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Cyn.isMDXComponent=!0;const vyn={toc:[]};function Lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Lyn.isMDXComponent=!0;const Zyn={toc:[]};function byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}byn.isMDXComponent=!0;const Nyn={toc:[]};function zyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zyn.isMDXComponent=!0;const Ayn={toc:[]};function Wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wyn.isMDXComponent=!0;const Ryn={toc:[]};function Iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Iyn.isMDXComponent=!0;const Syn={toc:[]};function Pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Syn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Pyn.isMDXComponent=!0;const Eyn={toc:[]};function Byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Byn.isMDXComponent=!0;const Gyn={toc:[]};function Oyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Oyn.isMDXComponent=!0;const Fyn={toc:[]};function Uyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Uyn.isMDXComponent=!0;const qyn={toc:[]};function Vyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vyn.isMDXComponent=!0;const jyn={toc:[]};function Qyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qyn.isMDXComponent=!0;const Hyn={toc:[]};function Yyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yyn.isMDXComponent=!0;const $yn={toc:[]};function Kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]};function tMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tMn.isMDXComponent=!0;const nMn={toc:[]};function eMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eMn.isMDXComponent=!0;const oMn={toc:[]};function pMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}pMn.isMDXComponent=!0;const rMn={toc:[]};function sMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}sMn.isMDXComponent=!0;const cMn={toc:[]};function iMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}iMn.isMDXComponent=!0;const aMn={toc:[]};function lMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}lMn.isMDXComponent=!0;const uMn={toc:[]};function mMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}mMn.isMDXComponent=!0;const dMn={toc:[]};function hMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}hMn.isMDXComponent=!0;const fMn={toc:[]};function kMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kMn.isMDXComponent=!0;const yMn={toc:[]};function MMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}MMn.isMDXComponent=!0;const DMn={toc:[]};function _Mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Mn.isMDXComponent=!0;const XMn={toc:[]};function wMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wMn.isMDXComponent=!0;const gMn={toc:[]};function TMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TMn.isMDXComponent=!0;const xMn={toc:[]};function CMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}CMn.isMDXComponent=!0;const vMn={toc:[]};function LMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LMn.isMDXComponent=!0;const ZMn={toc:[]};function bMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bMn.isMDXComponent=!0;const NMn={toc:[]};function zMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}zMn.isMDXComponent=!0;const AMn={toc:[]};function WMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}WMn.isMDXComponent=!0;const RMn={toc:[]};function IMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IMn.isMDXComponent=!0;const SMn={toc:[]};function PMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PMn.isMDXComponent=!0;const EMn={toc:[]};function BMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}BMn.isMDXComponent=!0;const GMn={toc:[]};function OMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}OMn.isMDXComponent=!0;const FMn={toc:[]};function UMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UMn.isMDXComponent=!0;const qMn={toc:[]};function VMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}VMn.isMDXComponent=!0;const jMn={toc:[]};function QMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}QMn.isMDXComponent=!0;const HMn={toc:[]};function YMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}YMn.isMDXComponent=!0;const $Mn={toc:[]};function KMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}KMn.isMDXComponent=!0;const JMn={toc:[]};function tDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}tDn.isMDXComponent=!0;const nDn={toc:[]};function eDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}eDn.isMDXComponent=!0;const oDn={toc:[]};function pDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pDn.isMDXComponent=!0;const rDn={toc:[]};function sDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sDn.isMDXComponent=!0;const cDn={toc:[]};function iDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iDn.isMDXComponent=!0;const aDn={toc:[]};function lDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lDn.isMDXComponent=!0;const uDn={toc:[]};function mDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mDn.isMDXComponent=!0;const dDn={toc:[]};function hDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hDn.isMDXComponent=!0;const fDn={toc:[]};function kDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kDn.isMDXComponent=!0;const yDn={toc:[]};function MDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}MDn.isMDXComponent=!0;const DDn={toc:[]};function _Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Dn.isMDXComponent=!0;const XDn={toc:[]};function wDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wDn.isMDXComponent=!0;const gDn={toc:[]};function TDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TDn.isMDXComponent=!0;const xDn={toc:[]};function CDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}CDn.isMDXComponent=!0;const vDn={toc:[]};function LDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LDn.isMDXComponent=!0;const ZDn={toc:[]};function bDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bDn.isMDXComponent=!0;const NDn={toc:[]};function zDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zDn.isMDXComponent=!0;const ADn={toc:[]};function WDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WDn.isMDXComponent=!0;const RDn={toc:[]};function IDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IDn.isMDXComponent=!0;const SDn={toc:[]};function PDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PDn.isMDXComponent=!0;const EDn={toc:[]};function BDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BDn.isMDXComponent=!0;const GDn={toc:[]};function ODn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ODn.isMDXComponent=!0;const FDn={toc:[]};function UDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UDn.isMDXComponent=!0;const qDn={toc:[]};function VDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VDn.isMDXComponent=!0;const jDn={toc:[]};function QDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}QDn.isMDXComponent=!0;const HDn={toc:[]};function YDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}YDn.isMDXComponent=!0;const $Dn={toc:[]};function KDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KDn.isMDXComponent=!0;const JDn={toc:[]};function t_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}t_n.isMDXComponent=!0;const n_n={toc:[]};function e_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}e_n.isMDXComponent=!0;const o_n={toc:[]};function p_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}p_n.isMDXComponent=!0;const r_n={toc:[]};function s_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s_n.isMDXComponent=!0;const c_n={toc:[]};function i_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}i_n.isMDXComponent=!0;const a_n={toc:[]};function l_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}l_n.isMDXComponent=!0;const u_n={toc:[]};function m_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}m_n.isMDXComponent=!0;const d_n={toc:[]};function h_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}h_n.isMDXComponent=!0;const f_n={toc:[]};function k_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}k_n.isMDXComponent=!0;const y_n={toc:[]};function M_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M_n.isMDXComponent=!0;const D_n={toc:[]};function __n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}__n.isMDXComponent=!0;const X_n={toc:[]};function w_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}w_n.isMDXComponent=!0;const g_n={toc:[]};function T_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}T_n.isMDXComponent=!0;const x_n={toc:[]};function C_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}C_n.isMDXComponent=!0;const v_n={toc:[]};function L_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}L_n.isMDXComponent=!0;const Z_n={toc:[]};function b_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b_n.isMDXComponent=!0;const N_n={toc:[]};function z_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}z_n.isMDXComponent=!0;const A_n={toc:[]};function W_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}W_n.isMDXComponent=!0;const R_n={toc:[]};function I_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}I_n.isMDXComponent=!0;const S_n={toc:[]};function P_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}P_n.isMDXComponent=!0;const E_n={toc:[]};function B_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}B_n.isMDXComponent=!0;const G_n={toc:[]};function O_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}O_n.isMDXComponent=!0;const F_n={toc:[]};function U_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}U_n.isMDXComponent=!0;const q_n={toc:[]};function V_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}V_n.isMDXComponent=!0;const j_n={toc:[]};function Q_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q_n.isMDXComponent=!0;const H_n={toc:[]};function Y_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y_n.isMDXComponent=!0;const $_n={toc:[]};function K_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K_n.isMDXComponent=!0;const J_n={toc:[]};function tXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tXn.isMDXComponent=!0;const nXn={toc:[]};function eXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eXn.isMDXComponent=!0;const oXn={toc:[]};function pXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pXn.isMDXComponent=!0;const rXn={toc:[]};function sXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sXn.isMDXComponent=!0;const cXn={toc:[]};function iXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iXn.isMDXComponent=!0;const aXn={toc:[]};function lXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lXn.isMDXComponent=!0;const uXn={toc:[]};function mXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mXn.isMDXComponent=!0;const dXn={toc:[]};function hXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hXn.isMDXComponent=!0;const fXn={toc:[]};function kXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kXn.isMDXComponent=!0;const yXn={toc:[]};function MXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}MXn.isMDXComponent=!0;const DXn={toc:[]};function _Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Xn.isMDXComponent=!0;const XXn={toc:[]};function wXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wXn.isMDXComponent=!0;const gXn={toc:[]};function TXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}TXn.isMDXComponent=!0;const xXn={toc:[]};function CXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}CXn.isMDXComponent=!0;const vXn={toc:[]};function LXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LXn.isMDXComponent=!0;const ZXn={toc:[]};function bXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bXn.isMDXComponent=!0;const NXn={toc:[]};function zXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zXn.isMDXComponent=!0;const AXn={toc:[]};function WXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WXn.isMDXComponent=!0;const RXn={toc:[]};function IXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IXn.isMDXComponent=!0;const SXn={toc:[]};function PXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}PXn.isMDXComponent=!0;const EXn={toc:[]};function BXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}BXn.isMDXComponent=!0;const GXn={toc:[]};function OXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}OXn.isMDXComponent=!0;const FXn={toc:[]};function UXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UXn.isMDXComponent=!0;const qXn={toc:[]};function VXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}VXn.isMDXComponent=!0;const jXn={toc:[]};function QXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QXn.isMDXComponent=!0;const HXn={toc:[]};function YXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}YXn.isMDXComponent=!0;const $Xn={toc:[]};function KXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KXn.isMDXComponent=!0;const JXn={toc:[]};function twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}twn.isMDXComponent=!0;const nwn={toc:[]};function ewn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ewn.isMDXComponent=!0;const own={toc:[]};function pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},own,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pwn.isMDXComponent=!0;const rwn={toc:[]};function swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}swn.isMDXComponent=!0;const cwn={toc:[]};function iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}iwn.isMDXComponent=!0;const awn={toc:[]};function lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lwn.isMDXComponent=!0;const uwn={toc:[]};function mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}mwn.isMDXComponent=!0;const dwn={toc:[]};function hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}hwn.isMDXComponent=!0;const fwn={toc:[]};function kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kwn.isMDXComponent=!0;const ywn={toc:[]};function Mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mwn.isMDXComponent=!0;const Dwn={toc:[]};function _wn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_wn.isMDXComponent=!0;const Xwn={toc:[]};function wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wwn.isMDXComponent=!0;const gwn={toc:[]};function Twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Twn.isMDXComponent=!0;const xwn={toc:[]};function Cwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Cwn.isMDXComponent=!0;const vwn={toc:[]};function Lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]};function bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bwn.isMDXComponent=!0;const Nwn={toc:[]};function zwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}zwn.isMDXComponent=!0;const Awn={toc:[]};function Wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Wwn.isMDXComponent=!0;const Rwn={toc:[]};function Iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Iwn.isMDXComponent=!0;const Swn={toc:[]};function Pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Swn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pwn.isMDXComponent=!0;const Ewn={toc:[]};function Bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bwn.isMDXComponent=!0;const Gwn={toc:[]};function Own(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Own.isMDXComponent=!0;const Fwn={toc:[]};function Uwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Uwn.isMDXComponent=!0;const qwn={toc:[]};function Vwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vwn.isMDXComponent=!0;const jwn={toc:[]};function Qwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Qwn.isMDXComponent=!0;const Hwn={toc:[]};function Ywn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ywn.isMDXComponent=!0;const $wn={toc:[]};function Kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]};function tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tgn.isMDXComponent=!0;const ngn={toc:[]};function egn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}egn.isMDXComponent=!0;const ogn={toc:[]};function pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pgn.isMDXComponent=!0;const rgn={toc:[]};function sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}sgn.isMDXComponent=!0;const cgn={toc:[]};function ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ign.isMDXComponent=!0;const agn={toc:[]};function lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lgn.isMDXComponent=!0;const ugn={toc:[]};function mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}mgn.isMDXComponent=!0;const dgn={toc:[]};function hgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}hgn.isMDXComponent=!0;const fgn={toc:[]};function kgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kgn.isMDXComponent=!0;const ygn={toc:[]};function Mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Mgn.isMDXComponent=!0;const Dgn={toc:[]};function _gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_gn.isMDXComponent=!0;const Xgn={toc:[]};function wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wgn.isMDXComponent=!0;const ggn={toc:[]};function Tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Tgn.isMDXComponent=!0;const xgn={toc:[]};function Cgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Cgn.isMDXComponent=!0;const vgn={toc:[]};function Lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]};function bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bgn.isMDXComponent=!0;const Ngn={toc:[]};function zgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zgn.isMDXComponent=!0;const Agn={toc:[]};function Wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wgn.isMDXComponent=!0;const Rgn={toc:[]};function Ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ign.isMDXComponent=!0;const Sgn={toc:[]};function Pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pgn.isMDXComponent=!0;const Egn={toc:[]};function Bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bgn.isMDXComponent=!0;const Ggn={toc:[]};function Ogn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ogn.isMDXComponent=!0;const Fgn={toc:[]};function Ugn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ugn.isMDXComponent=!0;const qgn={toc:[]};function Vgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Vgn.isMDXComponent=!0;const jgn={toc:[]};function Qgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Qgn.isMDXComponent=!0;const Hgn={toc:[]};function Ygn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}Ygn.isMDXComponent=!0;const $gn={toc:[]};function Kgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]};function tTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tTn.isMDXComponent=!0;const nTn={toc:[]};function eTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eTn.isMDXComponent=!0;const oTn={toc:[]};function pTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pTn.isMDXComponent=!0;const rTn={toc:[]};function sTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sTn.isMDXComponent=!0;const cTn={toc:[]};function iTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}iTn.isMDXComponent=!0;const aTn={toc:[]};function lTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lTn.isMDXComponent=!0;const uTn={toc:[]};function mTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mTn.isMDXComponent=!0;const dTn={toc:[]};function hTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hTn.isMDXComponent=!0;const fTn={toc:[]};function kTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kTn.isMDXComponent=!0;const yTn={toc:[]};function MTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MTn.isMDXComponent=!0;const DTn={toc:[]};function _Tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_Tn.isMDXComponent=!0;const XTn={toc:[]};function wTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wTn.isMDXComponent=!0;const gTn={toc:[]};function TTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}TTn.isMDXComponent=!0;const xTn={toc:[]};function CTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CTn.isMDXComponent=!0;const vTn={toc:[]};function LTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LTn.isMDXComponent=!0;const ZTn={toc:[]};function bTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}bTn.isMDXComponent=!0;const NTn={toc:[]};function zTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}zTn.isMDXComponent=!0;const ATn={toc:[]};function WTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WTn.isMDXComponent=!0;const RTn={toc:[]};function ITn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ITn.isMDXComponent=!0;const STn={toc:[]};function PTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},STn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}PTn.isMDXComponent=!0;const ETn={toc:[]};function BTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}BTn.isMDXComponent=!0;const GTn={toc:[]};function OTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OTn.isMDXComponent=!0;const FTn={toc:[]};function UTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}UTn.isMDXComponent=!0;const qTn={toc:[]};function VTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VTn.isMDXComponent=!0;const jTn={toc:[]};function QTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}QTn.isMDXComponent=!0;const HTn={toc:[]};function YTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YTn.isMDXComponent=!0;const $Tn={toc:[]};function KTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KTn.isMDXComponent=!0;const JTn={toc:[]};function txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}txn.isMDXComponent=!0;const nxn={toc:[]};function exn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}exn.isMDXComponent=!0;const oxn={toc:[]};function pxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pxn.isMDXComponent=!0;const rxn={toc:[]};function sxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}sxn.isMDXComponent=!0;const cxn={toc:[]};function ixn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ixn.isMDXComponent=!0;const axn={toc:[]};function lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lxn.isMDXComponent=!0;const uxn={toc:[]};function mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mxn.isMDXComponent=!0;const dxn={toc:[]};function hxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hxn.isMDXComponent=!0;const fxn={toc:[]};function kxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kxn.isMDXComponent=!0;const yxn={toc:[]};function Mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mxn.isMDXComponent=!0;const Dxn={toc:[]};function _xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_xn.isMDXComponent=!0;const Xxn={toc:[]};function wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wxn.isMDXComponent=!0;const gxn={toc:[]};function Txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Txn.isMDXComponent=!0;const xxn={toc:[]};function Cxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Cxn.isMDXComponent=!0;const vxn={toc:[]};function Lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]};function bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bxn.isMDXComponent=!0;const Nxn={toc:[]};function zxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}zxn.isMDXComponent=!0;const Axn={toc:[]};function Wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Wxn.isMDXComponent=!0;const Rxn={toc:[]};function Ixn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ixn.isMDXComponent=!0;const Sxn={toc:[]};function Pxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pxn.isMDXComponent=!0;const Exn={toc:[]};function Bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Exn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bxn.isMDXComponent=!0;const Gxn={toc:[]};function Oxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Oxn.isMDXComponent=!0;const Fxn={toc:[]};function Uxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uxn.isMDXComponent=!0;const qxn={toc:[]};function Vxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vxn.isMDXComponent=!0;const jxn={toc:[]};function Qxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Qxn.isMDXComponent=!0;const Hxn={toc:[]};function Yxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Yxn.isMDXComponent=!0;const $xn={toc:[]};function Kxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]};function tCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tCn.isMDXComponent=!0;const nCn={toc:[]};function eCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}eCn.isMDXComponent=!0;const oCn={toc:[]};function pCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pCn.isMDXComponent=!0;const rCn={toc:[]};function sCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}sCn.isMDXComponent=!0;const cCn={toc:[]};function iCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}iCn.isMDXComponent=!0;const aCn={toc:[]};function lCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lCn.isMDXComponent=!0;const uCn={toc:[]};function mCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mCn.isMDXComponent=!0;const dCn={toc:[]};function hCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}hCn.isMDXComponent=!0;const fCn={toc:[]};function kCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kCn.isMDXComponent=!0;const yCn={toc:[]};function MCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}MCn.isMDXComponent=!0;const DCn={toc:[]};function _Cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}_Cn.isMDXComponent=!0;const XCn={toc:[]};function wCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}wCn.isMDXComponent=!0;const gCn={toc:[]};function TCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}TCn.isMDXComponent=!0;const xCn={toc:[]};function CCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}CCn.isMDXComponent=!0;const vCn={toc:[]};function LCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LCn.isMDXComponent=!0;const ZCn={toc:[]};function bCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bCn.isMDXComponent=!0;const NCn={toc:[]};function zCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zCn.isMDXComponent=!0;const ACn={toc:[]};function WCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}WCn.isMDXComponent=!0;const RCn={toc:[]};function ICn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ICn.isMDXComponent=!0;const SCn={toc:[]};function PCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PCn.isMDXComponent=!0;const ECn={toc:[]};function BCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BCn.isMDXComponent=!0;const GCn={toc:[]};function OCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OCn.isMDXComponent=!0;const FCn={toc:[]};function UCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UCn.isMDXComponent=!0;const qCn={toc:[]};function VCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VCn.isMDXComponent=!0;const jCn={toc:[]};function QCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QCn.isMDXComponent=!0;const HCn={toc:[]};function YCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YCn.isMDXComponent=!0;const $Cn={toc:[]};function KCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KCn.isMDXComponent=!0;const JCn={toc:[]};function tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tvn.isMDXComponent=!0;const nvn={toc:[]};function evn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}evn.isMDXComponent=!0;const ovn={toc:[]};function pvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pvn.isMDXComponent=!0;const rvn={toc:[]};function svn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}svn.isMDXComponent=!0;const cvn={toc:[]};function ivn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}ivn.isMDXComponent=!0;const avn={toc:[]};function lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lvn.isMDXComponent=!0;const uvn={toc:[]};function mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mvn.isMDXComponent=!0;const dvn={toc:[]};function hvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hvn.isMDXComponent=!0;const fvn={toc:[]};function kvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kvn.isMDXComponent=!0;const yvn={toc:[]};function Mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mvn.isMDXComponent=!0;const Dvn={toc:[]};function _vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_vn.isMDXComponent=!0;const Xvn={toc:[]};function wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wvn.isMDXComponent=!0;const gvn={toc:[]};function Tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tvn.isMDXComponent=!0;const xvn={toc:[]};function Cvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Cvn.isMDXComponent=!0;const vvn={toc:[]};function Lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]};function bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bvn.isMDXComponent=!0;const Nvn={toc:[]};function zvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zvn.isMDXComponent=!0;const Avn={toc:[]};function Wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wvn.isMDXComponent=!0;const Rvn={toc:[]};function Ivn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ivn.isMDXComponent=!0;const Svn={toc:[]};function Pvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Svn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pvn.isMDXComponent=!0;const Evn={toc:[]};function Bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bvn.isMDXComponent=!0;const Gvn={toc:[]};function Ovn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ovn.isMDXComponent=!0;const Fvn={toc:[]};function Uvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Uvn.isMDXComponent=!0;const qvn={toc:[]};function Vvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vvn.isMDXComponent=!0;const jvn={toc:[]};function Qvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qvn.isMDXComponent=!0;const Hvn={toc:[]};function Yvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Yvn.isMDXComponent=!0;const $vn={toc:[]};function Kvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Kvn.isMDXComponent=!0;const Jvn={toc:[]};function tLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}tLn.isMDXComponent=!0;const nLn={toc:[]};function eLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eLn.isMDXComponent=!0;const oLn={toc:[]};function pLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pLn.isMDXComponent=!0;const rLn={toc:[]};function sLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}sLn.isMDXComponent=!0;const cLn={toc:[]};function iLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}iLn.isMDXComponent=!0;const aLn={toc:[]};function lLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}lLn.isMDXComponent=!0;const uLn={toc:[]};function mLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}mLn.isMDXComponent=!0;const dLn={toc:[]};function hLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}hLn.isMDXComponent=!0;const fLn={toc:[]};function kLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}kLn.isMDXComponent=!0;const yLn={toc:[]};function MLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MLn.isMDXComponent=!0;const DLn={toc:[]};function _Ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_Ln.isMDXComponent=!0;const XLn={toc:[]};function wLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wLn.isMDXComponent=!0;const gLn={toc:[]};function TLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}TLn.isMDXComponent=!0;const xLn={toc:[]};function CLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CLn.isMDXComponent=!0;const vLn={toc:[]};function LLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LLn.isMDXComponent=!0;const ZLn={toc:[]};function bLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bLn.isMDXComponent=!0;const NLn={toc:[]};function zLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zLn.isMDXComponent=!0;const ALn={toc:[]};function WLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WLn.isMDXComponent=!0;const RLn={toc:[]};function ILn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ILn.isMDXComponent=!0;const SLn={toc:[]};function PLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PLn.isMDXComponent=!0;const ELn={toc:[]};function BLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BLn.isMDXComponent=!0;const GLn={toc:[]};function OLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}OLn.isMDXComponent=!0;const FLn={toc:[]};function ULn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}ULn.isMDXComponent=!0;const qLn={toc:[]};function VLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VLn.isMDXComponent=!0;const jLn={toc:[]};function QLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QLn.isMDXComponent=!0;const HLn={toc:[]};function YLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}YLn.isMDXComponent=!0;const $Ln={toc:[]};function KLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}KLn.isMDXComponent=!0;const JLn={toc:[]};function tZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tZn.isMDXComponent=!0;const nZn={toc:[]};function eZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}eZn.isMDXComponent=!0;const oZn={toc:[]};function pZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pZn.isMDXComponent=!0;const rZn={toc:[]};function sZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}sZn.isMDXComponent=!0;const cZn={toc:[]};function iZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iZn.isMDXComponent=!0;const aZn={toc:[]};function lZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lZn.isMDXComponent=!0;const uZn={toc:[]};function mZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mZn.isMDXComponent=!0;const dZn={toc:[]};function hZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hZn.isMDXComponent=!0;const fZn={toc:[]};function kZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kZn.isMDXComponent=!0;const yZn={toc:[]};function MZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}MZn.isMDXComponent=!0;const DZn={toc:[]};function _Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}_Zn.isMDXComponent=!0;const XZn={toc:[]};function wZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}wZn.isMDXComponent=!0;const gZn={toc:[]};function TZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}TZn.isMDXComponent=!0;const xZn={toc:[]};function CZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}CZn.isMDXComponent=!0;const vZn={toc:[]};function LZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}LZn.isMDXComponent=!0;const ZZn={toc:[]};function bZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}bZn.isMDXComponent=!0;const NZn={toc:[]};function zZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}zZn.isMDXComponent=!0;const AZn={toc:[]};function WZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}WZn.isMDXComponent=!0;const RZn={toc:[]};function IZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}IZn.isMDXComponent=!0;const SZn={toc:[]};function PZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}PZn.isMDXComponent=!0;const EZn={toc:[]};function BZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}BZn.isMDXComponent=!0;const GZn={toc:[]};function OZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}OZn.isMDXComponent=!0;const FZn={toc:[]};function UZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}UZn.isMDXComponent=!0;const qZn={toc:[]};function VZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}VZn.isMDXComponent=!0;const jZn={toc:[]};function QZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}QZn.isMDXComponent=!0;const HZn={toc:[]};function YZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}YZn.isMDXComponent=!0;const $Zn={toc:[]};function KZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}KZn.isMDXComponent=!0;const JZn={toc:[]};function tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}tbn.isMDXComponent=!0;const nbn={toc:[]};function ebn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}ebn.isMDXComponent=!0;const obn={toc:[]};function pbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}pbn.isMDXComponent=!0;const rbn={toc:[]};function sbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}sbn.isMDXComponent=!0;const cbn={toc:[]};function ibn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}ibn.isMDXComponent=!0;const abn={toc:[]};function lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}lbn.isMDXComponent=!0;const ubn={toc:[]};function mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}mbn.isMDXComponent=!0;const dbn={toc:[]};function hbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}hbn.isMDXComponent=!0;const fbn={toc:[]};function kbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}kbn.isMDXComponent=!0;const ybn={toc:[]};function Mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}Mbn.isMDXComponent=!0;const Dbn={toc:[]};function _bn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}_bn.isMDXComponent=!0;const Xbn={toc:[]};function wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}wbn.isMDXComponent=!0;const gbn={toc:[]};function Tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}Tbn.isMDXComponent=!0;const xbn={toc:[]};function Cbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}Cbn.isMDXComponent=!0;const vbn={toc:[]};function Lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}Lbn.isMDXComponent=!0;const Zbn={toc:[]};function bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}bbn.isMDXComponent=!0;const Nbn={toc:[]};function zbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}zbn.isMDXComponent=!0;const Abn={toc:[]};function Wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Wbn.isMDXComponent=!0;const Rbn={toc:[]};function Ibn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Ibn.isMDXComponent=!0;const Sbn={toc:[]};function Pbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Pbn.isMDXComponent=!0;const Ebn={toc:[]};function Bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Bbn.isMDXComponent=!0;const Gbn={toc:[]};function Obn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}Obn.isMDXComponent=!0;const Fbn={toc:[]};function Ubn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Ubn.isMDXComponent=!0;const qbn={toc:[]};function Vbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Vbn.isMDXComponent=!0;const jbn={toc:[]};function Qbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}Qbn.isMDXComponent=!0;const Hbn={toc:[]};function Ybn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Ybn.isMDXComponent=!0;const $bn={toc:[]};function Kbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Kbn.isMDXComponent=!0;const Jbn={toc:[]};function tNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}tNn.isMDXComponent=!0;const nNn={toc:[]};function eNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}eNn.isMDXComponent=!0;const oNn={toc:[]};function pNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}pNn.isMDXComponent=!0;const rNn={toc:[]};function sNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}sNn.isMDXComponent=!0;const cNn={toc:[]};function iNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}iNn.isMDXComponent=!0;const aNn={toc:[]};function lNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}lNn.isMDXComponent=!0;const uNn={toc:[]};function mNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}mNn.isMDXComponent=!0;const dNn={toc:[]};function hNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}hNn.isMDXComponent=!0;const fNn={toc:[]};function kNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNn,e,{components:n,mdxType:"MDXLayout"}))}kNn.isMDXComponent=!0;const yNn={toc:[]};function MNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}MNn.isMDXComponent=!0;const DNn={toc:[]};function _Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}_Nn.isMDXComponent=!0;const XNn={toc:[]};function wNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}wNn.isMDXComponent=!0;const gNn={toc:[]};function TNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}TNn.isMDXComponent=!0;const xNn={toc:[]};function CNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}CNn.isMDXComponent=!0;const vNn={toc:[]};function LNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}LNn.isMDXComponent=!0;const ZNn={toc:[]};function bNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}bNn.isMDXComponent=!0;const NNn={toc:[]};function zNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}zNn.isMDXComponent=!0;const ANn={toc:[]};function WNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}WNn.isMDXComponent=!0;const RNn={toc:[]};function INn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}INn.isMDXComponent=!0;const SNn={toc:[]};function PNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}PNn.isMDXComponent=!0;const ENn={toc:[]};function BNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}BNn.isMDXComponent=!0;const GNn={toc:[]};function ONn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}ONn.isMDXComponent=!0;const FNn={toc:[]};function UNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}UNn.isMDXComponent=!0;const qNn={toc:[]};function VNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}VNn.isMDXComponent=!0;const jNn={toc:[]};function QNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}QNn.isMDXComponent=!0;const HNn={toc:[]};function YNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}YNn.isMDXComponent=!0;const $Nn={toc:[]};function KNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}KNn.isMDXComponent=!0;const JNn={toc:[]};function tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}tzn.isMDXComponent=!0;const nzn={toc:[]};function ezn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}ezn.isMDXComponent=!0;const ozn={toc:[]};function pzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}pzn.isMDXComponent=!0;const rzn={toc:[]};function szn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}szn.isMDXComponent=!0;const czn={toc:[]};function izn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}izn.isMDXComponent=!0;const azn={toc:[]};function lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}lzn.isMDXComponent=!0;const uzn={toc:[]};function mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mzn.isMDXComponent=!0;const dzn={toc:[]};function hzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}hzn.isMDXComponent=!0;const fzn={toc:[]};function kzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}kzn.isMDXComponent=!0;const yzn={toc:[]};function Mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}Mzn.isMDXComponent=!0;const Dzn={toc:[]};function _zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}_zn.isMDXComponent=!0;const Xzn={toc:[]};function wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}wzn.isMDXComponent=!0;const gzn={toc:[]};function Tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}Tzn.isMDXComponent=!0;const xzn={toc:[]};function Czn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}Czn.isMDXComponent=!0;const vzn={toc:[]};function Lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]};function bzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}bzn.isMDXComponent=!0;const Nzn={toc:[]};function zzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}zzn.isMDXComponent=!0;const Azn={toc:[]};function Wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}Wzn.isMDXComponent=!0;const Rzn={toc:[]};function Izn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Izn.isMDXComponent=!0;const Szn={toc:[]};function Pzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Szn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Pzn.isMDXComponent=!0;const Ezn={toc:[]};function Bzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}Bzn.isMDXComponent=!0;const Gzn={toc:[]};function Ozn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}Ozn.isMDXComponent=!0;const Fzn={toc:[]};function Uzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}Uzn.isMDXComponent=!0;const qzn={toc:[]};function Vzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Vzn.isMDXComponent=!0;const jzn={toc:[]};function Qzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}Qzn.isMDXComponent=!0;const Hzn={toc:[]};function Yzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Yzn.isMDXComponent=!0;const $zn={toc:[]};function Kzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Kzn.isMDXComponent=!0;const Jzn={toc:[]};function tAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}tAn.isMDXComponent=!0;const nAn={toc:[]};function eAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}eAn.isMDXComponent=!0;const oAn={toc:[]};function pAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}pAn.isMDXComponent=!0;const rAn={toc:[]};function sAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}sAn.isMDXComponent=!0;const cAn={toc:[]};function iAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}iAn.isMDXComponent=!0;const aAn={toc:[]};function lAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}lAn.isMDXComponent=!0;const uAn={toc:[]};function mAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}mAn.isMDXComponent=!0;const dAn={toc:[]};function hAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}hAn.isMDXComponent=!0;const fAn={toc:[]};function kAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}kAn.isMDXComponent=!0;const yAn={toc:[]};function MAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}MAn.isMDXComponent=!0;const DAn={toc:[]};function _An(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}_An.isMDXComponent=!0;const XAn={toc:[]};function wAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}wAn.isMDXComponent=!0;const gAn={toc:[]};function TAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}TAn.isMDXComponent=!0;const xAn={toc:[]};function CAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}CAn.isMDXComponent=!0;const vAn={toc:[]};function LAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}LAn.isMDXComponent=!0;const ZAn={toc:[]};function bAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}bAn.isMDXComponent=!0;const NAn={toc:[]};function zAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}zAn.isMDXComponent=!0;const AAn={toc:[]};function WAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}WAn.isMDXComponent=!0;const RAn={toc:[]};function IAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}IAn.isMDXComponent=!0;const SAn={toc:[]};function PAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}PAn.isMDXComponent=!0;const EAn={toc:[]};function BAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}BAn.isMDXComponent=!0;const GAn={toc:[]};function OAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}OAn.isMDXComponent=!0;const FAn={toc:[]};function UAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}UAn.isMDXComponent=!0;const qAn={toc:[]};function VAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}VAn.isMDXComponent=!0;const jAn={toc:[]};function QAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}QAn.isMDXComponent=!0;const HAn={toc:[]};function YAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}YAn.isMDXComponent=!0;const $An={toc:[]};function KAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$An,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}KAn.isMDXComponent=!0;const JAn={toc:[]};function tWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function nWn(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}tWn.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(4404),r=e(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@preview"===n}))}),[n]),h=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),f=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,e&&c),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,n,e)=>{e.d(n,{Z:()=>Ot});var o=e(2784),p=e(7390),r=e(6835),s=e(68),c=e(6277),i=e(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,e&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},n)}var f=e(9817);function k(t){let{children:n,type:e,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(e);return p?o.createElement(f.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),n):o.createElement("span",(0,l.Z)({id:r},i),n)}let y,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function _(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[e??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:a.element},t)))))}var X=e(8617);function w(t){var n;let{type:e}=t;const p=(0,X.RU)(e.project),r=null==p?void 0:p[e.id],s=e.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:s,type:s?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(_,{type:y.Angle},e.typeArguments.map(((t,n)=>o.createElement(E,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(k,{type:"keyword"},n.name)}function T(t){let{type:n}=t;return n.elements?o.createElement(_,{type:y.Square},n.elements.map(((t,n)=>o.createElement(E,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.elementType}),"[]")}function C(t){let{type:n}=t;return o.createElement(_,{type:y.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(k,{type:p},e)}function L(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,n.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(E,{type:n.targetType}))}function Z(t){let{type:n}=t;const e=(0,X.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(_,{type:y.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:n,type:e}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(E,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(E,{type:n.extendsType})," ? ",o.createElement(E,{type:n.trueType})," : ",o.createElement(E,{type:n.falseType}))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.objectType}),"[",o.createElement(E,{type:n.indexType}),"]")}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},n.operator," "),o.createElement(E,{type:n.target}))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(_,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},n.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(E,{type:n.parameterType}),"]: ",o.createElement(E,{type:n.templateType}))))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(E,{type:n.element}))}function E(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return w;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return S;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function B(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(E,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},n.defaultValue)))}function O(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.varianceModifier&&o.createElement(k,{type:"keyword"},n.varianceModifier," "),o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:n.default})))}function F(t){var n,e;let{reflection:r,flags:s}=t;const c=(0,X.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,X.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):i?"":o.createElement(k,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(_,{type:y.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(_,{type:y.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function U(t){let{reflection:n}=t;return o.createElement(G,{reflection:n})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var n,e,p;let{reflection:r}=t;const s=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(k,{type:"keyword"},q[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(_,{type:y.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(_,null,r.extendedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(_,null,r.implementedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))))}function j(t){let{reflection:n}=t;const e=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},n.name),n.typeParameters&&o.createElement(_,{type:y.Angle},n.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:e(t)}))))," = ",o.createElement(E,{type:n.type}))}function Q(t){let{reflection:n}=t;const e=(0,X.in)();return n.signatures?o.createElement(F,{reflection:n.signatures[0]}):n.children?o.createElement(_,{type:y.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function H(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(F,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return F;case p.W.Property:return U;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return Q;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function $(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${a.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,c.Z)(a.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),J=e(4404);function tt(t){let{parameters:n}=t;const e=(0,X.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,X.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,X.in)(),s=(0,o.useMemo)((()=>n.map(r)),[n]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(F,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(nt,{parameters:c.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(3851),mt=e(4126),dt=e(2424),ht=e(2244),ft=e(4155);function kt(t){return function(t){var n;return(null==(n=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function yt(t){const{values:n,children:e}=t;return(0,o.useMemo)((()=>{const t=n??kt(e);return function(t){const n=(0,ht.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function Mt(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function Dt(t){let{queryString:n=!1,groupId:e}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const n=new URLSearchParams(p.location.search);n.set(r,t),p.replace({...p.location,search:n.toString()})}),[r,p])]}function _t(t){const{defaultValue:n,queryString:e=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!Mt({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:r}))),[i,a]=Dt({queryString:e,groupId:p}),[l,u]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[p,r]=(0,ft.Nk)(e);return[p,(0,o.useCallback)((t=>{e&&r.set(t)}),[e,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var Xt=e(9741);const wt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:n,block:e,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const n=t.currentTarget,e=i.indexOf(n),o=s[e].value;o!==p&&(a(n),r(o))},m=t=>{var n;let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=i.indexOf(t.currentTarget)+1;e=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(t.currentTarget)-1;e=i[n]??i[i.length-1];break}}null==(n=e)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":e},n)},s.map((t=>{let{value:n,label:e,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===n})}),e??n)})))}function xt(t){let{lazy:n,children:e,selectedValue:p}=t;const r=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==p}))))}function Ct(t){const n=_t(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",wt)},o.createElement(Tt,(0,l.Z)({},t,n)),o.createElement(xt,(0,l.Z)({},t,n)))}function vt(t){const n=(0,Xt.Z)();return o.createElement(Ct,(0,l.Z)({key:String(n)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:e},n)}function bt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Ot,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,X.RU)(e),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const s of t.children){const t=n[s];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[n,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of i)if(n.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(vt,{groupId:n.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var n,e,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(Y,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(w,{type:e.overwrites}))))}function Wt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(U,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:p.inheritedFrom}))))}function Rt(t){var n,e,p;let{reflection:r}=t;const s=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=e(8128);function St(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(at,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(Nt,{group:t,key:t.title,project:e.project}))))}const Pt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:n}=t;const e=(0,X.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Gt;case p.W.Module:return St;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function s(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function i(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=e(2784),p=e(822);const r=o.createContext(null);function s(t){let{children:n}=t;const e=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:s},n)}function c(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function i(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[e,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(a)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},5192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=e(7896),p=(e(2784),e(876)),r=e(2072),s=e(2665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Logan Zehm",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u};function d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);