"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1276],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function c(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):c(c({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,c(c({ref:n},l),{},{components:e})):o.createElement(h,c({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,c=new Array(r);c[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,c[1]=s;for(var i=2;i<r;i++)c[i]=e[i];return o.createElement.apply(null,c)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>l});var o=e(7896),p=e(2784),r=e(6277),c=e(1077),s=e(7683);const a="anchorWithStickyNavbar_fF9Z",i="anchorWithHideOnScrollNavbar_Yh18";function l(t){let{as:n,id:e,...l}=t;const{navbar:{hideOnScroll:u}}=(0,s.L)();return"h1"!==n&&e?p.createElement(n,(0,o.Z)({},l,{className:(0,r.Z)("anchor",u?i:a),id:e}),l.children,p.createElement("a",{className:"hash-link",href:`#${e}`,title:(0,c.I)({id:"theme.common.headingLinkTitle",message:"Direct link to heading",description:"Title for link to heading"})},"\u200b")):p.createElement(n,(0,o.Z)({},l,{id:void 0}))}},2072:(t,n,e)=>{e.d(n,{Z:()=>c});var o=e(2784),p=e(8617),r=e(1836);function c(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},6964:(t,n,e)=>{e.d(n,{Z:()=>h4});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>w,content_0_100:()=>tn,content_0_102:()=>en,content_0_104:()=>pn,content_0_106:()=>cn,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>Dn,content_0_12:()=>M,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Cn,content_0_126:()=>Ln,content_0_128:()=>Zn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>Rn,content_0_136:()=>In,content_0_138:()=>Wn,content_0_14:()=>X,content_0_140:()=>Fn,content_0_142:()=>jn,content_0_144:()=>Vn,content_0_146:()=>Bn,content_0_148:()=>$n,content_0_150:()=>Jn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>re,content_0_16:()=>x,content_0_160:()=>se,content_0_162:()=>ie,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>De,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Ce,content_0_18:()=>T,content_0_180:()=>Le,content_0_182:()=>Ze,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Ie,content_0_192:()=>We,content_0_194:()=>Fe,content_0_196:()=>je,content_0_198:()=>Ve,content_0_2:()=>l,content_0_20:()=>v,content_0_200:()=>Be,content_0_202:()=>$e,content_0_204:()=>Je,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>io,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>vo,content_0_236:()=>bo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>So,content_0_242:()=>zo,content_0_244:()=>Po,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>Oo,content_0_252:()=>qo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>S,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>cp,content_0_268:()=>ap,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>wp,content_0_28:()=>z,content_0_280:()=>Mp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Tp,content_0_288:()=>vp,content_0_290:()=>bp,content_0_292:()=>Ep,content_0_294:()=>Sp,content_0_296:()=>zp,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Gp,content_0_302:()=>Up,content_0_304:()=>Op,content_0_306:()=>qp,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>G,content_0_320:()=>cr,content_0_322:()=>ar,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>Xr,content_0_338:()=>xr,content_0_34:()=>U,content_0_340:()=>Tr,content_0_342:()=>vr,content_0_344:()=>br,content_0_346:()=>Er,content_0_348:()=>Sr,content_0_350:()=>zr,content_0_352:()=>Pr,content_0_354:()=>Gr,content_0_356:()=>Ur,content_0_358:()=>Or,content_0_36:()=>O,content_0_360:()=>qr,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>tc,content_0_370:()=>ec,content_0_372:()=>pc,content_0_374:()=>cc,content_0_376:()=>ac,content_0_378:()=>lc,content_0_38:()=>q,content_0_380:()=>mc,content_0_382:()=>hc,content_0_384:()=>yc,content_0_386:()=>wc,content_0_388:()=>Mc,content_0_390:()=>Xc,content_0_392:()=>xc,content_0_394:()=>Tc,content_0_396:()=>vc,content_0_398:()=>bc,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Ec,content_0_402:()=>Sc,content_0_404:()=>zc,content_0_406:()=>Pc,content_0_408:()=>Gc,content_0_410:()=>Uc,content_0_412:()=>Oc,content_0_414:()=>qc,content_0_416:()=>Hc,content_0_418:()=>Yc,content_0_42:()=>Y,content_0_420:()=>Kc,content_0_422:()=>ts,content_0_424:()=>es,content_0_426:()=>ps,content_0_428:()=>cs,content_0_430:()=>as,content_0_432:()=>ls,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ys,content_0_44:()=>K,content_0_440:()=>ws,content_0_442:()=>Ms,content_0_444:()=>Xs,content_0_446:()=>xs,content_0_448:()=>Ts,content_0_450:()=>vs,content_0_452:()=>bs,content_0_454:()=>Es,content_0_456:()=>Ss,content_0_458:()=>zs,content_0_46:()=>tt,content_0_460:()=>Ps,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>Os,content_0_468:()=>qs,content_0_470:()=>Hs,content_0_472:()=>Ys,content_0_474:()=>Ks,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ca,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ya,content_0_494:()=>wa,content_0_496:()=>Ma,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ta,content_0_504:()=>va,content_0_506:()=>ba,content_0_508:()=>Ea,content_0_510:()=>Sa,content_0_512:()=>za,content_0_514:()=>Pa,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>ct,content_0_520:()=>Oa,content_0_522:()=>qa,content_0_524:()=>Ha,content_0_526:()=>Ya,content_0_528:()=>Ka,content_0_530:()=>ti,content_0_532:()=>ei,content_0_534:()=>pi,content_0_536:()=>ci,content_0_538:()=>ai,content_0_54:()=>at,content_0_540:()=>li,content_0_542:()=>mi,content_0_544:()=>hi,content_0_546:()=>yi,content_0_548:()=>wi,content_0_550:()=>Mi,content_0_552:()=>Xi,content_0_554:()=>xi,content_0_556:()=>Ti,content_0_558:()=>vi,content_0_56:()=>lt,content_0_560:()=>bi,content_0_562:()=>Ei,content_0_564:()=>Si,content_0_566:()=>zi,content_0_568:()=>Pi,content_0_570:()=>Gi,content_0_572:()=>Ui,content_0_574:()=>Oi,content_0_576:()=>qi,content_0_578:()=>Hi,content_0_58:()=>mt,content_0_580:()=>Yi,content_0_582:()=>Ki,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>cl,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>vl,content_0_614:()=>bl,content_0_616:()=>El,content_0_618:()=>Sl,content_0_62:()=>yt,content_0_620:()=>zl,content_0_622:()=>Pl,content_0_624:()=>Gl,content_0_626:()=>Ul,content_0_628:()=>Ol,content_0_630:()=>ql,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>cu,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>vu,content_0_668:()=>bu,content_0_670:()=>Eu,content_0_672:()=>Su,content_0_674:()=>zu,content_0_676:()=>Pu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Uu,content_0_682:()=>Ou,content_0_684:()=>qu,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>cm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>vm,content_0_722:()=>bm,content_0_724:()=>Em,content_0_726:()=>Sm,content_0_728:()=>zm,content_0_730:()=>Pm,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>Om,content_0_738:()=>qm,content_0_74:()=>vt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>cd,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>vd,content_0_776:()=>bd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Sd,content_0_782:()=>zd,content_0_784:()=>Pd,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>Od,content_0_792:()=>qd,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>y,content_0_80:()=>St,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>ch,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>wh,content_0_82:()=>zt,content_0_820:()=>Mh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>vh,content_0_830:()=>bh,content_0_832:()=>Eh,content_0_834:()=>Sh,content_0_836:()=>zh,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>Oh,content_0_846:()=>qh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Gt,content_0_860:()=>ck,content_0_862:()=>ak,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>wk,content_0_874:()=>Mk,content_0_876:()=>Xk,content_0_878:()=>xk,content_0_88:()=>Ut,content_0_880:()=>Tk,content_0_882:()=>vk,content_0_884:()=>bk,content_0_886:()=>Ek,content_0_888:()=>Sk,content_0_890:()=>zk,content_0_892:()=>Pk,content_0_894:()=>Gk,content_0_896:()=>Uk,content_0_898:()=>Ok,content_0_90:()=>Ot,content_0_900:()=>qk,content_0_902:()=>Hk,content_0_904:()=>Yk,content_0_906:()=>Kk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>cy,content_0_916:()=>ay,content_0_918:()=>ly,content_0_92:()=>qt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>wy,content_0_928:()=>My,content_0_930:()=>Xy,content_0_932:()=>xy,content_0_934:()=>Ty,content_0_936:()=>vy,content_0_938:()=>by,content_0_94:()=>Ht,content_0_96:()=>Yt,content_0_98:()=>Kt,content_2149_0:()=>Ey,content_2149_10:()=>Uy,content_2149_100:()=>Cw,content_2149_1000:()=>sR,content_2149_1002:()=>iR,content_2149_1004:()=>uR,content_2149_1006:()=>dR,content_2149_1008:()=>kR,content_2149_1010:()=>fR,content_2149_1012:()=>DR,content_2149_1014:()=>_R,content_2149_1016:()=>gR,content_2149_1018:()=>CR,content_2149_102:()=>Lw,content_2149_1020:()=>LR,content_2149_1022:()=>ZR,content_2149_1024:()=>NR,content_2149_1026:()=>AR,content_2149_1028:()=>RR,content_2149_1030:()=>IR,content_2149_1032:()=>WR,content_2149_1034:()=>FR,content_2149_1036:()=>jR,content_2149_1038:()=>VR,content_2149_104:()=>Zw,content_2149_1040:()=>BR,content_2149_1042:()=>$R,content_2149_1044:()=>JR,content_2149_1046:()=>QR,content_2149_1048:()=>nz,content_2149_1050:()=>oz,content_2149_1052:()=>rz,content_2149_1054:()=>sz,content_2149_1056:()=>iz,content_2149_1058:()=>uz,content_2149_106:()=>Nw,content_2149_1060:()=>dz,content_2149_1062:()=>kz,content_2149_1064:()=>fz,content_2149_1066:()=>Dz,content_2149_1068:()=>_z,content_2149_1070:()=>gz,content_2149_1072:()=>Cz,content_2149_1074:()=>Lz,content_2149_1076:()=>Zz,content_2149_1078:()=>Nz,content_2149_108:()=>Aw,content_2149_1080:()=>Az,content_2149_1082:()=>Rz,content_2149_1084:()=>Iz,content_2149_1086:()=>Wz,content_2149_1088:()=>Fz,content_2149_1090:()=>jz,content_2149_1092:()=>Vz,content_2149_1094:()=>Bz,content_2149_1096:()=>$z,content_2149_1098:()=>Jz,content_2149_110:()=>Rw,content_2149_1100:()=>Qz,content_2149_1102:()=>nI,content_2149_1104:()=>oI,content_2149_1106:()=>rI,content_2149_1108:()=>sI,content_2149_1110:()=>iI,content_2149_1112:()=>uI,content_2149_1114:()=>dI,content_2149_1116:()=>kI,content_2149_1118:()=>fI,content_2149_112:()=>Iw,content_2149_1120:()=>DI,content_2149_1122:()=>_I,content_2149_1124:()=>gI,content_2149_1126:()=>CI,content_2149_1128:()=>LI,content_2149_1130:()=>ZI,content_2149_1132:()=>NI,content_2149_1134:()=>AI,content_2149_1136:()=>RI,content_2149_1138:()=>II,content_2149_114:()=>Ww,content_2149_1140:()=>WI,content_2149_1142:()=>FI,content_2149_1144:()=>jI,content_2149_1146:()=>VI,content_2149_1148:()=>BI,content_2149_1150:()=>$I,content_2149_1152:()=>JI,content_2149_1154:()=>QI,content_2149_1156:()=>nP,content_2149_1158:()=>oP,content_2149_116:()=>Fw,content_2149_1160:()=>rP,content_2149_1162:()=>sP,content_2149_1164:()=>iP,content_2149_1166:()=>uP,content_2149_1168:()=>dP,content_2149_1170:()=>kP,content_2149_1172:()=>fP,content_2149_1174:()=>DP,content_2149_1176:()=>_P,content_2149_1178:()=>gP,content_2149_118:()=>jw,content_2149_1180:()=>CP,content_2149_1182:()=>LP,content_2149_1184:()=>ZP,content_2149_1186:()=>NP,content_2149_1188:()=>AP,content_2149_1190:()=>RP,content_2149_1192:()=>IP,content_2149_1194:()=>WP,content_2149_1196:()=>FP,content_2149_1198:()=>jP,content_2149_12:()=>Oy,content_2149_120:()=>Vw,content_2149_1200:()=>VP,content_2149_1202:()=>BP,content_2149_1204:()=>$P,content_2149_1206:()=>JP,content_2149_1208:()=>QP,content_2149_1210:()=>nW,content_2149_1212:()=>oW,content_2149_1214:()=>rW,content_2149_1216:()=>sW,content_2149_1218:()=>iW,content_2149_122:()=>Bw,content_2149_1220:()=>uW,content_2149_1222:()=>dW,content_2149_1224:()=>kW,content_2149_1226:()=>fW,content_2149_1228:()=>DW,content_2149_1230:()=>_W,content_2149_1232:()=>gW,content_2149_1234:()=>CW,content_2149_1236:()=>LW,content_2149_1238:()=>ZW,content_2149_124:()=>$w,content_2149_1240:()=>NW,content_2149_1242:()=>AW,content_2149_1244:()=>RW,content_2149_1246:()=>IW,content_2149_1248:()=>WW,content_2149_1250:()=>FW,content_2149_1252:()=>jW,content_2149_1254:()=>VW,content_2149_1256:()=>BW,content_2149_1258:()=>$W,content_2149_126:()=>Jw,content_2149_1260:()=>JW,content_2149_1262:()=>QW,content_2149_1264:()=>nG,content_2149_1266:()=>oG,content_2149_1268:()=>rG,content_2149_1270:()=>sG,content_2149_1272:()=>iG,content_2149_1274:()=>uG,content_2149_1276:()=>dG,content_2149_1278:()=>kG,content_2149_128:()=>Qw,content_2149_1280:()=>fG,content_2149_1282:()=>DG,content_2149_1284:()=>_G,content_2149_1286:()=>gG,content_2149_1288:()=>CG,content_2149_1290:()=>LG,content_2149_1292:()=>ZG,content_2149_1294:()=>NG,content_2149_1296:()=>AG,content_2149_1298:()=>RG,content_2149_130:()=>nD,content_2149_1300:()=>IG,content_2149_1302:()=>WG,content_2149_1304:()=>FG,content_2149_1306:()=>jG,content_2149_1308:()=>VG,content_2149_1310:()=>BG,content_2149_1312:()=>$G,content_2149_1314:()=>JG,content_2149_1316:()=>QG,content_2149_1318:()=>nF,content_2149_132:()=>oD,content_2149_1320:()=>oF,content_2149_1322:()=>rF,content_2149_1324:()=>sF,content_2149_1326:()=>iF,content_2149_1328:()=>uF,content_2149_1330:()=>dF,content_2149_1332:()=>kF,content_2149_1334:()=>fF,content_2149_1336:()=>DF,content_2149_1338:()=>_F,content_2149_134:()=>rD,content_2149_1340:()=>gF,content_2149_1342:()=>CF,content_2149_1344:()=>LF,content_2149_1346:()=>ZF,content_2149_1348:()=>NF,content_2149_1350:()=>AF,content_2149_1352:()=>RF,content_2149_1354:()=>IF,content_2149_1356:()=>WF,content_2149_1358:()=>FF,content_2149_136:()=>sD,content_2149_1360:()=>jF,content_2149_1362:()=>VF,content_2149_1364:()=>BF,content_2149_1366:()=>$F,content_2149_1368:()=>JF,content_2149_1370:()=>QF,content_2149_1372:()=>nU,content_2149_1374:()=>oU,content_2149_1376:()=>rU,content_2149_1378:()=>sU,content_2149_138:()=>iD,content_2149_1380:()=>iU,content_2149_1382:()=>uU,content_2149_1384:()=>dU,content_2149_1386:()=>kU,content_2149_1388:()=>fU,content_2149_1390:()=>DU,content_2149_1392:()=>_U,content_2149_1394:()=>gU,content_2149_1396:()=>CU,content_2149_1398:()=>LU,content_2149_14:()=>qy,content_2149_140:()=>uD,content_2149_1400:()=>ZU,content_2149_1402:()=>NU,content_2149_1404:()=>AU,content_2149_1406:()=>RU,content_2149_1408:()=>IU,content_2149_1410:()=>WU,content_2149_1412:()=>FU,content_2149_1414:()=>jU,content_2149_1416:()=>VU,content_2149_1418:()=>BU,content_2149_142:()=>dD,content_2149_1420:()=>$U,content_2149_1422:()=>JU,content_2149_1424:()=>QU,content_2149_1426:()=>nj,content_2149_1428:()=>oj,content_2149_1430:()=>rj,content_2149_1432:()=>sj,content_2149_1434:()=>ij,content_2149_1436:()=>uj,content_2149_1438:()=>dj,content_2149_144:()=>kD,content_2149_1440:()=>kj,content_2149_1442:()=>fj,content_2149_1444:()=>Dj,content_2149_1446:()=>_j,content_2149_1448:()=>gj,content_2149_1450:()=>Cj,content_2149_1452:()=>Lj,content_2149_1454:()=>Zj,content_2149_1456:()=>Nj,content_2149_1458:()=>Aj,content_2149_146:()=>fD,content_2149_1460:()=>Rj,content_2149_1462:()=>Ij,content_2149_1464:()=>Wj,content_2149_1466:()=>Fj,content_2149_1468:()=>jj,content_2149_1470:()=>Vj,content_2149_1472:()=>Bj,content_2149_1474:()=>$j,content_2149_1476:()=>Jj,content_2149_1478:()=>Qj,content_2149_148:()=>DD,content_2149_1480:()=>nO,content_2149_1482:()=>oO,content_2149_1484:()=>rO,content_2149_1486:()=>sO,content_2149_1488:()=>iO,content_2149_1490:()=>uO,content_2149_1492:()=>dO,content_2149_1494:()=>kO,content_2149_1496:()=>fO,content_2149_1498:()=>DO,content_2149_150:()=>_D,content_2149_1500:()=>_O,content_2149_1502:()=>gO,content_2149_1504:()=>CO,content_2149_1506:()=>LO,content_2149_1508:()=>ZO,content_2149_1510:()=>NO,content_2149_1512:()=>AO,content_2149_1514:()=>RO,content_2149_1516:()=>IO,content_2149_1518:()=>WO,content_2149_152:()=>gD,content_2149_1520:()=>FO,content_2149_1522:()=>jO,content_2149_1524:()=>VO,content_2149_1526:()=>BO,content_2149_1528:()=>$O,content_2149_1530:()=>JO,content_2149_1532:()=>QO,content_2149_1534:()=>nV,content_2149_1536:()=>oV,content_2149_1538:()=>rV,content_2149_154:()=>CD,content_2149_1540:()=>sV,content_2149_1542:()=>iV,content_2149_1544:()=>uV,content_2149_1546:()=>dV,content_2149_1548:()=>kV,content_2149_1550:()=>fV,content_2149_1552:()=>DV,content_2149_1554:()=>_V,content_2149_1556:()=>gV,content_2149_1558:()=>CV,content_2149_156:()=>LD,content_2149_1560:()=>LV,content_2149_1562:()=>ZV,content_2149_1564:()=>NV,content_2149_1566:()=>AV,content_2149_1568:()=>RV,content_2149_1570:()=>IV,content_2149_1572:()=>WV,content_2149_1574:()=>FV,content_2149_1576:()=>jV,content_2149_1578:()=>VV,content_2149_158:()=>ZD,content_2149_1580:()=>BV,content_2149_1582:()=>$V,content_2149_1584:()=>JV,content_2149_1586:()=>QV,content_2149_1588:()=>nq,content_2149_1590:()=>oq,content_2149_1592:()=>rq,content_2149_1594:()=>sq,content_2149_1596:()=>iq,content_2149_1598:()=>uq,content_2149_16:()=>Hy,content_2149_160:()=>ND,content_2149_1600:()=>dq,content_2149_1602:()=>kq,content_2149_1604:()=>fq,content_2149_1606:()=>Dq,content_2149_1608:()=>_q,content_2149_1610:()=>gq,content_2149_1612:()=>Cq,content_2149_1614:()=>Lq,content_2149_1616:()=>Zq,content_2149_1618:()=>Nq,content_2149_162:()=>AD,content_2149_1620:()=>Aq,content_2149_1622:()=>Rq,content_2149_1624:()=>Iq,content_2149_1626:()=>Wq,content_2149_1628:()=>Fq,content_2149_1630:()=>jq,content_2149_1632:()=>Vq,content_2149_1634:()=>Bq,content_2149_1636:()=>$q,content_2149_1638:()=>Jq,content_2149_164:()=>RD,content_2149_1640:()=>Qq,content_2149_1642:()=>nB,content_2149_1644:()=>oB,content_2149_1646:()=>rB,content_2149_1648:()=>sB,content_2149_1650:()=>iB,content_2149_1652:()=>uB,content_2149_1654:()=>dB,content_2149_1656:()=>kB,content_2149_1658:()=>fB,content_2149_166:()=>ID,content_2149_1660:()=>DB,content_2149_1662:()=>_B,content_2149_1664:()=>gB,content_2149_1666:()=>CB,content_2149_1668:()=>LB,content_2149_1670:()=>ZB,content_2149_1672:()=>NB,content_2149_1674:()=>AB,content_2149_1676:()=>RB,content_2149_1678:()=>IB,content_2149_168:()=>WD,content_2149_1680:()=>WB,content_2149_1682:()=>FB,content_2149_1684:()=>jB,content_2149_1686:()=>VB,content_2149_1688:()=>BB,content_2149_1690:()=>$B,content_2149_1692:()=>JB,content_2149_1694:()=>QB,content_2149_1696:()=>nH,content_2149_1698:()=>oH,content_2149_170:()=>FD,content_2149_1700:()=>rH,content_2149_1702:()=>sH,content_2149_1704:()=>iH,content_2149_1706:()=>uH,content_2149_1708:()=>dH,content_2149_1710:()=>kH,content_2149_1712:()=>fH,content_2149_1714:()=>DH,content_2149_1716:()=>_H,content_2149_1718:()=>gH,content_2149_172:()=>jD,content_2149_1720:()=>CH,content_2149_1722:()=>LH,content_2149_1724:()=>ZH,content_2149_1726:()=>NH,content_2149_1728:()=>AH,content_2149_1730:()=>RH,content_2149_1732:()=>IH,content_2149_1734:()=>WH,content_2149_1736:()=>FH,content_2149_1738:()=>jH,content_2149_174:()=>VD,content_2149_1740:()=>VH,content_2149_1742:()=>BH,content_2149_1744:()=>$H,content_2149_1746:()=>JH,content_2149_1748:()=>QH,content_2149_1750:()=>n$,content_2149_1752:()=>o$,content_2149_1754:()=>r$,content_2149_1756:()=>s$,content_2149_1758:()=>i$,content_2149_176:()=>BD,content_2149_1760:()=>u$,content_2149_1762:()=>d$,content_2149_1764:()=>k$,content_2149_1766:()=>f$,content_2149_1768:()=>D$,content_2149_1770:()=>_$,content_2149_1772:()=>g$,content_2149_1774:()=>C$,content_2149_1776:()=>L$,content_2149_1778:()=>Z$,content_2149_178:()=>$D,content_2149_1780:()=>N$,content_2149_1782:()=>A$,content_2149_1784:()=>R$,content_2149_1786:()=>I$,content_2149_1788:()=>W$,content_2149_1790:()=>F$,content_2149_1792:()=>j$,content_2149_1794:()=>V$,content_2149_1796:()=>B$,content_2149_1798:()=>$$,content_2149_18:()=>Yy,content_2149_180:()=>JD,content_2149_1800:()=>J$,content_2149_1802:()=>Q$,content_2149_1804:()=>nY,content_2149_1806:()=>oY,content_2149_1808:()=>rY,content_2149_1810:()=>sY,content_2149_1812:()=>iY,content_2149_1814:()=>uY,content_2149_1816:()=>dY,content_2149_1818:()=>kY,content_2149_182:()=>QD,content_2149_1820:()=>fY,content_2149_1822:()=>DY,content_2149_1824:()=>_Y,content_2149_1826:()=>gY,content_2149_1828:()=>CY,content_2149_1830:()=>LY,content_2149_1832:()=>ZY,content_2149_1834:()=>NY,content_2149_1836:()=>AY,content_2149_1838:()=>RY,content_2149_184:()=>nM,content_2149_1840:()=>IY,content_2149_1842:()=>WY,content_2149_1844:()=>FY,content_2149_1846:()=>jY,content_2149_1848:()=>VY,content_2149_1850:()=>BY,content_2149_1852:()=>$Y,content_2149_1854:()=>JY,content_2149_1856:()=>QY,content_2149_1858:()=>nJ,content_2149_186:()=>oM,content_2149_1860:()=>oJ,content_2149_1862:()=>rJ,content_2149_1864:()=>sJ,content_2149_1866:()=>iJ,content_2149_1868:()=>uJ,content_2149_1870:()=>dJ,content_2149_1872:()=>kJ,content_2149_1874:()=>fJ,content_2149_1876:()=>DJ,content_2149_1878:()=>_J,content_2149_188:()=>rM,content_2149_1880:()=>gJ,content_2149_1882:()=>CJ,content_2149_1884:()=>LJ,content_2149_1886:()=>ZJ,content_2149_1888:()=>NJ,content_2149_1890:()=>AJ,content_2149_1892:()=>RJ,content_2149_1894:()=>IJ,content_2149_1896:()=>WJ,content_2149_1898:()=>FJ,content_2149_190:()=>sM,content_2149_1900:()=>jJ,content_2149_1902:()=>VJ,content_2149_1904:()=>BJ,content_2149_1906:()=>$J,content_2149_1908:()=>JJ,content_2149_1910:()=>QJ,content_2149_1912:()=>nK,content_2149_1914:()=>oK,content_2149_1916:()=>rK,content_2149_1918:()=>sK,content_2149_192:()=>iM,content_2149_1920:()=>iK,content_2149_1922:()=>uK,content_2149_1924:()=>dK,content_2149_1926:()=>kK,content_2149_1928:()=>fK,content_2149_1930:()=>DK,content_2149_1932:()=>_K,content_2149_1934:()=>gK,content_2149_1936:()=>CK,content_2149_1938:()=>LK,content_2149_194:()=>uM,content_2149_1940:()=>ZK,content_2149_1942:()=>NK,content_2149_1944:()=>AK,content_2149_1946:()=>RK,content_2149_1948:()=>IK,content_2149_1950:()=>WK,content_2149_1952:()=>FK,content_2149_1954:()=>jK,content_2149_1956:()=>VK,content_2149_1958:()=>BK,content_2149_196:()=>dM,content_2149_1960:()=>$K,content_2149_1962:()=>JK,content_2149_1964:()=>QK,content_2149_1966:()=>nQ,content_2149_1968:()=>oQ,content_2149_1970:()=>rQ,content_2149_1972:()=>sQ,content_2149_1974:()=>iQ,content_2149_1976:()=>uQ,content_2149_1978:()=>dQ,content_2149_198:()=>kM,content_2149_1980:()=>kQ,content_2149_1982:()=>fQ,content_2149_1984:()=>DQ,content_2149_1986:()=>_Q,content_2149_1988:()=>gQ,content_2149_1990:()=>CQ,content_2149_1992:()=>LQ,content_2149_1994:()=>ZQ,content_2149_1996:()=>NQ,content_2149_1998:()=>AQ,content_2149_2:()=>Sy,content_2149_20:()=>Ky,content_2149_200:()=>fM,content_2149_2000:()=>RQ,content_2149_2002:()=>IQ,content_2149_2004:()=>WQ,content_2149_2006:()=>FQ,content_2149_2008:()=>jQ,content_2149_2010:()=>VQ,content_2149_2012:()=>BQ,content_2149_2014:()=>$Q,content_2149_2016:()=>JQ,content_2149_2018:()=>QQ,content_2149_202:()=>DM,content_2149_2020:()=>n0,content_2149_2022:()=>o0,content_2149_2024:()=>r0,content_2149_2026:()=>s0,content_2149_2028:()=>i0,content_2149_2030:()=>u0,content_2149_2032:()=>d0,content_2149_2034:()=>k0,content_2149_2036:()=>f0,content_2149_2038:()=>D0,content_2149_204:()=>_M,content_2149_2040:()=>_0,content_2149_2042:()=>g0,content_2149_2044:()=>C0,content_2149_2046:()=>L0,content_2149_2048:()=>Z0,content_2149_2050:()=>N0,content_2149_2052:()=>A0,content_2149_2054:()=>R0,content_2149_2056:()=>I0,content_2149_2058:()=>W0,content_2149_206:()=>gM,content_2149_2060:()=>F0,content_2149_2062:()=>j0,content_2149_2064:()=>V0,content_2149_2066:()=>B0,content_2149_2068:()=>$0,content_2149_2070:()=>J0,content_2149_2072:()=>Q0,content_2149_2074:()=>n1,content_2149_2076:()=>o1,content_2149_2078:()=>r1,content_2149_208:()=>CM,content_2149_2080:()=>s1,content_2149_2082:()=>i1,content_2149_2084:()=>u1,content_2149_2086:()=>d1,content_2149_2088:()=>k1,content_2149_2090:()=>f1,content_2149_2092:()=>D1,content_2149_2094:()=>_1,content_2149_2096:()=>g1,content_2149_2098:()=>C1,content_2149_210:()=>LM,content_2149_2100:()=>L1,content_2149_2102:()=>Z1,content_2149_2104:()=>N1,content_2149_2106:()=>A1,content_2149_2108:()=>R1,content_2149_2110:()=>I1,content_2149_2112:()=>W1,content_2149_2114:()=>F1,content_2149_2116:()=>j1,content_2149_2118:()=>V1,content_2149_212:()=>ZM,content_2149_2120:()=>B1,content_2149_2122:()=>$1,content_2149_2124:()=>J1,content_2149_2126:()=>Q1,content_2149_2128:()=>n2,content_2149_2130:()=>o2,content_2149_2132:()=>r2,content_2149_2134:()=>s2,content_2149_2136:()=>i2,content_2149_2138:()=>u2,content_2149_214:()=>NM,content_2149_2140:()=>d2,content_2149_2142:()=>k2,content_2149_2144:()=>f2,content_2149_2146:()=>D2,content_2149_2148:()=>_2,content_2149_2150:()=>g2,content_2149_2152:()=>C2,content_2149_2154:()=>L2,content_2149_2156:()=>Z2,content_2149_2158:()=>N2,content_2149_216:()=>AM,content_2149_2160:()=>A2,content_2149_2162:()=>R2,content_2149_2164:()=>I2,content_2149_2166:()=>W2,content_2149_2168:()=>F2,content_2149_2170:()=>j2,content_2149_2172:()=>V2,content_2149_2174:()=>B2,content_2149_2176:()=>$2,content_2149_2178:()=>J2,content_2149_218:()=>RM,content_2149_2180:()=>Q2,content_2149_2182:()=>n4,content_2149_2184:()=>o4,content_2149_2186:()=>r4,content_2149_2188:()=>s4,content_2149_2190:()=>i4,content_2149_2192:()=>u4,content_2149_2194:()=>d4,content_2149_22:()=>tf,content_2149_220:()=>IM,content_2149_222:()=>WM,content_2149_224:()=>FM,content_2149_226:()=>jM,content_2149_228:()=>VM,content_2149_230:()=>BM,content_2149_232:()=>$M,content_2149_234:()=>JM,content_2149_236:()=>QM,content_2149_238:()=>n_,content_2149_24:()=>ef,content_2149_240:()=>o_,content_2149_242:()=>r_,content_2149_244:()=>s_,content_2149_246:()=>i_,content_2149_248:()=>u_,content_2149_250:()=>d_,content_2149_252:()=>k_,content_2149_254:()=>f_,content_2149_256:()=>D_,content_2149_258:()=>__,content_2149_26:()=>pf,content_2149_260:()=>g_,content_2149_262:()=>C_,content_2149_264:()=>L_,content_2149_266:()=>Z_,content_2149_268:()=>N_,content_2149_270:()=>A_,content_2149_272:()=>R_,content_2149_274:()=>I_,content_2149_276:()=>W_,content_2149_278:()=>F_,content_2149_28:()=>cf,content_2149_280:()=>j_,content_2149_282:()=>V_,content_2149_284:()=>B_,content_2149_286:()=>$_,content_2149_288:()=>J_,content_2149_290:()=>Q_,content_2149_292:()=>nX,content_2149_294:()=>oX,content_2149_296:()=>rX,content_2149_298:()=>sX,content_2149_30:()=>af,content_2149_300:()=>iX,content_2149_302:()=>uX,content_2149_304:()=>dX,content_2149_306:()=>kX,content_2149_308:()=>fX,content_2149_310:()=>DX,content_2149_312:()=>_X,content_2149_314:()=>gX,content_2149_316:()=>CX,content_2149_318:()=>LX,content_2149_32:()=>uf,content_2149_320:()=>ZX,content_2149_322:()=>NX,content_2149_324:()=>AX,content_2149_326:()=>RX,content_2149_328:()=>IX,content_2149_330:()=>WX,content_2149_332:()=>FX,content_2149_334:()=>jX,content_2149_336:()=>VX,content_2149_338:()=>BX,content_2149_34:()=>df,content_2149_340:()=>$X,content_2149_342:()=>JX,content_2149_344:()=>QX,content_2149_346:()=>ng,content_2149_348:()=>og,content_2149_350:()=>rg,content_2149_352:()=>sg,content_2149_354:()=>ig,content_2149_356:()=>ug,content_2149_358:()=>dg,content_2149_36:()=>kf,content_2149_360:()=>kg,content_2149_362:()=>fg,content_2149_364:()=>Dg,content_2149_366:()=>_g,content_2149_368:()=>gg,content_2149_370:()=>Cg,content_2149_372:()=>Lg,content_2149_374:()=>Zg,content_2149_376:()=>Ng,content_2149_378:()=>Ag,content_2149_38:()=>ff,content_2149_380:()=>Rg,content_2149_382:()=>Ig,content_2149_384:()=>Wg,content_2149_386:()=>Fg,content_2149_388:()=>jg,content_2149_390:()=>Vg,content_2149_392:()=>Bg,content_2149_394:()=>$g,content_2149_396:()=>Jg,content_2149_398:()=>Qg,content_2149_4:()=>zy,content_2149_40:()=>Df,content_2149_400:()=>nx,content_2149_402:()=>ox,content_2149_404:()=>rx,content_2149_406:()=>sx,content_2149_408:()=>ix,content_2149_410:()=>ux,content_2149_412:()=>dx,content_2149_414:()=>kx,content_2149_416:()=>fx,content_2149_418:()=>Dx,content_2149_42:()=>_f,content_2149_420:()=>_x,content_2149_422:()=>gx,content_2149_424:()=>Cx,content_2149_426:()=>Lx,content_2149_428:()=>Zx,content_2149_430:()=>Nx,content_2149_432:()=>Ax,content_2149_434:()=>Rx,content_2149_436:()=>Ix,content_2149_438:()=>Wx,content_2149_44:()=>gf,content_2149_440:()=>Fx,content_2149_442:()=>jx,content_2149_444:()=>Vx,content_2149_446:()=>Bx,content_2149_448:()=>$x,content_2149_450:()=>Jx,content_2149_452:()=>Qx,content_2149_454:()=>nC,content_2149_456:()=>oC,content_2149_458:()=>rC,content_2149_46:()=>Cf,content_2149_460:()=>sC,content_2149_462:()=>iC,content_2149_464:()=>uC,content_2149_466:()=>dC,content_2149_468:()=>kC,content_2149_470:()=>fC,content_2149_472:()=>DC,content_2149_474:()=>_C,content_2149_476:()=>gC,content_2149_478:()=>CC,content_2149_48:()=>Lf,content_2149_480:()=>LC,content_2149_482:()=>ZC,content_2149_484:()=>NC,content_2149_486:()=>AC,content_2149_488:()=>RC,content_2149_490:()=>IC,content_2149_492:()=>WC,content_2149_494:()=>FC,content_2149_496:()=>jC,content_2149_498:()=>VC,content_2149_50:()=>Zf,content_2149_500:()=>BC,content_2149_502:()=>$C,content_2149_504:()=>JC,content_2149_506:()=>QC,content_2149_508:()=>nT,content_2149_510:()=>oT,content_2149_512:()=>rT,content_2149_514:()=>sT,content_2149_516:()=>iT,content_2149_518:()=>uT,content_2149_52:()=>Nf,content_2149_520:()=>dT,content_2149_522:()=>kT,content_2149_524:()=>fT,content_2149_526:()=>DT,content_2149_528:()=>_T,content_2149_530:()=>gT,content_2149_532:()=>CT,content_2149_534:()=>LT,content_2149_536:()=>ZT,content_2149_538:()=>NT,content_2149_54:()=>Af,content_2149_540:()=>AT,content_2149_542:()=>RT,content_2149_544:()=>IT,content_2149_546:()=>WT,content_2149_548:()=>FT,content_2149_550:()=>jT,content_2149_552:()=>VT,content_2149_554:()=>BT,content_2149_556:()=>$T,content_2149_558:()=>JT,content_2149_56:()=>Rf,content_2149_560:()=>QT,content_2149_562:()=>nL,content_2149_564:()=>oL,content_2149_566:()=>rL,content_2149_568:()=>sL,content_2149_570:()=>iL,content_2149_572:()=>uL,content_2149_574:()=>dL,content_2149_576:()=>kL,content_2149_578:()=>fL,content_2149_58:()=>If,content_2149_580:()=>DL,content_2149_582:()=>_L,content_2149_584:()=>gL,content_2149_586:()=>CL,content_2149_588:()=>LL,content_2149_590:()=>ZL,content_2149_592:()=>NL,content_2149_594:()=>AL,content_2149_596:()=>RL,content_2149_598:()=>IL,content_2149_6:()=>Py,content_2149_60:()=>Wf,content_2149_600:()=>WL,content_2149_602:()=>FL,content_2149_604:()=>jL,content_2149_606:()=>VL,content_2149_608:()=>BL,content_2149_610:()=>$L,content_2149_612:()=>JL,content_2149_614:()=>QL,content_2149_616:()=>nv,content_2149_618:()=>ov,content_2149_62:()=>Ff,content_2149_620:()=>rv,content_2149_622:()=>sv,content_2149_624:()=>iv,content_2149_626:()=>uv,content_2149_628:()=>dv,content_2149_630:()=>kv,content_2149_632:()=>fv,content_2149_634:()=>Dv,content_2149_636:()=>_v,content_2149_638:()=>gv,content_2149_64:()=>jf,content_2149_640:()=>Cv,content_2149_642:()=>Lv,content_2149_644:()=>Zv,content_2149_646:()=>Nv,content_2149_648:()=>Av,content_2149_650:()=>Rv,content_2149_652:()=>Iv,content_2149_654:()=>Wv,content_2149_656:()=>Fv,content_2149_658:()=>jv,content_2149_66:()=>Vf,content_2149_660:()=>Vv,content_2149_662:()=>Bv,content_2149_664:()=>$v,content_2149_666:()=>Jv,content_2149_668:()=>Qv,content_2149_670:()=>nZ,content_2149_672:()=>oZ,content_2149_674:()=>rZ,content_2149_676:()=>sZ,content_2149_678:()=>iZ,content_2149_68:()=>Bf,content_2149_680:()=>uZ,content_2149_682:()=>dZ,content_2149_684:()=>kZ,content_2149_686:()=>fZ,content_2149_688:()=>DZ,content_2149_690:()=>_Z,content_2149_692:()=>gZ,content_2149_694:()=>CZ,content_2149_696:()=>LZ,content_2149_698:()=>ZZ,content_2149_70:()=>$f,content_2149_700:()=>NZ,content_2149_702:()=>AZ,content_2149_704:()=>RZ,content_2149_706:()=>IZ,content_2149_708:()=>WZ,content_2149_710:()=>FZ,content_2149_712:()=>jZ,content_2149_714:()=>VZ,content_2149_716:()=>BZ,content_2149_718:()=>$Z,content_2149_72:()=>Jf,content_2149_720:()=>JZ,content_2149_722:()=>QZ,content_2149_724:()=>nb,content_2149_726:()=>ob,content_2149_728:()=>rb,content_2149_730:()=>sb,content_2149_732:()=>ib,content_2149_734:()=>ub,content_2149_736:()=>db,content_2149_738:()=>kb,content_2149_74:()=>Qf,content_2149_740:()=>fb,content_2149_742:()=>Db,content_2149_744:()=>_b,content_2149_746:()=>gb,content_2149_748:()=>Cb,content_2149_750:()=>Lb,content_2149_752:()=>Zb,content_2149_754:()=>Nb,content_2149_756:()=>Ab,content_2149_758:()=>Rb,content_2149_76:()=>nw,content_2149_760:()=>Ib,content_2149_762:()=>Wb,content_2149_764:()=>Fb,content_2149_766:()=>jb,content_2149_768:()=>Vb,content_2149_770:()=>Bb,content_2149_772:()=>$b,content_2149_774:()=>Jb,content_2149_776:()=>Qb,content_2149_778:()=>nN,content_2149_78:()=>ow,content_2149_780:()=>oN,content_2149_782:()=>rN,content_2149_784:()=>sN,content_2149_786:()=>iN,content_2149_788:()=>uN,content_2149_790:()=>dN,content_2149_792:()=>kN,content_2149_794:()=>fN,content_2149_796:()=>DN,content_2149_798:()=>_N,content_2149_8:()=>Gy,content_2149_80:()=>rw,content_2149_800:()=>gN,content_2149_802:()=>CN,content_2149_804:()=>LN,content_2149_806:()=>ZN,content_2149_808:()=>NN,content_2149_810:()=>AN,content_2149_812:()=>RN,content_2149_814:()=>IN,content_2149_816:()=>WN,content_2149_818:()=>FN,content_2149_82:()=>sw,content_2149_820:()=>jN,content_2149_822:()=>VN,content_2149_824:()=>BN,content_2149_826:()=>$N,content_2149_828:()=>JN,content_2149_830:()=>QN,content_2149_832:()=>nE,content_2149_834:()=>oE,content_2149_836:()=>rE,content_2149_838:()=>sE,content_2149_84:()=>iw,content_2149_840:()=>iE,content_2149_842:()=>uE,content_2149_844:()=>dE,content_2149_846:()=>kE,content_2149_848:()=>fE,content_2149_850:()=>DE,content_2149_852:()=>_E,content_2149_854:()=>gE,content_2149_856:()=>CE,content_2149_858:()=>LE,content_2149_86:()=>uw,content_2149_860:()=>ZE,content_2149_862:()=>NE,content_2149_864:()=>AE,content_2149_866:()=>RE,content_2149_868:()=>IE,content_2149_870:()=>WE,content_2149_872:()=>FE,content_2149_874:()=>jE,content_2149_876:()=>VE,content_2149_878:()=>BE,content_2149_88:()=>dw,content_2149_880:()=>$E,content_2149_882:()=>JE,content_2149_884:()=>QE,content_2149_886:()=>nA,content_2149_888:()=>oA,content_2149_890:()=>rA,content_2149_892:()=>sA,content_2149_894:()=>iA,content_2149_896:()=>uA,content_2149_898:()=>dA,content_2149_90:()=>kw,content_2149_900:()=>kA,content_2149_902:()=>fA,content_2149_904:()=>DA,content_2149_906:()=>_A,content_2149_908:()=>gA,content_2149_910:()=>CA,content_2149_912:()=>LA,content_2149_914:()=>ZA,content_2149_916:()=>NA,content_2149_918:()=>AA,content_2149_92:()=>fw,content_2149_920:()=>RA,content_2149_922:()=>IA,content_2149_924:()=>WA,content_2149_926:()=>FA,content_2149_928:()=>jA,content_2149_930:()=>VA,content_2149_932:()=>BA,content_2149_934:()=>$A,content_2149_936:()=>JA,content_2149_938:()=>QA,content_2149_94:()=>Dw,content_2149_940:()=>nS,content_2149_942:()=>oS,content_2149_944:()=>rS,content_2149_946:()=>sS,content_2149_948:()=>iS,content_2149_950:()=>uS,content_2149_952:()=>dS,content_2149_954:()=>kS,content_2149_956:()=>fS,content_2149_958:()=>DS,content_2149_96:()=>_w,content_2149_960:()=>_S,content_2149_962:()=>gS,content_2149_964:()=>CS,content_2149_966:()=>LS,content_2149_968:()=>ZS,content_2149_970:()=>NS,content_2149_972:()=>AS,content_2149_974:()=>RS,content_2149_976:()=>IS,content_2149_978:()=>WS,content_2149_98:()=>gw,content_2149_980:()=>FS,content_2149_982:()=>jS,content_2149_984:()=>VS,content_2149_986:()=>BS,content_2149_988:()=>$S,content_2149_990:()=>JS,content_2149_992:()=>QS,content_2149_994:()=>nR,content_2149_996:()=>oR,content_2149_998:()=>rR});var p=e(2784),r=e(7896),c=e(876);const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscriptions and triggering of events."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,c.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches an asynchronous ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}y.isMDXComponent=!0;const f={toc:[]};function w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}w.isMDXComponent=!0;const D={toc:[]};function M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}M.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}T.isMDXComponent=!0;const L={toc:[]};function v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}v.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}b.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const R={toc:[]};function z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}z.isMDXComponent=!0;const I={toc:[]};function P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}P.isMDXComponent=!0;const W={toc:[]};function G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}O.isMDXComponent=!0;const V={toc:[]};function q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}q.isMDXComponent=!0;const B={toc:[]};function H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value argument to subscribers."))}H.isMDXComponent=!0;const $={toc:[]};function Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A base for dispatching ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,c.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const J={toc:[]};function K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}pt.isMDXComponent=!0;const rt={toc:[]};function ct(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}ct.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,c.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,c.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}yt.isMDXComponent=!0;const ft={toc:[]};function wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}wt.isMDXComponent=!0;const Dt={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}Mt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Are subscribers being notified?"))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Notify all current and future subscribers."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ct,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stop notifying future subscribers."))}Tt.isMDXComponent=!0;const Lt={toc:[]};function vt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}vt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}bt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function St(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const Rt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}zt.isMDXComponent=!0;const It={toc:[]};function Pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Pt.isMDXComponent=!0;const Wt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}Ot.isMDXComponent=!0;const Vt={toc:[]};function qt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}qt.isMDXComponent=!0;const Bt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Jt={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}pn.isMDXComponent=!0;const rn={toc:[]};function cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}cn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}fn.isMDXComponent=!0;const wn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Dn.isMDXComponent=!0;const Mn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Ln.isMDXComponent=!0;const vn={toc:[]};function Zn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value."))}An.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}Rn.isMDXComponent=!0;const zn={toc:[]};function In(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Setting the value will immediately notify all subscribers."))}In.isMDXComponent=!0;const Pn={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set the current value of this dispatcher."))}Wn.isMDXComponent=!0;const Gn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new value."))}Fn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const On={toc:[]};function Vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}Vn.isMDXComponent=!0;const qn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Yn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Jn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}re.isMDXComponent=!0;const ce={toc:[]};function se(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ce,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const we={toc:[]};function De(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}De.isMDXComponent=!0;const Me={toc:[]};function _e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of times the timer has ticked."))}ge.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator responsible for running this timer."))}Ce.isMDXComponent=!0;const Te={toc:[]};function Le(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the timer ticks."))}Le.isMDXComponent=!0;const ve={toc:[]};function Ze(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ve,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current iteration index."))}Ze.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ne.isMDXComponent=!0;const Ee={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ae.isMDXComponent=!0;const Se={toc:[]};function Re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Re.isMDXComponent=!0;const ze={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ie.isMDXComponent=!0;const Pe={toc:[]};function We(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}We.isMDXComponent=!0;const Ge={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const Oe={toc:[]};function Ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run tasks one after another."))}Ve.isMDXComponent=!0;const qe={toc:[]};function Be(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Be.isMDXComponent=!0;const He={toc:[]};function $e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}$e.isMDXComponent=!0;const Ye={toc:[]};function Je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Je.isMDXComponent=!0;const Ke={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay in seconds"))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task or callback to run after the delay."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const co={toc:[]};function so(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to be called."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator N times."))}yo.isMDXComponent=!0;const fo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The number of iterations."))}wo.isMDXComponent=!0;const Do={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Mo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Do nothing."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}To.isMDXComponent=!0;const Lo={toc:[]};function vo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}vo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}bo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function So(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ro={toc:[]};function zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}zo.isMDXComponent=!0;const Io={toc:[]};function Po(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Po.isMDXComponent=!0;const Wo={toc:[]};function Go(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay between each of the tasks."))}Oo.isMDXComponent=!0;const Vo={toc:[]};function qo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to be run in a sequence."))}qo.isMDXComponent=!0;const Bo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Ho.isMDXComponent=!0;const $o={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Jo={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The relative time in seconds."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}pp.isMDXComponent=!0;const rp={toc:[]};function cp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the given time event."))}cp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the time event."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Main Motion Canvas classes."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when a new message is logged."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the meta file of a given entity."))}yp.isMDXComponent=!0;const fp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when metadata changes."))}wp.isMDXComponent=!0;const Dp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Load new metadata from a file."))}Mp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New metadata."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any possible errors will be logged to the console."))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set data without waiting for confirmation."))}Tp.isMDXComponent=!0;const Lp={toc:[]};function vp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New data."))}vp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the data stored in the meta file."))}bp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,c.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}))}Sp.isMDXComponent=!0;const Rp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The project configuration."))}zp.isMDXComponent=!0;const Ip={toc:[]};function Pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the current scene changes."))}Pp.isMDXComponent=!0;const Wp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gp.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}Op.isMDXComponent=!0;const Vp={toc:[]};function qp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Multi-media management."))}qp.isMDXComponent=!0;const Bp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause/resume the audio."))}Yp.isMDXComponent=!0;const Jp={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the audio should be paused or resumed."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of samples taken."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}pr.isMDXComponent=!0;const rr={toc:[]};function cr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Samples per seconds."))}cr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Abstract scene representations and related utilities."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Signifies the various stages of a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}yr.isMDXComponent=!0;const fr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,c.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}wr.isMDXComponent=!0;const Dr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,c.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Mr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes the state of a scene."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished transitioning in."))}Tr.isMDXComponent=!0;const Lr={toc:[]};function vr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}vr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene is ready to transition out."))}br.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoking ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has just been created/reset."))}zr.isMDXComponent=!0;const Ir={toc:[]};function Pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The default implementation of the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,c.kt)("p",null,"Uses generators to control the animation."))}Pr.isMDXComponent=!0;const Wr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Or.isMDXComponent=!0;const Vr={toc:[]};function qr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}qr.isMDXComponent=!0;const Br={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Yr.isMDXComponent=!0;const Jr={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}pc.isMDXComponent=!0;const rc={toc:[]};function cc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}cc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yc.isMDXComponent=!0;const fc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}wc.isMDXComponent=!0;const Dc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}Mc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Tc.isMDXComponent=!0;const Lc={toc:[]};function vc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}vc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}zc.isMDXComponent=!0;const Ic={toc:[]};function Pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Pc.isMDXComponent=!0;const Wc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}Oc.isMDXComponent=!0;const Vc={toc:[]};function qc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Lifecycle events for ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}qc.isMDXComponent=!0;const Bc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A random number generator based on\n",(0,c.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,c.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random floats in the given range."))}Yc.isMDXComponent=!0;const Jc={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random integers in the given range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"}),(0,c.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const rs={toc:[]};function cs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}ys.isMDXComponent=!0;const fs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random integer in the given range."))}ws.isMDXComponent=!0;const Ds={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Ms.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a new independent generator."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Manages time events for a given scene."))}Ts.isMDXComponent=!0;const Ls={toc:[]};function vs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when time events change."))}vs.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the time offset of the given event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,c.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}zs.isMDXComponent=!0;const Is={toc:[]};function Ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get variable signal if exists or create signal if not"))}Ps.isMDXComponent=!0;const Ws={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the variable."))}Gs.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset all stored signals."))}Us.isMDXComponent=!0;const js={toc:[]};function Os(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update all signals with new project variable values."))}Os.isMDXComponent=!0;const Vs={toc:[]};function qs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes cached information about the timing of a scene."))}qs.isMDXComponent=!0;const Bs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a complete scene together with the meta file."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}Ys.isMDXComponent=!0;const Js={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}pa.isMDXComponent=!0;const ra={toc:[]};function ca(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}ca.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for the inspected element."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element for which to draw an overlay."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ya.isMDXComponent=!0;const fa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Return the attributes of the inspected element."))}wa.isMDXComponent=!0;const Da={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to inspect."))}Ma.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a possible element to inspect at a given position."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The x coordinate."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The y coordinate."))}Ta.isMDXComponent=!0;const La={toc:[]};function va(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}va.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Za,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the inspected element is still valid."))}ba.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to validate."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event stored in a meta file."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,c.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}za.isMDXComponent=!0;const Ia={toc:[]};function Pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main interface for scenes."))}Pa.isMDXComponent=!0;const Wa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ga.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ua.isMDXComponent=!0;const ja={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Oa.isMDXComponent=!0;const Va={toc:[]};function qa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene's ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,c.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}qa.isMDXComponent=!0;const Ba={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Ya.isMDXComponent=!0;const Ja={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}pi.isMDXComponent=!0;const ri={toc:[]};function ci(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}ci.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yi.isMDXComponent=!0;const fi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}wi.isMDXComponent=!0;const Di={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}Mi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ti.isMDXComponent=!0;const Li={toc:[]};function vi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}vi.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Si(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Si.isMDXComponent=!0;const Ri={toc:[]};function zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}zi.isMDXComponent=!0;const Ii={toc:[]};function Pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Pi.isMDXComponent=!0;const Wi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Ui.isMDXComponent=!0;const ji={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}Oi.isMDXComponent=!0;const Vi={toc:[]};function qi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each class implementing the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}qi.isMDXComponent=!0;const Bi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The constructor used when creating new scenes."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,c.kt)("inlineCode",{parentName:"a"},"config")),"."))}Yi.isMDXComponent=!0;const Ji={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a scene exposed by scene files."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}pl.isMDXComponent=!0;const rl={toc:[]};function cl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}cl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event at runtime."))}yl.isMDXComponent=!0;const fl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"In other words, the moment at which ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,c.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}wl.isMDXComponent=!0;const Dl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}Ml.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the event."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Duration of the event in seconds."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stack trace at the moment of registration."))}Tl.isMDXComponent=!0;const Ll={toc:[]};function vl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}vl.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents attributes of an inspected element."))}bl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}El.isMDXComponent=!0;const Al={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents an element to inspect."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}zl.isMDXComponent=!0;const Il={toc:[]};function Pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}Pl.isMDXComponent=!0;const Wl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Gl.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Ul.isMDXComponent=!0;const jl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Ol.isMDXComponent=!0;const Vl={toc:[]};function ql(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ql.isMDXComponent=!0;const Bl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Hl.isMDXComponent=!0;const $l={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Yl.isMDXComponent=!0;const Jl={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}pu.isMDXComponent=!0;const ru={toc:[]};function cu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}cu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const fu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}wu.isMDXComponent=!0;const Du={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Mu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread management."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,c.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A class representing an individual thread."))}Tu.isMDXComponent=!0;const Lu={toc:[]};function vu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}vu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}bu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Used by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Su(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current time of this thread."))}Su.isMDXComponent=!0;const Ru={toc:[]};function zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The next value to be passed to the wrapped generator."))}zu.isMDXComponent=!0;const Iu={toc:[]};function Pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Pu.isMDXComponent=!0;const Wu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress the wrapped generator once."))}Gu.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the thread for the next update cycle."))}Uu.isMDXComponent=!0;const ju={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a normal function that returns a generator."))}Ou.isMDXComponent=!0;const Vu={toc:[]};function qu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,c.kt)("p",null,"Progress to the next frame:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,c.kt)("p",null,"Run another generator synchronously:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,c.kt)("p",null,"Run another generator concurrently:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,c.kt)("p",null,"Await a Promise:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}qu.isMDXComponent=!0;const Bu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Hu.isMDXComponent=!0;const $u={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Cancel all listed tasks."),(0,c.kt)("p",null,"Example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Yu.isMDXComponent=!0;const Ju={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to cancel."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}pm.isMDXComponent=!0;const rm={toc:[]};function cm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible thread ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}cm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until listed tasks are finished."))}ym.isMDXComponent=!0;const fm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}wm.isMDXComponent=!0;const Dm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}Mm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"From the perspective of the external generator, ",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a context in which generators can be run concurrently."))}Tm.isMDXComponent=!0;const Lm={toc:[]};function vm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function that returns the generator to run."))}vm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}bm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transitions between scenes."))}Em.isMDXComponent=!0;const Am={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The direction in which to slide."))}zm.isMDXComponent=!0;const Im={toc:[]};function Pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}Pm.isMDXComponent=!0;const Wm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Gm.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the current scene is rendered."))}Um.isMDXComponent=!0;const jm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the previous scene is rendered."))}Om.isMDXComponent=!0;const Vm={toc:[]};function qm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}qm.isMDXComponent=!0;const Bm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area on which to zoom in."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}Ym.isMDXComponent=!0;const Jm={toc:[]};function Km(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area from which to zoom out."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolation and timing of tweens."))}pd.isMDXComponent=!0;const rd={toc:[]};function cd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any old key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,c.kt)("ol",null,(0,c.kt)("li",{parentName:"ol"})))}cd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}yd.isMDXComponent=!0;const fd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}wd.isMDXComponent=!0;const Dd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Md.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Td.isMDXComponent=!0;const Ld={toc:[]};function vd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Complex types used in animations."))}vd.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a two-dimensional vector."))}bd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The unclipped RGB components."))}Sd.isMDXComponent=!0;const Rd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}zd.isMDXComponent=!0;const Id={toc:[]};function Pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Pd.isMDXComponent=!0;const Wd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Gd.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ud.isMDXComponent=!0;const jd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Od.isMDXComponent=!0;const Vd={toc:[]};function qd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}qd.isMDXComponent=!0;const Bd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Hd.isMDXComponent=!0;const $d={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Alias of ",(0,c.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Yd.isMDXComponent=!0;const Jd={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}ph.isMDXComponent=!0;const rh={toc:[]};function ch(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}ch.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"L"),", ",(0,c.kt)("strong",{parentName:"p"},"a"),", and ",(0,c.kt)("strong",{parentName:"p"},"b")," components."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,c.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,c.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}yh.isMDXComponent=!0;const fh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}wh.isMDXComponent=!0;const Dh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Mh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get and set the color opacity."))}Th.isMDXComponent=!0;const Lh={toc:[]};function vh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,c.kt)("code",null,"'rgb'")))}vh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Similar to saturate, but the opposite direction."))}bh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"set"))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a single channel value.\nAlso"))}Sh.isMDXComponent=!0;const Rh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}zh.isMDXComponent=!0;const Ih={toc:[]};function Ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color as hexadecimal string."))}Ph.isMDXComponent=!0;const Wh={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Gh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,c.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Uh.isMDXComponent=!0;const jh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Oh.isMDXComponent=!0;const Vh={toc:[]};function qh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}qh.isMDXComponent=!0;const Bh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Hh.isMDXComponent=!0;const $h={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Yh.isMDXComponent=!0;const Jh={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Kh.isMDXComponent=!0;const Qh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}pk.isMDXComponent=!0;const rk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}ck.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Convert the given origin to a vector representing its offset."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The origin to convert."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"General utilities and helper functions."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}yk.isMDXComponent=!0;const fk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Optional override for formatting stack traces"))}wk.isMDXComponent=!0;const Dk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create .stack property on a target object"))}Mk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the given function as deprecated."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function to deprecate."))}xk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The log message."))}Tk.isMDXComponent=!0;const Lk={toc:[]};function vk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The optional log remarks."))}vk.isMDXComponent=!0;const Zk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}bk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the current scene as ready to transition out."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}Sk.isMDXComponent=!0;const Rk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}zk.isMDXComponent=!0;const Ik={toc:[]};function Pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The length of the array."))}Pk.isMDXComponent=!0;const Wk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}Gk.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}Uk.isMDXComponent=!0;const jk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Ok.isMDXComponent=!0;const Vk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}qk.isMDXComponent=!0;const Bk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Hk.isMDXComponent=!0;const $k={toc:[]};function Yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context before render."))}Yk.isMDXComponent=!0;const Jk={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Kk.isMDXComponent=!0;const Qk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context after render."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}py.isMDXComponent=!0;const ry={toc:[]};function cy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the event in seconds."))}cy.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Register a time event and get its duration in seconds."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current project."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the current scene."))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the given seed."))}yy.isMDXComponent=!0;const fy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The seed for the generator."))}wy.isMDXComponent=!0;const Dy={toc:[]};function My(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}My.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current scene."))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current thread."))}xy.isMDXComponent=!0;const Cy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Ty.isMDXComponent=!0;const Ly={toc:[]};function vy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}vy.isMDXComponent=!0;const Zy={toc:[]};function by(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the real time since the start of the animation."))}by.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}Sy.isMDXComponent=!0;const Ry={toc:[]};function zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zy.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Py.isMDXComponent=!0;const Wy={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Uy.isMDXComponent=!0;const jy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Oy.isMDXComponent=!0;const Vy={toc:[]};function qy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}qy.isMDXComponent=!0;const By={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Hy.isMDXComponent=!0;const $y={toc:[]};function Yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Yy.isMDXComponent=!0;const Jy={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}pf.isMDXComponent=!0;const rf={toc:[]};function cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}cf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ff.isMDXComponent=!0;const wf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Df.isMDXComponent=!0;const Mf={toc:[]};function _f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lf.isMDXComponent=!0;const vf={toc:[]};function Zf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Af.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Rf.isMDXComponent=!0;const zf={toc:[]};function If(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}If.isMDXComponent=!0;const Pf={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Wf.isMDXComponent=!0;const Gf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jf.isMDXComponent=!0;const Of={toc:[]};function Vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Vf.isMDXComponent=!0;const qf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Bf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}$f.isMDXComponent=!0;const Yf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Jf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Qf.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}rw.isMDXComponent=!0;const cw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}fw.isMDXComponent=!0;const ww={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}Dw.isMDXComponent=!0;const Mw={toc:[]};function _w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lw.isMDXComponent=!0;const vw={toc:[]};function Zw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}Aw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Rw.isMDXComponent=!0;const zw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}Iw.isMDXComponent=!0;const Pw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}Ww.isMDXComponent=!0;const Gw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}jw.isMDXComponent=!0;const Ow={toc:[]};function Vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Vw.isMDXComponent=!0;const qw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Bw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$w.isMDXComponent=!0;const Yw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qw.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}rD.isMDXComponent=!0;const cD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}fD.isMDXComponent=!0;const wD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}DD.isMDXComponent=!0;const MD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}CD.isMDXComponent=!0;const TD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LD.isMDXComponent=!0;const vD={toc:[]};function ZD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}AD.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}RD.isMDXComponent=!0;const zD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}ID.isMDXComponent=!0;const PD={toc:[]};function WD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}WD.isMDXComponent=!0;const GD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}FD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jD.isMDXComponent=!0;const OD={toc:[]};function VD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}VD.isMDXComponent=!0;const qD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}BD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$D.isMDXComponent=!0;const YD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QD.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}rM.isMDXComponent=!0;const cM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}fM.isMDXComponent=!0;const wM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}DM.isMDXComponent=!0;const MM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}CM.isMDXComponent=!0;const TM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LM.isMDXComponent=!0;const vM={toc:[]};function ZM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}RM.isMDXComponent=!0;const zM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}IM.isMDXComponent=!0;const PM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}WM.isMDXComponent=!0;const GM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}jM.isMDXComponent=!0;const OM={toc:[]};function VM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}VM.isMDXComponent=!0;const qM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}BM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$M.isMDXComponent=!0;const YM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}JM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}QM.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}r_.isMDXComponent=!0;const c_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}f_.isMDXComponent=!0;const w_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}D_.isMDXComponent=!0;const M_={toc:[]};function __(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}C_.isMDXComponent=!0;const T_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}L_.isMDXComponent=!0;const v_={toc:[]};function Z_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}A_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}R_.isMDXComponent=!0;const z_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}I_.isMDXComponent=!0;const P_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}W_.isMDXComponent=!0;const G_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}F_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}j_.isMDXComponent=!0;const O_={toc:[]};function V_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}V_.isMDXComponent=!0;const q_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}B_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}$_.isMDXComponent=!0;const Y_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}J_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}rX.isMDXComponent=!0;const cX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}fX.isMDXComponent=!0;const wX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}DX.isMDXComponent=!0;const MX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}CX.isMDXComponent=!0;const TX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LX.isMDXComponent=!0;const vX={toc:[]};function ZX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}AX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}RX.isMDXComponent=!0;const zX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}IX.isMDXComponent=!0;const PX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}WX.isMDXComponent=!0;const GX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}FX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}jX.isMDXComponent=!0;const OX={toc:[]};function VX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}VX.isMDXComponent=!0;const qX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}BX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$X.isMDXComponent=!0;const YX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}rg.isMDXComponent=!0;const cg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fg.isMDXComponent=!0;const wg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Dg.isMDXComponent=!0;const Mg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Lg.isMDXComponent=!0;const vg={toc:[]};function Zg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ag.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Rg.isMDXComponent=!0;const zg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}Ig.isMDXComponent=!0;const Pg={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Wg.isMDXComponent=!0;const Gg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}jg.isMDXComponent=!0;const Og={toc:[]};function Vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Vg.isMDXComponent=!0;const qg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Bg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}$g.isMDXComponent=!0;const Yg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Jg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rx.isMDXComponent=!0;const cx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}fx.isMDXComponent=!0;const wx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}Dx.isMDXComponent=!0;const Mx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Lx.isMDXComponent=!0;const vx={toc:[]};function Zx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Ax.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Rx.isMDXComponent=!0;const zx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Ix.isMDXComponent=!0;const Px={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wx.isMDXComponent=!0;const Gx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}jx.isMDXComponent=!0;const Ox={toc:[]};function Vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Vx.isMDXComponent=!0;const qx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Bx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}$x.isMDXComponent=!0;const Yx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Jx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Qx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}rC.isMDXComponent=!0;const cC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given position."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The position in local space at which to sample the color."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given pixel."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The pixel's position."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}fC.isMDXComponent=!0;const wC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DC.isMDXComponent=!0;const MC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}CC.isMDXComponent=!0;const TC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}LC.isMDXComponent=!0;const vC={toc:[]};function ZC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}AC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}RC.isMDXComponent=!0;const zC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}IC.isMDXComponent=!0;const PC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}WC.isMDXComponent=!0;const GC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}jC.isMDXComponent=!0;const OC={toc:[]};function VC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}VC.isMDXComponent=!0;const qC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}BC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}$C.isMDXComponent=!0;const YC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}JC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}QC.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}rT.isMDXComponent=!0;const cT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fT.isMDXComponent=!0;const wT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}DT.isMDXComponent=!0;const MT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}CT.isMDXComponent=!0;const TT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}LT.isMDXComponent=!0;const vT={toc:[]};function ZT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}AT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}RT.isMDXComponent=!0;const zT={toc:[]};function IT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}IT.isMDXComponent=!0;const PT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}WT.isMDXComponent=!0;const GT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}FT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jT.isMDXComponent=!0;const OT={toc:[]};function VT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}VT.isMDXComponent=!0;const qT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}BT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$T.isMDXComponent=!0;const YT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}JT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}QT.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}rL.isMDXComponent=!0;const cL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}fL.isMDXComponent=!0;const wL={toc:[]};function DL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}DL.isMDXComponent=!0;const ML={toc:[]};function _L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}CL.isMDXComponent=!0;const TL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}LL.isMDXComponent=!0;const vL={toc:[]};function ZL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}AL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}RL.isMDXComponent=!0;const zL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}IL.isMDXComponent=!0;const PL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}WL.isMDXComponent=!0;const GL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}FL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}jL.isMDXComponent=!0;const OL={toc:[]};function VL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}VL.isMDXComponent=!0;const qL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}BL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}$L.isMDXComponent=!0;const YL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}JL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}QL.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rv.isMDXComponent=!0;const cv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}fv.isMDXComponent=!0;const wv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Dv.isMDXComponent=!0;const Mv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Lv.isMDXComponent=!0;const vv={toc:[]};function Zv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Av.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Rv.isMDXComponent=!0;const zv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Iv.isMDXComponent=!0;const Pv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Wv.isMDXComponent=!0;const Gv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}jv.isMDXComponent=!0;const Ov={toc:[]};function Vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Vv.isMDXComponent=!0;const qv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$v.isMDXComponent=!0;const Yv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}Jv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}Qv.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}rZ.isMDXComponent=!0;const cZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}fZ.isMDXComponent=!0;const wZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DZ.isMDXComponent=!0;const MZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}LZ.isMDXComponent=!0;const vZ={toc:[]};function ZZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}AZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}RZ.isMDXComponent=!0;const zZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}IZ.isMDXComponent=!0;const PZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}WZ.isMDXComponent=!0;const GZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}jZ.isMDXComponent=!0;const OZ={toc:[]};function VZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}VZ.isMDXComponent=!0;const qZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}BZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}$Z.isMDXComponent=!0;const YZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}JZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}QZ.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}rb.isMDXComponent=!0;const cb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}fb.isMDXComponent=!0;const wb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Db.isMDXComponent=!0;const Mb={toc:[]};function _b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Lb.isMDXComponent=!0;const vb={toc:[]};function Zb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ab.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Rb.isMDXComponent=!0;const zb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ib.isMDXComponent=!0;const Pb={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}Wb.isMDXComponent=!0;const Gb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}jb.isMDXComponent=!0;const Ob={toc:[]};function Vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Vb.isMDXComponent=!0;const qb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}Bb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}$b.isMDXComponent=!0;const Yb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Jb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Qb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}rN.isMDXComponent=!0;const cN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}fN.isMDXComponent=!0;const wN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}DN.isMDXComponent=!0;const MN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}CN.isMDXComponent=!0;const TN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}LN.isMDXComponent=!0;const vN={toc:[]};function ZN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}AN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}RN.isMDXComponent=!0;const zN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}IN.isMDXComponent=!0;const PN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}WN.isMDXComponent=!0;const GN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}FN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}jN.isMDXComponent=!0;const ON={toc:[]};function VN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}VN.isMDXComponent=!0;const qN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}BN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$N.isMDXComponent=!0;const YN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}JN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}QN.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}rE.isMDXComponent=!0;const cE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}sE.isMDXComponent=!0;const aE={toc:[]};function iE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}iE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}fE.isMDXComponent=!0;const wE={toc:[]};function DE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}DE.isMDXComponent=!0;const ME={toc:[]};function _E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}CE.isMDXComponent=!0;const TE={toc:[]};function LE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}LE.isMDXComponent=!0;const vE={toc:[]};function ZE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}AE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}RE.isMDXComponent=!0;const zE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IE.isMDXComponent=!0;const PE={toc:[]};function WE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}WE.isMDXComponent=!0;const GE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}FE.isMDXComponent=!0;const UE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jE.isMDXComponent=!0;const OE={toc:[]};function VE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}VE.isMDXComponent=!0;const qE={toc:[]};function BE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}$E.isMDXComponent=!0;const YE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}JE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QE.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}rA.isMDXComponent=!0;const cA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}fA.isMDXComponent=!0;const wA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DA.isMDXComponent=!0;const MA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}CA.isMDXComponent=!0;const TA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}LA.isMDXComponent=!0;const vA={toc:[]};function ZA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RA.isMDXComponent=!0;const zA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}IA.isMDXComponent=!0;const PA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WA.isMDXComponent=!0;const GA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}jA.isMDXComponent=!0;const OA={toc:[]};function VA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VA.isMDXComponent=!0;const qA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}$A.isMDXComponent=!0;const YA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}QA.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rS.isMDXComponent=!0;const cS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}fS.isMDXComponent=!0;const wS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}DS.isMDXComponent=!0;const MS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}CS.isMDXComponent=!0;const TS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}LS.isMDXComponent=!0;const vS={toc:[]};function ZS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}AS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RS.isMDXComponent=!0;const zS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IS.isMDXComponent=!0;const PS={toc:[]};function WS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WS.isMDXComponent=!0;const GS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}FS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jS.isMDXComponent=!0;const OS={toc:[]};function VS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}VS.isMDXComponent=!0;const qS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}BS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}$S.isMDXComponent=!0;const YS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}JS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}QS.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rR.isMDXComponent=!0;const cR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}sR.isMDXComponent=!0;const aR={toc:[]};function iR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}iR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fR.isMDXComponent=!0;const wR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DR.isMDXComponent=!0;const MR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}CR.isMDXComponent=!0;const TR={toc:[]};function LR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}LR.isMDXComponent=!0;const vR={toc:[]};function ZR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}AR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}RR.isMDXComponent=!0;const zR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}IR.isMDXComponent=!0;const PR={toc:[]};function WR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}WR.isMDXComponent=!0;const GR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FR.isMDXComponent=!0;const UR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}jR.isMDXComponent=!0;const OR={toc:[]};function VR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}VR.isMDXComponent=!0;const qR={toc:[]};function BR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}BR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}$R.isMDXComponent=!0;const YR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}JR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}QR.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}rz.isMDXComponent=!0;const cz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sz.isMDXComponent=!0;const az={toc:[]};function iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}iz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fz.isMDXComponent=!0;const wz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Dz.isMDXComponent=!0;const Mz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function Lz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Lz.isMDXComponent=!0;const vz={toc:[]};function Zz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Az.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Rz.isMDXComponent=!0;const zz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Iz.isMDXComponent=!0;const Pz={toc:[]};function Wz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Wz.isMDXComponent=!0;const Gz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}jz.isMDXComponent=!0;const Oz={toc:[]};function Vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Vz.isMDXComponent=!0;const qz={toc:[]};function Bz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Bz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}$z.isMDXComponent=!0;const Yz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Jz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qz.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}rI.isMDXComponent=!0;const cI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}sI.isMDXComponent=!0;const aI={toc:[]};function iI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}fI.isMDXComponent=!0;const wI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DI.isMDXComponent=!0;const MI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}CI.isMDXComponent=!0;const TI={toc:[]};function LI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LI.isMDXComponent=!0;const vI={toc:[]};function ZI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}AI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RI.isMDXComponent=!0;const zI={toc:[]};function II(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}II.isMDXComponent=!0;const PI={toc:[]};function WI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}WI.isMDXComponent=!0;const GI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}FI.isMDXComponent=!0;const UI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}jI.isMDXComponent=!0;const OI={toc:[]};function VI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}VI.isMDXComponent=!0;const qI={toc:[]};function BI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}BI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$I.isMDXComponent=!0;const YI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}JI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}QI.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}rP.isMDXComponent=!0;const cP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}fP.isMDXComponent=!0;const wP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}DP.isMDXComponent=!0;const MP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}CP.isMDXComponent=!0;const TP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}LP.isMDXComponent=!0;const vP={toc:[]};function ZP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}AP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}RP.isMDXComponent=!0;const zP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}IP.isMDXComponent=!0;const PP={toc:[]};function WP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}WP.isMDXComponent=!0;const GP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}FP.isMDXComponent=!0;const UP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}jP.isMDXComponent=!0;const OP={toc:[]};function VP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}VP.isMDXComponent=!0;const qP={toc:[]};function BP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}BP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}$P.isMDXComponent=!0;const YP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}JP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}QP.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}rW.isMDXComponent=!0;const cW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}sW.isMDXComponent=!0;const aW={toc:[]};function iW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}iW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}fW.isMDXComponent=!0;const wW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}DW.isMDXComponent=!0;const MW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}CW.isMDXComponent=!0;const TW={toc:[]};function LW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}LW.isMDXComponent=!0;const vW={toc:[]};function ZW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}AW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}RW.isMDXComponent=!0;const zW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}IW.isMDXComponent=!0;const PW={toc:[]};function WW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}WW.isMDXComponent=!0;const GW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}FW.isMDXComponent=!0;const UW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}jW.isMDXComponent=!0;const OW={toc:[]};function VW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}VW.isMDXComponent=!0;const qW={toc:[]};function BW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}$W.isMDXComponent=!0;const YW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}JW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}QW.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}rG.isMDXComponent=!0;const cG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}fG.isMDXComponent=!0;const wG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}DG.isMDXComponent=!0;const MG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}CG.isMDXComponent=!0;const TG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}LG.isMDXComponent=!0;const vG={toc:[]};function ZG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}AG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}RG.isMDXComponent=!0;const zG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}IG.isMDXComponent=!0;const PG={toc:[]};function WG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}WG.isMDXComponent=!0;const GG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}FG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}jG.isMDXComponent=!0;const OG={toc:[]};function VG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}VG.isMDXComponent=!0;const qG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}BG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}$G.isMDXComponent=!0;const YG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}JG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}QG.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}rF.isMDXComponent=!0;const cF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}sF.isMDXComponent=!0;const aF={toc:[]};function iF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}iF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}fF.isMDXComponent=!0;const wF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DF.isMDXComponent=!0;const MF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}CF.isMDXComponent=!0;const TF={toc:[]};function LF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}LF.isMDXComponent=!0;const vF={toc:[]};function ZF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}AF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}RF.isMDXComponent=!0;const zF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}IF.isMDXComponent=!0;const PF={toc:[]};function WF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WF.isMDXComponent=!0;const GF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}FF.isMDXComponent=!0;const UF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jF.isMDXComponent=!0;const OF={toc:[]};function VF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}VF.isMDXComponent=!0;const qF={toc:[]};function BF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}$F.isMDXComponent=!0;const YF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}JF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}rU.isMDXComponent=!0;const cU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sU.isMDXComponent=!0;const aU={toc:[]};function iU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}iU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}fU.isMDXComponent=!0;const wU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}DU.isMDXComponent=!0;const MU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}CU.isMDXComponent=!0;const TU={toc:[]};function LU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LU.isMDXComponent=!0;const vU={toc:[]};function ZU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}AU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}RU.isMDXComponent=!0;const zU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}IU.isMDXComponent=!0;const PU={toc:[]};function WU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WU.isMDXComponent=!0;const GU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}FU.isMDXComponent=!0;const UU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jU.isMDXComponent=!0;const OU={toc:[]};function VU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}VU.isMDXComponent=!0;const qU={toc:[]};function BU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}BU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$U.isMDXComponent=!0;const YU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}JU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QU.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rj.isMDXComponent=!0;const cj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}sj.isMDXComponent=!0;const aj={toc:[]};function ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ij.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}fj.isMDXComponent=!0;const wj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Dj.isMDXComponent=!0;const Mj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function Lj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Lj.isMDXComponent=!0;const vj={toc:[]};function Zj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Aj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Rj.isMDXComponent=!0;const zj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Ij.isMDXComponent=!0;const Pj={toc:[]};function Wj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Wj.isMDXComponent=!0;const Gj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}jj.isMDXComponent=!0;const Oj={toc:[]};function Vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Vj.isMDXComponent=!0;const qj={toc:[]};function Bj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Bj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}$j.isMDXComponent=!0;const Yj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Jj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qj.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}rO.isMDXComponent=!0;const cO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}sO.isMDXComponent=!0;const aO={toc:[]};function iO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fO.isMDXComponent=!0;const wO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}DO.isMDXComponent=!0;const MO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}CO.isMDXComponent=!0;const TO={toc:[]};function LO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}LO.isMDXComponent=!0;const vO={toc:[]};function ZO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}AO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}RO.isMDXComponent=!0;const zO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}IO.isMDXComponent=!0;const PO={toc:[]};function WO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}WO.isMDXComponent=!0;const GO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FO.isMDXComponent=!0;const UO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}jO.isMDXComponent=!0;const OO={toc:[]};function VO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}VO.isMDXComponent=!0;const qO={toc:[]};function BO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}BO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}$O.isMDXComponent=!0;const YO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}JO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QO.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rV.isMDXComponent=!0;const cV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}sV.isMDXComponent=!0;const aV={toc:[]};function iV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}iV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fV.isMDXComponent=!0;const wV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}DV.isMDXComponent=!0;const MV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CV.isMDXComponent=!0;const TV={toc:[]};function LV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}LV.isMDXComponent=!0;const vV={toc:[]};function ZV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}NV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}AV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}RV.isMDXComponent=!0;const zV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}IV.isMDXComponent=!0;const PV={toc:[]};function WV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}WV.isMDXComponent=!0;const GV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}FV.isMDXComponent=!0;const UV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}jV.isMDXComponent=!0;const OV={toc:[]};function VV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}VV.isMDXComponent=!0;const qV={toc:[]};function BV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}BV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}$V.isMDXComponent=!0;const YV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}JV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}QV.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}rq.isMDXComponent=!0;const cq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}sq.isMDXComponent=!0;const aq={toc:[]};function iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}iq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fq.isMDXComponent=!0;const wq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}Dq.isMDXComponent=!0;const Mq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function Lq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lq.isMDXComponent=!0;const vq={toc:[]};function Zq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Aq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}Rq.isMDXComponent=!0;const zq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Iq.isMDXComponent=!0;const Pq={toc:[]};function Wq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Wq.isMDXComponent=!0;const Gq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}jq.isMDXComponent=!0;const Oq={toc:[]};function Vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Vq.isMDXComponent=!0;const qq={toc:[]};function Bq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Bq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}$q.isMDXComponent=!0;const Yq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Jq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qq.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}rB.isMDXComponent=!0;const cB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}sB.isMDXComponent=!0;const aB={toc:[]};function iB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}iB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}fB.isMDXComponent=!0;const wB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DB.isMDXComponent=!0;const MB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}CB.isMDXComponent=!0;const TB={toc:[]};function LB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}LB.isMDXComponent=!0;const vB={toc:[]};function ZB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}NB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}AB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}RB.isMDXComponent=!0;const zB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}IB.isMDXComponent=!0;const PB={toc:[]};function WB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WB.isMDXComponent=!0;const GB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}FB.isMDXComponent=!0;const UB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}jB.isMDXComponent=!0;const OB={toc:[]};function VB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}VB.isMDXComponent=!0;const qB={toc:[]};function BB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}BB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$B.isMDXComponent=!0;const YB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}JB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}QB.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}rH.isMDXComponent=!0;const cH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}sH.isMDXComponent=!0;const aH={toc:[]};function iH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}iH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}fH.isMDXComponent=!0;const wH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}DH.isMDXComponent=!0;const MH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CH.isMDXComponent=!0;const TH={toc:[]};function LH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LH.isMDXComponent=!0;const vH={toc:[]};function ZH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}NH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}AH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}RH.isMDXComponent=!0;const zH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}IH.isMDXComponent=!0;const PH={toc:[]};function WH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}WH.isMDXComponent=!0;const GH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FH.isMDXComponent=!0;const UH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}jH.isMDXComponent=!0;const OH={toc:[]};function VH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}VH.isMDXComponent=!0;const qH={toc:[]};function BH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}BH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}$H.isMDXComponent=!0;const YH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}JH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QH.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}r$.isMDXComponent=!0;const c$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}s$.isMDXComponent=!0;const a$={toc:[]};function i$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}i$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}f$.isMDXComponent=!0;const w$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}D$.isMDXComponent=!0;const M$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}C$.isMDXComponent=!0;const T$={toc:[]};function L$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}L$.isMDXComponent=!0;const v$={toc:[]};function Z$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}N$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}A$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}R$.isMDXComponent=!0;const z$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}I$.isMDXComponent=!0;const P$={toc:[]};function W$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}W$.isMDXComponent=!0;const G$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}F$.isMDXComponent=!0;const U$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}j$.isMDXComponent=!0;const O$={toc:[]};function V$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}V$.isMDXComponent=!0;const q$={toc:[]};function B$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}B$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$$.isMDXComponent=!0;const Y$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}J$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}Q$.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}rY.isMDXComponent=!0;const cY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}sY.isMDXComponent=!0;const aY={toc:[]};function iY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}iY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fY.isMDXComponent=!0;const wY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DY.isMDXComponent=!0;const MY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}CY.isMDXComponent=!0;const TY={toc:[]};function LY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LY.isMDXComponent=!0;const vY={toc:[]};function ZY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}NY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}AY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}RY.isMDXComponent=!0;const zY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}IY.isMDXComponent=!0;const PY={toc:[]};function WY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}WY.isMDXComponent=!0;const GY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}FY.isMDXComponent=!0;const UY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}jY.isMDXComponent=!0;const OY={toc:[]};function VY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}VY.isMDXComponent=!0;const qY={toc:[]};function BY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}BY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$Y.isMDXComponent=!0;const YY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}JY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QY.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rJ.isMDXComponent=!0;const cJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}sJ.isMDXComponent=!0;const aJ={toc:[]};function iJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}iJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}fJ.isMDXComponent=!0;const wJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}DJ.isMDXComponent=!0;const MJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function LJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}LJ.isMDXComponent=!0;const vJ={toc:[]};function ZJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}AJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}RJ.isMDXComponent=!0;const zJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}IJ.isMDXComponent=!0;const PJ={toc:[]};function WJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}WJ.isMDXComponent=!0;const GJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}FJ.isMDXComponent=!0;const UJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jJ.isMDXComponent=!0;const OJ={toc:[]};function VJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}VJ.isMDXComponent=!0;const qJ={toc:[]};function BJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}BJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$J.isMDXComponent=!0;const YJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}JJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QJ.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}rK.isMDXComponent=!0;const cK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sK.isMDXComponent=!0;const aK={toc:[]};function iK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}iK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}fK.isMDXComponent=!0;const wK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}DK.isMDXComponent=!0;const MK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}CK.isMDXComponent=!0;const TK={toc:[]};function LK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LK.isMDXComponent=!0;const vK={toc:[]};function ZK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}AK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}RK.isMDXComponent=!0;const zK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}IK.isMDXComponent=!0;const PK={toc:[]};function WK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}WK.isMDXComponent=!0;const GK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}FK.isMDXComponent=!0;const UK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}jK.isMDXComponent=!0;const OK={toc:[]};function VK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}VK.isMDXComponent=!0;const qK={toc:[]};function BK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}BK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}$K.isMDXComponent=!0;const YK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}JK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}QK.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}rQ.isMDXComponent=!0;const cQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}sQ.isMDXComponent=!0;const aQ={toc:[]};function iQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}iQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}fQ.isMDXComponent=!0;const wQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DQ.isMDXComponent=!0;const MQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}CQ.isMDXComponent=!0;const TQ={toc:[]};function LQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}LQ.isMDXComponent=!0;const vQ={toc:[]};function ZQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}NQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}AQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RQ.isMDXComponent=!0;const zQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}IQ.isMDXComponent=!0;const PQ={toc:[]};function WQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WQ.isMDXComponent=!0;const GQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jQ.isMDXComponent=!0;const OQ={toc:[]};function VQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}VQ.isMDXComponent=!0;const qQ={toc:[]};function BQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}BQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}$Q.isMDXComponent=!0;const YQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}JQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}r0.isMDXComponent=!0;const c0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}s0.isMDXComponent=!0;const a0={toc:[]};function i0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}i0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}f0.isMDXComponent=!0;const w0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}D0.isMDXComponent=!0;const M0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}C0.isMDXComponent=!0;const T0={toc:[]};function L0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}L0.isMDXComponent=!0;const v0={toc:[]};function Z0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}N0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}A0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}R0.isMDXComponent=!0;const z0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}I0.isMDXComponent=!0;const P0={toc:[]};function W0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}W0.isMDXComponent=!0;const G0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}F0.isMDXComponent=!0;const U0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}j0.isMDXComponent=!0;const O0={toc:[]};function V0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}V0.isMDXComponent=!0;const q0={toc:[]};function B0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}B0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}$0.isMDXComponent=!0;const Y0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}J0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}Q0.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}r1.isMDXComponent=!0;const c1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}s1.isMDXComponent=!0;const a1={toc:[]};function i1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}i1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,c.kt)("p",null,"By default, any property is cloneable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}f1.isMDXComponent=!0;const w1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}D1.isMDXComponent=!0;const M1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a cloneable property decorator."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be cloneable."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}C1.isMDXComponent=!0;const T1={toc:[]};function L1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}L1.isMDXComponent=!0;const v1={toc:[]};function Z1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a compound property decorator."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}N1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,c.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,c.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}A1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a computed method decorator."))}R1.isMDXComponent=!0;const z1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the initial value of a property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}I1.isMDXComponent=!0;const P1={toc:[]};function W1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}W1.isMDXComponent=!0;const G1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an initial signal value decorator."))}F1.isMDXComponent=!0;const U1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value of the property."))}j1.isMDXComponent=!0;const O1={toc:[]};function V1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,c.kt)("p",null,"By default, any property is inspectable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}V1.isMDXComponent=!0;const q1={toc:[]};function B1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}B1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an inspectable property decorator."))}$1.isMDXComponent=!0;const Y1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be inspectable."))}J1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Q1.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal interpolation function decorator."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interpolation function for the property."))}r2.isMDXComponent=!0;const c2={toc:[]};function s2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,c.kt)("p",null,"If the wrapper class has a method called ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}s2.isMDXComponent=!0;const a2={toc:[]};function i2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}i2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal parser decorator."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given property into a signal."),(0,c.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}f2.isMDXComponent=!0;const w2={toc:[]};function D2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal decorator."))}D2.isMDXComponent=!0;const M2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,c.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,c.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,c.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}g2.isMDXComponent=!0;const x2={toc:[]};function C2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal wrapper decorator."))}C2.isMDXComponent=!0;const T2={toc:[]};function L2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}L2.isMDXComponent=!0;const v2={toc:[]};function Z2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A unified abstraction for all CSS filters."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value can be either:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length (equivalent to ",(0,c.kt)("inlineCode",{parentName:"li"},"auto")," in CSS)")))}N2.isMDXComponent=!0;const E2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a length used by most layout properties."))}A2.isMDXComponent=!0;const S2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,c.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}R2.isMDXComponent=!0;const z2={toc:[]};function I2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in pixels."))}I2.isMDXComponent=!0;const P2={toc:[]};function W2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,c.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}W2.isMDXComponent=!0;const G2={toc:[]};function F2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}F2.isMDXComponent=!0;const U2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,c.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}j2.isMDXComponent=!0;const O2={toc:[]};function V2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}V2.isMDXComponent=!0;const q2={toc:[]};function B2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,c.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}B2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}$2.isMDXComponent=!0;const Y2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,c.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}J2.isMDXComponent=!0;const K2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in degrees."))}Q2.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,c.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,c.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}r4.isMDXComponent=!0;const c4={toc:[]};function s4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}s4.isMDXComponent=!0;const a4={toc:[]};function i4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,c.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}i4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}function h4(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}d4.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(6964),r=e(8698);const c="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",i="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(c,e&&s),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,i)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:h.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:k.contentId})))}},1836:(t,n,e)=>{e.d(n,{Z:()=>St});var o=e(2784),p=e(7390),r=e(6835),c=e(68),s=e(6277),a=e(8569);const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,c.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,i.codeBlock,e&&i.highlight,p&&i.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(i.codeBlockContainer,"language-typescript")},n)}var k=e(9817);function y(t){let{children:n,type:e,to:p,id:r,tooltip:s}=t;const a=(0,c.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":s},a),n):o.createElement("span",(0,l.Z)({id:r},a),n)}let f,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const D={[f.None]:i.none,[f.Angle]:i.angle,[f.Curly]:i.curly,[f.Square]:i.square,[f.Parentheses]:i.parentheses};function M(t){let{children:n,type:e,separator:p=w.Comma}=t;return o.createElement("span",{className:(0,s.Z)(i.list,D[e??f.None])},o.createElement("span",{className:(0,s.Z)(i.elements,p!==w.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:i.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],c=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:c,type:c?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(M,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(W,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(M,{type:f.Square},n.elements.map(((t,n)=>o.createElement(W,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.elementType}),"[]")}function T(t){let{type:n}=t;return o.createElement(M,{type:f.Parentheses,separator:w.Pipe},n.types.map(((t,n)=>o.createElement(W,{key:n,type:t}))))}function L(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function v(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(W,{type:n.targetType}))}function Z(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(M,{type:f.Parentheses,separator:w.Ampersand},n.types.map(((t,n)=>o.createElement(W,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(W,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(W,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(W,{type:n.extendsType})," ? ",o.createElement(W,{type:n.trueType})," : ",o.createElement(W,{type:n.falseType}))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.objectType}),"[",o.createElement(W,{type:n.indexType}),"]")}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(W,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(W,{type:n.parameterType}),"]: ",o.createElement(W,{type:n.templateType}))))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(W,{type:n.element}))}function W(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return z;case"conditional":return A;case"reflection":return Z;case"query":return E;case"named-tuple-member":return P;case"union":return T;case"intrinsic":return g;case"literal":return L;case"reference":return X;case"predicate":return v;case"tuple":return x;case"array":return C;case"intersection":return b;case"inferred":return S;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(W,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function U(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(W,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(W,{type:n.default})))}function j(t){var n,e;let{reflection:r,flags:c}=t;const s=(0,_.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:c??r.flags,explicitAccessModifier:!a}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):a?"":o.createElement(y,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(M,{type:f.Angle},r.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(M,{type:f.Parentheses},r.parameters.map((t=>o.createElement(F,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(W,{type:r.type})))}function O(t){let{reflection:n}=t;return o.createElement(F,{reflection:n})}const V={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function q(t){var n,e,p;let{reflection:r}=t;const c=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(y,{type:"keyword"},V[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(M,{type:f.Angle},r.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:c(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,n)=>o.createElement(W,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,n)=>o.createElement(W,{key:n,type:t}))))))}function B(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(M,{type:f.Angle},n.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:e(t)}))))," = ",o.createElement(W,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(j,{reflection:n.signatures[0]}):n.children?o.createElement(M,{type:f.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function $(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(j,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return q;case p.W.Constructor:return j;case p.W.Property:return O;case p.W.Method:return $;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return U;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return B;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function J(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,s.Z)(i.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),Q=e(6964);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),c=(0,o.useMemo)((()=>n.map(r)),[n]),[s,a]=(0,o.useState)(c[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,c.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===s.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(J,null,o.createElement(j,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(nt,{parameters:s.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",ct="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function it(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",ct)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(8963),mt=e(3851),dt=e(9741),ht=e(2244),kt=e(4126);const yt="tabList_M0Dn",ft="tabItem_ysIP";function wt(t){var n;const{lazy:e,block:p,defaultValue:r,values:c,groupId:a,className:i}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=c??u.map((t=>{let{props:{value:n,label:e,attributes:o}}=t;return{value:n,label:e,attributes:o}})),d=(0,ht.l)(m,((t,n)=>t.value===n.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(n=u.find((t=>t.props.default)))?void 0:n.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:y}=(0,ut.U)(),[f,w]=(0,o.useState)(h),D=[],{blockElementScrollPositionUntilNextRender:M}=(0,kt.o5)();if(null!=a){const t=k[a];null!=t&&t!==f&&m.some((n=>n.value===t))&&w(t)}const _=t=>{const n=t.currentTarget,e=D.indexOf(n),o=m[e].value;o!==f&&(M(n),w(o),null!=a&&y(a,String(o)))},X=t=>{var n;let e=null;switch(t.key){case"Enter":_(t);break;case"ArrowRight":{const n=D.indexOf(t.currentTarget)+1;e=D[n]??D[0];break}case"ArrowLeft":{const n=D.indexOf(t.currentTarget)-1;e=D[n]??D[D.length-1];break}}null==(n=e)||n.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",yt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":p},i)},m.map((t=>{let{value:n,label:e,attributes:p}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:f===n?0:-1,"aria-selected":f===n,key:n,ref:t=>D.push(t),onKeyDown:X,onClick:_},p,{className:(0,s.Z)("tabs__item",ft,null==p?void 0:p.className,{"tabs__item--active":f===n})}),e??n)}))),e?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==f})))))}function Dt(t){const n=(0,dt.Z)();return o.createElement(wt,(0,l.Z)({key:String(n)},t))}const Mt="tabItem_OMyP";function _t(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(Mt,p),hidden:e},n)}function Xt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(St,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(St,{reflection:t})))))}function gt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,_.RU)(e),{setTabGroupChoices:c}=(0,ut.U)(),s=p.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const c of t.children){const t=n[c];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,a))).filter((t=>!!t))),[n,r,a]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return void c(n.title,e.title)}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(Dt,{groupId:n.title},i.map((t=>o.createElement(_t,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Xt,{group:t}))))):o.createElement(Xt,{group:i[0]}))}function xt(t){var n,e,p,r,c;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:s})))),o.createElement(it,{kind:s.kind},o.createElement(K.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(p=s.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(c=s.groups)?void 0:c.map((t=>o.createElement(gt,{group:t,key:t.title,project:s.project}))))}function Ct(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(mt.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Tt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(mt.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(O,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Lt(t){var n,e,p;let{reflection:r}=t;const c=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>c[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(St,{key:t.id,reflection:t})))))))}var vt=e(8128);function Zt(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(vt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(it,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(gt,{group:t,key:t.title,project:e.project}))))}const bt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,s.Z)("card padding--lg",bt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function St(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return At;case p.W.Module:return Zt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return xt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return Ct;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Tt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Lt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>i,RU:()=>c,gs:()=>r,in:()=>s,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function c(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function s(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function i(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>s,Y0:()=>c,s2:()=>a});var o=e(2784),p=e(822);const r=o.createContext(null);function c(t){let{children:n}=t;const e=(0,p.p)(),c=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:c},n)}function s(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const c="api-filters",s=p.Z.canUseDOM?localStorage.getItem(c):null,a=s?JSON.parse(s):{inherited:!0,private:!1},i=o.createContext([a,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(i.Provider,{value:[e,t=>{s&&localStorage.setItem(c,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(i)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},6412:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var o=e(7896),p=(e(2784),e(876)),r=(e(8128),e(2072));const c={sidebar_position:3,slug:"/hierarchy"},s="Scene hierarchy",a={unversionedId:"getting-started/hierarchy",id:"getting-started/hierarchy",title:"Scene hierarchy",description:"Scenes are collections of nodes displayed in your animation. They're organized",source:"@site/docs/getting-started/hierarchy.mdx",sourceDirName:"getting-started",slug:"/hierarchy",permalink:"/docs/hierarchy",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/hierarchy.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/hierarchy"},sidebar:"docs",previous:{title:"Animation flow",permalink:"/docs/flow"},next:{title:"Positioning",permalink:"/docs/positioning"}},i={},l=[{value:"<code>Node.add</code>",id:"nodeadd",level:2},{value:"<code>Node.insert</code>",id:"nodeinsert",level:2},{value:"<code>Node.remove</code>",id:"noderemove",level:2},{value:"<code>Node.reparent</code>",id:"nodereparent",level:2},{value:"<code>Node.moveUp</code>",id:"nodemoveup",level:2},{value:"<code>Node.moveDown</code>",id:"nodemovedown",level:2},{value:"<code>Node.moveToTop</code>",id:"nodemovetotop",level:2},{value:"<code>Node.moveToBottom</code>",id:"nodemovetobottom",level:2},{value:"<code>Node.removeChildren</code>",id:"noderemovechildren",level:2}],u={toc:l};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"scene-hierarchy"},"Scene hierarchy"),(0,p.kt)("p",null,"Scenes are collections of nodes displayed in your animation. They're organized\nin a tree hierarchy, with the scene view at its root. This concept is similar to\nthe Document Object Model used to represent HTML and XML documents."),(0,p.kt)("p",null,"Here's an example of a simple scene hierarchy together with its object\nrepresentation:"),(0,p.kt)("div",{className:"row margin-bottom--md"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"view.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("mermaid",{value:"graph TD;\n  view[Scene View]\n  circle([Circle])\n  layout([Layout])\n  rect([Rect])\n  text([text 'Hi'])\n    view--\x3ecircle;\n    view--\x3elayout;\n    layout--\x3erect;\n    layout--\x3etext;"}))),(0,p.kt)("p",null,"Each node is an instance of a class extending the base ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class. To\nmake the code more readable, Motion Canvas uses a custom\n",(0,p.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX")," runtime. This way, instead\nof instantiating the nodes ourselves, we can write an XML-like markup. Note that\nMotion Canvas does ",(0,p.kt)("strong",{parentName:"p"},"not")," use React itself, only JSX. There's no virtual DOM or\nreconciliation and the JSX tags are mapped directly to Node instances. These two\ncode snippets are equivalent:"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// JSX\nview.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// No JSX\nview.add([\n  new Circle({}),\n  new Layout({\n    children: [\n      // highlight-start\n      new Rect({}),\n      new Text({text: 'Hi'}),\n    ],\n  }),\n]);\n")))),(0,p.kt)("p",null,"Just like with DOM, it's possible to add, remove, and rearrange nodes at any\ntime. The ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class contains the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,p.kt)("inlineCode",{parentName:"a"},"children"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#parent"},(0,p.kt)("inlineCode",{parentName:"a"},"parent"))," properties that can be used to\ntraverse the tree. But in order to modify it, it's recommended to use the\nfollowing helper methods:"),(0,p.kt)("h2",{id:"nodeadd"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.add")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#add",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodeinsert"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.insert")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#insert",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.remove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#remove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodereparent"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.reparent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#reparent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveup"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveUp")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveUp",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovedown"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveDown")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveDown",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetotop"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToTop")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToTop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetobottom"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToBottom")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToBottom",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemovechildren"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.removeChildren")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#removeChildren",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}m.isMDXComponent=!0}}]);